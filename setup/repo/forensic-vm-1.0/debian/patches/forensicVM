Description: First beta package distro
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 forensic-vm (1.0-1) unstable; urgency=medium
 .
   * Initial release (Closes: #nnnn)  <nnnn is the bug number of your ITP>
Author: root <root@v2v-forensicVM>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2023-07-21

--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/.idea/bin.iml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="PYTHON_MODULE" version="4">
+  <component name="NewModuleRootManager">
+    <content url="file://$MODULE_DIR$" />
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/.idea/inspectionProfiles/profiles_settings.xml
@@ -0,0 +1,6 @@
+<component name="InspectionProjectProfileManager">
+  <settings>
+    <option name="USE_PROJECT_PROFILE" value="false" />
+    <version value="1.0" />
+  </settings>
+</component>
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/.idea/misc.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10" project-jdk-type="Python SDK" />
+</project>
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/.idea/modules.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/bin.iml" filepath="$PROJECT_DIR$/.idea/bin.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/.idea/vcs.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$/.." vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/.idea/workspace.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="AutoImportSettings">
+    <option name="autoReloadType" value="SELECTIVE" />
+  </component>
+  <component name="ChangeListManager">
+    <list default="true" id="a09adc92-5fca-4b67-89b7-f2f3ca8d835e" name="Changes" comment="" />
+    <option name="SHOW_DIALOG" value="false" />
+    <option name="HIGHLIGHT_CONFLICTS" value="true" />
+    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
+    <option name="LAST_RESOLUTION" value="IGNORE" />
+  </component>
+  <component name="Git.Settings">
+    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
+  </component>
+  <component name="MarkdownSettingsMigration">
+    <option name="stateVersion" value="1" />
+  </component>
+  <component name="ProjectId" id="2MbGnqvz3w1G90POPJI6jtgEvzU" />
+  <component name="ProjectViewState">
+    <option name="hideEmptyMiddlePackages" value="true" />
+    <option name="showLibraryContents" value="true" />
+  </component>
+  <component name="PropertiesComponent"><![CDATA[{
+  "keyToString": {
+    "RunOnceActivity.OpenProjectViewOnStart": "true",
+    "RunOnceActivity.ShowReadmeOnStart": "true"
+  }
+}]]></component>
+  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
+  <component name="TaskManager">
+    <task active="true" id="Default" summary="Default task">
+      <changelist id="a09adc92-5fca-4b67-89b7-f2f3ca8d835e" name="Changes" comment="" />
+      <created>1678029038162</created>
+      <option name="number" value="Default" />
+      <option name="presentableId" value="Default" />
+      <updated>1678029038162</updated>
+    </task>
+    <servers />
+  </component>
+</project>
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/activate_venv
@@ -0,0 +1,3 @@
+source /forensicVM/main/django-app/env_linux/bin/activate
+bash -i
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/convert_to_mbr.sh
@@ -0,0 +1,38 @@
+#!/bin/bash
+
+set -e
+
+original_image="/dev/sda"
+new_image="/path/to/new_image.qcow2"
+additional_size="100M"
+
+# Calculate sizes
+original_size=$(stat -c %s "$original_image")
+new_size=$((original_size + additional_size))
+
+# Create the new qcow2 image
+qemu-img create -f qcow2 "$new_image" "$new_size"
+
+# Initialize the new image
+guestfish -a "$new_image" <<EOF
+run
+part-add /dev/sda mbr
+part-set-bootable /dev/sda 1 true
+part-set-gpt-type /dev/sda 1 0x83
+part-set-name /dev/sda 1 "Primary"
+EOF
+
+# Copy the contents of the original image to the new image
+if qemu-nbd --connect=/dev/nbd0 "$new_image"; then
+  if dd if="$original_image" of=/dev/nbd0p1 bs=4M status=progress; then
+    qemu-nbd --disconnect /dev/nbd0
+  else
+    echo "Error: Failed to copy the contents of the original image."
+    qemu-nbd --disconnect /dev/nbd0
+    exit 1
+  fi
+else
+  echo "Error: Failed to connect the new image to NBD."
+  exit 1
+fi
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/copy_vnc.sh
@@ -0,0 +1,77 @@
+#!/bin/bash
+
+# This script is a shell script written in Bash that is designed to convert forensic images into virtual machine images that can be run with QEMU, a virtualization software. The script starts by checking the command-line arguments passed to it, namely the path to the forensic image and the name of the virtual machine to be created. If any of these arguments is missing, the script displays an error message and exits.
+# The script then proceeds to detect the image format of the forensic image, which could be in either qcow2, ewf, or aff format. It does this by using the 'qemu-img info' command to detect if the image is in qcow2 format, or by using the 'ewfinfo' and 'affinfo' commands to detect if it is in ewf or aff format respectively. If the format is not detected, the script displays an error message and exits.
+# Next, the script mounts the forensic image using the appropriate command for the detected image format, and extracts information about the image using the 'virt-inspector' command. It then creates a snapshot of the image using the 'qemu-img create' command and sets up a block device using the 'qemu-nbd' command.
+# The script then removes hibernate files from any mounted NTFS partitions in the snapshot using the 'ntfsfix' command, adds virtio drivers and QEMU guest agent to the snapshot using the 'virt-v2v' command, and modifies the QEMU startup script to include necessary parameters.
+# If the script is run in 'copy' mode, it unmounts the mounted directories and deletes the temporary snapshot. If the script is run in 'snap' mode, it leaves the mounted directories and the temporary snapshot intact for later use. Finally, the script records the time it started and the time it ended, and calculates and displays the elapsed time.
+
+
+# Record the start time
+start_time=$(date +%s)
+
+check_disk_partitions() {
+  local image_file="$1"
+
+  # Use fdisk to check disk partitions and grep for "not in disk order"
+  if fdisk -lu "$image_file" | grep -q "not in disk order"; then
+    echo "Invalid partitions detected in $image_file"
+    return 1
+  else
+    echo "No invalid partitions found in $image_file"
+    return 0
+  fi
+}
+
+get_first_free_nbd() {
+    for nbd_device in /dev/nbd*; do
+        echo $nbd_device
+        if ! $(lsblk -l | grep -q "^${nbd_device#/dev/}"); then
+            echo "$nbd_device"
+            return
+        fi
+    done
+    echo ""
+}
+
+function change_qemu_vm {
+   #echo "$5"
+   startScript="#!/bin/bash
+
+# Function to find the next available number for bridge and tap interfaces
+find_next_available() {
+     local base_name=\$1
+     local i=0
+     while ip link show \"\${base_name}\${i}\" >/dev/null 2>&1; do
+        i=\$((i+1))
+     done
+     echo \"\${base_name}\${i}\"
+}
+
+tapInterface=\$(find_next_available \"tap\")
+"
+
+   vmconfig=$(cat "$1" | grep -v bash | grep -v /bin/sh | grep -v net0 | grep -v display | grep -v qxl | grep -v balloon | grep -v viosock | sed 's|format=raw|format=qcow2|g' | sed "s|cp '/usr/share/OVMF/OVMF_VARS.fd'|cp -n '/forensicVM/usr/share/qemu/OVMF_VARS.qcow2'|" | sed 's|/usr/share/OVMF/OVMF_CODE.fd|/forensicVM/usr/share/qemu/OVMF_CODE.qcow2|' | sed "s|\$uefi_vars|$5/OVMF_VARS.qcow2|")
+   extra_parameters="-display vnc=0.0.0.0:\$1,websocket=\$2 \\
+    -qmp unix:$3,server,nowait \\
+    -pidfile $4 \\
+    -usb -device usb-tablet -device usb-kbd \\
+    -drive if=none,id=drive-ide0-0-0,readonly=on \\
+    -device ide-cd,bus=ide.0,unit=0,drive=drive-ide0-0-0,id=ide0-0-0 \\
+    -vga virtio \\
+    -drive file=evidence.qcow2,format=qcow2,if=virtio,index=1,media=disk \\
+    -boot menu=on,strict=on,reboot-timeout=10000,splash-time=20000,splash=/forensicVM/branding/bootsplash.jpg \\
+    -netdev tap,id=u1,ifname=\$tapInterface,script=/forensicVM/bin/start_tap.sh,downscript=/forensicVM/bin/end_tap.sh -device e1000,netdev=u1 -object filter-dump,id=f1,netdev=u1,file=$5/network.pcap"
+    echo "$startScript
+    $vmconfig
+    $extra_parameters" >$2
+    chmod 700 $2
+
+}
+
+echo "1) vm script"
+echo "2) destination"
+echo "3) websocket qmp/qmp.pid"
+echo "4) pid"
+echo "5) network"
+change_qemu_vm $1 $2 "qmp/qmp.pid" "run/run.pid" "./network"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/create-windows-partition.sh
@@ -0,0 +1,105 @@
+#!/bin/bash
+
+#set -e
+
+# Check if the correct number of arguments has been passed
+if [ $# -ne 3 ]; then
+    echo "Usage: $0 disk_image_base input_file output_name"
+    exit 1
+fi
+
+# Check if input file exists and is readable
+if [ ! -r "$2" ]; then
+    echo "Error: Input file $2 does not exist or is not readable."
+    exit 1
+fi
+
+# Check if the first argument is not empty
+if [ -z "$1" ]; then
+    echo "Error: The first argument must not be empty."
+    exit 1
+fi
+
+# Check if the third argument is not empty
+if [ -z "$3" ]; then
+    echo "Error: The third argument must not be empty."
+    exit 1
+fi
+
+# Check for necessary commands
+for cmd in qemu-img guestfish qemu-nbd fdisk dd virt-v2v rm; do
+    if ! command -v $cmd &> /dev/null; then
+        echo "Error: $cmd is not installed."
+        exit 1
+    fi
+done
+
+first_nbd=""
+for nbd_device in /dev/nbd*; do
+    /sbin/nbd-client -c $nbd_device
+    if [[ $? -eq 1 ]]; then
+        first_nbd=$nbd_device
+        echo $first_nbd
+        break
+    fi
+done
+
+if [ -n "$first_nbd" ]; then
+    echo "First available NBD device: $first_nbd"
+else
+    echo "First available NBD device: $first_nbd"
+    echo "Error: No available NBD devices found"
+    exit 1
+fi
+
+disk_image="$1"
+base_size=$((($(stat -c%s "$2") / 1024 / 1024 / 1024)+5))  # base_size in GB
+partition_image="/forensicVM/bin/win10bootp1.raw"
+
+part_system_size=$((550 * 1024 * 1024))  # 550MB
+part_windows_size=$(($base_size * 1024 * 1024 * 1024))  # base_size GB
+
+# Calculate the total disk size
+disk_size=$(($part_system_size + $part_windows_size))
+
+# Create the disk image
+qemu-img create -f qcow2 "$disk_image" "$disk_size"
+
+# Start guestfish on the disk image
+guestfish -a "$disk_image" <<EOF
+# Launch the guestfish session
+run
+
+# Create the MBR partition table
+part-init /dev/sda mbr
+
+# Create the system partition
+part-add /dev/sda p 2048 $(($part_system_size / 512))
+
+# Create the Windows partition
+part-add /dev/sda p $(($(($part_system_size / 512)) + 1)) $(($part_windows_size / 512))
+
+# Mark the Windows partition as bootable
+part-set-bootable /dev/sda 2 true
+part-set-bootable /dev/sda 1 true
+
+# Format the Windows partition as NTFS
+mkfs ntfs /dev/sda1
+
+# Format the Windows partition as NTFS
+mkfs ntfs /dev/sda2
+
+# Copy the partition image to the system partition
+upload $partition_image /dev/sda1
+
+# Quit guestfish
+quit
+EOF
+
+qemu-nbd --connect=$first_nbd $disk_image
+fdisk -lu /dev/nbd0
+dd if=/forensicVM/bin/win10bootp1.raw of=/dev/nbd0p1 bs=4MB status=progress
+dd if=$2 of=/dev/nbd0p2 bs=4MB status=progress
+qemu-nbd --disconnect $first_nbd
+/forensicVM/bin/remove-hibernation.sh $disk_image
+#rm $disk_image
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/create_tap_network.sh
@@ -0,0 +1,126 @@
+#!/bin/bash
+
+apt install bridge-utils -y
+apt install iptables -y
+apt install -y uml-utilities
+
+# Function to find the next available number for bridge and tap interfaces
+find_next_available() {
+    local base_name=$1
+    local i=0
+    while ip link show "${base_name}${i}" >/dev/null 2>&1; do
+        i=$((i+1))
+    done
+    echo "${base_name}${i}"
+}
+
+# The interface for the default route
+default_route_interface=$(route -n | grep 'UG[ \t]' | awk '{print $8}')
+default_route_gw=$(route -n | grep 'UG[ \t]' | awk '{print $2}')
+
+# Find next available bridge and tap interface
+#next_br=$(find_next_available "br")
+next_br=br0
+next_tap=$(find_next_available "tap")
+next_tap=tap1
+
+brctl addbr $next_br
+ip tuntap add dev $next_tap mode tap user `whoami`
+tunctl -u `whoami` -t $next_tap
+brctl addif $next_br $next_tap
+brctl addif $next_br $default_route_interface
+ip link set $next_tap up promisc on
+ip link set $next_tap down
+ifconfig $next_br up
+ifconfig $next_tap down
+
+# Flush existing rules
+iptables -F
+iptables -X
+
+modprobe br_netfilter
+echo 1 > /proc/sys/net/bridge/bridge-nf-call-iptables
+
+iptables -P FORWARD ACCEPT
+
+iptables -A INPUT -i lo -j ACCEPT
+iptables -A OUTPUT -o lo -j ACCEPT
+
+## Accept all other incoming and outgoing traffic, if it's related or established
+iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
+iptables -A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
+
+# Allow all traffic on default_gw
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s $default_route_gw -j ACCEPT
+iptables -A FORWARD -m physdev --physdev-out $next_tap -d $default_route_gw -j ACCEPT
+iptables -A FORWARD -s $default_route_gw -j ACCEPT
+iptables -A FORWARD -d $default_route_gw -j ACCEPT
+
+# Drop all local traffic
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 192.168.0.0/16 -d 192.168.0.0/16 -j DROP
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 172.16.0.0/16 -d 192.168.0.0/16 -j DROP
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 10.0.0.0/8 -d 192.168.0.0/16 -j DROP
+
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 192.168.0.0/16 -d 172.16.0.0/12 -j DROP
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 172.16.0.0/16 -d 172.16.0.0/12 -j DROP
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 10.0.0.0/8 -d 172.16.0.0/12 -j DROP
+
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 192.168.0.0/16 -d 10.0.0.0/8 -j DROP
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 172.16.0.0/16 -d 10.0.0.0/8 -j DROP
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 10.0.0.0/8 -d 10.0.0.0/8 -j DROP
+
+
+
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 192.168.0.0/16 -d 192.168.0.0/16 -j DROP
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 172.16.0.0/16 -d 192.168.0.0/16 -j DROP
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 10.0.0.0/8 -d 192.168.0.0/16 -j DROP
+
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 192.168.0.0/16 -d 172.16.0.0/12 -j DROP
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 172.16.0.0/16 -d 172.16.0.0/12 -j DROP
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 10.0.0.0/8 -d 172.16.0.0/12 -j DROP
+
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 192.168.0.0/16 -d 10.0.0.0/8 -j DROP
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 172.16.0.0/16 -d 10.0.0.0/8 -j DROP
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 10.0.0.0/8 -d 10.0.0.0/8 -j DROP
+
+
+# Accept remaining forwarded traffic
+iptables -A FORWARD -j ACCEPT
+
+
+# IPV6 Firewall
+# The interface for the default route
+default_route_interface_ipv6=$(ip -6 route | grep default | awk '{print $5}')
+default_route_gw_ipv6=$(ip -6 route | grep default | awk '{print $3}')
+
+ip6tables -P FORWARD ACCEPT
+ip6tables -A INPUT -i lo -j ACCEPT
+ip6tables -A OUTPUT -o lo -j ACCEPT
+
+## Accept all other incoming and outgoing traffic, if it's related or established
+ip6tables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
+ip6tables -A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
+
+# Allow all traffic on default_gw_ipv6
+ip6tables -A FORWARD -m physdev --physdev-in $next_tap -s $default_route_gw_ipv6 -j ACCEPT
+ip6tables -A FORWARD -m physdev --physdev-out $next_tap -d $default_route_gw_ipv6 -j ACCEPT
+ip6tables -A FORWARD -s $default_route_gw_ipv6 -j ACCEPT
+ip6tables -A FORWARD -d $default_route_gw_ipv6 -j ACCEPT
+
+# Drop all local traffic
+ip6tables -A FORWARD -m physdev --physdev-out $next_tap -s fc00::/7 -d fc00::/7 -j DROP
+ip6tables -A FORWARD -m physdev --physdev-out $next_tap -s fe80::/10 -d fc00::/7 -j DROP
+
+ip6tables -A FORWARD -m physdev --physdev-in $next_tap -s fc00::/7 -d fc00::/7 -j DROP
+ip6tables -A FORWARD -m physdev --physdev-in $next_tap -s fe80::/10 -d fc00::/7 -j DROP
+
+# Accept remaining forwarded traffic
+ip6tables -A FORWARD -j ACCEPT
+
+
+echo "Bridge: $next_br"
+echo "Tap: $next_tap"
+echo "Interface: $default_route_interface"
+echo "Interface: $default_route_interface_ipv6"
+echo "GW: $default_route_gw"
+echo "GW: $default_route_gw_ipv6"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/end_tap.sh
@@ -0,0 +1,114 @@
+#!/bin/bash
+
+# The interface for the default route
+default_route_interface=br0
+#$(route -n | grep 'UG[ \t]' | awk '{print $8}' | tail -n 1)
+default_route_gw=$(route -n | grep 'UG[ \t]' | awk '{print $2}' | tail -n 1)
+
+# Find next available bridge and tap interface
+next_br=br0
+next_tap=$1
+
+# Get the uuid from the qemu command line
+#uuid=$(ps -ef | grep qemu | grep $next_tap | awk -F '/' '{ for(i=1;i<=NF;i++) if ($i ~ /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/) print $i; exit}' | awk '{print $1}')
+#uuid=$(ps -ef | grep qemu | grep $next_tap | awk -F '/' '{ for(i=1;i<=NF;i++) if ($i ~ /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/) {print $i; exit}}')
+uuid=$(ps -ef | grep qemu | grep $next_tap | awk -F '/' '{ for(i=1;i<=NF;i++) if ($i ~ /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/) {print $i; exit}}')
+
+echo $uuid
+
+# Check if the pcap directory exists and create if not
+if [[ ! -e /forensicVM/mnt/vm/${uuid}/pcap ]]; then
+    mkdir -p /forensicVM/mnt/vm/${uuid}/pcap
+fi
+
+# Move the pcap file to the pcap directory
+pcap_file_num=$(ls /forensicVM/mnt/vm/${uuid}/pcap/network*.pcap 2>/dev/null | wc -l)
+new_pcap_file=$(printf "/forensicVM/mnt/vm/%s/pcap/network%04d.pcap" "$uuid" "$((pcap_file_num+1))")
+
+if [[ -e /forensicVM/mnt/vm/${uuid}/network.pcap ]]; then
+    mv /forensicVM/mnt/vm/${uuid}/network.pcap $new_pcap_file
+fi
+
+# Delete all traffic on default_gw
+iptables -D FORWARD -m physdev --physdev-in $next_tap -s $default_route_gw -j ACCEPT
+iptables -D FORWARD -m physdev --physdev-out $next_tap -d $default_route_gw -j ACCEPT
+iptables -D FORWARD -s $default_route_gw -j ACCEPT
+iptables -D FORWARD -d $default_route_gw -j ACCEPT
+
+# Delete all local traffic
+iptables -D FORWARD -m physdev --physdev-out $next_tap -s 192.168.0.0/16 -d 192.168.0.0/16 -j DROP
+iptables -D FORWARD -m physdev --physdev-out $next_tap -s 172.16.0.0/16 -d 192.168.0.0/16 -j DROP
+iptables -D FORWARD -m physdev --physdev-out $next_tap -s 10.0.0.0/8 -d 192.168.0.0/16 -j DROP
+
+iptables -D FORWARD -m physdev --physdev-out $next_tap -s 192.168.0.0/16 -d 172.16.0.0/12 -j DROP
+iptables -D FORWARD -m physdev --physdev-out $next_tap -s 172.16.0.0/16 -d 172.16.0.0/12 -j DROP
+iptables -D FORWARD -m physdev --physdev-out $next_tap -s 10.0.0.0/8 -d 172.16.0.0/12 -j DROP
+
+iptables -D FORWARD -m physdev --physdev-out $next_tap -s 192.168.0.0/16 -d 10.0.0.0/8 -j DROP
+iptables -D FORWARD -m physdev --physdev-out $next_tap -s 172.16.0.0/16 -d 10.0.0.0/8 -j DROP
+iptables -D FORWARD -m physdev --physdev-out $next_tap -s 10.0.0.0/8 -d 10.0.0.0/8 -j DROP
+
+iptables -D FORWARD -m physdev --physdev-in $next_tap -s 192.168.0.0/16 -d 192.168.0.0/16 -j DROP
+iptables -D FORWARD -m physdev --physdev-in $next_tap -s 172.16.0.0/16 -d 192.168.0.0/16 -j DROP
+iptables -D FORWARD -m physdev --physdev-in $next_tap -s 10.0.0.0/8 -d 192.168.0.0/16 -j DROP
+
+iptables -D FORWARD -m physdev --physdev-in $next_tap -s 192.168.0.0/16 -d 172.16.0.0/12 -j DROP
+iptables -D FORWARD -m physdev --physdev-in $next_tap -s 172.16.0.0/16 -d 172.16.0.0/12 -j DROP
+iptables -D FORWARD -m physdev --physdev-in $next_tap -s 10.0.0.0/8 -d 172.16.0.0/12 -j DROP
+
+iptables -D FORWARD -m physdev --physdev-in $next_tap -s 192.168.0.0/16 -d 10.0.0.0/8 -j DROP
+iptables -D FORWARD -m physdev --physdev-in $next_tap -s 172.16.0.0/16 -d 10.0.0.0/8 -j DROP
+iptables -D FORWARD -m physdev --physdev-in $next_tap -s 10.0.0.0/8 -d 10.0.0.0/8 -j DROP
+
+
+# Delete remaining forwarded traffic
+iptables -D FORWARD -j ACCEPT
+
+
+# IPV6 Firewall
+# The interface for the default route
+default_route_interface_ipv6=br0
+#$(ip -6 route | grep default | awk '{print $5}' | tail -n 1)
+default_route_gw_ipv6=$(ip -6 route | grep default | grep "$default_route_interface_ipv6" | awk '{print $3}' | tail -n 1)
+echo
+echo
+echo $default_route_gw_ipv6
+echo
+echo
+
+# Allow all traffic on default_gw_ipv6
+ip6tables -D FORWARD -m physdev --physdev-in $next_tap -s $default_route_gw_ipv6 -j ACCEPT
+#echo "1"
+ip6tables -D FORWARD -m physdev --physdev-out $next_tap -d $default_route_gw_ipv6 -j ACCEPT
+#echo "2"
+ip6tables -D FORWARD -s $default_route_gw_ipv6 -j ACCEPT
+#echo "3"
+ip6tables -D FORWARD -d $default_route_gw_ipv6 -j ACCEPT
+
+# Drop all local traffic
+ip6tables -D FORWARD -m physdev --physdev-out $next_tap -s fc00::/7 -d fc00::/7 -j DROP
+#echo "4"
+ip6tables -D FORWARD -m physdev --physdev-out $next_tap -s fe80::/10 -d fc00::/7 -j DROP
+#echo "5"
+
+ip6tables -D FORWARD -m physdev --physdev-in $next_tap -s fc00::/7 -d fc00::/7 -j DROP
+#echo "6"
+ip6tables -D FORWARD -m physdev --physdev-in $next_tap -s fe80::/10 -d fc00::/7 -j DROP
+#echo "7"
+
+# Accept remaining forwarded traffic
+ip6tables -D FORWARD -j ACCEPT
+#echo "8"
+
+ip link set $next_tap down
+brctl delif $next_br $next_tap
+ip link delete $next_tap
+#ip link set dev $default_route_interface master $next_br
+
+echo "Bridge: $next_br"
+echo "Tap: $next_tap"
+echo "Interface IPV4: $default_route_interface"
+echo "Interface IPV6: $default_route_interface_ipv6"
+echo "GW IPV4: $default_route_gw"
+echo "GW IPV6: $default_route_gw_ipv6"
+exit 0
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/env.sh
@@ -0,0 +1 @@
+source /forensicVM/main/django-app/env_linux/bin/activate
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/forensic2v.sh
@@ -0,0 +1,451 @@
+#!/bin/bash
+
+# This script is a shell script written in Bash that is designed to convert forensic images into virtual machine images that can be run with QEMU, a virtualization software. The script starts by checking the command-line arguments passed to it, namely the path to the forensic image and the name of the virtual machine to be created. If any of these arguments is missing, the script displays an error message and exits.
+# The script then proceeds to detect the image format of the forensic image, which could be in either qcow2, ewf, or aff format. It does this by using the 'qemu-img info' command to detect if the image is in qcow2 format, or by using the 'ewfinfo' and 'affinfo' commands to detect if it is in ewf or aff format respectively. If the format is not detected, the script displays an error message and exits.
+# Next, the script mounts the forensic image using the appropriate command for the detected image format, and extracts information about the image using the 'virt-inspector' command. It then creates a snapshot of the image using the 'qemu-img create' command and sets up a block device using the 'qemu-nbd' command.
+# The script then removes hibernate files from any mounted NTFS partitions in the snapshot using the 'ntfsfix' command, adds virtio drivers and QEMU guest agent to the snapshot using the 'virt-v2v' command, and modifies the QEMU startup script to include necessary parameters.
+# If the script is run in 'copy' mode, it unmounts the mounted directories and deletes the temporary snapshot. If the script is run in 'snap' mode, it leaves the mounted directories and the temporary snapshot intact for later use. Finally, the script records the time it started and the time it ended, and calculates and displays the elapsed time.
+
+
+# Record the start time
+start_time=$(date +%s)
+
+check_disk_partitions() {
+  local image_file="$1"
+
+  # Use fdisk to check disk partitions and grep for "not in disk order"
+  if fdisk -lu "$image_file" | grep -q "not in disk order"; then
+    echo "Invalid partitions detected in $image_file"
+    return 1
+  else
+    echo "No invalid partitions found in $image_file"
+    return 0
+  fi
+}
+
+get_first_free_nbd() {
+    for nbd_device in /dev/nbd*; do
+        echo $nbd_device
+        if ! $(lsblk -l | grep -q "^${nbd_device#/dev/}"); then
+            echo "$nbd_device"
+            return
+        fi
+    done
+    echo ""
+}
+
+first_nbd=$(get_first_free_nbd)
+first_nbd="/dev/nbd2"
+echo $first_nbd
+#read -p "pause"
+#exit 1
+
+# Helper function: Change qemu startup script.
+# This is a Bash function that generates a modified QEMU virtual machine configuration file based on the input parameters.
+
+# The function takes four arguments:
+
+# $1 - the path to the original QEMU virtual machine configuration file
+# $2 - the path to the output file where the modified configuration will be saved
+# $3 - the path to the QEMU monitor socket
+# $4 - the path to the PID file for the QEMU process
+# $5 - the path of the vm
+# The function first reads the original configuration file and filters out certain lines using grep. It # then replaces a path string using sed.
+# The modified QEMU configuration includes additional parameters for the display, QEMU monitor, USB devices, VGA, and boot options. It also adds a read-only CD-ROM drive to the virtual machine.
+# The modified configuration is then saved to the output file specified by $2. The file permissions are set to 700 to ensure that only the owner can execute it.
+
+function change_qemu_vm {
+   #echo "$5"
+
+   missingScript="
+qemu-system-x86_64 \\
+    -no-user-config \\
+    -nodefaults \\
+    -name S0002-P0001.qcow2 \\
+    -machine pc,accel=kvm:tcg \\
+    -m 2048 \\
+    -drive file=$5/S0002-P0001.qcow2-sda,format=qcow2,if=virtio,index=0,media=disk \\"
+
+   startScript="#!/bin/bash
+
+# Function to find the next available number for bridge and tap interfaces
+find_next_available() {
+     local base_name=\$1
+     local i=0
+     while ip link show \"\${base_name}\${i}\" >/dev/null 2>&1; do
+        i=\$((i+1))
+     done
+     echo \"\${base_name}\${i}\"
+}
+
+tapInterface=\$(find_next_available \"tap\")
+
+echo \$tapInterface > $5/tap.interface
+"
+   if [ -f "$1" ]; then
+      vmconfig=$(cat "$1" | grep -v bash | grep -v /bin/sh | grep -v net0 | grep -v display | grep -v qxl | grep -v balloon | grep -v viosock | sed 's|format=raw|format=qcow2|g' | sed "s|cp '/usr/share/OVMF/OVMF_VARS.fd'|cp -n '/forensicVM/usr/share/qemu/OVMF_VARS.qcow2'|" | sed 's|/usr/share/OVMF/OVMF_CODE.fd|/forensicVM/usr/share/qemu/OVMF_CODE.qcow2|' | sed "s|\$uefi_vars|$5/OVMF_VARS.qcow2|")
+   else
+	vmconfig=$missingScript
+        echo "Appending extra qemu init"
+   fi
+   extra_parameters="-display vnc=0.0.0.0:\$1,websocket=\$2 \\
+    -qmp unix:$3,server,nowait \\
+    -pidfile $4 \\
+    -usb -device usb-tablet -device usb-kbd \\
+    -drive if=none,id=drive-ide0-0-0,readonly=on \\
+    -device ide-cd,bus=ide.0,unit=0,drive=drive-ide0-0-0,id=ide0-0-0 \\
+    -vga virtio \\
+    -drive file=evidence.qcow2,format=qcow2,if=virtio,index=1,media=disk \\
+    -boot menu=on,strict=on,reboot-timeout=10000,splash-time=20000,splash=/forensicVM/branding/bootsplash.jpg \\
+    -netdev tap,id=u1,ifname=\$tapInterface,script=/forensicVM/bin/start_tap.sh,downscript=/forensicVM/bin/end_tap.sh -device e1000,netdev=u1 -object filter-dump,id=f1,netdev=u1,file=$5/network.pcap"
+    echo "$startScript
+    $vmconfig
+    $extra_parameters" >$2
+
+    chmod 700 $2
+
+}
+
+function create_and_format_qcow2 {
+    # Path to the new QCOW2 file
+    qcow2_file="$1"
+
+    # Create a new QCOW2 file with 20GB of space
+    qemu-img create -f qcow2 $qcow2_file 20G
+
+    # Name for the label
+    label_name="possible evidence"
+
+    # Create a new NTFS partition with guestfish
+    guestfish --rw -a $qcow2_file <<EOF
+    launch
+#   part-init /dev/sda gpt
+    part-init /dev/sda mbr
+    part-add /dev/sda p 2048 -1024
+    part-set-mbr-id /dev/sda 1 0x07
+#   part-set-gpt-type /dev/sda 1 EBD0A0A2-B9E5-4433-87C0-68B6B72699C7
+    mkfs ntfs /dev/sda1
+    set-label /dev/sda1 "$label_name"
+    mount /dev/sda1 /
+#    mkdir /important001
+#    mkdir /important002
+#    mkdir /important003
+    write /readme.txt "Forensic VM: This drive was automaticaly created. Please put the probable evidence inside the sub-folders with the same tag of autopsy software for the easyest classification"
+    write /leiame.txt "Forensic VM: Este disco foi criado automáticamente. Para facilitar a classificação, por favor coloque as evidências recolhidas nas subpastas que têm o mesmo nome que a etiqueta no software autopsy"
+    umount /
+EOF
+}
+
+# Image is the complete path for the forensic image
+
+if [[ -z $1 ]] || [[ -z $2 ]]; then
+    echo "Sintaxe: forensic2v <forensic-image> <name> [copy|snap]"
+    read -p "Image not detected"
+    exit 1
+fi
+
+
+# Detect what image manager should be used to open the forensic image
+imagemanager=""
+if [[ -n $1 ]]; then
+    qemu-img info "$1" | grep "file format" | grep qcow2
+    if [[ $? -eq 0 ]]; then
+        imagemanager="qemu"
+    else
+      ewfinfo "$1"
+      if [[ $? -eq 0 ]]; then
+          imagemanager="ewf"
+      else
+          affinfo "$1"
+          if [[ $? -eq 0 ]]; then
+             imagemanager="aff"
+          else
+              qemu-img info "$1"
+              if [[ $? -eq 0 ]]; then
+                 imagemanager="qemu"
+              else
+                 echo "Image format not detected. Aborting"
+                 read -p "Image not detected"
+                 exit 1
+              fi
+          fi
+      fi
+  fi
+  else
+      echo "The image parameter (1) is missing"
+      read -p "Image not detected"
+      exit 1
+fi
+
+echo "Converting using utility: $imagemanager"
+
+image=$1
+
+# Name: Name
+name=$2
+# shellcheck disable=SC2236
+if [ ! -z "$3" ]; then
+	mode=$3
+else
+	mode="copy"
+fi
+echo $mode
+
+image_ewf_mnt=/forensicVM/mnt/vm/$name/ewf
+image_aff_mnt=/forensicVM/mnt/vm/$name/aff
+win_mount=/forensicVM/mnt/vm/$name/win
+run_mount=/forensicVM/mnt/vm/$name/run
+evidence_disk=/forensicVM/mnt/vm/$name/evidence.qcow2
+
+qmp_socket=$run_mount/qmp.sock
+run_pid=$run_mount/run.pid
+vm_mount=/forensicVM/mnt/vm
+tmp_mount=$vm_mount
+vm_name=/forensicVM/mnt/vm/$name
+info_name=/forensicVM/mnt/vm/$name/${name}.info
+
+if [ $mode == "snap" ]; then
+   touch /tmp/qemu-img-cp-now
+fi
+
+mkdir "$vm_name"
+mkdir "$image_ewf_mnt"
+mkdir "$image_aff_mnt"
+mkdir "$win_mount"
+mkdir "$run_mount"
+
+function DismountImage {
+     #qemu-nbd --disconnect "/dev/nbd0"
+     qemu-nbd --disconnect $first_nbd
+     if [ $imagemanager == "ewf" ]; then
+        umount "$image_ewf_mnt"
+        echo "Dismounted $image_ewf_mnt"
+     fi
+     if [ $imagemanager == "aff" ]; then
+        umount "$image_aff_mnt"
+        echo "Dismounted $image_aff_mnt"
+
+     fi
+     sleep 5
+}
+
+function CleanUpINT {
+     echo "CleanUp on errors"
+     #qemu-nbd --disconnect "/dev/nbd0"
+     qemu-nbd --disconnect $first_nbd
+     if [ $imagemanager == "ewf" ]; then
+        umount "$image_ewf_mnt"
+     fi
+     if [ $imagemanager == "aff" ]; then
+        umount "$image_aff_mnt"
+     fi
+     rm "${vm_name}/S0001-P0000.qcow2-sda"
+     read -p "Verify if the are any errors. Press any key to continue..."
+     exit 1
+}
+
+function CleanUpEXIT {
+     echo "Normal CleanUp"
+     # Record the end time
+     end_time=$(date +%s)
+
+
+     # Calculate the elapsed time in seconds
+     elapsed_time=$(($end_time - $start_time))
+
+
+     # Convert the elapsed time to days, hours, minutes, and seconds
+     days=$(($elapsed_time / 86400))
+     hours=$(($elapsed_time / 3600 % 24))
+     minutes=$(($elapsed_time / 60 % 60))
+     seconds=$(($elapsed_time % 60))
+
+
+     # Print the elapsed time in days, hours, minutes, and seconds
+     echo "Elapsed time: $days days, $hours hours, $minutes minutes, $seconds seconds"
+     read -p "Verify if the are any errors. Press any key to continue..."
+     exit 0
+}
+
+# Call the CleanUp function on exit
+
+trap CleanUpINT INT
+trap CleanUpEXIT EXIT
+
+
+tput bold
+tput setaf 2
+echo "1) Access forensic image location"
+tput sgr0
+tput bold
+tput setaf 2
+echo "2) Mount forensic image"
+tput sgr0
+
+if [ $imagemanager == "ewf" ]; then
+   ewfmount "$image" "$image_ewf_mnt"/
+   # TODO: Create an extra mount image to snapshot
+fi
+
+if [ $imagemanager == "aff" ]; then
+   affuse -o direct_io "$image" "$image_aff_mnt"/
+   if [[ $? -eq 0 ]]; then
+       affrawmnt="${image_aff_mnt}/`ls $image_aff_mnt`"
+       echo "Image mounted on: $affrawmnt"
+       # TODO: Create an extra mount image to snapshot
+   else
+       echo "Error: could not mount $image"
+       read -p ""
+       exit 1
+   fi
+fi
+
+tput bold
+tput setaf 2
+echo "3) Get image information"
+tput sgr0
+if [ $imagemanager == "ewf" ]; then
+   virt-inspector "$image_ewf_mnt"/ewf1 > ${info_name}
+   # DEBUG: Comment bellow:
+   #bash -i
+fi
+
+if [ $imagemanager == "aff" ]; then
+   virt-inspector "$affrawmnt" > ${info_name}
+   # DEBUG: Comment bellow:
+   #bash -i
+fi
+
+if [ $imagemanager == "qemu" ]; then
+   virt-inspector "$1" > ${info_name}
+fi
+
+
+tput bold
+tput setaf 2
+echo "4) Create backing file snapshot"
+tput sgr0
+# shellcheck disable=SC2164
+cd "$vm_name"
+forensic_source=""
+if [ $imagemanager == "ewf" ]; then
+   qemu-img create -f qcow2 -b "$image_ewf_mnt"/ewf1 -F raw S0001-P0000.qcow2-sda
+   forensic_source="$image_ewf_mnt"/ewf1
+fi
+
+if [ $imagemanager == "aff" ]; then
+   echo "$affrawmnt"
+   ls "$affrawmnt"
+   qemu-img create -f qcow2 -b "$affrawmnt" -F raw S0001-P0000.qcow2-sda
+   forensic_source="$affrawmnt"
+fi
+
+if [ $imagemanager == "qemu" ]; then
+   qemu-img create -f qcow2 -b "$1" -F qcow2 S0001-P0000.qcow2-sda
+   forensic_source="$1"
+fi
+
+tput bold
+tput setaf 2
+
+
+
+
+echo "5) Activate nbd block device"
+tput sgr0
+/sbin/modprobe nbd max_parts=25
+qemu-nbd --connect=$first_nbd S0001-P0000.qcow2-sda
+echo qemu-nbd --connect=$first_nbd S0001-P0000.qcow2-sda
+#read -p "pause"
+#qemu-nbd --connect=/dev/nbd0 S0001-P0000.qcow2-sda
+tput bold
+tput setaf 2
+echo "6) Remove hibernate file"
+tput sgr0
+# shellcheck disable=SC2162
+xmllint --xpath '//mountpoint' ${info_name} | awk -F'"' '{print $2}' | while read line ; do
+   NUMBER=$(echo "$line" | tr -dc '0-9')
+   tput bold
+   tput setaf 2
+   echo "6.1) Removing hibernate file form partition number $NUMBER"
+   tput sgr0
+   ntfsfix "${first_nbd}p$NUMBER"
+   sync
+   ntfsfix -d "${first_nbd}p$NUMBER"
+   sync
+   mount -t ntfs-3g "${first_nbd}p$NUMBER" "$win_mount" -o remove_hiberfile
+   umount  "$win_mount"
+   ntfsfix "${first_nbd}p$NUMBER"
+   sync
+   ntfsfix -d "${first_nbd}p$NUMBER"
+done
+qemu-nbd --disconnect "${first_nbd}"
+sync
+
+
+tput bold
+tput setaf 2
+echo "7) Add virtio drivers and qemu guest"
+tput sgr0
+virt-v2v -i disk "$vm_name/S0001-P0000.qcow2-sda"  -o qemu -of qcow2 -os "$vm_name" -on "S0002-P0001.qcow2"
+#DEBUG
+if [[ $? -eq 1 ]]; then
+   check_disk_partitions "$forensic_source"
+   exit_code=$?
+   # Check if forrensic image has valid partions or is a single partion
+   if [ $exit_code -eq 0 ]; then
+      echo "Valid partitions detected. Copying image..."
+      qemu-img convert -p -O qcow2 "$forensic_source" "$vm_name/S0002-P0001.qcow2-sda"
+   else
+      echo "Invalid partitions detected."
+      tput bold
+      tput setaf 2
+      echo "Disk without partitions. Forensic image probably of a single partion. Heading to plan B..."
+      echo "/forensicVM/bin/create-windows-partition.sh" "${vm_name}/temp_image.qcow2" $forensic_source ${vm_name}/S0002-P0001.qcow2
+      tput sgr0
+      /forensicVM/bin/create-windows-partition.sh "${vm_name}/temp_image.qcow2" $forensic_source ${vm_name}/S0002-P0001.qcow2
+      #/forensicVM/bin/create-windows-partition.sh "${vm_name}/temp_image.qcow2" "$vm_name/S0001-P0000.qcow2-sda"  ${vm_name}/S0002-P0001.qcow2
+      echo virt-v2v -i disk "${vm_name}/temp_image.qcow2" -o qemu -of qcow2 -os "$vm_name" -on "S0002-P0001.qcow2"
+      virt-v2v -i disk "${vm_name}/temp_image.qcow2" -o qemu -of qcow2 -os "$vm_name" -on "S0002-P0001.qcow2"
+      echo virt-inspector "${vm_image}/S0002-P0001.qcow2-sda" > ${info_name}
+      virt-inspector "S0002-P0001.qcow2-sda" > ${info_name}
+   fi
+   #echo bash -i
+   #bash -i
+fi
+
+change_qemu_vm "$vm_name/S0002-P0001.qcow2.sh" "$vm_name/S0002-P0001.qcow2-vnc.sh" "$qmp_socket" "$run_pid" "$vm_name"
+
+tput bold
+tput setaf 2
+echo "8) Create a evidence disk"
+tput sgr0
+# Create a evidence disk
+create_and_format_qcow2 "${evidence_disk}"
+
+
+if [ $mode != "snap" ]; then
+  tput bold
+  tput setaf 2
+  echo "9) Umounting paths"
+  tput sgr0
+  cd ..
+  if [ $imagemanager == "ewf" ]; then
+     umount "$image_ewf_mnt"
+  fi
+
+  if [ $imagemanager == "aff" ]; then
+     umount "$image_aff_mnt"
+  fi
+
+  tput bold
+  tput setaf 2
+  echo "10) Delete temp snapshot"
+  tput sgr0
+  rm "${vm_name}/S0001-P0000.qcow2-sda"
+  echo "copy" > "${vm_name}/mode"
+else
+  DismountImage
+  echo "snap" > "${vm_name}/mode"
+fi
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/messages.pot
@@ -0,0 +1,18 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
+#
+#, fuzzy
+msgid ""
+msgstr ""
+"Project-Id-Version: PACKAGE VERSION\n"
+"Report-Msgid-Bugs-To: \n"
+"POT-Creation-Date: 2023-03-04 12:07+0000\n"
+"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
+"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
+"Language-Team: LANGUAGE <LL@li.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=CHARSET\n"
+"Content-Transfer-Encoding: 8bit\n"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/qemu-img
@@ -0,0 +1,13 @@
+#!/bin/bash
+echo "interceptado" >> /tmp/qemu-forensicVM.txt
+echo $@ >> /tmp/qemu-forensicVM.txt
+if [[ $1 == "convert" ]] && [[ ${10} == *"tmp"* ]] && [[ ${11} == *"forensicVM"* ]] && [[ -f "/tmp/qemu-img-cp-now" ]]; then
+    rm /tmp/qemu-img-cp-now
+    mv ${10} ${11}
+    touch ${10}
+    exit 0
+else
+    /usr/bin/qemu-img.forensicVM $@
+    erro=$?
+fi
+exit $erro
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/remove-hibernation.sh
@@ -0,0 +1,59 @@
+if [ -z "$1" ]; then
+    echo "sintaxe: disable-hibernation.sh <image.qcow2>"
+    exit 1
+fi
+
+image=$1
+randname=`cat /dev/urandom | tr -cd 'a-f0-9' | head -c 7;`
+tput sgr0
+win_mount="/tmp/$randname-win"
+mkdir ${win_mount}
+tput bold
+tput setaf 2
+echo "Inspect image $1"
+tput sgr0
+virt-inspector $image > /tmp/$randname.txt
+/sbin/modprobe nbd max_parts=25
+first_nbd=""
+for nbd_device in /dev/nbd*; do
+    /sbin/nbd-client -c $nbd_device
+    if [[ $? -eq 1 ]]; then
+        first_nbd=$nbd_device
+        echo $first_nbd
+        break
+    fi
+done
+
+if [ -n "$first_nbd" ]; then
+    echo "First available NBD device: $first_nbd"
+else
+    echo "First available NBD device: $first_nbd"
+    echo "Error: No available NBD devices found"
+    exit 1
+fi
+qemu-nbd --connect=$first_nbd $image
+tput bold
+tput setaf 2
+echo "Remove hibernate file"
+tput sgr0
+xmllint --xpath '//mountpoint' /tmp/$randname.txt | awk -F'"' '{print $2}' | while read line ; do
+   NUMBER=$(echo $line | tr -dc '0-9')
+   tput bold
+   tput setaf 2
+   echo "Removing hibernate file form partion number $NUMBER"
+   tput sgr0
+   ntfsfix ${first_nbd}p${NUMBER}
+   sync
+   ntfsfix -d ${first_nbd}p${NUMBER}
+   sync
+   mount -t ntfs-3g ${first_nbd}p${NUMBER} $win_mount -o remove_hiberfile
+   umount  $win_mount
+   ntfsfix ${first_nbd}p${NUMBER}
+   sync
+   ntfsfix -d ${first_nbd}p${NUMBER}
+done
+qemu-nbd --disconnect $first_nbd
+sync
+tput sgr0
+rmdir ${win_mount}
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/run-django
@@ -0,0 +1,4 @@
+source /forensicVM/main/django-app/venv_2023/bin/activate
+source /forensicVM/main/django-app/env_linux/bin/activate
+python3 /forensicVM/main/django-app/manage.py runserver 192.168.1.112:8000 
+deactivate
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/run-django-screen
@@ -0,0 +1,2 @@
+cd /forensicVM/bin
+screen -dmS forensicVM-screen bash run-django
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/run-or-convert.sh
@@ -0,0 +1,79 @@
+#!/bin/bash
+
+echo "$@"
+
+# Show help if no arguments or if -h or --help are specified
+if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
+    echo "Usage: $0 --windows-share <value> --share-login <value> --share-password <value> --replacement-share <value> --forensic-image-path <value> --folder-uuid <value> --copy [copy|snap]"
+    exit 0
+fi
+
+echo "1)"
+
+# Parse command-line arguments
+while [[ $# -gt 0 ]]
+do
+key="$1"
+
+case $key in
+    --windows-share)
+    windows_share="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --share-login)
+    share_login="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --share-password)
+    share_password="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --replacement-share)
+    replacement_share="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --forensic-image-path)
+    forensic_image_path="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --folder-uuid)
+    folder_uuid="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --copy)
+    copy="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --share-port)
+    share_port="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    *)    # unknown option
+    echo "Unknown option: $1"
+    exit 1
+    ;;
+esac
+done
+
+echo "2)"
+
+if ! [ -e "/forensicVM/mnt/vm/$folder_uuid/mode" ]
+then
+   echo "3)"
+   mkdir /forensicVM/mnt/vm/$folder_uuid
+   mkdir /forensicVM/mnt/vm/$folder_uuid/mnt
+   # Mount the windows share
+   mount -o username="$share_login",pass="$share_password",nobrl,ro,port=$share_port -t cifs "//127.0.0.1/$windows_share" "/forensicVM/mnt/vm/$folder_uuid/mnt"
+
+   # Run forensic2v script
+   /forensicVM/bin/forensic2v.sh "/forensicVM/mnt/vm/$folder_uuid/mnt/$forensic_image_path" "$folder_uuid" "$copy"
+   umount /forensicVM/mnt/vm/$folder_uuid/mnt
+fi
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/run_snap_1
@@ -0,0 +1,79 @@
+#!/bin/bash
+
+echo "$@"
+
+# Show help if no arguments or if -h or --help are specified
+if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
+    echo "Usage: $0 --windows-share <value> --share-login <value> --share-password <value> --replacement-share <value> --forensic-image-path <value> --folder-uuid <value> --copy [copy|snap]"
+    exit 0
+fi
+
+echo "1)"
+
+# Parse command-line arguments
+while [[ $# -gt 0 ]]
+do
+key="$1"
+
+case $key in
+    --windows-share)
+    windows_share="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --share-login)
+    share_login="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --share-password)
+    share_password="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --replacement-share)
+    replacement_share="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --forensic-image-path)
+    forensic_image_path="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --folder-uuid)
+    folder_uuid="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --copy)
+    copy="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --share-port)
+    share_port="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    *)    # unknown option
+    echo "Unknown option: $1"
+    exit 1
+    ;;
+esac
+done
+
+echo "2)"
+
+if [ -e "/forensicVM/mnt/vm/$folder_uuid/mode" ]
+then
+   echo "3)"
+   mkdir /forensicVM/mnt/vm/$folder_uuid
+   mkdir /forensicVM/mnt/vm/$folder_uuid/mnt
+   # Mount the windows share
+   mount -o username="$share_login",pass="$share_password",nobrl,ro,port=$share_port -t cifs "//127.0.0.1/$windows_share" "/forensicVM/mnt/vm/$folder_uuid/mnt"
+
+   # Run forensic2v script
+   /forensicVM/bin/run_snap_2 "/forensicVM/mnt/vm/$folder_uuid/mnt/$forensic_image_path" "$folder_uuid" "$copy"
+   umount /forensicVM/mnt/vm/$folder_uuid/mnt
+fi
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/run_snap_2
@@ -0,0 +1,440 @@
+#!/bin/bash
+
+# Record the start time
+start_time=$(date +%s)
+
+check_disk_partitions() {
+  local image_file="$1"
+
+  # Use fdisk to check disk partitions and grep for "not in disk order"
+  if fdisk -lu "$image_file" | grep -q "not in disk order"; then
+    echo "Invalid partitions detected in $image_file"
+    return 1
+  else
+    echo "No invalid partitions found in $image_file"
+    return 0
+  fi
+}
+
+get_first_free_nbd() {
+    for nbd_device in /dev/nbd*; do
+        echo $nbd_device
+        if ! $(lsblk -l | grep -q "^${nbd_device#/dev/}"); then
+            echo "$nbd_device"
+            return
+        fi
+    done
+    echo ""
+}
+
+first_nbd=$(get_first_free_nbd)
+first_nbd="/dev/nbd2"
+echo $first_nbd
+
+
+find_available_ports() {
+    local start_port=$1
+    local port=$start_port
+    local max_retries=100
+    local retry_count=0
+    while true; do
+        nc -z localhost $port &>/dev/null
+        status_port1=$?
+        nc -z localhost $(($port + 1)) &>/dev/null
+        status_port2=$?
+        if [ $status_port1 -ne 0 ] && [ $status_port2 -ne 0 ]; then
+            echo "$port $(($port + 1))"
+            break
+        else
+            if [ $retry_count -lt $max_retries ]; then
+                retry_count=$(($retry_count + 1))
+                port=$(($port + 1))  # Try the next port
+                sleep 1  # Wait for 1 second before retrying
+            else
+                echo "Max retries exceeded. Unable to find available ports." >&2
+                exit 1
+            fi
+        fi
+    done
+}
+
+#function change_qemu_vm {
+#   #echo "$5"
+#
+#   missingScript="
+#qemu-system-x86_64 \\
+#    -no-user-config \\
+#    -nodefaults \\
+#    -name S0002-P0001.qcow2 \\
+#    -machine pc,accel=kvm:tcg \\
+#    -m 2048 \\
+#    -drive file=$5/S0002-P0001.qcow2-sda,format=qcow2,if=virtio,index=0,media=disk \\"
+#
+#   startScript="#!/bin/bash
+#
+## Function to find the next available number for bridge and tap interfaces
+#find_next_available() {
+#     local base_name=\$1
+#     local i=0
+#     while ip link show \"\${base_name}\${i}\" >/dev/null 2>&1; do
+#        i=\$((i+1))
+#     done
+#     echo \"\${base_name}\${i}\"
+#}
+#
+#tapInterface=\$(find_next_available \"tap\")
+#
+#echo \$tapInterface > $5/tap.interface
+#"
+#   if [ -f "$1" ]; then
+#      vmconfig=$(cat "$1" | grep -v bash | grep -v /bin/sh | grep -v net0 | grep -v display | grep -v qxl | grep -v balloon | grep -v viosock | sed 's|format=raw|format=qcow2|g' | sed "s|cp '/usr/share/OVMF/OVMF_VARS.fd'|cp -n '/forensicVM/usr/share/qemu/OVMF_VARS.qcow2'|" | sed 's|/usr/share/OVMF/OVMF_CODE.fd|/forensicVM/usr/share/qemu/OVMF_CODE.qcow2|' | sed "s|\$uefi_vars|$5/OVMF_VARS.qcow2|")
+#   else
+#	vmconfig=$missingScript
+#        echo "Appending extra qemu init"
+#   fi
+#   extra_parameters="-display vnc=0.0.0.0:\$1,websocket=\$2 \\
+#    -qmp unix:$3,server,nowait \\
+#    -pidfile $4 \\
+#    -usb -device usb-tablet -device usb-kbd \\
+#    -drive if=none,id=drive-ide0-0-0,readonly=on \\
+#    -device ide-cd,bus=ide.0,unit=0,drive=drive-ide0-0-0,id=ide0-0-0 \\
+#    -vga virtio \\
+#    -drive file=evidence.qcow2,format=qcow2,if=virtio,index=1,media=disk \\
+#    -boot menu=on,strict=on,reboot-timeout=10000,splash-time=20000,splash=/forensicVM/branding/bootsplash.jpg \\
+#    -netdev tap,id=u1,ifname=\$tapInterface,script=/forensicVM/bin/start_tap.sh,downscript=/forensicVM/bin/end_tap.sh -device e1000,netdev=u1 -object filter-dump,id=f1,netdev=u1,file=$5/network.pcap"
+#    echo "$startScript
+#    $vmconfig
+#    $extra_parameters" >$2
+#
+#    chmod 700 $2
+#
+#}
+
+function create_and_format_qcow2 {
+    # Path to the new QCOW2 file
+    qcow2_file="$1"
+
+    # Create a new QCOW2 file with 20GB of space
+    qemu-img create -f qcow2 $qcow2_file 20G
+
+    # Name for the label
+    label_name="possible evidence"
+
+    # Create a new NTFS partition with guestfish
+    guestfish --rw -a $qcow2_file <<EOF
+    launch
+#   part-init /dev/sda gpt
+    part-init /dev/sda mbr
+    part-add /dev/sda p 2048 -1024
+    part-set-mbr-id /dev/sda 1 0x07
+#   part-set-gpt-type /dev/sda 1 EBD0A0A2-B9E5-4433-87C0-68B6B72699C7
+    mkfs ntfs /dev/sda1
+    set-label /dev/sda1 "$label_name"
+    mount /dev/sda1 /
+#    mkdir /important001
+#    mkdir /important002
+#    mkdir /important003
+    write /readme.txt "Forensic VM: This drive was automaticaly created. Please put the probable evidence inside the sub-folders with the same tag of autopsy software for the easyest classification"
+    write /leiame.txt "Forensic VM: Este disco foi criado automáticamente. Para facilitar a classificação, por favor coloque as evidências recolhidas nas subpastas que têm o mesmo nome que a etiqueta no software autopsy"
+    umount /
+EOF
+}
+
+# Image is the complete path for the forensic image
+
+if [[ -z $1 ]] || [[ -z $2 ]]; then
+    echo "Sintaxe: forensic2v <forensic-image> <name> [copy|snap]"
+    read -p "Image not detected"
+    exit 1
+fi
+
+
+# Detect what image manager should be used to open the forensic image
+imagemanager=""
+if [[ -n $1 ]]; then
+    qemu-img info "$1" | grep "file format" | grep qcow2
+    if [[ $? -eq 0 ]]; then
+        imagemanager="qemu"
+    else
+      ewfinfo "$1"
+      if [[ $? -eq 0 ]]; then
+          imagemanager="ewf"
+      else
+          affinfo "$1"
+          if [[ $? -eq 0 ]]; then
+             imagemanager="aff"
+          else
+              qemu-img info "$1"
+              if [[ $? -eq 0 ]]; then
+                 imagemanager="qemu"
+              else
+                 echo "Image format not detected. Aborting"
+                 read -p "Image not detected"
+                 exit 1
+              fi
+          fi
+      fi
+  fi
+  else
+      echo "The image parameter (1) is missing"
+      read -p "Image not detected"
+      exit 1
+fi
+
+echo "Open using utility: $imagemanager"
+
+image=$1
+
+# Name: Name
+name=$2
+# shellcheck disable=SC2236
+if [ ! -z "$3" ]; then
+	mode=$3
+else
+	mode="copy"
+fi
+echo $mode
+
+image_ewf_mnt=/forensicVM/mnt/vm/$name/ewf
+image_aff_mnt=/forensicVM/mnt/vm/$name/aff
+win_mount=/forensicVM/mnt/vm/$name/win
+run_mount=/forensicVM/mnt/vm/$name/run
+evidence_disk=/forensicVM/mnt/vm/$name/evidence.qcow2
+
+qmp_socket=$run_mount/qmp.sock
+run_pid=$run_mount/run.pid
+vm_mount=/forensicVM/mnt/vm
+tmp_mount=$vm_mount
+vm_name=/forensicVM/mnt/vm/$name
+info_name=/forensicVM/mnt/vm/$name/${name}.info
+
+if [ $mode == "snap" ]; then
+   touch /tmp/qemu-img-cp-now
+fi
+
+mkdir "$vm_name"
+mkdir "$image_ewf_mnt"
+mkdir "$image_aff_mnt"
+mkdir "$win_mount"
+mkdir "$run_mount"
+
+function DismountImage {
+     screen -wipe
+     #qemu-nbd --disconnect "/dev/nbd0"
+     qemu-nbd --disconnect $first_nbd
+     if [ $imagemanager == "ewf" ]; then
+        umount -f -l "$image_ewf_mnt"
+        echo "Dismounted $image_ewf_mnt"
+     fi
+     if [ $imagemanager == "aff" ]; then
+        umount -f -l "$image_aff_mnt"
+        echo "Dismounted $image_aff_mnt"
+
+     fi
+     sleep 5
+     screen -wipe
+}
+
+function CleanUpINT {
+     screen -wipe
+     echo "CleanUp on errors"
+     #qemu-nbd --disconnect "/dev/nbd0"
+     qemu-nbd --disconnect $first_nbd
+     if [ $imagemanager == "ewf" ]; then
+        umount -f -l "$image_ewf_mnt"
+     fi
+     if [ $imagemanager == "aff" ]; then
+        umount -f -l "$image_aff_mnt"
+     fi
+     rm "${vm_name}/S0001-P0000.qcow2-sda"
+     screen -wipe
+     exit 0
+}
+
+function CleanUpEXIT {
+     echo "Normal CleanUp"
+     # Record the end time
+     end_time=$(date +%s)
+
+
+     # Calculate the elapsed time in seconds
+     elapsed_time=$(($end_time - $start_time))
+
+
+     # Convert the elapsed time to days, hours, minutes, and seconds
+     days=$(($elapsed_time / 86400))
+     hours=$(($elapsed_time / 3600 % 24))
+     minutes=$(($elapsed_time / 60 % 60))
+     seconds=$(($elapsed_time % 60))
+
+
+     # Print the elapsed time in days, hours, minutes, and seconds
+     echo "Elapsed time: $days days, $hours hours, $minutes minutes, $seconds seconds"
+     screen -wipe
+     exit 0
+}
+
+# Call the CleanUp function on exit
+
+trap CleanUpINT INT
+trap CleanUpEXIT EXIT
+
+
+tput bold
+tput setaf 2
+echo "1) Access forensic image location"
+tput sgr0
+tput bold
+tput setaf 2
+echo "2) Mount forensic image"
+tput sgr0
+
+if [ $imagemanager == "ewf" ]; then
+   ewfmount "$image" "$image_ewf_mnt"/
+   # TODO: Create an extra mount image to snapshot
+fi
+
+if [ $imagemanager == "aff" ]; then
+   affuse -o direct_io "$image" "$image_aff_mnt"/
+   if [[ $? -eq 0 ]]; then
+       affrawmnt="${image_aff_mnt}/`ls $image_aff_mnt`"
+       echo "Image mounted on: $affrawmnt"
+       # TODO: Create an extra mount image to snapshot
+   else
+       echo "Error: could not mount $image"
+       read -p ""
+       exit 1
+   fi
+fi
+
+tput bold
+tput setaf 2
+echo "3) Get image information"
+tput sgr0
+#if [ $imagemanager == "ewf" ]; then
+#   virt-inspector "$image_ewf_mnt"/ewf1 > ${info_name}
+#   # DEBUG: Comment bellow:
+#   #bash -i
+#fi
+#
+#if [ $imagemanager == "aff" ]; then
+#   virt-inspector "$affrawmnt" > ${info_name}
+#   # DEBUG: Comment bellow:
+#   #bash -i
+#fi
+#
+#if [ $imagemanager == "qemu" ]; then
+#   virt-inspector "$1" > ${info_name}
+#fi
+
+
+tput bold
+tput setaf 2
+echo "4) Create backing file snapshot"
+tput sgr0
+# shellcheck disable=SC2164
+cd "$vm_name"
+forensic_source=""
+if [ $imagemanager == "ewf" ]; then
+   qemu-img create -f qcow2 -b "$image_ewf_mnt"/ewf1 -F raw S0001-P0000.qcow2-sda
+   forensic_source="$image_ewf_mnt"/ewf1
+fi
+
+if [ $imagemanager == "aff" ]; then
+   echo "$affrawmnt"
+   ls "$affrawmnt"
+   qemu-img create -f qcow2 -b "$affrawmnt" -F raw S0001-P0000.qcow2-sda
+   forensic_source="$affrawmnt"
+fi
+
+if [ $imagemanager == "qemu" ]; then
+   qemu-img create -f qcow2 -b "$1" -F qcow2 S0001-P0000.qcow2-sda
+   forensic_source="$1"
+fi
+
+tput bold
+tput setaf 2
+
+
+
+
+#echo "5) Activate nbd block device"
+#tput sgr0
+#/sbin/modprobe nbd max_parts=25
+#qemu-nbd --connect=$first_nbd S0001-P0000.qcow2-sda
+#echo qemu-nbd --connect=$first_nbd S0001-P0000.qcow2-sda
+##read -p "pause"
+##qemu-nbd --connect=/dev/nbd0 S0001-P0000.qcow2-sda
+#tput bold
+#tput setaf 2
+#echo "6) Remove hibernate file"
+#tput sgr0
+## shellcheck disable=SC2162
+#xmllint --xpath '//mountpoint' ${info_name} | awk -F'"' '{print $2}' | while read line ; do
+#   NUMBER=$(echo "$line" | tr -dc '0-9')
+#   tput bold
+#   tput setaf 2
+#   echo "6.1) Removing hibernate file form partition number $NUMBER"
+#   tput sgr0
+#   ntfsfix "${first_nbd}p$NUMBER"
+#   sync
+#   ntfsfix -d "${first_nbd}p$NUMBER"
+#   sync
+#   mount -t ntfs-3g "${first_nbd}p$NUMBER" "$win_mount" -o remove_hiberfile
+#   umount  "$win_mount"
+#   ntfsfix "${first_nbd}p$NUMBER"
+#   sync
+#   ntfsfix -d "${first_nbd}p$NUMBER"
+#done
+#qemu-nbd --disconnect "${first_nbd}"
+#sync
+
+
+#tput bold
+#tput setaf 2
+#echo "7) Add virtio drivers and qemu guest"
+#tput sgr0
+#virt-v2v -i disk "$vm_name/S0001-P0000.qcow2-sda"  -o qemu -of qcow2 -os "$vm_name" -on "S0002-P0001.qcow2"
+##DEBUG
+#if [[ $? -eq 1 ]]; then
+#   check_disk_partitions "$forensic_source"
+#   exit_code=$?
+#   # Check if forrensic image has valid partions or is a single partion
+#   if [ $exit_code -eq 0 ]; then
+#      echo "Valid partitions detected. Copying image..."
+#      qemu-img convert -p -O qcow2 "$forensic_source" "$vm_name/S0002-P0001.qcow2-sda"
+#   else
+#      echo "Invalid partitions detected."
+#      tput bold
+#      tput setaf 2
+#      echo "Disk without partitions. Forensic image probably of a single partion. Heading to plan B..."
+#      echo "/forensicVM/bin/create-windows-partition.sh" "${vm_name}/temp_image.qcow2" $forensic_source ${vm_name}/S0002-P0001.qcow2
+#      tput sgr0
+#      /forensicVM/bin/create-windows-partition.sh "${vm_name}/temp_image.qcow2" $forensic_source ${vm_name}/S0002-P0001.qcow2
+#      #/forensicVM/bin/create-windows-partition.sh "${vm_name}/temp_image.qcow2" "$vm_name/S0001-P0000.qcow2-sda"  ${vm_name}/S0002-P0001.qcow2
+#      echo virt-v2v -i disk "${vm_name}/temp_image.qcow2" -o qemu -of qcow2 -os "$vm_name" -on "S0002-P0001.qcow2"
+#      virt-v2v -i disk "${vm_name}/temp_image.qcow2" -o qemu -of qcow2 -os "$vm_name" -on "S0002-P0001.qcow2"
+#      echo virt-inspector "${vm_image}/S0002-P0001.qcow2-sda" > ${info_name}
+#      virt-inspector "S0002-P0001.qcow2-sda" > ${info_name}
+#   fi
+#   #echo bash -i
+#   #bash -i
+#fi
+
+start_port=5900
+result=$(find_available_ports $start_port)
+
+echo "Available ports: $result"
+screen -m -S $name bash "$vm_name/S0002-P0001.qcow2-vnc.sh" $result
+
+#tput bold
+#tput setaf 2
+#echo "8) Create a evidence disk"
+#tput sgr0
+## Create a evidence disk
+#create_and_format_qcow2 "${evidence_disk}"
+
+
+DismountImage
+echo "snap" > "${vm_name}/mode"
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/start_tap.sh
@@ -0,0 +1,119 @@
+#!/bin/bash
+
+# The interface for the default route
+default_route_interface=br0
+#$(route -n | grep 'UG[ \t]' | awk '{print $8}' | tail -n 1)
+default_route_gw=$(route -n | grep 'UG[ \t]' | awk '{print $2}' | tail -n 1)
+
+# Find next available bridge and tap interface
+next_br=br0
+next_tap=$1
+
+#brctl addbr $next_br
+ip tuntap add dev $next_tap mode tap user `whoami`
+tunctl -u `whoami` -t $next_tap
+brctl addif $next_br $next_tap
+#brctl addif $next_br $default_route_interface
+ip link set $next_tap up promisc on
+ip link set $next_tap down
+#ifconfig $next_br up
+ifconfig $next_tap down
+#ip link set dev $default_route_interface master $next_br
+
+
+# Flush existing rules
+#iptables -F
+#iptables -X
+
+modprobe br_netfilter
+echo 1 > /proc/sys/net/bridge/bridge-nf-call-iptables
+
+iptables -P FORWARD ACCEPT
+iptables -A INPUT -i lo -j ACCEPT
+iptables -A OUTPUT -o lo -j ACCEPT
+
+## Accept all other incoming and outgoing traffic, if it's related or established
+iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
+iptables -A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
+
+# Allow all traffic on default_gw
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s $default_route_gw -j ACCEPT
+iptables -A FORWARD -m physdev --physdev-out $next_tap -d $default_route_gw -j ACCEPT
+iptables -A FORWARD -s $default_route_gw -j ACCEPT
+iptables -A FORWARD -d $default_route_gw -j ACCEPT
+
+# Drop all local traffic
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 192.168.0.0/16 -d 192.168.0.0/16 -j DROP
+#iptables -A FORWARD -p tcp --syn --physdev-out $next_tap -s 192.168.0.0/16 -d 192.168.0.0/16 -j DROP
+
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 172.16.0.0/16 -d 192.168.0.0/16 -j DROP
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 10.0.0.0/8 -d 192.168.0.0/16 -j DROP
+
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 192.168.0.0/16 -d 172.16.0.0/12 -j DROP
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 172.16.0.0/16 -d 172.16.0.0/12 -j DROP
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 10.0.0.0/8 -d 172.16.0.0/12 -j DROP
+
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 192.168.0.0/16 -d 10.0.0.0/8 -j DROP
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 172.16.0.0/16 -d 10.0.0.0/8 -j DROP
+iptables -A FORWARD -m physdev --physdev-out $next_tap -s 10.0.0.0/8 -d 10.0.0.0/8 -j DROP
+
+
+
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 192.168.0.0/16 -d 192.168.0.0/16 -j DROP
+#iptables -A FORWARD -p tcp --syn --physdev-in $next_tap -s 192.168.0.0/16 -d 192.168.0.0/16 -j DROP
+
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 172.16.0.0/16 -d 192.168.0.0/16 -j DROP
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 10.0.0.0/8 -d 192.168.0.0/16 -j DROP
+
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 192.168.0.0/16 -d 172.16.0.0/12 -j DROP
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 172.16.0.0/16 -d 172.16.0.0/12 -j DROP
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 10.0.0.0/8 -d 172.16.0.0/12 -j DROP
+
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 192.168.0.0/16 -d 10.0.0.0/8 -j DROP
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 172.16.0.0/16 -d 10.0.0.0/8 -j DROP
+iptables -A FORWARD -m physdev --physdev-in $next_tap -s 10.0.0.0/8 -d 10.0.0.0/8 -j DROP
+
+
+# Accept remaining forwarded traffic
+iptables -A FORWARD -j ACCEPT
+
+
+# IPV6 Firewall
+# The interface for the default route
+default_route_interface_ipv6=br0
+#$(ip -6 route | grep default | awk '{print $5}' | tail -n 1)
+default_route_gw_ipv6=$(ip -6 route | grep default | grep "$default_route_interface_ipv6" | awk '{print $3}' | tail -n 1)
+
+ip6tables -P FORWARD DROP
+ip6tables -A INPUT -i lo -j ACCEPT
+ip6tables -A OUTPUT -o lo -j ACCEPT
+
+## Accept all other incoming and outgoing traffic, if it's related or established
+ip6tables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
+ip6tables -A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
+
+# Allow all traffic on default_gw_ipv6
+ip6tables -A FORWARD -m physdev --physdev-in $next_tap -s $default_route_gw_ipv6 -j ACCEPT
+ip6tables -A FORWARD -m physdev --physdev-out $next_tap -d $default_route_gw_ipv6 -j ACCEPT
+ip6tables -A FORWARD -s $default_route_gw_ipv6 -j ACCEPT
+ip6tables -A FORWARD -d $default_route_gw_ipv6 -j ACCEPT
+
+# Drop all local traffic
+ip6tables -A FORWARD -m physdev --physdev-out $next_tap -s fc00::/7 -d fc00::/7 -j DROP
+ip6tables -A FORWARD -m physdev --physdev-out $next_tap -s fe80::/10 -d fc00::/7 -j DROP
+
+ip6tables -A FORWARD -m physdev --physdev-in $next_tap -s fc00::/7 -d fc00::/7 -j DROP
+ip6tables -A FORWARD -m physdev --physdev-in $next_tap -s fe80::/10 -d fc00::/7 -j DROP
+
+# Accept remaining forwarded traffic
+ip6tables -A FORWARD -j ACCEPT
+
+
+echo "Bridge: $next_br"
+echo "Tap: $next_tap"
+echo "Interface IPV4: $default_route_interface"
+echo "Interface IPV6: $default_route_interface_ipv6"
+echo "GW IPV4: $default_route_gw"
+echo "GW IPV6: $default_route_gw_ipv6"
+
+exit 0
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/virt-diff-test.sh
@@ -0,0 +1,72 @@
+image=$1
+name=$2
+
+tput bold
+tput setaf 2
+echo "1) Access forensic image location"
+tput sgr0
+###mount -o username=qemu,pass=qemu,nobrl -t cifs //192.168.1.75/convertidos /mnt/destino
+tput bold
+tput setaf 2
+echo "2) Mount forensic image"
+tput sgr0
+ewfmount $image /mnt/image/
+tput bold
+tput setaf 2
+echo "3) Get image information"
+tput sgr0
+virt-inspector /mnt/image/ewf1 | tee /mnt/destino/soinfo-$name.txt
+tput bold
+tput setaf 2
+echo "4) Create backing file snapshot"
+tput sgr0
+cd /mnt/destino
+qemu-img create -f qcow2 -b /mnt/image/ewf1 -F raw snapshot-temp-$name.qcow2.snap
+tput bold
+tput setaf 2
+echo "5) Activate nbd block device"
+tput sgr0
+modprobe nbd max_parts=25
+qemu-nbd --connect=/dev/nbd0 snapshot-temp-$name.qcow2.snap
+tput bold
+tput setaf 2
+echo "6) Remove hibernate file"
+tput sgr0
+xmllint --xpath '//mountpoint' /mnt/destino/soinfo-mobitral-drivers.txt | awk -F'"' '{print $2}' | while read line ; do
+   NUMBER=$(echo $line | tr -dc '0-9')
+   tput bold
+   tput setaf 2
+   echo "6.1) Removing hibernate file form partion number $NUMBER"
+   tput sgr0
+   ntfsfix /dev/nbd0p$NUMBER
+   sync
+   ntfsfix -d /dev/nbd0p$NUMBER
+   sync
+   mount -t ntfs-3g /dev/nbd0p$NUMBER /mnt/win -o remove_hiberfile
+   umount /mnt/win
+   ntfsfix /dev/nbd0p$NUMBER
+   sync
+   ntfsfix -d /dev/nbd0p$NUMBER
+done
+qemu-nbd --disconnect /dev/nbd0
+sync
+tput bold
+tput setaf 2
+echo "7) Add virtio drivers and qemu guest"
+tput sgr0
+virt-v2v -i disk /mnt/destino/snapshot-temp-$name.qcow2.snap  -o qemu -of qcow2 -os /mnt/destino -on $name.qcow2
+tput bold
+tput setaf 2
+echo "8) Umounting paths"
+tput sgr0
+cd ..
+virt-diff -a /mnt/image/ewf1 -A /mnt/destino/snapshot-temp-$name.qcow2.snap
+umount /mnt/image
+##umount /mnt/destino
+tput bold
+tput setaf 2
+echo "9) Delete temp snapshot"
+tput sgr0
+rm /mnt/destino/snapshot-temp-$name.qcow2.snap
+
+
--- /dev/null
+++ forensic-vm-1.0/make-deb.sh
@@ -0,0 +1,2 @@
+dpkg-source --commit
+dpkg-buildpackage -us -uc
