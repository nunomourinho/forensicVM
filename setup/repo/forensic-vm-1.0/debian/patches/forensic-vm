Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 forensic-vm (1.0-1) unstable; urgency=medium
 .
   * Initial release (Closes: #nnnn)  <nnnn is the bug number of your ITP>
Author: root <root@v2v-forensicVM>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2023-07-24

--- /dev/null
+++ forensic-vm-1.0/find_binaries.sh
@@ -0,0 +1,14 @@
+#!/bin/bash
+
+# Directory to search for binary files (update this path accordingly)
+SEARCH_DIRECTORY="./forensicVM"
+
+# Output file for debian/source/include-binaries
+INCLUDE_BINARIES_FILE="debian/source/include-binaries"
+
+# Find binary files and write to the include-binaries file
+find "$SEARCH_DIRECTORY" -type f -exec file {} \; | grep -E ":.* (executable|shared object)" | awk -F: '{print $1}' > "$INCLUDE_BINARIES_FILE"
+
+echo "Binary files found and added to $INCLUDE_BINARIES_FILE:"
+cat "$INCLUDE_BINARIES_FILE"
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/compile_django.py
@@ -0,0 +1,39 @@
+import argparse
+import compileall
+import os
+import shutil
+import re
+
+def compile_and_copy(input_directory, output_directory):
+    # Compile all .py files in the input directory
+    compileall.compile_dir(input_directory, force=True)
+
+    # Define the Python version suffix that you want to remove
+    suffix = '.cpython-39'
+
+    for foldername, subfolders, filenames in os.walk(input_directory):
+        if '__pycache__' in foldername:
+            for filename in filenames:
+                if filename.endswith(suffix + '.pyc'):
+                    old_filepath = os.path.join(foldername, filename)
+                    new_filename = re.sub(suffix, '', filename)
+
+                    # Create the same directory structure in the output directory
+                    new_foldername = foldername.replace(input_directory, output_directory, 1)
+                    new_foldername = new_foldername.rsplit('__pycache__', 1)[0]  # Remove the __pycache__
+                    os.makedirs(new_foldername, exist_ok=True)
+
+                    new_filepath = os.path.join(new_foldername, new_filename)
+
+                    # Copy the file to the new location
+                    shutil.copy2(old_filepath, new_filepath)
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description='Compile Python files and copy .pyc files to another directory.')
+    parser.add_argument('input_directory', type=str, help='The directory to compile.')
+    parser.add_argument('output_directory', type=str, help='The directory to copy the compiled files to.')
+    args = parser.parse_args()
+
+    # Call the function
+    compile_and_copy(args.input_directory, args.output_directory)
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/bin/compile_django.sh
@@ -0,0 +1,8 @@
+source /forensicVM/main/django-app/env_linux/bin/activate
+python3 compile_django.py /forensicVM/main/django-app /forensicVM/setup/repo/forensic-vm-1.0/forensicVM/main
+rsync -a /forensicVM/bin/ /forensicVM/setup/repo/forensic-vm-1.0/forensicVM/bin
+rsync -a /forensicVM/usr/ /forensicVM/setup/repo/forensic-vm-1.0/forensicVM/usr
+rsync -a /forensicVM/plugins/ /forensicVM/setup/repo/forensic-vm-1.0/forensicVM/plugins
+rsync -a /forensicVM/main/django-app/env_linux/ /forensicVM/setup/repo/forensic-vm-1.0/forensicVM/main/env_linux
+
+deactivate
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/apikeys/_output/apikeys.migrations.rst
@@ -0,0 +1,45 @@
+apikeys.migrations package
+==========================
+
+Submodules
+----------
+
+apikeys.migrations.0001\_initial module
+---------------------------------------
+
+.. automodule:: apikeys.migrations.0001_initial
+   :members:
+   :undoc-members:
+   :show-inheritance:
+
+apikeys.migrations.0002\_alter\_apikey\_key module
+--------------------------------------------------
+
+.. automodule:: apikeys.migrations.0002_alter_apikey_key
+   :members:
+   :undoc-members:
+   :show-inheritance:
+
+apikeys.migrations.0003\_alter\_apikey\_key module
+--------------------------------------------------
+
+.. automodule:: apikeys.migrations.0003_alter_apikey_key
+   :members:
+   :undoc-members:
+   :show-inheritance:
+
+apikeys.migrations.0004\_alter\_apikey\_key module
+--------------------------------------------------
+
+.. automodule:: apikeys.migrations.0004_alter_apikey_key
+   :members:
+   :undoc-members:
+   :show-inheritance:
+
+Module contents
+---------------
+
+.. automodule:: apikeys.migrations
+   :members:
+   :undoc-members:
+   :show-inheritance:
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/apikeys/_output/apikeys.rst
@@ -0,0 +1,77 @@
+apikeys package
+===============
+
+Subpackages
+-----------
+
+.. toctree::
+   :maxdepth: 4
+
+   apikeys.migrations
+
+Submodules
+----------
+
+apikeys.admin module
+--------------------
+
+.. automodule:: apikeys.admin
+   :members:
+   :undoc-members:
+   :show-inheritance:
+
+apikeys.apps module
+-------------------
+
+.. automodule:: apikeys.apps
+   :members:
+   :undoc-members:
+   :show-inheritance:
+
+apikeys.models module
+---------------------
+
+.. automodule:: apikeys.models
+   :members:
+   :undoc-members:
+   :show-inheritance:
+
+apikeys.serializers module
+--------------------------
+
+.. automodule:: apikeys.serializers
+   :members:
+   :undoc-members:
+   :show-inheritance:
+
+apikeys.tests module
+--------------------
+
+.. automodule:: apikeys.tests
+   :members:
+   :undoc-members:
+   :show-inheritance:
+
+apikeys.urls module
+-------------------
+
+.. automodule:: apikeys.urls
+   :members:
+   :undoc-members:
+   :show-inheritance:
+
+apikeys.views module
+--------------------
+
+.. automodule:: apikeys.views
+   :members:
+   :undoc-members:
+   :show-inheritance:
+
+Module contents
+---------------
+
+.. automodule:: apikeys
+   :members:
+   :undoc-members:
+   :show-inheritance:
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/apikeys/_output/modules.rst
@@ -0,0 +1,7 @@
+apikeys
+=======
+
+.. toctree::
+   :maxdepth: 4
+
+   apikeys
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/apikeys/admin.py
@@ -0,0 +1,115 @@
+from django import forms
+from django.contrib import admin
+from django.utils.html import format_html
+from django.contrib import messages
+from .models import ApiKey
+
+class MaskedInput(forms.TextInput):
+    """
+    A custom form input widget that masks the input value.
+
+    This widget replaces the actual value with a masked version for display purposes.
+    The masked value consists of a configurable mask character repeated for the length
+    of the value minus a specified mask length. The remaining characters at the end of
+    the value are displayed as is.
+    """
+    def __init__(self, attrs=None, mask_char='*', mask_length=4):
+        """
+        Initialize the MaskedInput widget.
+
+        Args:
+            attrs (dict, optional): HTML attributes to be added to the rendered widget.
+            mask_char (str, optional): The character used for masking the input value.
+                Defaults to '*'.
+            mask_length (int, optional): The number of characters to be masked at the
+                beginning of the input value. Defaults to 4.
+        """
+        self.mask_char = mask_char
+        self.mask_length = mask_length
+        super().__init__(attrs)
+
+    def format_value(self, value):
+        """
+        Formats the input value with masking.
+
+        Args:
+            value (str): The input value to be formatted.
+
+        Returns:
+            str: The masked value.
+        """
+        if value is None:
+            return None
+        masked_value = self.mask_char * (len(value) - self.mask_length)
+        masked_value += value[-self.mask_length:]
+        return masked_value
+
+class ApiKeyForm(forms.ModelForm):
+    """
+    A form for the ApiKey model.
+
+    This form specifies the model, fields, and any exclusions for the ApiKey model.
+    It also defines a custom widget for the 'key' field to display a masked input.
+    """
+    class Meta:
+        model = ApiKey
+        fields = ['user']
+        exclude = ['key']
+
+
+@admin.register(ApiKey)
+class ApiKeyAdmin(admin.ModelAdmin):
+    """
+    ModelAdmin for the ApiKey model.
+
+    This ModelAdmin provides customizations for the admin interface for the ApiKey model.
+    It specifies the form to use, the list display fields, and additional methods.
+    """
+    form = ApiKeyForm
+    list_display = ('masked_key', 'created_at')
+
+    def masked_key(self, obj):
+        """
+        Returns the masked version of the API key.
+
+        This method takes an ApiKey object and returns a masked version of the API key.
+        The masked version replaces most characters with a mask character, except for the
+        last few characters which are displayed as is.
+        """
+        masked_key_length = 4
+        if obj.key:
+            key = str(obj.key)
+            return f'{key[:masked_key_length]}{"*" * (len(key) - masked_key_length)}'
+        else:
+            return ""
+
+    masked_key.short_description = 'Key'
+
+    def get_queryset(self, request):
+        """
+        Returns the queryset of ApiKey objects.
+
+        This method is used to filter the queryset of ApiKey objects based on the user's
+        privileges. If the user is a superuser, all objects are returned. Otherwise, only
+        the objects belonging to the user are returned.
+        """
+        qs = super().get_queryset(request)
+        if request.user.is_superuser:
+            return qs
+        return qs.filter(user=request.user)
+
+    def save_model(self, request, obj, form, change):
+        """
+        Saves the ApiKey object.
+
+        This method is called when saving an ApiKey object through the admin interface.
+        It sets the user attribute of the object to the current user and then saves the object.
+        Additionally, it displays a success message with the generated API key.
+        """
+        obj.user = request.user
+        super().save_model(request, obj, form, change)
+
+        message = format_html('New API key generated: <strong><h2>{}</h2></strong>   Please copy it to the clipboard. This is the only time that this key is visible', obj.key)
+        messages.success(request, message)
+
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/apikeys/apps.py
@@ -0,0 +1,12 @@
+from django.apps import AppConfig
+
+
+class ApikeysConfig(AppConfig):
+    """
+    AppConfig for the 'apikeys' app.
+
+    This class represents the configuration for the 'apikeys' app.
+    It specifies the default auto field and the name of the app.
+    """
+    default_auto_field = 'django.db.models.BigAutoField'
+    name = 'apikeys'
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/apikeys/migrations/0001_initial.py
@@ -0,0 +1,26 @@
+# Generated by Django 4.1.7 on 2023-05-01 15:32
+
+from django.conf import settings
+from django.db import migrations, models
+import django.db.models.deletion
+
+
+class Migration(migrations.Migration):
+
+    initial = True
+
+    dependencies = [
+        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
+    ]
+
+    operations = [
+        migrations.CreateModel(
+            name='ApiKey',
+            fields=[
+                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
+                ('key', models.CharField(max_length=100, unique=True)),
+                ('created_at', models.DateTimeField(auto_now_add=True)),
+                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
+            ],
+        ),
+    ]
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/apikeys/migrations/0002_alter_apikey_key.py
@@ -0,0 +1,19 @@
+# Generated by Django 4.1.7 on 2023-05-01 16:34
+
+from django.db import migrations, models
+import uuid
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('apikeys', '0001_initial'),
+    ]
+
+    operations = [
+        migrations.AlterField(
+            model_name='apikey',
+            name='key',
+            field=models.UUIDField(default=uuid.uuid4, unique=True),
+        ),
+    ]
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/apikeys/migrations/0003_alter_apikey_key.py
@@ -0,0 +1,19 @@
+# Generated by Django 4.1.7 on 2023-05-01 16:35
+
+from django.db import migrations, models
+import uuid
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('apikeys', '0002_alter_apikey_key'),
+    ]
+
+    operations = [
+        migrations.AlterField(
+            model_name='apikey',
+            name='key',
+            field=models.UUIDField(default=uuid.uuid4, editable=False, unique=True),
+        ),
+    ]
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/apikeys/migrations/0004_alter_apikey_key.py
@@ -0,0 +1,19 @@
+# Generated by Django 4.1.7 on 2023-05-01 17:14
+
+from django.db import migrations, models
+import uuid
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('apikeys', '0003_alter_apikey_key'),
+    ]
+
+    operations = [
+        migrations.AlterField(
+            model_name='apikey',
+            name='key',
+            field=models.UUIDField(default=uuid.uuid4, editable=False, null=True, unique=True),
+        ),
+    ]
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/apikeys/models.py
@@ -0,0 +1,24 @@
+from django.db import models
+from django.contrib.auth.models import User
+import uuid
+
+class ApiKey(models.Model):
+    """Model representing an API key associated with a user."""
+    user = models.ForeignKey(User, on_delete=models.CASCADE)
+    key = models.UUIDField(default=uuid.uuid4, editable=False, unique=True, null=True)
+    created_at = models.DateTimeField(auto_now_add=True)
+
+    def mask_key(self):
+        """Return a masked version of the API key."""
+        masked_key_length = 4
+        if self.key is None:
+            masked_key = 'N/A'
+        else:
+            masked_key = '*' * (len(str(self.key)) - masked_key_length)
+            masked_key += str(self.key)[-masked_key_length:]
+        return masked_key
+
+    def __str__(self):
+        """Return the masked version of the API key when the instance is converted to a string."""
+        return self.mask_key()
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/apikeys/serializers.py
@@ -0,0 +1,21 @@
+"""
+This code defines a serializer class ApiKeySerializer that is used to serialize and deserialize instances of the
+ApiKey model.
+
+The ApiKeySerializer class inherits from the ModelSerializer class provided by the Django REST Framework.
+It specifies the ApiKey model as the model attribute in the Meta class.
+
+The fields attribute in the Meta class specifies the fields that should be included in the serialized representation
+of the ApiKey model. In this case, it includes only the key field.
+
+By using this serializer, one can easily convert instances of the ApiKey model to JSON format (serialization) and
+vice versa (deserialization) when working with API requests and responses.
+"""
+from rest_framework import serializers
+from .models import ApiKey
+
+class ApiKeySerializer(serializers.ModelSerializer):
+    class Meta:
+        model = ApiKey
+        fields = ['key']
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/apikeys/tests.py
@@ -0,0 +1,3 @@
+from django.test import TestCase
+
+# Create your tests here.
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/apikeys/urls.py
@@ -0,0 +1,157 @@
+"""
+The purpose of the program is to provide a set of API endpoints for managing a forensic virtual machine (VM).
+Each view class represents a specific functionality that can be accessed through the corresponding API endpoint.
+Here's a summary of each view's purpose:
+
+ProtectedView: A view that requires API key authentication. Returns an access granted message if the API key is valid.
+
+RunScriptView: Executes a script provided in the request data. Expects an API key and a script parameter.
+Returns the script output and error code.
+
+DeleteVMView: Deletes the forensic VM with the given UUID.
+
+MountFolderView: Mounts a specified folder to the VM with the given UUID.
+
+ResetVMView: Resets the forensic VM with the given UUID.
+
+ShutdownVMView: Shuts down the forensic VM with the given UUID.
+
+DownloadScreenshotsView: Downloads a zip file containing screenshots of the VM with the given UUID.
+
+CreateSshKeysView: Adds a public SSH key to the authorized keys file of the forensic investigator user.
+
+ForensicImageVMStatus: Retrieves the status of the forensic VM with the given UUID.
+
+StartVMView: Starts the forensic VM with the given UUID.
+
+StopVMView: Stops the forensic VM with the given UUID.
+
+CheckVMExistsView: Checks if the forensic VM with the given UUID exists.
+
+ScreenshotVMView: Takes a screenshot of the forensic VM with the given UUID.
+
+MemorySnapshotView: Takes a memory snapshot of the forensic VM with the given UUID.
+
+DownloadEvidenceView: Downloads the evidence file of the forensic VM with the given UUID.
+
+CreateFoldersView: Creates necessary folders for the forensic VM.
+
+ListISOFilesView: Lists ISO files available for the forensic VM.
+
+UploadISOView: Uploads an ISO file for the forensic VM.
+
+DeleteISOFileView: Deletes the specified ISO file for the forensic VM.
+
+EjectCDROMView: Ejects the CD/DVD drive of the forensic VM with the given UUID.
+
+InsertCDROMView: Inserts a specified CD/DVD into the forensic VM with the given UUID.
+
+InsertNetworkCardView: Inserts a network card into the forensic VM with the given UUID.
+
+ListPluginsView: Lists available plugins.
+
+RunPluginView: Runs a specified plugin.
+
+RecreateFoldersView: Recreates necessary folders for the forensic VM.
+
+SnapshotListView: Lists snapshots for the forensic VM with the given UUID.
+
+CreateSnapshotView: Creates a snapshot of the forensic VM with the given UUID.
+
+RollbackSnapshotView: Rolls back to a specified snapshot of the forensic VM with the given UUID.
+
+DeleteSnapshotView: Deletes the specified snapshot of the forensic VM with the given UUID.
+
+MemorySizeView: Retrieves the memory size of the forensic VM with the given UUID.
+
+ChangeMemorySizeView: Changes the memory size of the forensic VM with the given UUID.
+
+GetAvailableMemoryView: Retrieves the available memory of the forensic VM.
+
+StartTapInterfaceView: Starts the tap interface for capturing network traffic.
+
+StopTapInterfaceView: Stops the tap interface for capturing network traffic.
+
+CheckTapInterfaceView: Checks the status of the tap interface for capturing network traffic.
+
+DownloadNetworkPcapView: Downloads a network pcap file for the forensic VM with the given UUID.
+
+ChangeVMDateTimeView: Changes the date and time of the forensic VM with the given UUID.
+
+RemoveVMDateTimeView: Removes the date and time configuration of the forensic VM with the given UUID.
+
+DownloadVideoView: Downloads a video recording of the forensic VM with the given UUID.
+
+RecordVideoVMView: Starts recording a video of the forensic VM with the given UUID.
+
+StopVideoRecordingVMView: Stops recording a video of the forensic VM with the given UUID.
+
+CheckRecordingStatusVMView: Checks the recording status of the forensic VM with the given UUID.
+
+ListVideosView: Lists available video recordings of the forensic VM with the given UUID.
+
+CheckUserAuthenticatedView: Checks if the user is authenticated via an API key.
+"""
+from django.views.generic import View
+from django.urls import path
+from .views import ProtectedView, RunScriptView, DeleteVMView, MountFolderView, ResetVMView, ShutdownVMView
+from .views import DownloadScreenshotsView
+from .views import CreateSshKeysView, ForensicImageVMStatus, StartVMView, StopVMView, CheckVMExistsView
+from .views import ScreenshotVMView, MemorySnapshotView
+from .views import DownloadEvidenceView, CreateFoldersView, ListISOFilesView, UploadISOView, DeleteISOFileView
+from .views import EjectCDROMView, InsertCDROMView, InsertNetworkCardView, ListPluginsView, RunPluginView
+from .views import RecreateFoldersView, SnapshotListView, CreateSnapshotView, RollbackSnapshotView, DeleteSnapshotView
+from .views import MemorySizeView, ChangeMemorySizeView, GetAvailableMemoryView, StartTapInterfaceView, StopTapInterfaceView
+from .views import DownloadNetworkPcapView,CheckTapInterfaceView
+from .views import ChangeVMDateTimeView, RemoveVMDateTimeView, DownloadVideoView
+from .views import RecordVideoVMView, StopVideoRecordingVMView, CheckRecordingStatusVMView, ListVideosView
+from .views import CheckUserAuthenticatedView
+
+urlpatterns = [
+    #path('run-script/', RunScriptView.as_view(), name='run_script'),
+    path('test/', ProtectedView.as_view(), name='test'),
+    path('create-ssh-keys/', CreateSshKeysView.as_view(), name='create-ssh-keys'),
+    path('forensic-image-vm-status/<str:uuid>/', ForensicImageVMStatus.as_view(), name='forensic-image-vm-status'),
+    path('start-vm/<str:uuid>/', StartVMView.as_view(), name='start-vm'),
+    path('stop-vm/<str:uuid>/', StopVMView.as_view(), name='stop-vm'),
+    path('check-vm-exists/<uuid>/', CheckVMExistsView.as_view(), name='check-vm-exists'),
+    path('delete-vm/<uuid>/', DeleteVMView.as_view(), name='delete-vm'),
+    path('mount-folder/<uuid>/', MountFolderView.as_view(), name='mount-folder'),
+    path('reset-vm/<uuid>/', ResetVMView.as_view(), name='reset-vm'),
+    path('shutdown-vm/<uuid>/', ShutdownVMView.as_view(), name='shutdown_vm'),
+    path('screenshot-vm/<str:uuid>/', ScreenshotVMView.as_view(), name='screenshot_vm'),
+    path('download-screenshots/<str:uuid>/', DownloadScreenshotsView.as_view(), name='download_screenshots'),
+    path('download-memory-dump/<uuid>/', MemorySnapshotView.as_view(), name='download_memory_dump'),
+    path('download-evidence/<uuid>/', DownloadEvidenceView.as_view(), name='download_evidence'),
+    path('create-folders/', CreateFoldersView.as_view(), name='create_folders'),
+    path('list-iso-files/', ListISOFilesView.as_view(), name='list_iso_files'),
+    path('upload-iso/', UploadISOView.as_view(), name='upload_iso'),
+    path('delete-iso/<str:filename>/', DeleteISOFileView.as_view(), name='delete_iso'),
+    path('eject-cdrom/<str:uuid>/', EjectCDROMView.as_view(), name='eject_cdrom'),
+    path('insert-cdrom/<uuid>/<filename>/', InsertCDROMView.as_view(), name='insert-cdrom'),
+    path('insert-network-card/<str:uuid>/', InsertNetworkCardView.as_view(), name='insert_network_card'),
+    path('list-plugins/', ListPluginsView.as_view(), name='list-plugins'),
+    path('run-plugin/', RunPluginView.as_view(), name='run-plugin'),
+    path('api/recreate-folders/', RecreateFoldersView.as_view(), name='recreate-folders'),
+    path('recreate-folders/', RecreateFoldersView.as_view(), name='recreate-folders'),
+    path('snapshots-list/<uuid>/', SnapshotListView.as_view(), name='snapshot-list'),
+    path('create-snapshot/<uuid>/', CreateSnapshotView.as_view(), name='create-snapshot'),
+    path('rollback-snapshot/<uuid>/', RollbackSnapshotView.as_view(), name='rollback-snapshot'),
+    path('delete-snapshot/<uuid:uuid>/', DeleteSnapshotView.as_view(), name='delete-snapshot'),
+    path('get-memory-size/<uuid>/', MemorySizeView.as_view(), name='get-memory-size'),
+    path('change-memory-size/<uuid>/', ChangeMemorySizeView.as_view(), name='change_memory_size'),
+    path('get-available-memory/', GetAvailableMemoryView.as_view(), name='get_available_memory'),
+    path('start_tap/', StartTapInterfaceView.as_view(), name='start_tap'),
+    path('stop_tap/', StopTapInterfaceView.as_view(), name='stop_tap'),
+    path('check_tap/', CheckTapInterfaceView.as_view(), name='check_tap'),
+    path('download_pcap/<str:uuid>/', DownloadNetworkPcapView.as_view(), name='download_pcap'),
+    path('change_vm_datetime/', ChangeVMDateTimeView.as_view(), name='change_vm_datetime'),
+    path('remove_vm_datetime/', RemoveVMDateTimeView.as_view(), name='remove_vm_datetime'),
+    path('record_video/<str:uuid>/', RecordVideoVMView.as_view(), name='record_video'),
+    path('stop_video/<str:uuid>/', StopVideoRecordingVMView.as_view(), name='stop_video'),
+    path('check_recording/<str:uuid>/', CheckRecordingStatusVMView.as_view(), name='check_recording'),
+    path('list_videos/<str:uuid>/', ListVideosView.as_view(), name='list_videos'),
+    path('download_video/<uuid:uuid>/<str:filename>/', DownloadVideoView.as_view(), name='download_video'),
+    path('check-authenticated/', CheckUserAuthenticatedView.as_view(), name='check-authenticated'),
+]
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/apikeys/views.py
@@ -0,0 +1,3679 @@
+import os
+import re
+import subprocess
+import socket
+import glob
+import time
+from django.shortcuts import render
+from django.contrib.auth import get_user_model
+from django.contrib.auth import get_user
+from rest_framework.views import APIView
+from rest_framework.response import Response
+from rest_framework import status
+from .models import ApiKey
+from subprocess import CalledProcessError
+from django.shortcuts import render
+from rest_framework.views import APIView
+from rest_framework.response import Response
+from rest_framework.authentication import SessionAuthentication
+from rest_framework import status
+from .models import ApiKey
+import json
+import shutil
+import psutil
+import asyncio
+from asgiref.sync import async_to_sync
+from asgiref.sync import sync_to_async
+from apscheduler.schedulers.asyncio import AsyncIOScheduler
+try:
+    import asyncio
+except ImportError:
+    import trollius as asyncio
+from django.http import HttpResponseBadRequest
+from django.utils.decorators import method_decorator
+from qemu.qmp import QMPClient
+from django.http import JsonResponse
+from django.views.decorators.csrf import csrf_exempt
+from django.utils.decorators import method_decorator
+from django.contrib.auth.decorators import login_required
+from django.views import View
+from django.http import FileResponse
+import zipfile
+from PIL import Image
+import datetime
+from datetime import datetime
+import glob
+from os.path import basename, join, isfile
+from django.http import Http404
+from urllib.parse import quote
+import cv2
+
+recordings = {}
+
+class CheckUserAuthenticatedView(View):
+    """
+    A Django View class for checking if a user is authenticated.
+
+    This class uses SessionAuthentication for user authentication.
+    It doesn't implement any specific permission classes.
+
+    Attributes:
+    ----------
+    authentication_classes : list
+        List of authentication classes the view uses. Here, it's SessionAuthentication.
+    permission_classes : list
+        List of permission classes the view uses. Here, it's an empty list.
+
+    Methods:
+    -------
+    get(request):
+        Returns a JsonResponse indicating if a user is authenticated.
+    """
+    authentication_classes = [SessionAuthentication]
+    permission_classes = []
+
+    def get(self, request):
+        """
+        Handles GET request to the view.
+
+        This method retrieves a user from the request or an API key error if one occurred.
+        It then checks if the user is authenticated by checking if any API key error occurred.
+        If the user is authenticated, it returns a JSON response with the 'authenticated' key set to True.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+
+        Returns:
+        -------
+        django.http.JsonResponse
+            A JsonResponse that indicates if the user is authenticated.
+        """
+        user, api_key_error = self.get_user_or_key_error(request)
+        if api_key_error:
+            return api_key_error
+        else:
+            return JsonResponse({'authenticated': True}, status=status.HTTP_200_OK)
+
+    def get_user_or_key_error(self, request):
+        """
+        Retrieves the authenticated user from the request or returns an API key error.
+
+        This method attempts to get an authenticated user from the request.
+        If the user is authenticated, it will return the user and None for the error.
+        If the user is not authenticated, it will attempt to authenticate the user using an API key provided in the request.
+        If the API key is valid and associated with an active user, it returns the user and None for the error.
+        If the API key is invalid or the user associated with the key is not active, it returns None for the user and a JsonResponse indicating the error.
+        If no API key is provided in the request, it returns None for the user and a JsonResponse indicating that an API key is required.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+
+        Returns:
+        -------
+        tuple
+            A tuple where the first element is the authenticated user or None if no user could be authenticated,
+            and the second element is None or a JsonResponse containing an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        user = getattr(request, 'user', None)
+        if user and user.is_authenticated:
+            print("DEBUG: USER AUTHENTICATED")
+        elif api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = getattr(api_key, 'user')
+                if not user.is_active:
+                    return None, JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return None, JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return None, JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+        return user, None
+
+class DownloadVideoView(APIView):
+    """
+    A Django APIView class for downloading a video file.
+
+    This class uses SessionAuthentication for user authentication.
+    It doesn't implement any specific permission classes.
+
+    Attributes:
+    ----------
+    authentication_classes : list
+        List of authentication classes the view uses. Here, it's SessionAuthentication.
+    permission_classes : list
+        List of permission classes the view uses. Here, it's an empty list.
+
+    Methods:
+    -------
+    get(request, uuid, filename):
+        Returns a FileResponse to download a video file.
+    """
+    authentication_classes = [SessionAuthentication]
+    permission_classes = []
+
+    def get(self, request, uuid, filename):
+        """
+        Handles GET request to download a video.
+
+        This method checks if the user is authenticated, validates the filename,
+        constructs the file path, checks if the file exists, and returns a FileResponse
+        for the client to download the video.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+        uuid : str
+            The unique identifier for the video file's directory.
+        filename : str
+            The name of the video file to download.
+
+        Returns:
+        -------
+        django.http.FileResponse
+            A FileResponse that initiates the video file download.
+
+        Raises:
+        ------
+        Http404
+            If the video file does not exist.
+        """
+        user, api_key_error = self.get_user_or_key_error(request)
+        if api_key_error:
+            return api_key_error
+
+        # Check filename to prevent directory traversal attacks
+        if not re.match('^[a-zA-Z0-9_.-]*$', filename):
+            return JsonResponse({'error': 'Invalid filename'}, status=status.HTTP_400_BAD_REQUEST)
+
+        video_dir = f"/forensicVM/mnt/vm/{uuid}/video"
+        filepath = join(video_dir, filename)
+
+        if not isfile(filepath):
+            raise Http404("Video does not exist")
+
+        video_file = open(filepath, 'rb')
+        response = FileResponse(video_file)
+        #response['Content-Disposition'] = f'attachment; filename*=UTF-8\'\'{urlquote(basename(filepath))}'
+        response['Content-Disposition'] = f'attachment; filename*=UTF-8\'\'{quote(basename(filepath))}'
+        return response
+
+    def get_user_or_key_error(self, request):
+        """
+        Retrieves the authenticated user from the request or returns an API key error.
+
+        This method attempts to get an authenticated user from the request.
+        If the user is authenticated, it will return the user and None for the error.
+        If the user is not authenticated, it will attempt to authenticate the user using an API key provided in the request.
+        If the API key is valid and associated with an active user, it returns the user and None for the error.
+        If the API key is invalid or the user associated with the key is not active, it returns None for the user and a JsonResponse indicating the error.
+        If no API key is provided in the request, it returns None for the user and a JsonResponse indicating that an API key is required.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+
+        Returns:
+        -------
+        tuple
+            A tuple where the first element is the authenticated user or None if no user could be authenticated,
+            and the second element is None or a JsonResponse containing an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        user = getattr(request, 'user', None)
+        if user and user.is_authenticated:
+            print("DEBUG: USER AUTHENTICATED")
+        elif api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = getattr(api_key, 'user')
+                if not user.is_active:
+                    return None, JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return None, JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return None, JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+        return user, None
+
+class ListVideosView(APIView):
+    """
+    A Django APIView class for listing all the .mp4 video files in a specific directory.
+
+    This class uses SessionAuthentication for user authentication.
+    It doesn't implement any specific permission classes.
+
+    Attributes:
+    ----------
+    authentication_classes : list
+        List of authentication classes the view uses. Here, it's SessionAuthentication.
+    permission_classes : list
+        List of permission classes the view uses. Here, it's an empty list.
+
+    Methods:
+    -------
+    get(request, uuid):
+        Returns a JsonResponse with a list of all .mp4 video files in the specified directory.
+    """
+    authentication_classes = [SessionAuthentication]
+    permission_classes = []
+
+    def get(self, request, uuid):
+        """
+        Handles GET request to list all .mp4 video files in a specific directory.
+
+        This method checks if the user is authenticated, constructs the video directory path,
+        checks if the directory exists, and returns a JsonResponse containing a list of all .mp4 video files
+        in the directory, sorted in ascending order.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+        uuid : str
+            The unique identifier for the video files' directory.
+
+        Returns:
+        -------
+        django.http.JsonResponse
+            A JsonResponse containing a list of all .mp4 video files in the specified directory.
+        """
+        user, api_key_error = self.get_user_or_key_error(request)
+        if api_key_error:
+            return api_key_error
+
+        video_dir = f"/forensicVM/mnt/vm/{uuid}/video"
+        #video_exists = os.path.exists(video_dir)
+
+        if not os.path.exists(video_dir):
+            return JsonResponse({'error': 'Video directory not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        video_files = []
+        for file in os.listdir(video_dir):
+            if file.endswith('.mp4'):
+                video_files.append(file)
+            video_files.sort(reverse=True)
+        return JsonResponse({'video_files': video_files}, status=status.HTTP_200_OK)
+
+    def get_user_or_key_error(self, request):
+        """
+        Retrieves the authenticated user from the request or returns an API key error.
+
+        This method attempts to get an authenticated user from the request.
+        If the user is authenticated, it will return the user and None for the error.
+        If the user is not authenticated, it will attempt to authenticate the user using an API key provided in the request.
+        If the API key is valid and associated with an active user, it returns the user and None for the error.
+        If the API key is invalid or the user associated with the key is not active, it returns None for the user and a JsonResponse indicating the error.
+        If no API key is provided in the request, it returns None for the user and a JsonResponse indicating that an API key is required.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+
+        Returns:
+        -------
+        tuple
+            A tuple where the first element is the authenticated user or None if no user could be authenticated,
+            and the second element is None or a JsonResponse containing an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        user = getattr(request, 'user', None)
+        if user and user.is_authenticated:
+            print("DEBUG: USER AUTHENTICATED")
+        elif api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = getattr(api_key, 'user')
+                if not user.is_active:
+                    return None, JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return None, JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return None, JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+        return user, None
+
+video_writers = {}
+
+
+async def create_video(uuid, output_video_path):
+    """
+    Asynchronously create a video from screenshots taken in a virtual machine using QEMU Machine Protocol (QMP).
+
+    The function connects to QMP, executes a screendump command to take a screenshot and saves it to a specified path.
+    It then reads the screenshot into an image and writes the image as a frame to a video file.
+    If the video writer is not yet set up, it initializes it with the size of the first frame.
+    Once the frame has been written to the video, it removes the screenshot file.
+
+    Parameters:
+    ----------
+    uuid : str
+        The unique identifier for the video file's directory.
+    output_video_path : str
+        The path where the output video will be saved.
+
+    Raises:
+    ------
+    Exception
+        Any exception that occurs while creating the video or connecting/disconnecting from QMP.
+    """
+    qmp = QMPClient('forensicVM')
+    socket_path = f"/forensicVM/mnt/vm/{uuid}/run/qmp.sock"
+    frame_path = f"/forensicVM/mnt/vm/{uuid}/frames"
+    screenshot_path = f"/forensicVM/mnt/vm/{uuid}/frames/screenshot.ppm"
+
+    if not os.path.exists(frame_path):
+        os.makedirs(frame_path)
+
+    try:
+        await qmp.connect(socket_path)
+        res = await qmp.execute('screendump', {"filename": screenshot_path})
+
+        # Load screenshot as an image
+        img = cv2.imread(screenshot_path)
+
+        # If the video writer is not yet set up, initialize it with the size of the first frame
+        if uuid not in video_writers:
+            height, width, _ = img.shape
+            fourcc = cv2.VideoWriter_fourcc(*'mp4v')
+            video_writers[uuid] = cv2.VideoWriter(output_video_path, fourcc, 25, (width, height))
+            print("Video writer defined")
+
+        # Write frame to video
+        video_writers[uuid].write(img)
+
+
+        # Remove screenshot
+        if os.path.exists(screenshot_path):
+            os.remove(screenshot_path)
+    except Exception as e:
+        print(e)
+    finally:
+        await qmp.disconnect()
+
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class RecordVideoVMView(View):
+    """
+    A Django View class that handles the video recording process of a virtual machine.
+
+    This class implements the POST HTTP method to start and manage the recording of a video.
+    If the requested virtual machine (identified by uuid) exists and is not already recording,
+    it starts a new recording, creating a video file in a specified directory.
+    The recording runs asynchronously for a maximum duration of three hours or until it is manually stopped.
+
+    If the virtual machine is already recording, the POST request will return an error.
+    """
+    authentication_classes = [SessionAuthentication]
+    permission_classes = []
+
+    async def post(self, request, uuid):
+        """
+        Asynchronously handle a POST request to start recording a video.
+
+        This method attempts to start a recording for the specified virtual machine.
+        It checks if the machine exists and if a recording is not already in progress.
+        If these conditions are met, it sets up a new video file and starts the recording.
+        The recording runs for a maximum duration of three hours or until it is manually stopped.
+        After the recording is finished, it cleans up the resources and sends a response indicating success.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+        uuid : str
+            The unique identifier for the virtual machine.
+
+        Returns:
+        -------
+        JsonResponse
+            A JsonResponse indicating whether the recording started successfully or detailing any errors that occurred.
+
+        Raises:
+        ------
+        Exception
+            Any exception that occurs while starting or managing the recording.
+        """
+        user, api_key_error = await sync_to_async(self.get_user_or_key_error)(request)
+        if api_key_error:
+            return api_key_error
+
+        vm_path = f"/forensicVM/mnt/vm/{uuid}"
+        vm_exists = await sync_to_async(os.path.exists)(vm_path)
+
+        if not vm_exists:
+            return JsonResponse({'error': f'VM with UUID {uuid} not found'}, status=404)
+
+        video_path = f"/forensicVM/mnt/vm/{uuid}/video/"
+        if not os.path.exists(video_path):
+            os.makedirs(video_path)  # Recreate the empty directory
+
+        video_count = len(os.listdir(video_path))
+        output_video_path = os.path.join(video_path, f"video{video_count + 1:04d}.mp4")
+
+        video_writer = None  # Start with no video writer
+
+        try:
+            record = False
+            if uuid not in recordings:
+                record = True
+                print("uuid not in the recordigs")
+            elif uuid in recordings and not recordings[uuid]:
+                record = True
+                print("uuid is in the recordings, but not in the uuid")
+
+
+            if record:
+            #if uuid not in recordings:
+                recordings[uuid] = True
+                scheduler = AsyncIOScheduler()
+                scheduler.add_job(create_video, 'interval', seconds=0.04, id=f'create_video_job_{uuid}', args=[uuid, output_video_path], replace_existing=True)
+
+                #scheduler.add_job(create_video, 'interval', seconds=0.04, id=f'create_video_job_{uuid}', args=[uuid, output_video_path, video_writer], replace_existing=True)
+                scheduler.start()
+
+                for _ in range(3600*3):  # run the loop for 3600 interactions*3 (three hour)
+                    await asyncio.sleep(1)  # sleep for 1 second
+                    if not recordings[uuid]:  # if recordings[uuid] is False, break the loop
+                        break
+
+                scheduler.remove_job(f'create_video_job_{uuid}')
+                if uuid in video_writers:
+                    video_writers[uuid].release()
+                    del video_writers[uuid]  # remove the VideoWriter from the dictionary
+
+
+                result = {'video_recorded': True, 'message': f'Video recorded with the name video{video_count + 1:04d}.mp4'}
+                recordings[uuid] = False
+                return JsonResponse(result, status=status.HTTP_200_OK)
+
+                #return JsonResponse({"status": "Recording stopped"}, status=200)
+            else:
+                return JsonResponse({"error": "Recording already in progress"}, status=400)
+        except Exception as e:
+            print(e)
+
+
+    def get_user_or_key_error(self, request):
+        """
+        Check if the user is authenticated or if there is an API key error.
+
+        This method checks if the user associated with the request is authenticated.
+        If the user is not authenticated, it checks if there's an API key in the request.
+        If the API key is valid and associated with an active user, the method returns this user.
+        If the API key is not valid or the user is not active, it returns a JSON response with the corresponding error.
+        If there's no API key at all, it returns a JSON response indicating that the API key is required.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+
+        Returns:
+        -------
+        tuple
+            A tuple where the first element is the authenticated user or None,
+            and the second element is a JsonResponse with an error message or None.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        user = getattr(request, 'user', None)
+        if user and user.is_authenticated:
+            print("DEBUG: USER AUTHENTICATED")
+        elif api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = getattr(api_key, 'user')
+                if not user.is_active:
+                    return None, JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return None, JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return None, JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+        return user, None
+
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class StopVideoRecordingVMView(View):
+    """
+    View to handle the stoppage of video recording.
+
+    The view uses session authentication and has no permission restrictions.
+    The post method is used to handle the stoppage of the video recording for a VM with a given UUID.
+    """
+    authentication_classes = [SessionAuthentication]
+    permission_classes = []
+
+    async def post(self, request, uuid):
+        """
+        Handle a POST request to stop video recording for a VM with a given UUID.
+
+        This method first checks if the user is authenticated or if there is an API key error.
+        If there's an API key error, it returns a JSON response with the error.
+        If the UUID is present in the recordings, it stops the recording by setting the corresponding value to False.
+        If the UUID is not present, it returns a HTTP 400 error.
+        Finally, it returns a JSON response confirming the stoppage of the recording.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+        uuid : str
+            The UUID of the VM for which the recording should be stopped.
+
+        Returns:
+        -------
+        django.http.JsonResponse
+            A JsonResponse indicating the result of the operation.
+        """
+        user, api_key_error = await sync_to_async(self.get_user_or_key_error)(request)
+        if api_key_error:
+            return api_key_error
+
+        if uuid in recordings:
+            print("DEBUG: Stop uuid in recordings")
+            recordings[uuid] = False
+        else:
+            return HttpResponseBadRequest(f'No recording to stop for VM with UUID {uuid}')
+            recordings[uuid] = False
+
+
+        result = {'video_recording_stopped': True, 'message': f'Video recording stopped for VM with UUID {uuid}'}
+
+        return JsonResponse(result, status=status.HTTP_200_OK)
+
+    def get_user_or_key_error(self, request):
+        """
+        Check if the user is authenticated or if there is an API key error.
+
+        This method checks if the user associated with the request is authenticated.
+        If the user is not authenticated, it checks if there's an API key in the request.
+        If the API key is valid and associated with an active user, the method returns this user.
+        If the API key is not valid or the user is not active, it returns a JSON response with the corresponding error.
+        If there's no API key at all, it returns a JSON response indicating that the API key is required.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+
+        Returns:
+        -------
+        tuple
+            A tuple where the first element is the authenticated user or None,
+            and the second element is a JsonResponse with an error message or None.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        user = getattr(request, 'user', None)
+        if user and user.is_authenticated:
+            print("DEBUG: USER AUTHENTICATED")
+        elif api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = getattr(api_key, 'user')
+                if not user.is_active:
+                    return None, JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return None, JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return None, JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+        return user, None
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class CheckRecordingStatusVMView(View):
+    """
+    View to check the status of video recording.
+
+    The view uses session authentication and has no permission restrictions.
+    The get method is used to handle the checking of the video recording status for a VM with a given UUID.
+    """
+    authentication_classes = [SessionAuthentication]
+    permission_classes = []
+
+    async def get(self, request, uuid):
+        """
+        Handle a GET request to check video recording status for a VM with a given UUID.
+
+        This method first checks if the user is authenticated or if there is an API key error.
+        If there's an API key error, it returns a JSON response with the error.
+        If the UUID is present in the recordings and is recording, it returns a JSON response indicating the recording is in progress.
+        If the UUID is not present or not recording, it returns a JSON response indicating no recording is in progress.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+        uuid : str
+            The UUID of the VM for which the recording status should be checked.
+
+        Returns:
+        -------
+        django.http.JsonResponse
+            A JsonResponse indicating the result of the operation.
+        """
+        user, api_key_error = await sync_to_async(self.get_user_or_key_error)(request)
+        if api_key_error:
+            return api_key_error
+
+        if uuid in recordings and recordings[uuid]:
+            result = {'is_recording': True, 'message': f'Recording is in progress for VM with UUID {uuid}'}
+        else:
+            result = {'is_recording': False, 'message': f'No recording is in progress for VM with UUID {uuid}'}
+
+        return JsonResponse(result, status=status.HTTP_200_OK)
+
+    def get_user_or_key_error(self, request):
+        """
+        Check if the user is authenticated or if there is an API key error.
+
+        This method checks if the user associated with the request is authenticated.
+        If the user is not authenticated, it checks if there's an API key in the request.
+        If the API key is valid and associated with an active user, the method returns this user.
+        If the API key is not valid or the user is not active, it returns a JSON response with the corresponding error.
+        If there's no API key at all, it returns a JSON response indicating that the API key is required.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+
+        Returns:
+        -------
+        tuple
+            A tuple where the first element is the authenticated user or None,
+            and the second element is a JsonResponse with an error message or None.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        user = getattr(request, 'user', None)
+        if user and user.is_authenticated:
+            print("DEBUG: USER AUTHENTICATED")
+        elif api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = getattr(api_key, 'user')
+                if not user.is_active:
+                    return None, JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return None, JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return None, JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+        return user, None
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class RemoveVMDateTimeView(View):
+    """
+    View to remove the datetime line from a VM's configuration.
+
+    The view has no authentication or permission restrictions.
+    The post method is used to handle the removal of the datetime line from the configuration of a VM with a given UUID.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    async def post(self, request):
+        """
+        Handle a POST request to remove the datetime line from a VM's configuration.
+
+        This method first checks if the user is authenticated or if there is an API key error.
+        If there's an API key error, it returns a JSON response with the error.
+        The method then retrieves the UUID from the POST data.
+        It locates the .vnc configuration file for the VM with the provided UUID, reads its content, and removes any line containing the '-rtc base=' string.
+        If successful, the method returns a JSON response indicating the successful operation.
+        If there's an error, it returns a JSON response with the error message.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+
+        Returns:
+        -------
+        django.http.JsonResponse
+            A JsonResponse indicating the result of the operation.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+
+        user = await sync_to_async(getattr)(request, 'user', None)  # Get the user in the request
+        if user and user.is_authenticated:                          # User is authenticated via session
+            pass                                                    # Add this extra block to the request
+        elif api_key:                                               # <--- Changed
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        # Get the UUID from the POST data
+        uuid = request.POST.get('uuid')
+
+        try:
+            # Get the .vnc file path
+            vnc_file_path = glob.glob(f"/forensicVM/mnt/vm/{uuid}/*vnc.sh")[0]
+
+            # Read the content of the file
+            with open(vnc_file_path, 'r') as file:
+                lines = file.readlines()
+
+            # Remove the -rtc base=<datetime> line if it exists
+            lines = [line for line in lines if '-rtc base=' not in line]
+
+            # Write the changes back to the file
+            with open(vnc_file_path, 'w') as file:
+                file.writelines(lines)
+
+            return JsonResponse({'message': f'Date time line removed successfully for VM {uuid}'}, status=status.HTTP_200_OK)
+        except Exception as e:
+            return JsonResponse({'error': f'Error updating VM date time: {str(e)}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class ChangeVMDateTimeView(View):
+    """
+    View to change the datetime in a VM's configuration.
+
+    The view has no authentication or permission restrictions.
+    The post method is used to handle the updating of the datetime in the configuration of a VM with a given UUID.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    async def post(self, request):
+        """
+        Handle a POST request to change the datetime in a VM's configuration.
+
+        This method first checks if there is an API key error.
+        If there's an API key error, it returns a JSON response with the error.
+        The method then retrieves the UUID and the datetime from the POST data and validates the datetime format.
+        If the datetime format is invalid, it returns a JSON response indicating the error.
+        It locates the .sh configuration file for the VM with the provided UUID, reads its content, and changes or adds a line with the '-rtc base=' string and the new datetime.
+        If successful, the method returns a JSON response indicating the successful operation.
+        If there's an error, it returns a JSON response with the error message.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+
+        Returns:
+        -------
+        django.http.JsonResponse
+            A JsonResponse indicating the result of the operation.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+
+
+        # Get the UUID and datetime from the POST data
+        uuid = request.POST.get('uuid')
+        datetime_str = request.POST.get('datetime')
+
+        # Validate the datetime
+        if not validate_date(datetime_str):
+            return JsonResponse({'error': 'Invalid datetime format'}, status=status.HTTP_400_BAD_REQUEST)
+
+        try:
+            # Get the .sh file path
+            vnc_file_path = glob.glob(f"/forensicVM/mnt/vm/{uuid}/*vnc.sh")[0]
+
+            # Read the content of the file
+            with open(vnc_file_path, 'r') as file:
+                lines = file.readlines()
+
+            # Add the new line after the -vga section if it doesn't exist
+            for i, line in enumerate(lines):
+                if '-vga' in line:
+                    if '-rtc base=' not in lines[i+1]:
+                        lines.insert(i+1, f'    -rtc base={datetime_str} \\\n')
+                    else:
+                        lines[i+1]=f'    -rtc base={datetime_str} \\\n'
+                    break
+
+            # Write the changes back to the file
+            with open(vnc_file_path, 'w') as file:
+                file.writelines(lines)
+
+            return JsonResponse({'message': f'Date time {datetime_str} set successfully for VM {uuid}'}, status=status.HTTP_200_OK)
+        except Exception as e:
+            return JsonResponse({'error': f'Error updating VM date time: {str(e)}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+def validate_date(date_str):
+    """
+    Function to validate the date string against the format 'YYYY-MM-DDTHH:MM:SS'
+    """
+    try:
+        datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%S")
+        return True
+    except ValueError:
+        return False
+
+@method_decorator(csrf_exempt, name='dispatch')
+class DownloadNetworkPcapView(View):
+    """
+    View to download the pcap files of a VM.
+
+    The view has no authentication or permission restrictions.
+    The get method is used to handle the downloading of pcap files of a VM with a given UUID.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    async def get(self, request, uuid):
+        """
+        Handle a GET request to download the pcap files of a VM.
+
+        This method first checks if there is an API key error.
+        If there's an API key error, it returns a JSON response with the error.
+        The method then checks if the VM with the provided UUID exists.
+        If the VM does not exist, it returns a JSON response indicating the error.
+        It creates a zip file of all pcap files associated with the VM.
+        If successful, the method returns a FileResponse with the created zip file.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+        uuid : str
+            The UUID of the VM.
+
+        Returns:
+        -------
+        django.http.FileResponse
+            A FileResponse with the zip file of the pcap files of the VM.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        vm_path = f"/forensicVM/mnt/vm/{uuid}"
+        vm_exists = os.path.exists(vm_path)
+
+        if not vm_exists:
+            return JsonResponse({'error': f'VM with UUID {uuid} not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        pcap_path = f"/forensicVM/mnt/vm/{uuid}/pcap/"
+
+        # Create a zip file containing all pcap files
+        zip_file_path = f"/forensicVM/mnt/vm/{uuid}/pcap.zip"
+        with zipfile.ZipFile(zip_file_path, 'w') as zipf:
+            for pcap_file in glob.glob(f"{pcap_path}/*.pcap"):
+                zipf.write(pcap_file, os.path.basename(pcap_file))
+
+        # Return the zip file as a FileResponse
+        response = FileResponse(open(zip_file_path, 'rb'), content_type='application/zip')
+        response['Content-Disposition'] = f'attachment; filename="{os.path.basename(zip_file_path)}"'
+        return response
+
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class CheckTapInterfaceView(View):
+    """
+    View to check the status of the tap interface of a VM.
+
+    The view has no authentication or permission restrictions.
+    The post method is used to handle the status checking of the tap interface of a VM.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    async def post(self, request):
+        """
+        Handle a POST request to check the status of the tap interface of a VM.
+
+        This method first checks if there is an API key error.
+        If there's an API key error, it returns a JSON response with the error.
+        The method then gets the UUID from the POST data and checks the status of the tap interface.
+        It executes shell commands to get the tap interface and checks its status.
+        If the tap interface is up, the method returns a JSON response with a positive status and message.
+        If the tap interface is down, the method returns a JSON response with a negative status and message.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+
+        Returns:
+        -------
+        django.http.JsonResponse
+            A JsonResponse with the status and message about the status of the tap interface.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        # Get the uuid from the POST data
+        uuid = request.POST.get('uuid')
+
+        if not uuid:
+            return JsonResponse({'error': 'UUID required'}, status=status.HTTP_400_BAD_REQUEST)
+
+        # Execute the command to get the tap interface
+        cmd = f"ps -ef | grep qemu | grep {uuid}"
+        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
+        output, error = process.communicate()
+
+        if error:
+            return JsonResponse({'error': f'Error finding QEMU process: {error}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+        tap_interface = output.decode().split('-netdev tap,id=u1,ifname=')[1].split(',')[0]
+
+        # Check the status of the tap interface
+        check_tap_cmd = f"ifconfig {tap_interface}"
+        check_tap_process = subprocess.Popen(check_tap_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
+        check_tap_output, check_tap_error = check_tap_process.communicate()
+
+        if check_tap_error:
+            return JsonResponse({'error': f'Error checking tap interface: {check_tap_error}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+        is_up = 'UP' in check_tap_output.decode()
+
+        if is_up:
+            return JsonResponse({'message': f'Tap interface {tap_interface} is up', 'status': True}, status=status.HTTP_200_OK)
+        else:
+            return JsonResponse({'message': f'Tap interface {tap_interface} is down', 'status': False}, status=status.HTTP_200_OK)
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class StartTapInterfaceView(View):
+    """
+    View to start the tap interface of a VM.
+
+    The view authenticates the user with SessionAuthentication. The post method is used to handle the start request of
+    the tap interface of a VM.
+    """
+    authentication_classes = [SessionAuthentication]                # ADDED
+    permission_classes = []
+
+    async def post(self, request):
+        """
+        Handle a POST request to start the tap interface of a VM.
+
+        This method first checks if there is an API key error.
+        If there's an API key error, it returns a JSON response with the error.
+        The method then gets the UUID from the POST data and tries to start the tap interface.
+        It executes shell commands to get the tap interface and starts it.
+        If the tap interface starts successfully, the method returns a JSON response with a positive message.
+        If there's an error while starting the tap interface, the method returns a JSON response with the error.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+
+        Returns:
+        -------
+        django.http.JsonResponse
+            A JsonResponse with a message about the status of the tap interface start action.
+        """
+        # Authenticate user using API key
+        api_key = request.META.get('HTTP_X_API_KEY')
+        #user = getattr(request, 'user', None)                       # IF sync
+        #user = await sync_to_async(getattr)(request, 'user', None)  # ASYNC: Get the user in the request
+        user = await sync_to_async(get_user)(request)
+        if user and user.is_authenticated:                          # User is authenticated via session
+            print("DEBUG: USER AUTHENTICATED")
+            pass                                                    # Add this extra block to the request
+        elif api_key:                                               # <--- Changed
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        # Get the uuid from the POST data
+        uuid = request.POST.get('uuid')
+
+        if not uuid:
+            print('no UUID sent')
+            return JsonResponse({'error': 'UUID required'}, status=status.HTTP_400_BAD_REQUEST)
+
+        # Execute the command to get the tap interface
+        cmd = f"ps -ef | grep qemu | grep {uuid}"
+        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
+        output, error = process.communicate()
+
+        if error:
+            return JsonResponse({'error': f'Error finding QEMU process: {error}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+        tap_interface = output.decode().split('-netdev tap,id=u1,ifname=')[1].split(',')[0]
+
+        # Start the tap interface
+        start_tap_cmd = f"ifconfig {tap_interface} up"
+        start_tap_process = subprocess.Popen(start_tap_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
+        start_tap_output, start_tap_error = start_tap_process.communicate()
+
+        if start_tap_error:
+            return JsonResponse({'error': f'Error starting tap interface: {start_tap_error}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+        return JsonResponse({'message': f'Tap interface {tap_interface} started successfully'}, status=status.HTTP_200_OK)
+
+@method_decorator(csrf_exempt, name='dispatch')
+class StopTapInterfaceView(View):
+    """
+    View to stop the tap interface of a VM.
+
+    The view authenticates the user with SessionAuthentication. The post method is used to handle the stop request of
+    the tap interface of a VM.
+    """
+    authentication_classes = [SessionAuthentication]                # ADDED
+    permission_classes = []
+
+    async def post(self, request):
+        """
+        Handle a POST request to stop the tap interface of a VM.
+
+        This method first checks if there is an API key error.
+        If there's an API key error, it returns a JSON response with the error.
+        The method then gets the UUID from the POST data and tries to stop the tap interface.
+        It executes shell commands to get the tap interface and stops it.
+        If the tap interface stops successfully, the method returns a JSON response with a positive message.
+        If there's an error while stopping the tap interface, the method returns a JSON response with the error.
+
+        Parameters:
+        ----------
+        request : django.http.HttpRequest
+            The request instance for the current request.
+
+        Returns:
+        -------
+        django.http.JsonResponse
+            A JsonResponse with a message about the status of the tap interface stop action.
+        """
+        # Authenticate user using API key
+        api_key = request.META.get('HTTP_X_API_KEY')
+        #user = getattr(request, 'user', None)                       # IF sync
+        #user = await sync_to_async(getattr)(request, 'user', None)  # ASYNC: Get the user in the request
+        user = await sync_to_async(get_user)(request)
+
+        if user and user.is_authenticated:                          # User is authenticated via session
+            print("DEBUG: USER AUTHENTICATED")
+            pass                                                    # Add this extra block to the request
+        elif api_key:                                               # <--- Changed
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        # Get the uuid from the POST data
+        uuid = request.POST.get('uuid')
+
+        if not uuid:
+            print('no UUID sent')
+            return JsonResponse({'error': 'UUID required'}, status=status.HTTP_400_BAD_REQUEST)
+
+        # Execute the command to get the tap interface
+        cmd = f"ps -ef | grep qemu | grep {uuid}"
+        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
+        output, error = process.communicate()
+
+        if error:
+            return JsonResponse({'error': f'Error finding QEMU process: {error}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+        tap_interface = output.decode().split('-netdev tap,id=u1,ifname=')[1].split(',')[0]
+
+        # Start the tap interface
+        start_tap_cmd = f"ifconfig {tap_interface} down"
+        start_tap_process = subprocess.Popen(start_tap_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
+        start_tap_output, start_tap_error = start_tap_process.communicate()
+
+        if start_tap_error:
+            return JsonResponse({'error': f'Error stopping tap interface: {start_tap_error}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+        return JsonResponse({'message': f'Tap interface {tap_interface} stopped successfully'}, status=status.HTTP_200_OK)
+
+
+def get_available_memory():
+    """
+    Get the current available system memory.
+
+    This function uses the psutil library to fetch system memory information.
+    It returns the amount of available memory in Megabytes.
+
+    Returns:
+    -------
+    float
+        The amount of available system memory in Megabytes.
+    """
+    mem_info = psutil.virtual_memory()
+    available_memory = mem_info.available / 1024 / 1024  # Convert to MB
+    return available_memory
+
+@method_decorator(csrf_exempt, name='dispatch')
+class GetAvailableMemoryView(View):
+    """
+    API View that handles GET requests to retrieve available system memory.
+
+    This view requires an API key for authentication. If the API key is valid
+    and is associated with an active user, the system's available memory is returned.
+    The available memory is calculated using the get_available_memory function.
+
+    If the API key is missing, invalid, or associated with an inactive user, an error message is returned.
+
+    The available memory is returned in a JSON format:
+    {
+        "available_memory": <float>
+    }
+    """
+    def get(self, request):
+        """
+        Handles the GET request to retrieve the system's available memory.
+
+        Args:
+            request: The HTTP request from the client. Expected to contain the API key in the headers.
+
+        Returns:
+            JsonResponse: A JsonResponse that either contains the available memory or an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=401)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=401)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=401)
+
+        available_memory = get_available_memory()
+
+        return JsonResponse({'available_memory': available_memory}, status=200)
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class ChangeMemorySizeView(View):
+    """
+    API View that handles POST requests to change the memory size of a Virtual Machine (VM).
+
+    This view requires an API key for authentication and a POST body containing a new memory size.
+    If the API key is valid and is associated with an active user, and the POST body contains a valid
+    memory size, the script files in the VM directory are updated with the new memory size.
+
+    If the API key is missing, invalid, or associated with an inactive user, or if the memory size
+    is invalid, an error message is returned.
+
+    The response indicates whether the memory size update was successful or not in a JSON format:
+    {
+        "message": <string>
+    }
+    """
+    def post(self, request, uuid):
+        """
+        Handles the POST request to change the memory size of a VM.
+
+        Args:
+            request: The HTTP request from the client. Expected to contain the API key in the headers and the new
+                     memory size in the POST body.
+            uuid: The UUID of the VM whose memory size is to be changed.
+
+        Returns:
+            JsonResponse: A JsonResponse that either contains a success message or an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=401)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=401)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=401)
+
+        vm_path = f"/forensicVM/mnt/vm/{uuid}"
+        if not os.path.exists(vm_path):
+            return JsonResponse({'error': f'Path for UUID {uuid} not found'}, status=404)
+
+        script_files = glob.glob(os.path.join(vm_path, '*.sh'))
+        if not script_files:
+            return JsonResponse({'error': f'No script files found for UUID {uuid}'}, status=404)
+
+        recent_script_file = max(script_files, key=os.path.getctime)
+
+        with open(recent_script_file, 'r') as f:
+            script_content = f.read()
+
+        memory_pattern = r'-m\s+(\d+)'
+        new_memory_size = request.POST.get('memory_size')
+
+        if new_memory_size:
+            # Update the memory parameter in the script content
+            updated_script_content = re.sub(memory_pattern, f'-m {new_memory_size}', script_content)
+            # Write the updated script content back to the file
+            with open(recent_script_file, 'w') as f:
+                f.write(updated_script_content)
+
+            return JsonResponse({'message': 'Memory size updated successfully'}, status=200)
+        else:
+            return JsonResponse({'error': 'Invalid or missing memory_size parameter'}, status=400)
+
+
+#@method_decorator(csrf_exempt, name='dispatch')
+class MemorySizeView(View):
+    """
+    API View that handles GET requests to fetch the current memory size of a Virtual Machine (VM).
+
+    This view requires an API key for authentication. If the API key is valid and is associated
+    with an active user, the memory size is retrieved from the script files in the VM directory.
+
+    If the API key is missing, invalid, or associated with an inactive user, or if the memory size
+    cannot be found, an error message is returned.
+
+    The response indicates either the memory size or an error message in a JSON format:
+    {
+        "memory_size": <int>
+    }
+    or
+    {
+        "error": <string>
+    }
+    """
+    def get(self, request, uuid):
+        """
+        Handles the GET request to fetch the memory size of a VM.
+
+        Args:
+            request: The HTTP request from the client. Expected to contain the API key in the headers.
+            uuid: The UUID of the VM whose memory size is to be fetched.
+
+        Returns:
+            JsonResponse: A JsonResponse that either contains the memory size or an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=401)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=401)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=401)
+
+        vm_path = f"/forensicVM/mnt/vm/{uuid}"
+        if not os.path.exists(vm_path):
+            return JsonResponse({'error': f'Path for UUID {uuid} not found'}, status=404)
+
+        script_files = glob.glob(os.path.join(vm_path, '*.sh'))
+        if not script_files:
+            return JsonResponse({'error': f'No script files found for UUID {uuid}'}, status=404)
+
+        recent_script_file = max(script_files, key=os.path.getctime)
+
+        with open(recent_script_file, 'r') as f:
+            script_content = f.read()
+
+        memory_pattern = r'-m\s+(\d+)'
+        memory_match = re.search(memory_pattern, script_content)
+
+        if memory_match:
+            memory_size = int(memory_match.group(1))
+            return JsonResponse({'memory_size': memory_size}, status=200)
+        else:
+            return JsonResponse({'error': 'Memory parameter not found in the script.'}, status=404)
+
+async def delete_snapshot(uuid, snapshot_name):
+    """
+    Asynchronously delete a snapshot of a specific VM.
+
+    This function uses QEMU's QMP (QEMU Machine Protocol) to execute commands on the VM.
+    It specifically runs the `delvm` command to delete the snapshot.
+
+    Args:
+        uuid (str): The unique identifier for the VM.
+        snapshot_name (str): The name of the snapshot to delete.
+
+    Returns:
+        str: A message indicating whether the snapshot was successfully deleted or not.
+    """
+    qmp = QMPClient('forensicVM')
+    socket_path = f"/forensicVM/mnt/vm/{uuid}/run/qmp.sock"
+
+    try:
+        await qmp.connect(socket_path)
+        await qmp.execute("human-monitor-command", {
+            "command-line": f"delvm {snapshot_name}"
+        })
+        return "Snapshot deleted."
+    except Exception as e:
+        print(e)
+        return "Error deleting snapshot."
+    finally:
+        await qmp.disconnect()
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class DeleteSnapshotView(View):
+    """
+    API View that handles POST requests to delete a snapshot of a specific VM.
+
+    This view requires an API key for authentication. If the API key is valid and is associated
+    with an active user, it calls the `delete_snapshot` asynchronous function to delete the snapshot.
+
+    If the API key is missing, invalid, or associated with an inactive user, or if the snapshot
+    name is missing in the request data, an error message is returned.
+
+    The response indicates either a success or an error message in a JSON format:
+    {
+        "message": <string>
+    }
+    or
+    {
+        "error": <string>
+    }
+    """
+    async def post(self, request, uuid):
+        """
+        Handles the POST request to delete a snapshot of a VM.
+
+        Args:
+            request: The HTTP request from the client. Expected to contain the API key in the headers,
+                     and the snapshot name in the request data.
+            uuid: The UUID of the VM whose snapshot is to be deleted.
+
+        Returns:
+            JsonResponse: A JsonResponse that either contains a success message or an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=401)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=401)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=401)
+
+        snapshot_name = request.POST.get('snapshot_name')
+        if not snapshot_name:
+            return JsonResponse({'error': 'Snapshot name required'}, status=400)
+
+        delete_status = await delete_snapshot(uuid, snapshot_name)
+        return JsonResponse({'message': delete_status}, status=200)
+
+
+async def rollback_snapshot(uuid, snapshot_name):
+    """
+    Asynchronously rollback to a snapshot of a specific VM.
+
+    This function uses QEMU's QMP (QEMU Machine Protocol) to execute commands on the VM.
+    It specifically runs the `loadvm` command to rollback to the snapshot.
+
+    Args:
+        uuid (str): The unique identifier for the VM.
+        snapshot_name (str): The name of the snapshot to rollback to.
+
+    Returns:
+        str: A message indicating whether the snapshot was successfully rolled back or not.
+    """
+    qmp = QMPClient('forensicVM')
+    socket_path = f"/forensicVM/mnt/vm/{uuid}/run/qmp.sock"
+
+    try:
+        await qmp.connect(socket_path)
+        await qmp.execute("human-monitor-command", {
+            "command-line": f"loadvm {snapshot_name}"
+        })
+        return "Snapshot rollback successful."
+    except Exception as e:
+        print(e)
+        return "Error rolling back snapshot."
+    finally:
+        await qmp.disconnect()
+
+@method_decorator(csrf_exempt, name='dispatch')
+class RollbackSnapshotView(View):
+    """
+    API View that handles POST requests to rollback a snapshot of a specific VM.
+
+    This view requires an API key for authentication. If the API key is valid and is associated
+    with an active user, it calls the `rollback_snapshot` asynchronous function to rollback to the snapshot.
+
+    If the API key is missing, invalid, or associated with an inactive user, or if the snapshot
+    name is missing in the request data, an error message is returned.
+
+    The response indicates either a success or an error message in a JSON format:
+    {
+        "message": <string>
+    }
+    or
+    {
+        "error": <string>
+    }
+    """
+    async def post(self, request, uuid):
+        """
+        Handles the POST request to rollback to a snapshot of a VM.
+
+        Args:
+            request: The HTTP request from the client. Expected to contain the API key in the headers,
+                     and the snapshot name in the request data.
+            uuid: The UUID of the VM to rollback the snapshot.
+
+        Returns:
+            JsonResponse: A JsonResponse that either contains a success message or an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=401)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=401)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=401)
+
+        snapshot_name = request.POST.get('snapshot_name')
+        if not snapshot_name:
+            return JsonResponse({'error': 'Snapshot name required'}, status=400)
+
+        rollback_status = await rollback_snapshot(uuid, snapshot_name)
+        return JsonResponse({'message': rollback_status}, status=200)
+
+async def create_snapshot(uuid):
+    """
+    Asynchronously creates a snapshot of a specific VM.
+
+    This function uses QEMU's QMP (QEMU Machine Protocol) to execute commands on the VM.
+    It specifically runs the `savevm` command to create the snapshot.
+
+    Args:
+        uuid (str): The unique identifier for the VM.
+
+    Returns:
+        str: The name of the snapshot if successful, or an error message if an exception occurred.
+    """
+    qmp = QMPClient('forensicVM')
+    socket_path = f"/forensicVM/mnt/vm/{uuid}/run/qmp.sock"
+
+    print(socket_path)
+    try:
+        await qmp.connect(socket_path)
+
+        res = await qmp.execute('query-status')
+        print(res)
+        print(f"VM status: {res['status']}")
+        status = res['status']
+
+        snapshot_name = datetime.now().strftime("snap-%Y-%m-%d_%H%M%S")
+
+        print(snapshot_name)
+
+        res = await qmp.execute("human-monitor-command", {
+            "command-line": f"savevm {snapshot_name}"
+        })
+
+        print(f"Snapshot '{snapshot_name}' created.")
+
+        return snapshot_name
+    except Exception as e:
+        print(e)
+        return "Error creating snapshot."
+    finally:
+        await qmp.disconnect()
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class CreateSnapshotView(View):
+    """
+    API View that handles POST requests to create a snapshot of a specific VM.
+
+    This view requires an API key for authentication. If the API key is valid and is associated
+    with an active user, it calls the `create_snapshot` asynchronous function to create the snapshot.
+
+    If the API key is missing, invalid, or associated with an inactive user, an error message is returned.
+
+    The response indicates either the snapshot name or an error message in a JSON format:
+    {
+        "snapshot_name": <string>
+    }
+    or
+    {
+        "error": <string>
+    }
+    """
+    async def post(self, request, uuid):
+        """
+        Handles the POST request to create a snapshot of a VM.
+
+        Args:
+            request: The HTTP request from the client. Expected to contain the API key in the headers.
+            uuid: The UUID of the VM to create the snapshot.
+
+        Returns:
+            JsonResponse: A JsonResponse that either contains the snapshot name or an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=401)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=401)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=401)
+
+        snapshot_name = await create_snapshot(uuid)
+        return JsonResponse({'snapshot_name': snapshot_name}, status=200)
+
+async def get_snapshots(uuid):
+    """
+    Asynchronously retrieves the list of snapshots of a specific VM.
+
+    This function uses QEMU's QMP (QEMU Machine Protocol) to execute commands on the VM.
+    It specifically runs the `info snapshots` command to retrieve the list of snapshots.
+
+    Args:
+        uuid (str): The unique identifier for the VM.
+
+    Returns:
+        list: A list of dictionaries containing snapshot information. Each dictionary includes
+              snapshot id, tag, VM size, date, and VM clock.
+              If an exception occurred, an empty list is returned.
+    """
+    qmp = QMPClient('forensicVM')
+    socket_path = f"/forensicVM/mnt/vm/{uuid}/run/qmp.sock"
+    snapshots = []
+
+    try:
+        await qmp.connect(socket_path)
+        result = await qmp.execute("human-monitor-command", {
+            "command-line": "info snapshots"
+        })
+        
+        # Assuming that result is a string with a table-like structure
+        snapshot_lines = result.split('\n')
+        for line in snapshot_lines:
+            # DEBUG
+            print(line)
+            if line.startswith('--'):
+                snapshot_info = line.split()
+                snapshot_id = snapshot_info[0]
+                snapshot_tag = snapshot_info[1]
+                vm_size = snapshot_info[2]
+                date = snapshot_info[3]
+                vm_clock = snapshot_info[4]
+                snapshots.append({
+                    'id': snapshot_id,
+                    'tag': snapshot_tag,
+                    'vm_size': vm_size,
+                    'date': date,
+                    'vm_clock': vm_clock
+                })
+    except Exception as e:
+        print(e)
+    finally:
+        await qmp.disconnect()
+
+    return snapshots
+
+@method_decorator(csrf_exempt, name='dispatch')
+class SnapshotListView(View):
+    """
+    API View that handles GET requests to retrieve the list of snapshots of a specific VM.
+
+    This view requires an API key for authentication. If the API key is valid and is associated
+    with an active user, it calls the `get_snapshots` asynchronous function to retrieve the list of snapshots.
+
+    If the API key is missing, invalid, or associated with an inactive user, an error message is returned.
+
+    The response includes a list of snapshots or an error message in a JSON format:
+    {
+        "snapshots": [<list of snapshots>]
+    }
+    or
+    {
+        "error": <string>
+    }
+    """
+    async def get(self, request, uuid):
+        """
+        Handles the GET request to retrieve the list of snapshots of a VM.
+
+        Args:
+            request: The HTTP request from the client. Expected to contain the API key in the headers.
+            uuid: The UUID of the VM to get the snapshots.
+
+        Returns:
+            JsonResponse: A JsonResponse that either contains the list of snapshots or an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=401)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=401)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=401)
+
+        snapshots = await get_snapshots(uuid)
+        return JsonResponse({'snapshots': snapshots}, status=200)
+
+
+def create_and_format_qcow2(qcow2_file, folders):
+    """
+    Creates and formats a new QCOW2 file with a capacity of 20GB, and initializes it with a new NTFS partition.
+
+    This function first creates a new QCOW2 file using the `qemu-img` command. Then, it initializes a new NTFS partition on
+    the QCOW2 file using the `guestfish` command-line tool.
+
+    After the partition is created, the function creates a series of folders in the root directory of the partition.
+    Finally, it writes a readme file in the root directory of the partition.
+
+    Args:
+        qcow2_file (str): The path where the new QCOW2 file will be created.
+        folders (list): A list of folder names that will be created in the root directory of the NTFS partition.
+
+    Raises:
+        subprocess.CalledProcessError: If the `qemu-img` command or the `guestfish` command fails.
+    """
+    # Create a new QCOW2 file with 20GB of space
+    subprocess.run(['qemu-img', 'create', '-f', 'qcow2', qcow2_file, '20G'], check=True)
+
+    # Name for the label
+    label_name = "possible evidence"
+
+    # Create a new NTFS partition with guestfish
+    guestfish_commands = f"""
+    launch
+    part-init /dev/sda mbr
+    part-add /dev/sda p 2048 -1024
+    part-set-mbr-id /dev/sda 1 0x07
+    mkfs ntfs /dev/sda1
+    set-label /dev/sda1 "{label_name}"
+    mount /dev/sda1 /
+    """
+
+    # Create folders using guestfish
+    for folder in folders:
+        guestfish_commands += f"mkdir /{folder}\n"
+        print(folder)
+
+    guestfish_commands += """
+    umount /
+    """
+
+
+
+    command = f"guestfish --rw -a {qcow2_file} <<EOF\n{guestfish_commands}\nEOF\n"
+    subprocess.run(command, shell=True, check=True)
+
+    guestfish_commands = """
+    launch
+    mount /dev/sda1 /
+    write /readme.txt \"Forensic VM: This drive was automaticaly created. Please put the probable evidence inside the sub-folders with the same tag of autopsy software for the easiest classification\"
+    write /leiame.txt \"Forensic VM: Este disco foi criado automáticamente. Para facilitar a classificação, por favor coloque as evidências recolhidas nas subpastas que têm o mesmo nome que a etiqueta no software autopsy\"
+    umount /
+    """
+
+    command = f"guestfish --rw -a {qcow2_file} <<EOF\n{guestfish_commands}\nEOF\n"
+    subprocess.run(command, shell=True, check=True)
+
+    print("END guestfish")
+
+
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class RecreateFoldersView(View):
+    """
+    This Django view handles POST requests to recreate a set of folders inside a QCOW2 file in a Virtual Machine.
+
+    The view first authenticates the request based on the provided API key. If the user related to the API key is not active,
+    it returns an error.
+
+    Upon successful authentication, the view retrieves a list of folders and a VM uuid from the request. It then creates
+    a new QCOW2 file in the corresponding VM directory and formats it with NTFS filesystem, followed by creating the specified
+    folders in the root directory of the filesystem. If the QCOW2 file already exists, it is first deleted.
+
+    If the QCOW2 file is created and formatted successfully, the view returns a success message. If an error occurs during
+    the operation, it returns an error message.
+
+    The view uses the `create_and_format_qcow2` function to perform the creation and formatting operations.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    async def post(self, request):
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        # Get the list of folders from the POST data
+        folders = request.POST.getlist('folders')
+        uuid_path = request.POST.get('uuid_path')
+        qcow2_file = f"/forensicVM/mnt/vm/{uuid_path}/evidence.qcow2"
+
+        try:
+            # Remove existing qcow2_file if it exists
+            if os.path.exists(qcow2_file):
+                os.remove(qcow2_file)
+
+            # Create and format the Qcow2 file
+            print("before create qcow2")
+            create_and_format_qcow2(qcow2_file, folders)
+            print("after create qcow2")
+
+            return JsonResponse({'message': f'Folders {", ".join(folders)} created successfully in {qcow2_file}'}, status=status.HTTP_200_OK)
+        except Exception as e:
+            return JsonResponse({'error': f'Error executing guestfish: {str(e)}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+
+class RunPluginView(APIView):
+    """
+    This Django view handles GET requests to run a forensic plugin script on a specified image within a Virtual Machine.
+
+    The view first authenticates the request based on the provided API key. If the user related to the API key is not active,
+    it returns an error.
+
+    Upon successful authentication, the view retrieves the plugin directory and VM uuid from the request parameters.
+    It validates the existence of the plugin script and the image, both identified using the provided parameters.
+
+    If the validation is successful, it attempts to run the plugin script on the image and returns the script's stdout as
+    the response. If the script fails to run, the error details are returned in the response.
+
+    If the validation fails because of the non-existence of the plugin script or the image, an appropriate error message is returned.
+
+    This view does not require any special permissions or authentication classes, as it is intended to be used internally
+    by the system.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    def get(self, request):
+        """
+        Handles GET requests to execute a specific forensic plugin on a VM image.
+
+        The method retrieves the API key from the request headers and validates it. If the API key is invalid or
+        belongs to an inactive user, an error response is returned.
+
+        The method retrieves the plugin directory and image UUID from the GET parameters. It validates these parameters
+        by checking the existence of the plugin script and the image path. If any of these does not exist, an error response is returned.
+
+        The method looks for the latest '.qcow2-sda' file within the image path and sets it as the target for the plugin.
+
+        Upon successful validation, the method attempts to run the plugin script on the image using a bash subprocess. The output
+        from the subprocess is returned in the response.
+
+        If the plugin script execution fails, the error details are returned in the response.
+
+        Parameters:
+        request (HttpRequest): The request object that has triggered this method.
+
+        Returns:
+        JsonResponse: A JSON object containing either the output of the plugin execution or an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        plugin_directory = request.GET.get('plugin_directory')
+        image_uuid = request.GET.get('image_uuid')
+
+        if not plugin_directory or not image_uuid:
+            return JsonResponse({'error': 'Missing plugin_directory or image_uuid'}, status=status.HTTP_400_BAD_REQUEST)
+
+        plugin_script_path = f'/forensicVM/plugins/{plugin_directory}/run.sh'
+        image_path = f'/forensicVM/mnt/vm/{image_uuid}'
+
+        if not os.path.exists(plugin_script_path):
+            return JsonResponse({'error': 'Plugin script not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        if not os.path.exists(image_path):
+            return JsonResponse({'error': 'Image path not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        file_list = os.listdir(image_path)
+        file_list.sort(reverse=True)
+        for file in file_list:
+            if file.endswith('.qcow2-sda'):
+                image_file = os.path.join(image_path, file)
+                break
+        else:
+            return JsonResponse({'error': 'Image file not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        try:
+            result = subprocess.run(['bash', plugin_script_path, 'run', image_file], capture_output=True, text=True)
+            output = result.stdout.strip()
+            return JsonResponse({'output': output}, status=status.HTTP_200_OK)
+        except subprocess.CalledProcessError as e:
+            return JsonResponse({'error': f'Plugin execution failed: {e.stderr}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+
+class ListPluginsView(APIView):
+    """
+    This is a Django REST Framework view that extends from the APIView base class.
+
+    The ListPluginsView class defines behavior for handling HTTP GET requests on the URL path associated with it.
+    The purpose of this class is to provide an endpoint that responds with a list of available forensic plugins.
+    The view uses Django's APIView, which means it can handle different types of HTTP requests.
+    It currently only implements handling of GET requests via the defined get() method.
+
+    Attributes:
+        authentication_classes (list): A list of authentication classes the view should use. Empty in this case.
+        permission_classes (list): A list of permissions the view should enforce. Empty in this case.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    def get(self, request):
+        """
+        Handles GET requests to list all available forensic plugins.
+
+        The method retrieves the API key from the request headers and validates it. If the API key is invalid or
+        belongs to an inactive user, an error response is returned.
+
+        The method then reads the 'plugins' directory and looks for 'run.sh' files in each of the subdirectories.
+        For each such file found, it gets the plugin information by calling the get_plugin_info() function.
+
+        If the 'plugins' directory does not exist, an error response is returned.
+
+        Parameters:
+        request (HttpRequest): The request object that has triggered this method.
+
+        Returns:
+        JsonResponse: A JSON object containing a list of all available plugins with their names, descriptions and directories.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=401)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=401)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=401)
+
+        plugins_dir = '/forensicVM/plugins'
+        if not os.path.exists(plugins_dir):
+            return JsonResponse({'error': 'Plugins directory not found'}, status=404)
+
+        plugin_files = []
+        for root, dirs, files in os.walk(plugins_dir):
+            for file in files:
+                if file == 'run.sh':
+                    plugin_dir = os.path.basename(os.path.dirname(os.path.join(root, file)))
+                    plugin_files.append({
+                        'plugin_name': get_plugin_info(plugin_dir, 'plugin_name'),
+                        'plugin_description': get_plugin_info(plugin_dir, 'plugin_description'),
+                        'plugin_dir': plugin_dir
+                    })
+
+        return JsonResponse({'plugins': plugin_files}, status=200)
+
+
+def get_plugin_info(plugin_dir, info):
+    """
+    Runs the 'info' command of the plugin script and retrieves the specified information.
+
+    Parameters:
+    plugin_dir (str): The directory where the plugin script is located.
+    info (str): The type of information to retrieve (e.g. 'plugin_name', 'plugin_description').
+
+    Returns:
+    str: The requested information, or an empty string if the information could not be retrieved.
+    """
+    run_script_path = os.path.join('/forensicVM/plugins', plugin_dir, 'run.sh')
+    result = subprocess.run(['bash', run_script_path, 'info'], capture_output=True, text=True)
+    output = result.stdout.strip()
+
+    try:
+        info_dict = json.loads(output)
+    except json.JSONDecodeError:
+        info_dict = {}
+
+    return info_dict.get(info, '')
+
+async def insert_network_card(uuid, mac_address=None):
+    """
+    Asynchronously inserts a network card into a specified virtual machine.
+
+    This function first generates a random MAC address if none is provided. It then establishes a connection to
+    the QEMU Machine Protocol (QMP) and sends commands to add a new network device to the machine.
+
+    Parameters:
+    uuid (str): The unique identifier of the virtual machine.
+    mac_address (str, optional): The MAC address to assign to the network card.
+
+    Returns:
+    str: A confirmation message.
+    """
+    if not mac_address:
+        # Generate a random MAC address if not supplied
+        mac_address = generate_random_mac_address()
+
+    qmp = QMPClient('forensicVM')
+    socket_path = f"/forensicVM/mnt/vm/{uuid}/run/qmp.sock"
+
+    try:
+        await qmp.connect(socket_path)
+
+        res = await qmp.execute("netdev_add",
+                                { "type": "user",
+                                  "id": "net0"})
+        res = await qmp.execute("device_add",
+                                { "driver": "virtio-net-pci",
+                                  "netdev": "net0"})
+        res = await qmp.execute("query-pci", {})
+        print(res)
+
+        print(f"Network card inserted with MAC address: {mac_address}")
+    except Exception as e:
+        print(e)
+    finally:
+        await qmp.disconnect()
+
+    return "Network card inserted."
+
+def generate_random_mac_address():
+    """
+    Generates a random MAC address.
+
+    This function creates a MAC address with the locally administered and unicast bits set,
+    and with the rest of the bits randomized.
+
+    Returns:
+    str: The generated MAC address.
+    """
+    import random
+
+    mac = [0x52, 0x54, 0x00,
+           random.randint(0x00, 0x7f),
+           random.randint(0x00, 0xff),
+           random.randint(0x00, 0xff)]
+
+    mac_address = ':'.join(map(lambda x: "%02x" % x, mac))
+    return mac_address
+
+@method_decorator(csrf_exempt, name='dispatch')
+class InsertNetworkCardView(View):
+    """
+    This is a Django view that provides an endpoint for inserting a network card into a virtual machine.
+
+    The InsertNetworkCardView class handles HTTP GET requests to insert a network card into a virtual machine
+    identified by its unique identifier (uuid). The class uses Django's View, which means it can handle different types
+    of HTTP requests. It currently only implements handling of GET requests via the defined get() method.
+
+    Attributes:
+        authentication_classes (list): A list of authentication classes the view should use. Empty in this case.
+        permission_classes (list): A list of permissions the view should enforce. Empty in this case.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    async def get(self, request, uuid):
+        """
+        This method handles the GET request to insert a network card into a virtual machine.
+
+        It first validates the API key from the request. If the key is valid, it calls the asynchronous function
+        insert_network_card() to insert the network card and returns a confirmation message.
+
+        Parameters:
+        request (HttpRequest): The request object that has triggered this method.
+        uuid (str): The unique identifier of the virtual machine.
+
+        Returns:
+        JsonResponse: A JSON object containing a confirmation message or an error message with an HTTP status code.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                #api_key = ApiKey.objects.get(key=api_key)
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    print('User account disabled')
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                print('Invalid key')
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            print('api required')
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        if not uuid:
+            print('uuid required')
+            return JsonResponse({'error': 'UUID is required.'}, status=status.HTTP_400_BAD_REQUEST)
+
+        try:
+            print('inserting network card')
+            await insert_network_card(uuid)
+            print('inserted')
+        except Exception as e:
+            return JsonResponse({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+        return JsonResponse({'message': 'Network card inserted.'}, status=status.HTTP_200_OK)
+
+
+async def insert_cdrom(uuid, filename):
+    """
+    Asynchronously inserts a CD-ROM into a specified virtual machine.
+
+    This function establishes a connection to the QEMU Machine Protocol (QMP) and sends a command to change the medium
+    of the CD-ROM drive to the specified ISO file.
+
+    Parameters:
+    uuid (str): The unique identifier of the virtual machine.
+    filename (str): The name of the ISO file to insert into the CD-ROM drive.
+
+    Returns:
+    str: A confirmation message.
+    """
+    qmp = QMPClient('forensicVM')
+    socket_path = f"/forensicVM/mnt/vm/{uuid}/run/qmp.sock"
+
+    try:
+        await qmp.connect(socket_path)
+        res = await qmp.execute("blockdev-change-medium",
+                                { "id": "ide0-0-0",
+                                  "filename": f"/forensicVM/mnt/iso/{filename}",
+                                  "format": "raw" })
+        print(f"CD-ROM inserted.")
+    except Exception as e:
+        print(e)
+    finally:
+        await qmp.disconnect()
+
+    return "CD-ROM inserted."
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class InsertCDROMView(View):
+    """
+    This is a Django view that provides an endpoint for inserting a CD-ROM into a virtual machine.
+
+    The InsertCDROMView class handles HTTP GET requests to insert a CD-ROM into a virtual machine
+    identified by its unique identifier (uuid) and the filename of the ISO image.
+
+    The class uses Django's View, which means it can handle different types of HTTP requests. It currently only
+    implements handling of GET requests via the defined get() method. It also supports authentication via sessions.
+
+    Attributes:
+        authentication_classes (list): A list of authentication classes the view should use.
+                                       It includes SessionAuthentication.
+        permission_classes (list): A list of permissions the view should enforce. Empty in this case.
+    """
+    authentication_classes = [SessionAuthentication]
+    permission_classes = []
+
+    async def get(self, request, uuid, filename):
+        """
+        This method handles the GET request to insert a CD-ROM into a virtual machine.
+
+        It first validates the user or API key from the request. If the user is authenticated or the API key is valid,
+        it calls the asynchronous function insert_cdrom() to insert the CD-ROM and returns a confirmation message.
+
+        Parameters:
+        request (HttpRequest): The request object that has triggered this method.
+        uuid (str): The unique identifier of the virtual machine.
+        filename (str): The filename of the ISO image to insert into the CD-ROM drive.
+
+        Returns:
+        JsonResponse: A JSON object containing a confirmation message or an error message with an HTTP status code.
+        """
+        user, api_key_error = await sync_to_async(self.get_user_or_key_error)(request)
+        if api_key_error:
+            return api_key_error
+
+        cdrom_status = await insert_cdrom(uuid, filename)
+        return JsonResponse({'message': cdrom_status}, status=status.HTTP_200_OK)
+
+    def get_user_or_key_error(self, request):
+        """
+        This method handles the user authentication and API key validation.
+
+        It checks if the user is authenticated. If not, it validates the API key from the request. If the API key
+        is invalid or belongs to an inactive user, it returns a JSON response with an error message.
+
+        Parameters:
+        request (HttpRequest): The request object that has triggered this method.
+
+        Returns:
+        tuple: A tuple containing the user (if authenticated or API key is valid) and a JSON response (if any error occurs).
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        user = getattr(request, 'user', None)
+        if user and user.is_authenticated:
+            print("DEBUG: USER AUTHENTICATED")
+        elif api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = getattr(api_key, 'user')
+                if not user.is_active:
+                    return None, JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return None, JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return None, JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+        return user, None
+
+async def eject_cdrom(uuid):
+    """
+    Asynchronously ejects the CD-ROM from a specified virtual machine.
+
+    This function establishes a connection to the QEMU Machine Protocol (QMP) and sends a command to open the tray
+    of the CD-ROM drive, effectively ejecting the CD-ROM.
+
+    Parameters:
+    uuid (str): The unique identifier of the virtual machine.
+
+    Returns:
+    str: A confirmation message.
+    """
+    qmp = QMPClient('forensicVM')
+    socket_path = f"/forensicVM/mnt/vm/{uuid}/run/qmp.sock"
+
+    try:
+        await qmp.connect(socket_path)
+        res = await qmp.execute("blockdev-open-tray",
+                                { "id": "ide0-0-0"})
+        print(f"CD-ROM ejected.")
+    except Exception as e:
+        print(e)
+    finally:
+        await qmp.disconnect()
+
+    return "CD-ROM ejected."
+
+@method_decorator(csrf_exempt, name='dispatch')
+class EjectCDROMView(View):
+    """
+    This is a Django view that provides an endpoint for ejecting the CD-ROM from a virtual machine.
+
+    The EjectCDROMView class handles HTTP GET requests to eject the CD-ROM from a virtual machine
+    identified by its unique identifier (uuid).
+
+    The class uses Django's View, which means it can handle different types of HTTP requests. It currently only
+    implements handling of GET requests via the defined get() method. It also supports authentication via sessions.
+
+    Attributes:
+        authentication_classes (list): A list of authentication classes the view should use.
+                                       It includes SessionAuthentication.
+        permission_classes (list): A list of permissions the view should enforce. Empty in this case.
+    """
+    authentication_classes = [SessionAuthentication]
+    permission_classes = []
+
+    async def get(self, request, uuid):
+        """
+        This method handles the GET request to eject the CD-ROM from a virtual machine.
+
+        It first validates the user or API key from the request. If the user is authenticated or the API key is valid,
+        it calls the asynchronous function eject_cdrom() to eject the CD-ROM and returns a confirmation message.
+
+        Parameters:
+        request (HttpRequest): The request object that has triggered this method.
+        uuid (str): The unique identifier of the virtual machine.
+
+        Returns:
+        JsonResponse: A JSON object containing a confirmation message or an error message with an HTTP status code.
+        """
+        user, api_key_error = await sync_to_async(self.get_user_or_key_error)(request)
+        if api_key_error:
+            return api_key_error
+
+        cdrom_status = await eject_cdrom(uuid)
+        return JsonResponse({'message': cdrom_status}, status=status.HTTP_200_OK)
+
+    def get_user_or_key_error(self, request):
+        """
+        This method handles the user authentication and API key validation.
+
+        It checks if the user is authenticated. If not, it validates the API key from the request. If the API key
+        is invalid or belongs to an inactive user, it returns a JSON response with an error message.
+
+        Parameters:
+        request (HttpRequest): The request object that has triggered this method.
+
+        Returns:
+        tuple: A tuple containing the user (if authenticated or API key is valid) and a JSON response (if any error occurs).
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        user = getattr(request, 'user', None)
+        if user and user.is_authenticated:
+            print("DEBUG: USER AUTHENTICATED")
+        elif api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = getattr(api_key, 'user')
+                if not user.is_active:
+                    return None, JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return None, JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return None, JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+        return user, None
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class DeleteISOFileView(View):
+    """
+    This is a Django view that provides an endpoint for deleting an ISO file from a specified directory.
+
+    The DeleteISOFileView class handles HTTP POST requests to delete an ISO file identified by its filename.
+
+    The class uses Django's View, which means it can handle different types of HTTP requests. It currently only
+    implements handling of POST requests via the defined post() method.
+
+    Attributes:
+        authentication_classes (list): A list of authentication classes the view should use. It's empty in this case.
+        permission_classes (list): A list of permissions the view should enforce. It's empty in this case.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    def post(self, request, filename):
+        """
+        This method handles the POST request to delete an ISO file.
+
+        It first validates the API key from the request. If the API key is valid and belongs to an active user,
+        it checks if the ISO directory and the specified ISO file exist. If they do, it deletes the ISO file
+        and returns a confirmation message.
+
+        Parameters:
+        request (HttpRequest): The request object that has triggered this method.
+        filename (str): The name of the ISO file to be deleted.
+
+        Returns:
+        JsonResponse: A JSON object containing a confirmation message or an error message with an HTTP status code.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        iso_dir = '/forensicVM/mnt/iso'
+        if not os.path.exists(iso_dir):
+            return JsonResponse({'error': 'ISO directory not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        iso_file_path = os.path.join(iso_dir, filename)
+        if not os.path.isfile(iso_file_path):
+            return JsonResponse({'error': f'ISO file {filename} not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        os.remove(iso_file_path)
+
+        return JsonResponse({'message': f'ISO file {filename} deleted successfully'}, status=status.HTTP_200_OK)
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class UploadISOView(View):
+    """
+    This is a Django view that provides an endpoint for uploading an ISO file to a specified directory.
+
+    The UploadISOView class handles HTTP POST requests to receive an ISO file and save it to the directory.
+
+    The class uses Django's View, which means it can handle different types of HTTP requests. It currently only
+    implements handling of POST requests via the defined post() method.
+
+    Attributes:
+        authentication_classes (list): A list of authentication classes the view should use. It's empty in this case.
+        permission_classes (list): A list of permissions the view should enforce. It's empty in this case.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    def post(self, request):
+        """
+        This method handles the POST request to upload an ISO file.
+
+        It first validates the API key from the request. If the API key is valid and belongs to an active user,
+        it checks if an ISO file is provided in the request. If it is, it saves the ISO file
+        to a specified directory and returns a confirmation message.
+
+        Parameters:
+        request (HttpRequest): The request object that has triggered this method.
+
+        Returns:
+        JsonResponse: A JSON object containing a confirmation message or an error message with an HTTP status code.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        iso_file = request.FILES.get('iso_file')
+        if not iso_file:
+            return JsonResponse({'error': 'Missing ISO file'}, status=status.HTTP_400_BAD_REQUEST)
+
+        # Save the ISO file to the target directory
+        upload_dir = '/forensicVM/mnt/iso'
+        iso_file_path = os.path.join(upload_dir, iso_file.name)
+        with open(iso_file_path, 'wb') as f:
+            for chunk in iso_file.chunks():
+                f.write(chunk)
+
+        return JsonResponse({'message': 'ISO file uploaded successfully'}, status=status.HTTP_200_OK)
+
+
+class ListISOFilesView(APIView):
+    """
+    This is a Django view that provides an endpoint for retrieving a list of all ISO files in a specified directory.
+
+    The ListISOFilesView class handles HTTP GET requests to retrieve the ISO files.
+
+    The class uses Django's APIView, which allows it to handle different types of HTTP requests. It currently only
+    implements handling of GET requests via the defined get() method.
+
+    Attributes:
+        authentication_classes (list): A list of authentication classes the view should use. It's empty in this case.
+        permission_classes (list): A list of permissions the view should enforce. It's empty in this case.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    def get(self, request):
+        """
+        This method handles the GET request to list all ISO files.
+
+        It first validates the API key from the request. If the API key is valid and belongs to an active user,
+        it checks if the ISO directory exists and retrieves a list of all ISO files in the directory. If the directory
+        does not exist, it returns an error message.
+
+        Parameters:
+        request (HttpRequest): The request object that has triggered this method.
+
+        Returns:
+        JsonResponse: A JSON object containing a list of all ISO files in the directory or an error message with an HTTP status code.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        iso_dir = '/forensicVM/mnt/iso'
+        if not os.path.exists(iso_dir):
+            return JsonResponse({'error': 'ISO directory not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        iso_files = []
+        for file in os.listdir(iso_dir):
+            if file.endswith('.iso'):
+                iso_files.append(file)
+        return JsonResponse({'iso_files': iso_files}, status=status.HTTP_200_OK)
+
+
+def change_qcow2(qcow2_file, folders):
+    """
+    This function creates new folders in a qcow2 disk image. It uses guestfish commands to interact with the disk image.
+
+    Parameters:
+    qcow2_file (str): Path to the qcow2 file that should be changed.
+    folders (list): List of folder names to be created in the qcow2 image.
+
+    Returns:
+    None
+
+    Raises:
+    subprocess.CalledProcessError: If a guestfish command fails.
+    """
+    # Create a new NTFS partition with guestfish
+    guestfish_commands = f"""
+    launch
+    mount /dev/sda1 /
+    """
+
+    # Create folders using guestfish
+    for folder in folders:
+        guestfish_commands += f"-mkdir /{folder} \n"
+        print(folder)
+
+    guestfish_commands += """
+    umount /
+    """
+
+    command = f"guestfish --rw -a {qcow2_file} <<EOF\n{guestfish_commands}\nEOF\n"
+    subprocess.run(command, shell=True, check=True)
+
+    guestfish_commands = """
+    launch
+    mount /dev/sda1 /
+    write /readme.txt \"Forensic VM: This drive was automaticaly created. Please put the probable evidence inside the sub-folders with the same tag of autopsy software for the easiest classification\"
+    write /leiame.txt \"Forensic VM: Este disco foi criado automáticamente. Para facilitar a classificação, por favor coloque as evidências recolhidas nas subpastas que têm o mesmo nome que a etiqueta no software autopsy\"
+    umount /
+    """
+
+    command = f"guestfish -x --rw -a {qcow2_file} <<EOF\n{guestfish_commands}\nEOF\n"
+    subprocess.run(command, shell=True, check=True)
+
+    print("END guestfish")
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+
+class CreateFoldersView(View):
+    """
+      This class-based view handles the POST request to create specified folders in a qcow2 disk image.
+
+      The method checks the validity and activity status of the provided API key. If the API key is invalid or
+      belongs to an inactive user, it returns an error message.
+
+      It then retrieves the list of folders and the UUID path from the request data. It uses the UUID path to form
+      the path to the qcow2 file.
+
+      It checks if the qcow2 file exists. If it doesn't, it returns an error.
+
+      It calls the change_qcow2 function to create the folders in the qcow2 file. If successful, it returns a success
+      message. If an error occurs, it returns an error message.
+
+      Attributes:
+      authentication_classes (list): A list of authentication classes to use for the view.
+      permission_classes (list): A list of permission classes to use for the view.
+
+      Methods:
+      post(request): Asynchronously handles the POST request.
+      """
+    authentication_classes = []
+    permission_classes = []
+
+    async def post(self, request):
+        """
+        Asynchronously handles the POST request to create folders in a qcow2 file.
+
+        Parameters:
+        request (HttpRequest): The request object that has triggered this method.
+
+        Returns:
+        JsonResponse: A JSON object containing a success message if the folders were created successfully,
+                       or an error message otherwise.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        # Get the list of folders from the POST data
+        folders = request.POST.getlist('folders')
+        uuid_path = request.POST.get('uuid_path')
+        qcow2_file = f"/forensicVM/mnt/vm/{uuid_path}/evidence.qcow2"
+
+        # Check if vmdk_file exists
+        if not os.path.exists(qcow2_file):
+            return JsonResponse({'error': f'QCOW2 file {qcow2_file} not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        try:
+            change_qcow2(qcow2_file, folders)
+
+            return JsonResponse({'message': f'Folders {", ".join(folders)} created successfully in {qcow2_file}'}, status=status.HTTP_200_OK)
+        except Exception as e:
+            return JsonResponse({'error': f'Error executing guestfish: {str(e)}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class DownloadEvidenceView(View):
+    """
+    This class-based view handles the GET request to download a VMDK evidence file related to a specific VM.
+
+    The method checks the validity and activity status of the provided API key. If the API key is invalid or
+    belongs to an inactive user, it returns an error message.
+
+    It uses the UUID from the URL parameters to form the path to the VM directory and checks if it exists.
+
+    It then forms the path to the qcow2 file and converts it to a VMDK file using qemu-img. If this process fails,
+    it returns an error message.
+
+    It checks if the VMDK evidence file exists. If it doesn't, it returns an error.
+
+    Finally, it returns the evidence file as a FileResponse, allowing the client to download it.
+
+    Attributes:
+    authentication_classes (list): A list of authentication classes to use for the view.
+    permission_classes (list): A list of permission classes to use for the view.
+
+    Methods:
+    get(request, uuid): Asynchronously handles the GET request.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    async def get(self, request, uuid):
+        """
+        Asynchronously handles the GET request to download a VMDK evidence file.
+
+        Parameters:
+        request (HttpRequest): The request object that has triggered this method.
+        uuid (str): The UUID of the VM.
+
+        Returns:
+        FileResponse: A FileResponse object containing the VMDK evidence file,
+                      or a JsonResponse object containing an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        vm_path = f"/forensicVM/mnt/vm/{uuid}"
+        vm_exists = os.path.exists(vm_path)
+
+        if not vm_exists:
+            return JsonResponse({'error': f'VM with UUID {uuid} not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        evidence_path = f"/forensicVM/mnt/vm/{uuid}/evidence.vmdk"
+        qcow2_path = f"/forensicVM/mnt/vm/{uuid}/evidence.qcow2"
+        cmd = f"qemu-img convert {qcow2_path} -f qcow2 -O vmdk {evidence_path}"
+        try:
+            subprocess.run(cmd, shell=True, check=True)
+            result = {'folder_mounted': True}
+        except subprocess.CalledProcessError as e:
+            return Response({'error': f"Error converting evidence disk: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+        evidence_exists = os.path.exists(evidence_path)
+
+        if not evidence_exists:
+            return JsonResponse({'error': f'Evidence file not found for VM with UUID {uuid}'}, status=status.HTTP_404_NOT_FOUND)
+
+        # Return the evidence file as a FileResponse
+        response = FileResponse(open(evidence_path, 'rb'), content_type='application/octet-stream')
+        response['Content-Disposition'] = f'attachment; filename="{os.path.basename(evidence_path)}"'
+        return response
+
+async def memory_snapshot(uuid):
+    """
+    This asynchronous function captures a snapshot of a VM's memory.
+
+    It establishes a connection with the QEMU Machine Protocol (QMP) running on the VM,
+    then uses the QMP command 'dump-guest-memory' to capture the memory snapshot.
+
+    The function saves the memory snapshot to the VM's directory, with a unique filename
+    based on the current number of existing snapshots.
+
+    Parameters:
+    uuid (str): The UUID of the VM.
+
+    Returns:
+    str: The path to the newly created memory snapshot file.
+
+    Raises:
+    Exception: If there's an error executing the 'dump-guest-memory' command or disconnecting from QMP.
+    """
+    qmp = QMPClient('forensicVM')
+    socket_path = f"/forensicVM/mnt/vm/{uuid}/run/qmp.sock"
+    memory_snapshots_path = f"/forensicVM/mnt/vm/{uuid}/memory/"
+
+    if not os.path.exists(memory_snapshots_path):
+        os.makedirs(memory_snapshots_path)
+
+    existing_snapshots = sorted(glob.glob(f"{memory_snapshots_path}/memory_snapshot*.dmp"))
+    next_snapshot_number = len(existing_snapshots) + 1
+    next_snapshot_filename = f"memory_snapshot{next_snapshot_number:03d}.dmp"
+    next_snapshot_path = os.path.join(memory_snapshots_path, next_snapshot_filename)
+
+    try:
+        await qmp.connect(socket_path)
+        res = await qmp.execute('dump-guest-memory', { "paging": False, "protocol": f"file:{next_snapshot_path}", "detach": False})
+        print(f"Memory snapshot saved: {next_snapshot_path}")
+    except Exception as e:
+        print(e)
+    finally:
+        await qmp.disconnect()
+
+    return next_snapshot_path
+
+@method_decorator(csrf_exempt, name='dispatch')
+class MemorySnapshotView(View):
+    """
+    This is an API view for creating a memory snapshot of a Virtual Machine (VM) and downloading it.
+    It requires the UUID of the VM to be specified as a path parameter in the URL.
+
+    Authentication is done via an API key which must be included in the request headers.
+
+    This view will attempt to create a memory snapshot of the VM and then return it as a file download.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    async def get(self, request, uuid):
+        """
+        Handle the GET request to the MemorySnapshotView.
+
+        The function will first authenticate the user using the API key provided in the headers.
+        If the user is authenticated, it will proceed to create a memory snapshot of the VM
+        specified by the UUID in the URL and then return the snapshot file as a response.
+
+        Args:
+            request: The HTTP request.
+            uuid: The UUID of the VM to create a memory snapshot of.
+
+        Returns:
+            A FileResponse with the memory snapshot file. If an error occurs, a JsonResponse
+            with an error message will be returned.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        snapshot_file = await memory_snapshot(uuid)
+        response = FileResponse(open(snapshot_file, 'rb'), content_type='application/octet-stream', as_attachment=True, filename=os.path.basename(snapshot_file))
+        return response
+
+@method_decorator(csrf_exempt, name='dispatch')
+class DownloadScreenshotsView(View):
+    """
+    This is an API view for downloading all the screenshots of a Virtual Machine (VM) as a ZIP file.
+    It requires the UUID of the VM to be specified as a path parameter in the URL.
+
+    Authentication is done via an API key which must be included in the request headers.
+
+    This view will attempt to collect all the screenshots of the VM, convert them to JPG format if necessary,
+    compress them into a ZIP file, and then return it as a file download.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    async def get(self, request, uuid):
+        """
+        Handle the GET request to the DownloadScreenshotsView.
+
+        The function will first authenticate the user using the API key provided in the headers.
+        If the user is authenticated, it will proceed to collect all the screenshots of the VM specified by
+        the UUID in the URL, convert them to JPG format, compress them into a ZIP file, and then return the
+        ZIP file as a response.
+
+        Args:
+            request: The HTTP request.
+            uuid: The UUID of the VM to download the screenshots from.
+
+        Returns:
+            A FileResponse with the ZIP file containing all screenshots. If an error occurs, a JsonResponse
+            with an error message will be returned.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = await sync_to_async(ApiKey.objects.get)(key=api_key)
+                user = await sync_to_async(getattr)(api_key, 'user')
+                if not user.is_active:
+                    return JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        vm_path = f"/forensicVM/mnt/vm/{uuid}"
+        vm_exists = os.path.exists(vm_path)
+
+        if not vm_exists:
+            return JsonResponse({'error': f'VM with UUID {uuid} not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        screenshots_path = f"/forensicVM/mnt/vm/{uuid}/screenshots/"
+
+        # Convert PNG files to JPG
+        for png_file in glob.glob(f"{screenshots_path}/*.png"):
+            jpg_file = os.path.splitext(png_file)[0] + ".jpg"
+            img = Image.open(png_file)
+            img.convert("RGB").save(jpg_file)
+
+        # Create a zip file containing all JPG files
+        zip_file_path = f"/forensicVM/mnt/vm/{uuid}/screenshots.zip"
+        with zipfile.ZipFile(zip_file_path, 'w') as zipf:
+            for jpg_file in glob.glob(f"{screenshots_path}/*.jpg"):
+                zipf.write(jpg_file, os.path.basename(jpg_file))
+
+        # Return the zip file as a FileResponse
+        response = FileResponse(open(zip_file_path, 'rb'), content_type='application/zip')
+        response['Content-Disposition'] = f'attachment; filename="{os.path.basename(zip_file_path)}"'
+        return response
+
+async def screendump(uuid):
+    """
+    Capture a screenshot of a Virtual Machine (VM) and save it as a PNG file.
+
+    This function uses the QEMU Machine Protocol (QMP) to communicate with the VM and issue the 'screendump' command,
+    which captures a screenshot of the current state of the VM's display. The screenshot is saved to a directory
+    named 'screenshots' within the VM's directory, and the file is named 'sc' followed by a five-digit number,
+    with leading zeroes as necessary.
+
+    Args:
+        uuid: The UUID of the VM to capture a screenshot from.
+
+    Returns:
+        The number of the screenshot that was taken, as an integer.
+
+    Raises:
+        Prints an exception error if the QMP connection or command execution fails.
+    """
+    qmp = QMPClient('forensicVM')
+    socket_path = f"/forensicVM/mnt/vm/{uuid}/run/qmp.sock"
+    screenshots_path = f"/forensicVM/mnt/vm/{uuid}/screenshots/"
+
+    if not os.path.exists(screenshots_path):
+        os.makedirs(screenshots_path)
+
+    existing_screenshots = sorted(glob.glob(f"{screenshots_path}/sc*.png"))
+    next_screenshot_number = len(existing_screenshots) + 1
+    next_screenshot_filename = f"sc{next_screenshot_number:05d}.png"
+    next_screenshot_path = os.path.join(screenshots_path, next_screenshot_filename)
+
+    try:
+        await qmp.connect(socket_path)
+        res = await qmp.execute('screendump', {"filename": next_screenshot_path})
+        print(f"Screenshot saved: {next_screenshot_path}")
+        return(next_screenshot_number)
+    except Exception as e:
+        print(e)
+    finally:
+        await qmp.disconnect()
+
+@method_decorator(csrf_exempt, name='dispatch')
+class ScreenshotVMView(View):
+    """
+    A View class to handle the capture of screenshots from a Virtual Machine (VM).
+
+    This View supports an asynchronous POST request, which initiates the capture of a screenshot from the VM.
+    The VM is identified by its UUID, which is passed in the URL.
+
+    Authentication is required to access this View. It supports both session-based authentication and API key
+    authentication.
+
+    """
+    authentication_classes = [SessionAuthentication]                # ADDED
+    permission_classes = []
+
+    async def post(self, request, uuid):
+        """
+        Handles a POST request to capture a screenshot from a VM.
+
+        The VM is identified by its UUID, which is passed in the URL.
+
+        The request must be authenticated. This can be done either through session-based authentication or
+        by including an 'X-API-KEY' header in the request.
+
+        Args:
+            request: The Django request object.
+            uuid: The UUID of the VM.
+
+        Returns:
+            A JsonResponse containing the status of the screenshot operation. If the operation is successful,
+            the response will include a 'screenshot_taken' key with a value of True, and a 'message' key with the
+            screenshot number.
+
+            If an error occurs, the JsonResponse will contain an 'error' key with a description of the error.
+        """
+        user, api_key_error = await sync_to_async(self.get_user_or_key_error)(request)
+        if api_key_error:
+            return api_key_error
+
+        vm_path = f"/forensicVM/mnt/vm/{uuid}"
+        vm_exists = await sync_to_async(os.path.exists)(vm_path)
+
+        if not vm_exists:
+            return JsonResponse({'error': f'VM with UUID {uuid} not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        screen_number = await screendump(uuid)
+
+        result = {'screenshot_taken': True, 'message': f'{screen_number}'}
+
+        return JsonResponse(result, status=status.HTTP_200_OK)
+
+
+    def get_user_or_key_error(self, request):
+        """
+        Helper method to retrieve the authenticated user from the request, or return an error response if
+        the request is not authenticated.
+
+        The request can be authenticated either through session-based authentication or by including an
+        'X-API-KEY' header in the request.
+
+        Args:
+            request: The Django request object.
+
+        Returns:
+            If the request is authenticated, returns a tuple where the first element is the authenticated user
+            and the second element is None.
+
+            If the request is not authenticated, returns a tuple where the first element is None and the second
+            element is a JsonResponse with an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        user = getattr(request, 'user', None)
+        if user and user.is_authenticated:
+            print("DEBUG: USER AUTHENTICATED")
+        elif api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = getattr(api_key, 'user')
+                if not user.is_active:
+                    return None, JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return None, JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return None, JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+        return user, None
+
+
+async def system_shutdown(uuid):
+    """
+    This function sends a shutdown command to a VM specified by its UUID. It uses QEMU's QMP (QEMU Machine Protocol)
+    to interact with the VM.
+
+    Args:
+        uuid (str): The UUID of the VM to be shutdown.
+
+    Raises:
+        Exception: If there's an error while trying to interact with the VM, an exception will be raised.
+    """
+    qmp = QMPClient('forensicVM')
+    socket_path = f"/forensicVM/mnt/vm/{uuid}/run/qmp.sock"
+    try:
+        await qmp.connect(socket_path)
+        res = await qmp.execute('query-status')
+        print(f"VM status: {res['status']}")
+    except Exception as e:
+        print(e)
+
+    res = await qmp.execute('system_powerdown')
+    print(res)
+
+    await qmp.disconnect()
+
+@method_decorator(csrf_exempt, name='dispatch')
+class ShutdownVMView(View):
+    """
+    This Django View handles POST requests to shutdown a VM. It authenticates the request and then uses the
+    `system_shutdown` function to send a shutdown command to the VM.
+
+    The VM is identified by its UUID, which should be included in the URL of the request.
+    """
+    authentication_classes = [SessionAuthentication]
+    permission_classes = []
+
+    async def post(self, request, uuid):
+        """
+        This method handles the POST request to shut down a VM. It checks for user authentication, verifies the
+        existence of the VM, and then sends the shutdown command.
+
+        Args:
+            request (django.http.HttpRequest): The request instance.
+            uuid (str): The UUID of the VM to be shutdown.
+
+        Returns:
+            django.http.JsonResponse: A JSON response with the result of the operation.
+        """
+        user, api_key_error = await sync_to_async(self.get_user_or_key_error)(request)
+        if api_key_error:
+            return api_key_error
+
+        vm_path = f"/forensicVM/mnt/vm/{uuid}"
+        vm_exists = await sync_to_async(os.path.exists)(vm_path)
+
+        if not vm_exists:
+            return JsonResponse({'error': f'VM with UUID {uuid} not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        await system_shutdown(uuid)
+
+        result = {'vm_shutdown': True, 'message': f'Shutdown command sent to VM with UUID {uuid}'}
+
+        return JsonResponse(result, status=status.HTTP_200_OK)
+
+    def get_user_or_key_error(self, request):
+        """
+        Helper method to retrieve the authenticated user from the request, or return an error response if
+        the request is not authenticated.
+
+        The request can be authenticated either through session-based authentication or by including an
+        'X-API-KEY' header in the request.
+
+        Args:
+            request: The Django request object.
+
+        Returns:
+            If the request is authenticated, returns a tuple where the first element is the authenticated user
+            and the second element is None.
+
+            If the request is not authenticated, returns a tuple where the first element is None and the second
+            element is a JsonResponse with an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        user = getattr(request, 'user', None)
+        if user and user.is_authenticated:
+            print("DEBUG: USER AUTHENTICATED")
+        elif api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = getattr(api_key, 'user')
+                if not user.is_active:
+                    return None, JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return None, JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return None, JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+        return user, None
+
+
+async def system_reset(uuid):
+    """
+    This function sends a reset command to a VM specified by its UUID. It uses QEMU's QMP (QEMU Machine Protocol)
+    to interact with the VM.
+
+    Args:
+        uuid (str): The UUID of the VM to be reset.
+
+    Raises:
+        Exception: If there's an error while trying to interact with the VM, an exception will be raised.
+    """
+    qmp = QMPClient('forensicVM')
+    socket_path = f"/forensicVM/mnt/vm/{uuid}/run/qmp.sock"
+    try:
+        await qmp.connect(socket_path)
+        res = await qmp.execute('query-status')
+        print(f"VM status: {res['status']}")
+        status = {res['status']}
+    except Exception as e:
+        print(e)
+    res = await qmp.execute('system_reset')
+    print(res)
+    if status == {'suspended'}:
+        res = await qmp.execute('quit')
+        print(res)
+    await qmp.disconnect()
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class ResetVMView(View):
+    """
+    This Django View handles POST requests to reset a VM. It authenticates the request and then uses the
+    `system_reset` function to send a reset command to the VM.
+
+    The VM is identified by its UUID, which should be included in the URL of the request.
+    """
+    authentication_classes = [SessionAuthentication]
+    permission_classes = []
+
+    async def post(self, request, uuid):
+        """
+        This method handles the POST request to reset a VM. It checks for user authentication, verifies the
+        existence of the VM, and then sends the reset command.
+
+        Args:
+            request (django.http.HttpRequest): The request instance.
+            uuid (str): The UUID of the VM to be reset.
+
+        Returns:
+            django.http.JsonResponse: A JSON response with the result of the operation.
+        """
+        user, api_key_error = await sync_to_async(self.get_user_or_key_error)(request)
+        if api_key_error:
+            return api_key_error
+
+        vm_path = f"/forensicVM/mnt/vm/{uuid}"
+        vm_exists = await sync_to_async(os.path.exists)(vm_path)
+
+        if not vm_exists:
+            return JsonResponse({'error': f'VM with UUID {uuid} not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        await system_reset(uuid)
+
+        result = {'vm_reset': True, 'message': f'Reset command sent to VM with UUID {uuid}'}
+
+        return JsonResponse(result, status=status.HTTP_200_OK)
+
+    def get_user_or_key_error(self, request):
+        """
+        Helper method to retrieve the authenticated user from the request, or return an error response if
+        the request is not authenticated.
+
+        The request can be authenticated either through session-based authentication or by including an
+        'X-API-KEY' header in the request.
+
+        Args:
+            request: The Django request object.
+
+        Returns:
+            If the request is authenticated, returns a tuple where the first element is the authenticated user
+            and the second element is None.
+
+            If the request is not authenticated, returns a tuple where the first element is None and the second
+            element is a JsonResponse with an error message.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        user = getattr(request, 'user', None)
+        if user and user.is_authenticated:
+            print("DEBUG: USER AUTHENTICATED")
+        elif api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = getattr(api_key, 'user')
+                if not user.is_active:
+                    return None, JsonResponse({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return None, JsonResponse({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return None, JsonResponse({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+        return user, None
+
+class MountFolderView(APIView):
+    """
+    This Django View handles POST requests to mount a folder in a VM. It authenticates the request and then executes
+    a mount command to bind the specified folder to a location within the VM's filesystem.
+
+    The VM is identified by its UUID, which should be included in the URL of the request.
+
+    The folder to be mounted should be specified in the request's JSON body using the 'folder' key.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    def post(self, request, uuid):
+        """
+        This method handles the POST request to mount a folder in a VM. It checks for user authentication, verifies the
+        input folder path, and then sends the mount command.
+
+        Args:
+            request (django.http.HttpRequest): The request instance.
+            uuid (str): The UUID of the VM where the folder is to be mounted.
+
+        Returns:
+            rest_framework.response.Response: A JSON response with the result of the operation.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return Response({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return Response({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return Response({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        folder_to_mount = request.data.get('folder')
+        if not folder_to_mount:
+            return Response({'error': 'No folder specified to mount'}, status=status.HTTP_400_BAD_REQUEST)
+
+        mount_path = f"/forensicVM/mnt/vm/{uuid}/mnt"
+        os.makedirs(mount_path, exist_ok=True)
+
+        cmd = f"mount --bind {folder_to_mount} {mount_path}"
+        try:
+            subprocess.run(cmd, shell=True, check=True)
+            result = {'folder_mounted': True}
+            return Response(result, status=status.HTTP_200_OK)
+        except subprocess.CalledProcessError as e:
+            return Response({'error': f"Error mounting folder: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+class DeleteVMView(APIView):
+    """
+    This Django View handles POST requests to delete a VM. It authenticates the request and then removes the specified VM's
+    directory from the filesystem.
+
+    The VM is identified by its UUID, which should be included in the URL of the request.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    def post(self, request, uuid):
+        """
+        This method handles the POST request to delete a VM. It checks for user authentication, verifies the
+        existence of the VM, and then deletes the VM's directory.
+
+        Args:
+            request (django.http.HttpRequest): The request instance.
+            uuid (str): The UUID of the VM to be deleted.
+
+        Returns:
+            rest_framework.response.Response: A JSON response with the result of the operation.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return Response({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return Response({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return Response({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        vm_path = f"/forensicVM/mnt/vm/{uuid}"
+        if not os.path.exists(vm_path):
+            return Response({'error': f'Path for UUID {uuid} not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        # Delete the VM directory
+        try:
+            shutil.rmtree(vm_path)
+            result = {'vm_deleted': True}
+        except Exception as e:
+            result = {'vm_deleted': False, 'error': str(e)}
+
+        return Response(result, status=status.HTTP_200_OK)
+
+class CheckVMExistsView(APIView):
+    """
+    This Django View handles GET requests to check if a VM exists. It authenticates the request and then checks the
+    existence of the specified VM's directory in the filesystem.
+
+    The VM is identified by its UUID, which should be included in the URL of the request.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    def get(self, request, uuid):
+        """
+        This method handles the GET request to check if a VM exists. It checks for user authentication, verifies the
+        existence of the VM, and then returns a JSON response with the result.
+
+        Args:
+            request (django.http.HttpRequest): The request instance.
+            uuid (str): The UUID of the VM to be checked.
+
+        Returns:
+            rest_framework.response.Response: A JSON response indicating whether the VM exists.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return Response({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return Response({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return Response({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        vm_path = f"/forensicVM/mnt/vm/{uuid}/mode"
+        vm_exists = os.path.exists(vm_path)
+
+        result = {'vm_exists': vm_exists}
+
+        return Response(result, status=status.HTTP_200_OK)
+
+def find_available_port(start_port):
+    """
+    This function finds two available, sequential TCP ports to use, starting from the given `start_port`.
+
+    Args:
+        start_port (int): The port number from which to start checking for availability.
+
+    Returns:
+        tuple: A pair of two available, sequential TCP port numbers.
+
+    Raises:
+        OSError: If an error occurs that is not related to a port being in use (e.g., permission denied, etc.)
+    """
+    port = start_port
+    while True:
+        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
+            sock.settimeout(1)
+            try:
+                sock.bind(('localhost', port + 1))
+                return (port, port + 1)
+            except OSError as e:
+                if e.errno == 98:  # "Address already in use"
+                    port += 2
+                else:
+                    raise e
+
+class StopVMView(APIView):
+    """
+    API endpoint that allows VMs to be stopped via POST requests.
+
+    This view accepts a POST request with a UUID and attempts to stop the corresponding screen session of the VM.
+    If successful, it returns a 200 OK response with a JSON body indicating the VM has been stopped.
+    If the screen session cannot be found, it returns a 404 Not Found error.
+    An API key is required for authentication.
+    """
+    authentication_classes = [SessionAuthentication]                # ADDED
+    permission_classes = []
+
+    def post(self, request, uuid):
+        """
+        Stops the VM specified by the UUID.
+
+        Args:
+            request: The POST request received by the server.
+            uuid: The UUID of the VM to be stopped.
+
+        Returns:
+            Response: A Django Response object.
+        """
+        # Authenticate user using API key
+        api_key = request.META.get('HTTP_X_API_KEY')
+        user = getattr(request, 'user', None)                       # IF sync
+        #user = await sync_to_async(getattr)(request, 'user', None)  # ASYNC: Get the user in the request
+        if user and user.is_authenticated:                          # User is authenticated via session
+            print("DEBUG: USER AUTHENTICATED")
+            pass                                                    # Add this extra block to the request
+        elif api_key:                                               # <--- Changed
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return Response({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return Response({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return Response({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        # Stop the screen session
+        cmd = f"screen -S {uuid} -X quit"
+
+        try:
+            subprocess.run(cmd, shell=True, check=True)
+        except CalledProcessError:
+            return Response({'error': f'No screen session found for UUID {uuid}'}, status=status.HTTP_404_NOT_FOUND)
+
+        # Check if the screen session was terminated
+        screen_status = subprocess.run(f"screen -list | grep {uuid}", shell=True, capture_output=True).stdout.decode('utf-8')
+        vm_stopped = uuid not in screen_status
+
+        result = {'vm_stopped': vm_stopped}
+        return Response(result, status=status.HTTP_200_OK)
+
+
+class StartVMView(APIView):
+    """
+    API endpoint that allows VMs to be started via POST requests.
+
+    This view accepts a POST request with a UUID and attempts to start the corresponding VM.
+    If successful, it returns a 200 OK response with a JSON body indicating the VM has been started and provides the VNC and WebSocket ports.
+    If the VM path or VNC script cannot be found, it returns a 404 Not Found error.
+    An API key or session-based authentication is required.
+    """
+    authentication_classes = [SessionAuthentication]                # ADDED
+    permission_classes = []
+
+    def post(self, request, uuid):
+        """
+        Starts the VM specified by the UUID.
+
+        Args:
+            request: The POST request received by the server.
+            uuid: The UUID of the VM to be started.
+
+        Returns:
+            Response: A Django Response object.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        user = getattr(request, 'user', None)                       # IF sync
+        #user = await sync_to_async(getattr)(request, 'user', None)  # ASYNC: Get the user in the request
+        if user and user.is_authenticated:                          # User is authenticated via session
+            print("DEBUG: USER AUTHENTICATED")
+            pass                                                    # Add this extra block to the request
+        elif api_key:                                               # <--- Changed
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return Response({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return Response({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return Response({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        vm_path = f"/forensicVM/mnt/vm/{uuid}"
+        if not os.path.exists(vm_path):
+            return Response({'error': f'Path for UUID {uuid} not found'}, status=status.HTTP_404_NOT_FOUND)
+
+        vnc_scripts = glob.glob(os.path.join(vm_path, '*-vnc.sh'))
+        if not vnc_scripts:
+            return Response({'error': f'No VNC script found for UUID {uuid}'}, status=status.HTTP_404_NOT_FOUND)
+
+        recent_vnc_script = max(vnc_scripts, key=os.path.getctime)
+
+        vnc_port, websocket_port = find_available_port(5900)
+
+        cmd = f"screen -d -m -S {uuid} bash {recent_vnc_script} {vnc_port} {websocket_port}"
+        subprocess.run(cmd, shell=True, check=True, cwd=vm_path)
+
+        time.sleep(3)
+
+        run_path = os.path.join(vm_path, "run")
+        pid_file = os.path.join(run_path, "run.pid")
+        vm_running = os.path.exists(pid_file) and subprocess.run(f"ps -ef | grep {uuid}", shell=True, check=True).returncode == 0
+
+        result = {
+            'vm_running': vm_running,
+            'vnc_port': vnc_port,
+            'websocket_port': websocket_port
+        }
+
+        return Response(result, status=status.HTTP_200_OK)
+
+class ForensicImageVMStatus(APIView):
+    """
+    API endpoint that allows retrieval of the status of a forensic image VM via GET requests.
+
+    This view accepts a GET request with a UUID and returns the status of the corresponding forensic image VM.
+    If the VM path or mode file cannot be found, it returns a 404 Not Found error.
+    An API key or session-based authentication is required.
+    """
+    authentication_classes = [SessionAuthentication]                # ADDED
+    #authentication_classes = []
+    permission_classes = []
+
+    def get(self, request, uuid):
+        """
+        Retrieves the status of the forensic image VM specified by the UUID.
+
+        Args:
+            request: The GET request received by the server.
+            uuid: The UUID of the forensic image VM.
+
+        Returns:
+            Response: A Django Response object containing the VM status and related information.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        user = getattr(request, 'user', None)                       # IF sync
+        #user = await sync_to_async(getattr)(request, 'user', None)  # ASYNC: Get the user in the request
+        if user and user.is_authenticated:                          # User is authenticated via session
+            print("DEBUG: USER AUTHENTICATED")
+            pass                                                    # Add this extra block to the request
+        elif api_key:                                               # <--- Changed
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return Response({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return Response({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return Response({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        vm_path = f"/forensicVM/mnt/vm/{uuid}"
+        run_path = os.path.join(vm_path, "run")
+        pid_file = os.path.join(run_path, "run.pid")
+        mode_file = os.path.join(vm_path, "mode")
+
+        #if not os.path.exists(mode_file):
+        if not os.path.exists(vm_path):
+            print("Does no exist")
+            return Response({'PATH': 'not_exist'}, status=status.HTTP_404_NOT_FOUND)
+        else:
+            result = {'PATH': 'exists'}
+
+            mode = None
+            if os.path.exists(mode_file):
+                with open(mode_file, 'r') as f:
+                    mode = f.read().strip()
+            result['running_mode'] = mode
+
+            if os.path.exists(pid_file):
+                with open(pid_file, 'r') as f:
+                    pid = f.read().strip()
+
+                cmd = f"ps -ef | grep {pid} | grep {uuid}"
+                process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
+                output, _ = process.communicate()
+
+                if output:
+                    result['vm_status'] = 'running'
+
+
+                    qemu_cmd = output.decode("utf-8").strip()
+                    vnc_port = re.search(r'-display vnc=0.0.0.0:(\d+)', qemu_cmd)
+                    websocket_port = re.search(r',websocket=(\d+)', qemu_cmd)
+                    qmp_file = re.search(r'-qmp unix:([^,]+)', qemu_cmd)
+
+                    if vnc_port:
+                        result['vnc_port'] = int(vnc_port.group(1))
+                    else:
+                        result['vm_status'] = 'stopped'
+                    if websocket_port:
+                        result['websocket_port'] = int(websocket_port.group(1))
+                    else:
+                        result['vm_status'] = 'stopped'
+                    if qmp_file:
+                        result['qmp_file'] = qmp_file.group(1)
+                    else:
+                        result['vm_status'] = 'stopped'
+                else:
+                    result['vm_status'] = 'stopped'
+            else:
+                result['vm_status'] = 'stopped'
+
+            return Response(result, status=status.HTTP_200_OK)
+
+class CreateSshKeysView(APIView):
+    """
+    API endpoint that allows the creation of SSH keys by adding a public key to the authorized keys file of the forensic investigator user.
+
+    This view accepts a POST request with a public key as a parameter. The public key is added to the authorized keys file of the forensic investigator user.
+    An API key or session-based authentication is required.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    def post(self, request):
+        """
+        Adds a public key to the authorized keys file of the forensic investigator user.
+
+        Args:
+            request: The POST request received by the server.
+
+        Returns:
+            Response: A Django Response object containing the result of adding the public key to the authorized keys file.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return Response({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return Response({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return Response({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        # Read public key from request data
+        public_key = request.data.get('public_key')
+        if not public_key:
+            return Response({'error': 'Missing public key parameter'}, status=status.HTTP_400_BAD_REQUEST)
+
+        # Check if public key already exists in authorized keys
+        authorized_keys_file = f'/home/forensicinvestigator/.ssh/authorized_keys'
+        with open(authorized_keys_file, 'r') as f:
+            authorized_keys = f.read()
+
+        if public_key in authorized_keys:
+            return Response({'message': 'Public key already added to authorized keys'}, status=status.HTTP_200_OK)
+
+        # Add public key to authorized keys of the forensicinvestigator user
+        try:
+            with open(authorized_keys_file, 'a') as f:
+                f.write(public_key + '\n')
+        except FileNotFoundError:
+            return Response({'error': 'Failed to append public key to authorized keys file'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
+
+        return Response({'message': 'Public key added to authorized keys'}, status=status.HTTP_200_OK)
+
+
+class ProtectedView(APIView):
+    """
+    API endpoint that creates a protected view requiring an API key for access.
+
+    This view accepts a GET request and checks for the presence of an API key in the request headers.
+    If a valid API key is found, the access is granted and a success message is returned.
+    An API key is required for accessing this view.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    def get(self, request):
+        """
+        Handles the GET request and checks for the presence of a valid API key.
+
+        Args:
+            request: The GET request received by the server.
+
+        Returns:
+            Response: A Django Response object indicating the result of the access check.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+                user = api_key.user
+                if not user.is_active:
+                    return Response({'error': 'User account is disabled.'}, status=status.HTTP_401_UNAUTHORIZED)
+            except ApiKey.DoesNotExist:
+                return Response({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+            return Response({'message': 'Access granted'}, status=status.HTTP_200_OK)
+        else:
+            return Response({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+
+
+class RunScriptView(APIView):
+    """
+    API endpoint for running a script.
+
+    This view accepts a POST request and expects an API key to be provided in the request headers.
+    The request should contain a 'script' parameter in the data payload, which contains the script to be executed.
+    The script is executed using the subprocess module, and the output and error code are returned in the response.
+
+    Note: This view does not perform any authentication or permission checks beyond validating the API key.
+    """
+    authentication_classes = []
+    permission_classes = []
+
+    def post(self, request):
+        """
+        Handles the POST request to execute a script.
+
+        Args:
+            request: The POST request received by the server.
+
+        Returns:
+            Response: A Django Response object containing the script output and error code.
+        """
+        api_key = request.META.get('HTTP_X_API_KEY')
+        if api_key:
+            try:
+                api_key = ApiKey.objects.get(key=api_key)
+            except ApiKey.DoesNotExist:
+                return Response({'error': 'Invalid API key'}, status=status.HTTP_401_UNAUTHORIZED)
+        else:
+            return Response({'error': 'API key required'}, status=status.HTTP_401_UNAUTHORIZED)
+
+        if 'script' not in request.data:
+            return Response({'error': 'Missing script parameter'}, status=status.HTTP_400_BAD_REQUEST)
+
+        script = request.data['script']
+
+        try:
+            result = subprocess.run(script, shell=True, capture_output=True)
+            return Response({'output': result.stdout.decode('utf-8'), 'error_code': result.returncode}, status=status.HTTP_200_OK)
+        except subprocess.CalledProcessError as e:
+            return Response({'error': e.output.decode('utf-8'), 'error_code': e.returncode}, status=status.HTTP_400_BAD_REQUEST)
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/app/admin.py
@@ -0,0 +1,7 @@
+# coding=utf-8
+from django.contrib import admin
+from .models import Server
+
+@admin.register(Server)
+class ArticleAdmin(admin.ModelAdmin):
+    pass
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/app/apps.py
@@ -0,0 +1,5 @@
+from django.apps import AppConfig
+
+
+class AppConfig(AppConfig):
+    name = 'app'
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/app/migrations/0001_initial.py
@@ -0,0 +1,25 @@
+# -*- coding: utf-8 -*-
+# Generated by Django 1.9 on 2016-03-29 03:29
+from __future__ import unicode_literals
+
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    initial = True
+
+    dependencies = [
+    ]
+
+    operations = [
+        migrations.CreateModel(
+            name='Server',
+            fields=[
+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
+                ('name', models.CharField(max_length=30)),
+                ('token', models.CharField(max_length=30)),
+                ('vnc_password', models.CharField(max_length=30)),
+            ],
+        ),
+    ]
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/app/migrations/0002_forensicvm.py
@@ -0,0 +1,24 @@
+# Generated by Django 4.1.2 on 2023-02-19 18:23
+
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('app', '0001_initial'),
+    ]
+
+    operations = [
+        migrations.CreateModel(
+            name='forensicVM',
+            fields=[
+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
+                ('name', models.CharField(max_length=30)),
+                ('forensicImage', models.CharField(max_length=30)),
+                ('osDetected', models.BooleanField()),
+                ('vncHost', models.CharField(max_length=30)),
+                ('vncPort', models.IntegerField()),
+            ],
+        ),
+    ]
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/app/models.py
@@ -0,0 +1,25 @@
+# coding=utf-8
+
+
+from django.db import models
+
+
+class Server(models.Model):
+    name = models.CharField(max_length=30)
+    token = models.CharField(max_length=30)
+    vnc_password = models.CharField(max_length=30)
+
+
+class forensicVM(models.Model):
+    name = models.CharField(max_length=30)
+    forensicImage = models.CharField(max_length=30)
+    osDetected = models.BooleanField()
+    vncHost = models.CharField(max_length=30)
+    vncPort = models.IntegerField()
+
+    def __str__(self):
+        return self.name
+
+
+
+    
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/app/tests.py
@@ -0,0 +1,3 @@
+from django.test import TestCase
+
+# Create your tests here.
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/app/views.py
@@ -0,0 +1,166 @@
+# coding=utf-8
+from django.conf import settings
+from django.http import HttpResponse, JsonResponse
+from django.template import loader, Context
+from django.core.exceptions import ValidationError
+from revproxy.views import ProxyView
+from .models import Server
+from django.contrib.auth.forms import UserCreationForm
+from django.contrib.auth import login
+from django.shortcuts import render, redirect
+from django.utils.decorators import method_decorator
+from django.contrib.auth.decorators import login_required, permission_required
+from django.contrib.auth.mixins import LoginRequiredMixin
+import os
+import xml.etree.ElementTree as ET
+from django.views import View
+
+
+def register(request):
+    if request.method == 'POST':
+        form = UserCreationForm(request.POST)
+        if form.is_valid():
+            user = form.save()
+            login(request, user)
+            return redirect('/') # or where you want to redirect after successful registration
+    else:
+        form = UserCreationForm()
+    return render(request, 'register.html', {'form': form})
+
+
+
+def vnc_proxy(request):
+    """VNC agente de controlo remoto"""
+
+    token = request.GET.get('token')
+    try:
+        obj = Server.objects.get(pk=token)
+
+    except Server.DoesNotExist:
+        raise ValidationError('identificador errado', code=404)
+
+    except Exception as e:
+        raise ValidationError(str(e), code=500)
+
+    host = settings.VNC_PROXY_HOST
+    port = settings.VNC_PROXY_PORT
+    # password = obj.vnc_password
+
+    return JsonResponse({
+        'token': token,
+        'host': host,
+        'port': port,
+        # 'password': password,
+        'password': 'os9527'
+    })
+
+@login_required
+def vnc_proxy_http(request):
+    """VNC agente de controlo remoto"""
+
+    #token = request.GET.get('token')
+
+
+    #host = settings.VNC_PROXY_HOST
+    #port = settings.VNC_PROXY_PORT
+
+    #template = loader.get_template('novnc/vnc.html')
+    #context = {
+    #    "token": "",
+    #    "host": "localhost",
+    #    "port": 5901,        
+    #    "password": ''
+    #}
+
+
+    iso_dir = '/forensicVM/mnt/iso'
+
+    iso_files = []
+    for file in os.listdir(iso_dir):
+        if file.endswith('.iso'):
+            iso_files.append(file)
+
+    iso_files.sort()
+    return render(request, 'novnc/vnc.html', {'iso_files': iso_files})
+
+    #return HttpResponse(template.render(context))
+
+
+
+class ProxyNetdata(LoginRequiredMixin, ProxyView):
+    login_url = '/login/'  # Replace with your login URL
+    redirect_field_name = 'next'
+    upstream = 'http://localhost:19999'
+
+class ProxyShellbox(LoginRequiredMixin, ProxyView):
+    login_url = '/login/'  # Replace with your login URL
+    redirect_field_name = 'next'
+    upstream = 'http://localhost:4200'
+
+#@login_required
+#class ProxyNetdata(ProxyView):
+#    upstream = 'http://localhost:19999'
+
+#@login_required
+#class ProxyShellbox(ProxyView):
+#    upstream = 'http://localhost:4200'
+
+#class ProxyMeo(ProxyView):
+#    upstream = 'https://192.168.1.254'
+
+class VMListView(View):
+    @method_decorator(login_required)
+    def get(self, request):
+        vm_path = "/forensicVM/mnt/vm/"
+        vm_exists = os.path.exists(vm_path)
+
+        if not vm_exists:
+            return JsonResponse({'error': 'VM path not found'}, status=404)
+
+        folders = [f for f in os.listdir(vm_path) if os.path.isdir(os.path.join(vm_path, f))]
+        data = []
+
+        for folder in folders:
+            try:
+                info_name = folder + ".info"
+                print(info_name)
+                info_file = os.path.join(vm_path, folder, info_name)
+                if os.path.exists(info_file):
+                   data.append(self.process_info_file(info_file, folder))
+                else:
+                   data_item = {
+                       'uuid': folder,
+                       'distro': '---',
+                       'hostname': '---',
+                       'osinfo': '---',
+                       'product_name': '---'
+                   }
+                   data.append(data_item)
+            except Exception as e:
+                print(str(e))
+                try:
+                    data_item = {
+                        'uuid': folder,
+                        'distro': '---',
+                        'hostname': '---',
+                        'osinfo': '---',
+                        'product_name': '---'
+                    }
+                    data.append(data_item)
+                except Exception as e:
+                    print(str(e))
+
+        return render(request, 'vm_list.html', {'data': data})
+
+    def process_info_file(self, info_file, uuid):
+        tree = ET.parse(info_file)
+        root = tree.getroot()
+        os_data = root.find('operatingsystem')
+
+        return {
+            'uuid': uuid,
+            'distro': os_data.find('distro').text,
+            'hostname': os_data.find('hostname').text,
+            'osinfo': os_data.find('osinfo').text,
+            'product_name': os_data.find('product_name').text
+        }
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/conf/settings.py
@@ -0,0 +1,159 @@
+# coding=utf-8
+"""
+Django settings for noVNC-Proxy-Django project.
+
+Generated by 'django-admin startproject' using Django 1.9.
+
+"""
+
+import os
+
+# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
+BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+
+
+# Quick-start development settings - unsuitable for production
+
+# SECURITY WARNING: keep the secret key used in production secret!
+SECRET_KEY = '$8n81tj^32!$=tozs2lbg0mre=q(wxmy=tx-!4rxa@m)%dansu'
+
+# SECURITY WARNING: don't run with debug turned on in production!
+DEBUG = True
+
+ALLOWED_HOSTS = ['0.0.0.0', '127.0.0.1', '192.168.1.112', '85.240.2.211', 'forensicvm.mesi.ninja']
+
+
+# Application definition
+
+INSTALLED_APPS = [
+    'django.contrib.admin',
+    'django.contrib.auth',
+    'django.contrib.contenttypes',
+    'django.contrib.sessions',
+    'django.contrib.messages',
+    'django.contrib.staticfiles',
+    'django_extensions',
+    'revproxy',
+#    'django_otp',
+#    'django_otp.plugins.otp_totp',
+    # Application
+    'app',
+    'rest_framework',
+    'apikeys',
+]
+
+MIDDLEWARE = [
+    'django.middleware.security.SecurityMiddleware',
+    'django.contrib.sessions.middleware.SessionMiddleware',
+    'django_session_timeout.middleware.SessionTimeoutMiddleware',
+    'django.middleware.common.CommonMiddleware',
+    'django.middleware.csrf.CsrfViewMiddleware',
+    'django.contrib.auth.middleware.AuthenticationMiddleware',
+    'django.contrib.messages.middleware.MessageMiddleware',
+    'django.middleware.clickjacking.XFrameOptionsMiddleware',
+#    'django_otp.middleware.OTPMiddleware',
+]
+
+ROOT_URLCONF = 'conf.urls'
+
+TEMPLATES = [
+    {
+        'BACKEND': 'django.template.backends.django.DjangoTemplates',
+        'DIRS': ['',
+            os.path.join(BASE_DIR, 'templates'),
+            'django.template.loaders.filesystem.Loader',
+        ],
+        'APP_DIRS': True,
+        'OPTIONS': {
+            'context_processors': [
+                'django.template.context_processors.debug',
+                'django.template.context_processors.request',
+                'django.contrib.auth.context_processors.auth',
+                'django.contrib.messages.context_processors.messages',
+            ],
+        },
+    },
+]
+
+WSGI_APPLICATION = 'conf.wsgi.application'
+
+
+# Database
+
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
+    }
+}
+
+
+# Password validation
+
+AUTH_PASSWORD_VALIDATORS = [
+    {
+        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
+    },
+    {
+        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
+    },
+    {
+        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
+    },
+    {
+        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
+    },
+]
+
+
+# Internationalization
+
+#LANGUAGE_CODE = 'pt-PT'
+LANGUAGE_CODE = 'en-US'
+
+#TIME_ZONE = 'Greenwitch'
+TIME_ZONE = 'Europe/Lisbon'
+
+
+# Set the variable TIME_ZONE to Greenwitch time zone
+
+
+USE_I18N = True
+
+USE_L10N = True
+
+USE_TZ = True
+
+
+# Static files (CSS, JavaScript, Images)
+
+#STATIC_URL = '/static/'
+#STATICFILES_DIRS = [BASE_DIR / 'novnc-proxy-django-master/static']
+
+
+STATIC_URL = 'static/'
+STATICFILES_DIRS = [(os.path.join(BASE_DIR, 'static'))]
+#STATIC_ROOT = os.path.join(BASE_DIR, 'static')
+
+#if DEBUG:
+#    STATICFILES_DIRS = ('', os.path.join(BASE_DIR, 'static'))
+#else:
+#    STATIC_ROOT = os.path.join(BASE_DIR, 'static')
+
+
+LOGIN_URL = '/login/'
+LOGOUT_URL = '/logout/'
+LOGIN_REDIRECT_URL = '/'
+
+
+VNC_PROXY_HOST = '127.0.0.1'
+VNC_PROXY_PORT = '5900'
+
+# Session timeout control
+SESSION_COOKIE_AGE = 300
+#SESSION_EXPIRE_AT_BROWSER_CLOSE=True # Invalid session
+SESSION_EXPIRE_SECONDS = 300 # 5 minutes
+SESSION_EXPIRE_AFTER_LAST_ACTIVITY = True
+SESSION_TIMEOUT_REDIRECT = '/'
+
+CSRF_TRUSTED_ORIGINS = ['http://forensicvm.mesi.ninja','http://0.0.0.0', 'http://127.0.0.1', 'http://192.168.1.112', 'http://85.240.2.211', 'https://forensicvm.mesi.ninja']
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/conf/urls.py
@@ -0,0 +1,48 @@
+"""conf URL Configuration
+
+"""
+from django.conf import settings
+from django.urls import  path, re_path, include
+from django.contrib import admin
+from django.views import static
+import app.views
+from app.views import ProxyNetdata, ProxyShellbox
+from django.contrib.auth import views as auth_views
+#from django_otp.admin import OTPAdminSite
+#from django_otp.plugins.otp_totp.models import TOTPDevice
+#from django_otp.plugins.otp_totp.admin import TOTPDeviceAdmin
+from django.contrib.auth.models import User
+from django.contrib.auth.views import LoginView
+#from django_otp.forms import OTPAuthenticationForm
+
+
+#class OTPAdmin(OTPAdminSite):
+#   pass
+
+#admin_site = OTPAdmin(name='ForensicVmOTPadmin')
+#admin_site.register(User)
+#admin_site.register(TOTPDevice, TOTPDeviceAdmin)
+
+urlpatterns = [
+    #re_path(r'^admin/', admin_site.urls),
+    re_path(r'^admin/', admin.site.urls),
+    path('forensicVM', app.views.vnc_proxy_http),
+    re_path(r'^static/(?P<path>.*)$', static.serve, {
+        'document_root': (settings.DEBUG and 
+                          settings.STATICFILES_DIRS or 
+                          settings.STATIC_ROOT)
+    }),
+    # Generic path
+    #path('login/', app.views.LoginView.as_view(), name='login'),
+    #path('logout/', app.views.LogoutView.as_view(), name='logout'),
+    path('login/', auth_views.LoginView.as_view(), name='login'),
+    #path('login/', LoginView.as_view(authentication_form=OTPAuthenticationForm), name='login'),
+    path('logout/', auth_views.LogoutView.as_view(), name='logout'),
+    #path('register/', app.views.register, name='register'),
+    re_path(r'^netdata/(?P<path>.*)$', ProxyNetdata.as_view()),
+    re_path(r'^shell/(?P<path>.*)$', ProxyShellbox.as_view()),
+    path('api/', include('apikeys.urls')),
+    path('screen', app.views.vnc_proxy_http),
+    path('', app.views.VMListView.as_view(), name='vm_list'),
+    path('vm-list', app.views.VMListView.as_view(), name='vm_list'),
+]
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/conf/wsgi.py
@@ -0,0 +1,14 @@
+"""
+WSGI config for conf project.
+
+It exposes the WSGI callable as a module-level variable named ``application``.
+
+"""
+
+import os
+
+from django.core.wsgi import get_wsgi_application
+
+os.environ.setdefault("DJANGO_SETTINGS_MODULE", "conf.settings")
+
+application = get_wsgi_application()
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/manage.py
@@ -0,0 +1,10 @@
+#!/usr/bin/env python
+import os
+import sys
+
+if __name__ == "__main__":
+    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "conf.settings")
+
+    from django.core.management import execute_from_command_line
+
+    execute_from_command_line(sys.argv)
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/requirements.txt
@@ -0,0 +1,94 @@
+altgraph==0.17.3
+asgiref==3.6.0
+attrs==22.2.0
+auto-py-to-exe==2.30.0
+Automat==22.10.0
+bottle==0.12.23
+bottle-websocket==0.2.9
+certifi==2022.12.7
+cffi==1.15.1
+chardet==4.0.0
+charset-normalizer==3.0.1
+click==8.1.3
+colorama==0.4.6
+constantly==15.1.0
+cryptography==39.0.1
+Django==4.1.9
+django-extensions==3.2.1
+django-revproxy @ https://github.com/jazzband/django-revproxy/archive/refs/tags/0.11.0.zip#sha256=182206aa1d1719aa5abf7379efb45ccb93c0d7088b8a25d8a69c67459c1d547e
+django-session-timeout==0.1.0
+django-upgrade==1.13.0
+djangorestframework==3.14.0
+docopt==0.6.2
+Eel==0.14.0
+future==0.18.3
+gevent==22.10.2
+gevent-websocket==0.10.1
+gpg===1.14.0-unknown
+greenlet==2.0.2
+guibot==0.50.1
+gunicorn==20.1.0
+httplib2==0.18.1
+hyperlink==21.0.0
+idna==3.4
+imagemounter==3.1.0
+incremental==22.10.0
+iotop==0.6
+IProgress==0.4
+MarkupSafe==2.1.2
+MouseInfo==0.1.3
+numpy==1.24.2
+pefile==2023.2.7
+Pillow==9.5.0
+pipreqs==0.4.11
+psutil==5.9.5
+PyAutoGUI==0.9.53
+pycparser==2.21
+pycurl==7.43.0.6
+pygame==2.1.3
+PyGetWindow==0.0.9
+pyinstaller==5.8.0
+pyinstaller-hooks-contrib==2023.0
+PyMsgBox==1.0.9
+pyOpenSSL==23.0.0
+pyparsing==3.0.9
+pyperclip==1.8.2
+PyRect==0.2.0
+PyScreeze==0.1.28
+PySide2==5.15.2.1
+PySimpleGUI==4.60.4
+PySimpleGUIDesigner==0.1.4.7
+PySimpleSOAP==1.16.2
+python-apt==2.2.1
+python-debian==0.1.39
+python-debianbts==3.1.0
+python3-xlib==0.15
+pytweening==1.0.4
+pytz==2023.3
+PyWebDAV3==0.10.0
+pywin32-ctypes==0.2.0
+PyYAML==5.3.1
+qemu==0.0.0a1
+qemu.qmp==0.0.2
+qmp==0.0.1
+reportbug==7.10.3+deb11u1
+requests==2.31.0
+shiboken2==5.15.2.1
+six==1.16.0
+sqlparse==0.4.4
+tabulate==0.9.0
+termcolor==2.2.0
+tokenize-rt==5.0.0
+tqdm==4.64.1
+Twisted==22.10.0
+typing_extensions==4.5.0
+tzdata==2022.7
+urllib3==1.26.14
+vnc2flv-rec==0.2.0
+vncdotool==1.0.0
+websockify==0.10.0
+Werkzeug==2.2.3
+whichcraft==0.6.1
+yarg==0.1.9
+zope.event==4.6
+zope.interface==5.5.2
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static-production/novnc/vendor/pako/lib/utils/common.js
@@ -0,0 +1,45 @@
+// reduce buffer size, avoiding mem copy
+export function shrinkBuf (buf, size) {
+  if (buf.length === size) { return buf; }
+  if (buf.subarray) { return buf.subarray(0, size); }
+  buf.length = size;
+  return buf;
+};
+
+
+export function arraySet (dest, src, src_offs, len, dest_offs) {
+  if (src.subarray && dest.subarray) {
+    dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
+    return;
+  }
+  // Fallback to ordinary array
+  for (var i = 0; i < len; i++) {
+    dest[dest_offs + i] = src[src_offs + i];
+  }
+}
+
+// Join array of chunks to single array.
+export function flattenChunks (chunks) {
+  var i, l, len, pos, chunk, result;
+
+  // calculate data length
+  len = 0;
+  for (i = 0, l = chunks.length; i < l; i++) {
+    len += chunks[i].length;
+  }
+
+  // join chunks
+  result = new Uint8Array(len);
+  pos = 0;
+  for (i = 0, l = chunks.length; i < l; i++) {
+    chunk = chunks[i];
+    result.set(chunk, pos);
+    pos += chunk.length;
+  }
+
+  return result;
+}
+
+export var Buf8  = Uint8Array;
+export var Buf16 = Uint16Array;
+export var Buf32 = Int32Array;
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static-production/novnc/vendor/pako/lib/zlib/adler32.js
@@ -0,0 +1,27 @@
+// Note: adler32 takes 12% for level 0 and 2% for level 6.
+// It doesn't worth to make additional optimizationa as in original.
+// Small size is preferable.
+
+export default function adler32(adler, buf, len, pos) {
+  var s1 = (adler & 0xffff) |0,
+      s2 = ((adler >>> 16) & 0xffff) |0,
+      n = 0;
+
+  while (len !== 0) {
+    // Set limit ~ twice less than 5552, to keep
+    // s2 in 31-bits, because we force signed ints.
+    // in other case %= will fail.
+    n = len > 2000 ? 2000 : len;
+    len -= n;
+
+    do {
+      s1 = (s1 + buf[pos++]) |0;
+      s2 = (s2 + s1) |0;
+    } while (--n);
+
+    s1 %= 65521;
+    s2 %= 65521;
+  }
+
+  return (s1 | (s2 << 16)) |0;
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static-production/novnc/vendor/pako/lib/zlib/constants.js
@@ -0,0 +1,47 @@
+export default {
+
+  /* Allowed flush values; see deflate() and inflate() below for details */
+  Z_NO_FLUSH:         0,
+  Z_PARTIAL_FLUSH:    1,
+  Z_SYNC_FLUSH:       2,
+  Z_FULL_FLUSH:       3,
+  Z_FINISH:           4,
+  Z_BLOCK:            5,
+  Z_TREES:            6,
+
+  /* Return codes for the compression/decompression functions. Negative values
+  * are errors, positive values are used for special but normal events.
+  */
+  Z_OK:               0,
+  Z_STREAM_END:       1,
+  Z_NEED_DICT:        2,
+  Z_ERRNO:           -1,
+  Z_STREAM_ERROR:    -2,
+  Z_DATA_ERROR:      -3,
+  //Z_MEM_ERROR:     -4,
+  Z_BUF_ERROR:       -5,
+  //Z_VERSION_ERROR: -6,
+
+  /* compression levels */
+  Z_NO_COMPRESSION:         0,
+  Z_BEST_SPEED:             1,
+  Z_BEST_COMPRESSION:       9,
+  Z_DEFAULT_COMPRESSION:   -1,
+
+
+  Z_FILTERED:               1,
+  Z_HUFFMAN_ONLY:           2,
+  Z_RLE:                    3,
+  Z_FIXED:                  4,
+  Z_DEFAULT_STRATEGY:       0,
+
+  /* Possible values of the data_type field (though see inflate()) */
+  Z_BINARY:                 0,
+  Z_TEXT:                   1,
+  //Z_ASCII:                1, // = Z_TEXT (deprecated)
+  Z_UNKNOWN:                2,
+
+  /* The deflate compression method */
+  Z_DEFLATED:               8
+  //Z_NULL:                 null // Use -1 or null inline, depending on var type
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static-production/novnc/vendor/pako/lib/zlib/crc32.js
@@ -0,0 +1,36 @@
+// Note: we can't get significant speed boost here.
+// So write code to minimize size - no pregenerated tables
+// and array tools dependencies.
+
+
+// Use ordinary array, since untyped makes no boost here
+export default function makeTable() {
+  var c, table = [];
+
+  for (var n = 0; n < 256; n++) {
+    c = n;
+    for (var k = 0; k < 8; k++) {
+      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
+    }
+    table[n] = c;
+  }
+
+  return table;
+}
+
+// Create table on load. Just 255 signed longs. Not a problem.
+var crcTable = makeTable();
+
+
+function crc32(crc, buf, len, pos) {
+  var t = crcTable,
+      end = pos + len;
+
+  crc ^= -1;
+
+  for (var i = pos; i < end; i++) {
+    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
+  }
+
+  return (crc ^ (-1)); // >>> 0;
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static-production/novnc/vendor/pako/lib/zlib/deflate.js
@@ -0,0 +1,1846 @@
+import * as utils from "../utils/common.js";
+import * as trees from "./trees.js";
+import adler32 from "./adler32.js";
+import crc32 from "./crc32.js";
+import msg from "./messages.js";
+
+/* Public constants ==========================================================*/
+/* ===========================================================================*/
+
+
+/* Allowed flush values; see deflate() and inflate() below for details */
+export const Z_NO_FLUSH      = 0;
+export const Z_PARTIAL_FLUSH = 1;
+//export const Z_SYNC_FLUSH    = 2;
+export const Z_FULL_FLUSH    = 3;
+export const Z_FINISH        = 4;
+export const Z_BLOCK         = 5;
+//export const Z_TREES         = 6;
+
+
+/* Return codes for the compression/decompression functions. Negative values
+ * are errors, positive values are used for special but normal events.
+ */
+export const Z_OK            = 0;
+export const Z_STREAM_END    = 1;
+//export const Z_NEED_DICT     = 2;
+//export const Z_ERRNO         = -1;
+export const Z_STREAM_ERROR  = -2;
+export const Z_DATA_ERROR    = -3;
+//export const Z_MEM_ERROR     = -4;
+export const Z_BUF_ERROR     = -5;
+//export const Z_VERSION_ERROR = -6;
+
+
+/* compression levels */
+//export const Z_NO_COMPRESSION      = 0;
+//export const Z_BEST_SPEED          = 1;
+//export const Z_BEST_COMPRESSION    = 9;
+export const Z_DEFAULT_COMPRESSION = -1;
+
+
+export const Z_FILTERED            = 1;
+export const Z_HUFFMAN_ONLY        = 2;
+export const Z_RLE                 = 3;
+export const Z_FIXED               = 4;
+export const Z_DEFAULT_STRATEGY    = 0;
+
+/* Possible values of the data_type field (though see inflate()) */
+//export const Z_BINARY              = 0;
+//export const Z_TEXT                = 1;
+//export const Z_ASCII               = 1; // = Z_TEXT
+export const Z_UNKNOWN             = 2;
+
+
+/* The deflate compression method */
+export const Z_DEFLATED  = 8;
+
+/*============================================================================*/
+
+
+var MAX_MEM_LEVEL = 9;
+/* Maximum value for memLevel in deflateInit2 */
+var MAX_WBITS = 15;
+/* 32K LZ77 window */
+var DEF_MEM_LEVEL = 8;
+
+
+var LENGTH_CODES  = 29;
+/* number of length codes, not counting the special END_BLOCK code */
+var LITERALS      = 256;
+/* number of literal bytes 0..255 */
+var L_CODES       = LITERALS + 1 + LENGTH_CODES;
+/* number of Literal or Length codes, including the END_BLOCK code */
+var D_CODES       = 30;
+/* number of distance codes */
+var BL_CODES      = 19;
+/* number of codes used to transfer the bit lengths */
+var HEAP_SIZE     = 2 * L_CODES + 1;
+/* maximum heap size */
+var MAX_BITS  = 15;
+/* All codes must not exceed MAX_BITS bits */
+
+var MIN_MATCH = 3;
+var MAX_MATCH = 258;
+var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);
+
+var PRESET_DICT = 0x20;
+
+var INIT_STATE = 42;
+var EXTRA_STATE = 69;
+var NAME_STATE = 73;
+var COMMENT_STATE = 91;
+var HCRC_STATE = 103;
+var BUSY_STATE = 113;
+var FINISH_STATE = 666;
+
+var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
+var BS_BLOCK_DONE     = 2; /* block flush performed */
+var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
+var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */
+
+var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.
+
+function err(strm, errorCode) {
+  strm.msg = msg[errorCode];
+  return errorCode;
+}
+
+function rank(f) {
+  return ((f) << 1) - ((f) > 4 ? 9 : 0);
+}
+
+function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }
+
+
+/* =========================================================================
+ * Flush as much pending output as possible. All deflate() output goes
+ * through this function so some applications may wish to modify it
+ * to avoid allocating a large strm->output buffer and copying into it.
+ * (See also read_buf()).
+ */
+function flush_pending(strm) {
+  var s = strm.state;
+
+  //_tr_flush_bits(s);
+  var len = s.pending;
+  if (len > strm.avail_out) {
+    len = strm.avail_out;
+  }
+  if (len === 0) { return; }
+
+  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
+  strm.next_out += len;
+  s.pending_out += len;
+  strm.total_out += len;
+  strm.avail_out -= len;
+  s.pending -= len;
+  if (s.pending === 0) {
+    s.pending_out = 0;
+  }
+}
+
+
+function flush_block_only(s, last) {
+  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
+  s.block_start = s.strstart;
+  flush_pending(s.strm);
+}
+
+
+function put_byte(s, b) {
+  s.pending_buf[s.pending++] = b;
+}
+
+
+/* =========================================================================
+ * Put a short in the pending buffer. The 16-bit value is put in MSB order.
+ * IN assertion: the stream state is correct and there is enough room in
+ * pending_buf.
+ */
+function putShortMSB(s, b) {
+//  put_byte(s, (Byte)(b >> 8));
+//  put_byte(s, (Byte)(b & 0xff));
+  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
+  s.pending_buf[s.pending++] = b & 0xff;
+}
+
+
+/* ===========================================================================
+ * Read a new buffer from the current input stream, update the adler32
+ * and total number of bytes read.  All deflate() input goes through
+ * this function so some applications may wish to modify it to avoid
+ * allocating a large strm->input buffer and copying from it.
+ * (See also flush_pending()).
+ */
+function read_buf(strm, buf, start, size) {
+  var len = strm.avail_in;
+
+  if (len > size) { len = size; }
+  if (len === 0) { return 0; }
+
+  strm.avail_in -= len;
+
+  // zmemcpy(buf, strm->next_in, len);
+  utils.arraySet(buf, strm.input, strm.next_in, len, start);
+  if (strm.state.wrap === 1) {
+    strm.adler = adler32(strm.adler, buf, len, start);
+  }
+
+  else if (strm.state.wrap === 2) {
+    strm.adler = crc32(strm.adler, buf, len, start);
+  }
+
+  strm.next_in += len;
+  strm.total_in += len;
+
+  return len;
+}
+
+
+/* ===========================================================================
+ * Set match_start to the longest match starting at the given string and
+ * return its length. Matches shorter or equal to prev_length are discarded,
+ * in which case the result is equal to prev_length and match_start is
+ * garbage.
+ * IN assertions: cur_match is the head of the hash chain for the current
+ *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
+ * OUT assertion: the match length is not greater than s->lookahead.
+ */
+function longest_match(s, cur_match) {
+  var chain_length = s.max_chain_length;      /* max hash chain length */
+  var scan = s.strstart; /* current string */
+  var match;                       /* matched string */
+  var len;                           /* length of current match */
+  var best_len = s.prev_length;              /* best match length so far */
+  var nice_match = s.nice_match;             /* stop if match long enough */
+  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
+      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;
+
+  var _win = s.window; // shortcut
+
+  var wmask = s.w_mask;
+  var prev  = s.prev;
+
+  /* Stop when cur_match becomes <= limit. To simplify the code,
+   * we prevent matches with the string of window index 0.
+   */
+
+  var strend = s.strstart + MAX_MATCH;
+  var scan_end1  = _win[scan + best_len - 1];
+  var scan_end   = _win[scan + best_len];
+
+  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
+   * It is easy to get rid of this optimization if necessary.
+   */
+  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
+
+  /* Do not waste too much time if we already have a good match: */
+  if (s.prev_length >= s.good_match) {
+    chain_length >>= 2;
+  }
+  /* Do not look for matches beyond the end of the input. This is necessary
+   * to make deflate deterministic.
+   */
+  if (nice_match > s.lookahead) { nice_match = s.lookahead; }
+
+  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
+
+  do {
+    // Assert(cur_match < s->strstart, "no future");
+    match = cur_match;
+
+    /* Skip to next match if the match length cannot increase
+     * or if the match length is less than 2.  Note that the checks below
+     * for insufficient lookahead only occur occasionally for performance
+     * reasons.  Therefore uninitialized memory will be accessed, and
+     * conditional jumps will be made that depend on those values.
+     * However the length of the match is limited to the lookahead, so
+     * the output of deflate is not affected by the uninitialized values.
+     */
+
+    if (_win[match + best_len]     !== scan_end  ||
+        _win[match + best_len - 1] !== scan_end1 ||
+        _win[match]                !== _win[scan] ||
+        _win[++match]              !== _win[scan + 1]) {
+      continue;
+    }
+
+    /* The check at best_len-1 can be removed because it will be made
+     * again later. (This heuristic is not always a win.)
+     * It is not necessary to compare scan[2] and match[2] since they
+     * are always equal when the other bytes match, given that
+     * the hash keys are equal and that HASH_BITS >= 8.
+     */
+    scan += 2;
+    match++;
+    // Assert(*scan == *match, "match[2]?");
+
+    /* We check for insufficient lookahead only every 8th comparison;
+     * the 256th check will be made at strstart+258.
+     */
+    do {
+      // Do nothing
+    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
+             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
+             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
+             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
+             scan < strend);
+
+    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+
+    len = MAX_MATCH - (strend - scan);
+    scan = strend - MAX_MATCH;
+
+    if (len > best_len) {
+      s.match_start = cur_match;
+      best_len = len;
+      if (len >= nice_match) {
+        break;
+      }
+      scan_end1  = _win[scan + best_len - 1];
+      scan_end   = _win[scan + best_len];
+    }
+  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
+
+  if (best_len <= s.lookahead) {
+    return best_len;
+  }
+  return s.lookahead;
+}
+
+
+/* ===========================================================================
+ * Fill the window when the lookahead becomes insufficient.
+ * Updates strstart and lookahead.
+ *
+ * IN assertion: lookahead < MIN_LOOKAHEAD
+ * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
+ *    At least one byte has been read, or avail_in == 0; reads are
+ *    performed for at least two bytes (required for the zip translate_eol
+ *    option -- not supported here).
+ */
+function fill_window(s) {
+  var _w_size = s.w_size;
+  var p, n, m, more, str;
+
+  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
+
+  do {
+    more = s.window_size - s.lookahead - s.strstart;
+
+    // JS ints have 32 bit, block below not needed
+    /* Deal with !@#$% 64K limit: */
+    //if (sizeof(int) <= 2) {
+    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
+    //        more = wsize;
+    //
+    //  } else if (more == (unsigned)(-1)) {
+    //        /* Very unlikely, but possible on 16 bit machine if
+    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
+    //         */
+    //        more--;
+    //    }
+    //}
+
+
+    /* If the window is almost full and there is insufficient lookahead,
+     * move the upper half to the lower one to make room in the upper half.
+     */
+    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
+
+      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
+      s.match_start -= _w_size;
+      s.strstart -= _w_size;
+      /* we now have strstart >= MAX_DIST */
+      s.block_start -= _w_size;
+
+      /* Slide the hash table (could be avoided with 32 bit values
+       at the expense of memory usage). We slide even when level == 0
+       to keep the hash table consistent if we switch back to level > 0
+       later. (Using level 0 permanently is not an optimal usage of
+       zlib, so we don't care about this pathological case.)
+       */
+
+      n = s.hash_size;
+      p = n;
+      do {
+        m = s.head[--p];
+        s.head[p] = (m >= _w_size ? m - _w_size : 0);
+      } while (--n);
+
+      n = _w_size;
+      p = n;
+      do {
+        m = s.prev[--p];
+        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
+        /* If n is not on any hash chain, prev[n] is garbage but
+         * its value will never be used.
+         */
+      } while (--n);
+
+      more += _w_size;
+    }
+    if (s.strm.avail_in === 0) {
+      break;
+    }
+
+    /* If there was no sliding:
+     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
+     *    more == window_size - lookahead - strstart
+     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
+     * => more >= window_size - 2*WSIZE + 2
+     * In the BIG_MEM or MMAP case (not yet supported),
+     *   window_size == input_size + MIN_LOOKAHEAD  &&
+     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
+     * Otherwise, window_size == 2*WSIZE so more >= 2.
+     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
+     */
+    //Assert(more >= 2, "more < 2");
+    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
+    s.lookahead += n;
+
+    /* Initialize the hash value now that we have some input: */
+    if (s.lookahead + s.insert >= MIN_MATCH) {
+      str = s.strstart - s.insert;
+      s.ins_h = s.window[str];
+
+      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
+      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
+//#if MIN_MATCH != 3
+//        Call update_hash() MIN_MATCH-3 more times
+//#endif
+      while (s.insert) {
+        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
+        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
+
+        s.prev[str & s.w_mask] = s.head[s.ins_h];
+        s.head[s.ins_h] = str;
+        str++;
+        s.insert--;
+        if (s.lookahead + s.insert < MIN_MATCH) {
+          break;
+        }
+      }
+    }
+    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
+     * but this is not important since only literal bytes will be emitted.
+     */
+
+  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
+
+  /* If the WIN_INIT bytes after the end of the current data have never been
+   * written, then zero those bytes in order to avoid memory check reports of
+   * the use of uninitialized (or uninitialised as Julian writes) bytes by
+   * the longest match routines.  Update the high water mark for the next
+   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
+   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
+   */
+//  if (s.high_water < s.window_size) {
+//    var curr = s.strstart + s.lookahead;
+//    var init = 0;
+//
+//    if (s.high_water < curr) {
+//      /* Previous high water mark below current data -- zero WIN_INIT
+//       * bytes or up to end of window, whichever is less.
+//       */
+//      init = s.window_size - curr;
+//      if (init > WIN_INIT)
+//        init = WIN_INIT;
+//      zmemzero(s->window + curr, (unsigned)init);
+//      s->high_water = curr + init;
+//    }
+//    else if (s->high_water < (ulg)curr + WIN_INIT) {
+//      /* High water mark at or above current data, but below current data
+//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
+//       * to end of window, whichever is less.
+//       */
+//      init = (ulg)curr + WIN_INIT - s->high_water;
+//      if (init > s->window_size - s->high_water)
+//        init = s->window_size - s->high_water;
+//      zmemzero(s->window + s->high_water, (unsigned)init);
+//      s->high_water += init;
+//    }
+//  }
+//
+//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
+//    "not enough room for search");
+}
+
+/* ===========================================================================
+ * Copy without compression as much as possible from the input stream, return
+ * the current block state.
+ * This function does not insert new strings in the dictionary since
+ * uncompressible data is probably not useful. This function is used
+ * only for the level=0 compression option.
+ * NOTE: this function should be optimized to avoid extra copying from
+ * window to pending_buf.
+ */
+function deflate_stored(s, flush) {
+  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
+   * to pending_buf_size, and each stored block has a 5 byte header:
+   */
+  var max_block_size = 0xffff;
+
+  if (max_block_size > s.pending_buf_size - 5) {
+    max_block_size = s.pending_buf_size - 5;
+  }
+
+  /* Copy as much as possible from input to output: */
+  for (;;) {
+    /* Fill the window as much as possible: */
+    if (s.lookahead <= 1) {
+
+      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
+      //  s->block_start >= (long)s->w_size, "slide too late");
+//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
+//        s.block_start >= s.w_size)) {
+//        throw  new Error("slide too late");
+//      }
+
+      fill_window(s);
+      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
+        return BS_NEED_MORE;
+      }
+
+      if (s.lookahead === 0) {
+        break;
+      }
+      /* flush the current block */
+    }
+    //Assert(s->block_start >= 0L, "block gone");
+//    if (s.block_start < 0) throw new Error("block gone");
+
+    s.strstart += s.lookahead;
+    s.lookahead = 0;
+
+    /* Emit a stored block if pending_buf will be full: */
+    var max_start = s.block_start + max_block_size;
+
+    if (s.strstart === 0 || s.strstart >= max_start) {
+      /* strstart == 0 is possible when wraparound on 16-bit machine */
+      s.lookahead = s.strstart - max_start;
+      s.strstart = max_start;
+      /*** FLUSH_BLOCK(s, 0); ***/
+      flush_block_only(s, false);
+      if (s.strm.avail_out === 0) {
+        return BS_NEED_MORE;
+      }
+      /***/
+
+
+    }
+    /* Flush if we may have to slide, otherwise block_start may become
+     * negative and the data will be gone:
+     */
+    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
+      /*** FLUSH_BLOCK(s, 0); ***/
+      flush_block_only(s, false);
+      if (s.strm.avail_out === 0) {
+        return BS_NEED_MORE;
+      }
+      /***/
+    }
+  }
+
+  s.insert = 0;
+
+  if (flush === Z_FINISH) {
+    /*** FLUSH_BLOCK(s, 1); ***/
+    flush_block_only(s, true);
+    if (s.strm.avail_out === 0) {
+      return BS_FINISH_STARTED;
+    }
+    /***/
+    return BS_FINISH_DONE;
+  }
+
+  if (s.strstart > s.block_start) {
+    /*** FLUSH_BLOCK(s, 0); ***/
+    flush_block_only(s, false);
+    if (s.strm.avail_out === 0) {
+      return BS_NEED_MORE;
+    }
+    /***/
+  }
+
+  return BS_NEED_MORE;
+}
+
+/* ===========================================================================
+ * Compress as much as possible from the input stream, return the current
+ * block state.
+ * This function does not perform lazy evaluation of matches and inserts
+ * new strings in the dictionary only for unmatched strings or for short
+ * matches. It is used only for the fast compression options.
+ */
+function deflate_fast(s, flush) {
+  var hash_head;        /* head of the hash chain */
+  var bflush;           /* set if current block must be flushed */
+
+  for (;;) {
+    /* Make sure that we always have enough lookahead, except
+     * at the end of the input file. We need MAX_MATCH bytes
+     * for the next match, plus MIN_MATCH bytes to insert the
+     * string following the next match.
+     */
+    if (s.lookahead < MIN_LOOKAHEAD) {
+      fill_window(s);
+      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
+        return BS_NEED_MORE;
+      }
+      if (s.lookahead === 0) {
+        break; /* flush the current block */
+      }
+    }
+
+    /* Insert the string window[strstart .. strstart+2] in the
+     * dictionary, and set hash_head to the head of the hash chain:
+     */
+    hash_head = 0/*NIL*/;
+    if (s.lookahead >= MIN_MATCH) {
+      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
+      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
+      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
+      s.head[s.ins_h] = s.strstart;
+      /***/
+    }
+
+    /* Find the longest match, discarding those <= prev_length.
+     * At this point we have always match_length < MIN_MATCH
+     */
+    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
+      /* To simplify the code, we prevent matches with the string
+       * of window index 0 (in particular we have to avoid a match
+       * of the string with itself at the start of the input file).
+       */
+      s.match_length = longest_match(s, hash_head);
+      /* longest_match() sets match_start */
+    }
+    if (s.match_length >= MIN_MATCH) {
+      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only
+
+      /*** _tr_tally_dist(s, s.strstart - s.match_start,
+                     s.match_length - MIN_MATCH, bflush); ***/
+      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
+
+      s.lookahead -= s.match_length;
+
+      /* Insert new strings in the hash table only if the match length
+       * is not too large. This saves time but degrades compression.
+       */
+      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
+        s.match_length--; /* string at strstart already in table */
+        do {
+          s.strstart++;
+          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
+          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
+          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
+          s.head[s.ins_h] = s.strstart;
+          /***/
+          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
+           * always MIN_MATCH bytes ahead.
+           */
+        } while (--s.match_length !== 0);
+        s.strstart++;
+      } else
+      {
+        s.strstart += s.match_length;
+        s.match_length = 0;
+        s.ins_h = s.window[s.strstart];
+        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
+        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;
+
+//#if MIN_MATCH != 3
+//                Call UPDATE_HASH() MIN_MATCH-3 more times
+//#endif
+        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
+         * matter since it will be recomputed at next deflate call.
+         */
+      }
+    } else {
+      /* No match, output a literal byte */
+      //Tracevv((stderr,"%c", s.window[s.strstart]));
+      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
+      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
+
+      s.lookahead--;
+      s.strstart++;
+    }
+    if (bflush) {
+      /*** FLUSH_BLOCK(s, 0); ***/
+      flush_block_only(s, false);
+      if (s.strm.avail_out === 0) {
+        return BS_NEED_MORE;
+      }
+      /***/
+    }
+  }
+  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
+  if (flush === Z_FINISH) {
+    /*** FLUSH_BLOCK(s, 1); ***/
+    flush_block_only(s, true);
+    if (s.strm.avail_out === 0) {
+      return BS_FINISH_STARTED;
+    }
+    /***/
+    return BS_FINISH_DONE;
+  }
+  if (s.last_lit) {
+    /*** FLUSH_BLOCK(s, 0); ***/
+    flush_block_only(s, false);
+    if (s.strm.avail_out === 0) {
+      return BS_NEED_MORE;
+    }
+    /***/
+  }
+  return BS_BLOCK_DONE;
+}
+
+/* ===========================================================================
+ * Same as above, but achieves better compression. We use a lazy
+ * evaluation for matches: a match is finally adopted only if there is
+ * no better match at the next window position.
+ */
+function deflate_slow(s, flush) {
+  var hash_head;          /* head of hash chain */
+  var bflush;              /* set if current block must be flushed */
+
+  var max_insert;
+
+  /* Process the input block. */
+  for (;;) {
+    /* Make sure that we always have enough lookahead, except
+     * at the end of the input file. We need MAX_MATCH bytes
+     * for the next match, plus MIN_MATCH bytes to insert the
+     * string following the next match.
+     */
+    if (s.lookahead < MIN_LOOKAHEAD) {
+      fill_window(s);
+      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
+        return BS_NEED_MORE;
+      }
+      if (s.lookahead === 0) { break; } /* flush the current block */
+    }
+
+    /* Insert the string window[strstart .. strstart+2] in the
+     * dictionary, and set hash_head to the head of the hash chain:
+     */
+    hash_head = 0/*NIL*/;
+    if (s.lookahead >= MIN_MATCH) {
+      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
+      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
+      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
+      s.head[s.ins_h] = s.strstart;
+      /***/
+    }
+
+    /* Find the longest match, discarding those <= prev_length.
+     */
+    s.prev_length = s.match_length;
+    s.prev_match = s.match_start;
+    s.match_length = MIN_MATCH - 1;
+
+    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
+        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
+      /* To simplify the code, we prevent matches with the string
+       * of window index 0 (in particular we have to avoid a match
+       * of the string with itself at the start of the input file).
+       */
+      s.match_length = longest_match(s, hash_head);
+      /* longest_match() sets match_start */
+
+      if (s.match_length <= 5 &&
+         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {
+
+        /* If prev_match is also MIN_MATCH, match_start is garbage
+         * but we will ignore the current match anyway.
+         */
+        s.match_length = MIN_MATCH - 1;
+      }
+    }
+    /* If there was a match at the previous step and the current
+     * match is not better, output the previous match:
+     */
+    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
+      max_insert = s.strstart + s.lookahead - MIN_MATCH;
+      /* Do not insert strings in hash table beyond this. */
+
+      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);
+
+      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
+                     s.prev_length - MIN_MATCH, bflush);***/
+      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
+      /* Insert in hash table all strings up to the end of the match.
+       * strstart-1 and strstart are already inserted. If there is not
+       * enough lookahead, the last two strings are not inserted in
+       * the hash table.
+       */
+      s.lookahead -= s.prev_length - 1;
+      s.prev_length -= 2;
+      do {
+        if (++s.strstart <= max_insert) {
+          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
+          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
+          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
+          s.head[s.ins_h] = s.strstart;
+          /***/
+        }
+      } while (--s.prev_length !== 0);
+      s.match_available = 0;
+      s.match_length = MIN_MATCH - 1;
+      s.strstart++;
+
+      if (bflush) {
+        /*** FLUSH_BLOCK(s, 0); ***/
+        flush_block_only(s, false);
+        if (s.strm.avail_out === 0) {
+          return BS_NEED_MORE;
+        }
+        /***/
+      }
+
+    } else if (s.match_available) {
+      /* If there was no match at the previous position, output a
+       * single literal. If there was a match but the current match
+       * is longer, truncate the previous match to a single literal.
+       */
+      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
+      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
+      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
+
+      if (bflush) {
+        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
+        flush_block_only(s, false);
+        /***/
+      }
+      s.strstart++;
+      s.lookahead--;
+      if (s.strm.avail_out === 0) {
+        return BS_NEED_MORE;
+      }
+    } else {
+      /* There is no previous match to compare with, wait for
+       * the next step to decide.
+       */
+      s.match_available = 1;
+      s.strstart++;
+      s.lookahead--;
+    }
+  }
+  //Assert (flush != Z_NO_FLUSH, "no flush?");
+  if (s.match_available) {
+    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
+    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
+    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
+
+    s.match_available = 0;
+  }
+  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
+  if (flush === Z_FINISH) {
+    /*** FLUSH_BLOCK(s, 1); ***/
+    flush_block_only(s, true);
+    if (s.strm.avail_out === 0) {
+      return BS_FINISH_STARTED;
+    }
+    /***/
+    return BS_FINISH_DONE;
+  }
+  if (s.last_lit) {
+    /*** FLUSH_BLOCK(s, 0); ***/
+    flush_block_only(s, false);
+    if (s.strm.avail_out === 0) {
+      return BS_NEED_MORE;
+    }
+    /***/
+  }
+
+  return BS_BLOCK_DONE;
+}
+
+
+/* ===========================================================================
+ * For Z_RLE, simply look for runs of bytes, generate matches only of distance
+ * one.  Do not maintain a hash table.  (It will be regenerated if this run of
+ * deflate switches away from Z_RLE.)
+ */
+function deflate_rle(s, flush) {
+  var bflush;            /* set if current block must be flushed */
+  var prev;              /* byte at distance one to match */
+  var scan, strend;      /* scan goes up to strend for length of run */
+
+  var _win = s.window;
+
+  for (;;) {
+    /* Make sure that we always have enough lookahead, except
+     * at the end of the input file. We need MAX_MATCH bytes
+     * for the longest run, plus one for the unrolled loop.
+     */
+    if (s.lookahead <= MAX_MATCH) {
+      fill_window(s);
+      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
+        return BS_NEED_MORE;
+      }
+      if (s.lookahead === 0) { break; } /* flush the current block */
+    }
+
+    /* See how many times the previous byte repeats */
+    s.match_length = 0;
+    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
+      scan = s.strstart - 1;
+      prev = _win[scan];
+      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
+        strend = s.strstart + MAX_MATCH;
+        do {
+          // Do nothing
+        } while (prev === _win[++scan] && prev === _win[++scan] &&
+                 prev === _win[++scan] && prev === _win[++scan] &&
+                 prev === _win[++scan] && prev === _win[++scan] &&
+                 prev === _win[++scan] && prev === _win[++scan] &&
+                 scan < strend);
+        s.match_length = MAX_MATCH - (strend - scan);
+        if (s.match_length > s.lookahead) {
+          s.match_length = s.lookahead;
+        }
+      }
+      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
+    }
+
+    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
+    if (s.match_length >= MIN_MATCH) {
+      //check_match(s, s.strstart, s.strstart - 1, s.match_length);
+
+      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
+      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
+
+      s.lookahead -= s.match_length;
+      s.strstart += s.match_length;
+      s.match_length = 0;
+    } else {
+      /* No match, output a literal byte */
+      //Tracevv((stderr,"%c", s->window[s->strstart]));
+      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
+      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
+
+      s.lookahead--;
+      s.strstart++;
+    }
+    if (bflush) {
+      /*** FLUSH_BLOCK(s, 0); ***/
+      flush_block_only(s, false);
+      if (s.strm.avail_out === 0) {
+        return BS_NEED_MORE;
+      }
+      /***/
+    }
+  }
+  s.insert = 0;
+  if (flush === Z_FINISH) {
+    /*** FLUSH_BLOCK(s, 1); ***/
+    flush_block_only(s, true);
+    if (s.strm.avail_out === 0) {
+      return BS_FINISH_STARTED;
+    }
+    /***/
+    return BS_FINISH_DONE;
+  }
+  if (s.last_lit) {
+    /*** FLUSH_BLOCK(s, 0); ***/
+    flush_block_only(s, false);
+    if (s.strm.avail_out === 0) {
+      return BS_NEED_MORE;
+    }
+    /***/
+  }
+  return BS_BLOCK_DONE;
+}
+
+/* ===========================================================================
+ * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
+ * (It will be regenerated if this run of deflate switches away from Huffman.)
+ */
+function deflate_huff(s, flush) {
+  var bflush;             /* set if current block must be flushed */
+
+  for (;;) {
+    /* Make sure that we have a literal to write. */
+    if (s.lookahead === 0) {
+      fill_window(s);
+      if (s.lookahead === 0) {
+        if (flush === Z_NO_FLUSH) {
+          return BS_NEED_MORE;
+        }
+        break;      /* flush the current block */
+      }
+    }
+
+    /* Output a literal byte */
+    s.match_length = 0;
+    //Tracevv((stderr,"%c", s->window[s->strstart]));
+    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
+    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
+    s.lookahead--;
+    s.strstart++;
+    if (bflush) {
+      /*** FLUSH_BLOCK(s, 0); ***/
+      flush_block_only(s, false);
+      if (s.strm.avail_out === 0) {
+        return BS_NEED_MORE;
+      }
+      /***/
+    }
+  }
+  s.insert = 0;
+  if (flush === Z_FINISH) {
+    /*** FLUSH_BLOCK(s, 1); ***/
+    flush_block_only(s, true);
+    if (s.strm.avail_out === 0) {
+      return BS_FINISH_STARTED;
+    }
+    /***/
+    return BS_FINISH_DONE;
+  }
+  if (s.last_lit) {
+    /*** FLUSH_BLOCK(s, 0); ***/
+    flush_block_only(s, false);
+    if (s.strm.avail_out === 0) {
+      return BS_NEED_MORE;
+    }
+    /***/
+  }
+  return BS_BLOCK_DONE;
+}
+
+/* Values for max_lazy_match, good_match and max_chain_length, depending on
+ * the desired pack level (0..9). The values given below have been tuned to
+ * exclude worst case performance for pathological files. Better values may be
+ * found for specific files.
+ */
+function Config(good_length, max_lazy, nice_length, max_chain, func) {
+  this.good_length = good_length;
+  this.max_lazy = max_lazy;
+  this.nice_length = nice_length;
+  this.max_chain = max_chain;
+  this.func = func;
+}
+
+var configuration_table;
+
+configuration_table = [
+  /*      good lazy nice chain */
+  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
+  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
+  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
+  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */
+
+  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
+  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
+  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
+  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
+  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
+  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
+];
+
+
+/* ===========================================================================
+ * Initialize the "longest match" routines for a new zlib stream
+ */
+function lm_init(s) {
+  s.window_size = 2 * s.w_size;
+
+  /*** CLEAR_HASH(s); ***/
+  zero(s.head); // Fill with NIL (= 0);
+
+  /* Set the default configuration parameters:
+   */
+  s.max_lazy_match = configuration_table[s.level].max_lazy;
+  s.good_match = configuration_table[s.level].good_length;
+  s.nice_match = configuration_table[s.level].nice_length;
+  s.max_chain_length = configuration_table[s.level].max_chain;
+
+  s.strstart = 0;
+  s.block_start = 0;
+  s.lookahead = 0;
+  s.insert = 0;
+  s.match_length = s.prev_length = MIN_MATCH - 1;
+  s.match_available = 0;
+  s.ins_h = 0;
+}
+
+
+function DeflateState() {
+  this.strm = null;            /* pointer back to this zlib stream */
+  this.status = 0;            /* as the name implies */
+  this.pending_buf = null;      /* output still pending */
+  this.pending_buf_size = 0;  /* size of pending_buf */
+  this.pending_out = 0;       /* next pending byte to output to the stream */
+  this.pending = 0;           /* nb of bytes in the pending buffer */
+  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
+  this.gzhead = null;         /* gzip header information to write */
+  this.gzindex = 0;           /* where in extra, name, or comment */
+  this.method = Z_DEFLATED; /* can only be DEFLATED */
+  this.last_flush = -1;   /* value of flush param for previous deflate call */
+
+  this.w_size = 0;  /* LZ77 window size (32K by default) */
+  this.w_bits = 0;  /* log2(w_size)  (8..16) */
+  this.w_mask = 0;  /* w_size - 1 */
+
+  this.window = null;
+  /* Sliding window. Input bytes are read into the second half of the window,
+   * and move to the first half later to keep a dictionary of at least wSize
+   * bytes. With this organization, matches are limited to a distance of
+   * wSize-MAX_MATCH bytes, but this ensures that IO is always
+   * performed with a length multiple of the block size.
+   */
+
+  this.window_size = 0;
+  /* Actual size of window: 2*wSize, except when the user input buffer
+   * is directly used as sliding window.
+   */
+
+  this.prev = null;
+  /* Link to older string with same hash index. To limit the size of this
+   * array to 64K, this link is maintained only for the last 32K strings.
+   * An index in this array is thus a window index modulo 32K.
+   */
+
+  this.head = null;   /* Heads of the hash chains or NIL. */
+
+  this.ins_h = 0;       /* hash index of string to be inserted */
+  this.hash_size = 0;   /* number of elements in hash table */
+  this.hash_bits = 0;   /* log2(hash_size) */
+  this.hash_mask = 0;   /* hash_size-1 */
+
+  this.hash_shift = 0;
+  /* Number of bits by which ins_h must be shifted at each input
+   * step. It must be such that after MIN_MATCH steps, the oldest
+   * byte no longer takes part in the hash key, that is:
+   *   hash_shift * MIN_MATCH >= hash_bits
+   */
+
+  this.block_start = 0;
+  /* Window position at the beginning of the current output block. Gets
+   * negative when the window is moved backwards.
+   */
+
+  this.match_length = 0;      /* length of best match */
+  this.prev_match = 0;        /* previous match */
+  this.match_available = 0;   /* set if previous match exists */
+  this.strstart = 0;          /* start of string to insert */
+  this.match_start = 0;       /* start of matching string */
+  this.lookahead = 0;         /* number of valid bytes ahead in window */
+
+  this.prev_length = 0;
+  /* Length of the best match at previous step. Matches not greater than this
+   * are discarded. This is used in the lazy match evaluation.
+   */
+
+  this.max_chain_length = 0;
+  /* To speed up deflation, hash chains are never searched beyond this
+   * length.  A higher limit improves compression ratio but degrades the
+   * speed.
+   */
+
+  this.max_lazy_match = 0;
+  /* Attempt to find a better match only when the current match is strictly
+   * smaller than this value. This mechanism is used only for compression
+   * levels >= 4.
+   */
+  // That's alias to max_lazy_match, don't use directly
+  //this.max_insert_length = 0;
+  /* Insert new strings in the hash table only if the match length is not
+   * greater than this length. This saves time but degrades compression.
+   * max_insert_length is used only for compression levels <= 3.
+   */
+
+  this.level = 0;     /* compression level (1..9) */
+  this.strategy = 0;  /* favor or force Huffman coding*/
+
+  this.good_match = 0;
+  /* Use a faster search when the previous match is longer than this */
+
+  this.nice_match = 0; /* Stop searching when current match exceeds this */
+
+              /* used by trees.c: */
+
+  /* Didn't use ct_data typedef below to suppress compiler warning */
+
+  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
+  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
+  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
+
+  // Use flat array of DOUBLE size, with interleaved fata,
+  // because JS does not support effective
+  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
+  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
+  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
+  zero(this.dyn_ltree);
+  zero(this.dyn_dtree);
+  zero(this.bl_tree);
+
+  this.l_desc   = null;         /* desc. for literal tree */
+  this.d_desc   = null;         /* desc. for distance tree */
+  this.bl_desc  = null;         /* desc. for bit length tree */
+
+  //ush bl_count[MAX_BITS+1];
+  this.bl_count = new utils.Buf16(MAX_BITS + 1);
+  /* number of codes at each bit length for an optimal tree */
+
+  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
+  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
+  zero(this.heap);
+
+  this.heap_len = 0;               /* number of elements in the heap */
+  this.heap_max = 0;               /* element of largest frequency */
+  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
+   * The same heap array is used to build all trees.
+   */
+
+  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
+  zero(this.depth);
+  /* Depth of each subtree used as tie breaker for trees of equal frequency
+   */
+
+  this.l_buf = 0;          /* buffer index for literals or lengths */
+
+  this.lit_bufsize = 0;
+  /* Size of match buffer for literals/lengths.  There are 4 reasons for
+   * limiting lit_bufsize to 64K:
+   *   - frequencies can be kept in 16 bit counters
+   *   - if compression is not successful for the first block, all input
+   *     data is still in the window so we can still emit a stored block even
+   *     when input comes from standard input.  (This can also be done for
+   *     all blocks if lit_bufsize is not greater than 32K.)
+   *   - if compression is not successful for a file smaller than 64K, we can
+   *     even emit a stored file instead of a stored block (saving 5 bytes).
+   *     This is applicable only for zip (not gzip or zlib).
+   *   - creating new Huffman trees less frequently may not provide fast
+   *     adaptation to changes in the input data statistics. (Take for
+   *     example a binary file with poorly compressible code followed by
+   *     a highly compressible string table.) Smaller buffer sizes give
+   *     fast adaptation but have of course the overhead of transmitting
+   *     trees more frequently.
+   *   - I can't count above 4
+   */
+
+  this.last_lit = 0;      /* running index in l_buf */
+
+  this.d_buf = 0;
+  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
+   * the same number of elements. To use different lengths, an extra flag
+   * array would be necessary.
+   */
+
+  this.opt_len = 0;       /* bit length of current block with optimal trees */
+  this.static_len = 0;    /* bit length of current block with static trees */
+  this.matches = 0;       /* number of string matches in current block */
+  this.insert = 0;        /* bytes at end of window left to insert */
+
+
+  this.bi_buf = 0;
+  /* Output buffer. bits are inserted starting at the bottom (least
+   * significant bits).
+   */
+  this.bi_valid = 0;
+  /* Number of valid bits in bi_buf.  All bits above the last valid bit
+   * are always zero.
+   */
+
+  // Used for window memory init. We safely ignore it for JS. That makes
+  // sense only for pointers and memory check tools.
+  //this.high_water = 0;
+  /* High water mark offset in window for initialized bytes -- bytes above
+   * this are set to zero in order to avoid memory check warnings when
+   * longest match routines access bytes past the input.  This is then
+   * updated to the new high water mark.
+   */
+}
+
+
+function deflateResetKeep(strm) {
+  var s;
+
+  if (!strm || !strm.state) {
+    return err(strm, Z_STREAM_ERROR);
+  }
+
+  strm.total_in = strm.total_out = 0;
+  strm.data_type = Z_UNKNOWN;
+
+  s = strm.state;
+  s.pending = 0;
+  s.pending_out = 0;
+
+  if (s.wrap < 0) {
+    s.wrap = -s.wrap;
+    /* was made negative by deflate(..., Z_FINISH); */
+  }
+  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
+  strm.adler = (s.wrap === 2) ?
+    0  // crc32(0, Z_NULL, 0)
+  :
+    1; // adler32(0, Z_NULL, 0)
+  s.last_flush = Z_NO_FLUSH;
+  trees._tr_init(s);
+  return Z_OK;
+}
+
+
+function deflateReset(strm) {
+  var ret = deflateResetKeep(strm);
+  if (ret === Z_OK) {
+    lm_init(strm.state);
+  }
+  return ret;
+}
+
+
+function deflateSetHeader(strm, head) {
+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
+  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
+  strm.state.gzhead = head;
+  return Z_OK;
+}
+
+
+function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
+  if (!strm) { // === Z_NULL
+    return Z_STREAM_ERROR;
+  }
+  var wrap = 1;
+
+  if (level === Z_DEFAULT_COMPRESSION) {
+    level = 6;
+  }
+
+  if (windowBits < 0) { /* suppress zlib wrapper */
+    wrap = 0;
+    windowBits = -windowBits;
+  }
+
+  else if (windowBits > 15) {
+    wrap = 2;           /* write gzip wrapper instead */
+    windowBits -= 16;
+  }
+
+
+  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
+    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
+    strategy < 0 || strategy > Z_FIXED) {
+    return err(strm, Z_STREAM_ERROR);
+  }
+
+
+  if (windowBits === 8) {
+    windowBits = 9;
+  }
+  /* until 256-byte window bug fixed */
+
+  var s = new DeflateState();
+
+  strm.state = s;
+  s.strm = strm;
+
+  s.wrap = wrap;
+  s.gzhead = null;
+  s.w_bits = windowBits;
+  s.w_size = 1 << s.w_bits;
+  s.w_mask = s.w_size - 1;
+
+  s.hash_bits = memLevel + 7;
+  s.hash_size = 1 << s.hash_bits;
+  s.hash_mask = s.hash_size - 1;
+  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
+
+  s.window = new utils.Buf8(s.w_size * 2);
+  s.head = new utils.Buf16(s.hash_size);
+  s.prev = new utils.Buf16(s.w_size);
+
+  // Don't need mem init magic for JS.
+  //s.high_water = 0;  /* nothing written to s->window yet */
+
+  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
+
+  s.pending_buf_size = s.lit_bufsize * 4;
+
+  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
+  //s->pending_buf = (uchf *) overlay;
+  s.pending_buf = new utils.Buf8(s.pending_buf_size);
+
+  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
+  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
+  s.d_buf = 1 * s.lit_bufsize;
+
+  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
+  s.l_buf = (1 + 2) * s.lit_bufsize;
+
+  s.level = level;
+  s.strategy = strategy;
+  s.method = method;
+
+  return deflateReset(strm);
+}
+
+function deflateInit(strm, level) {
+  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
+}
+
+
+function deflate(strm, flush) {
+  var old_flush, s;
+  var beg, val; // for gzip header write only
+
+  if (!strm || !strm.state ||
+    flush > Z_BLOCK || flush < 0) {
+    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
+  }
+
+  s = strm.state;
+
+  if (!strm.output ||
+      (!strm.input && strm.avail_in !== 0) ||
+      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
+    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
+  }
+
+  s.strm = strm; /* just in case */
+  old_flush = s.last_flush;
+  s.last_flush = flush;
+
+  /* Write the header */
+  if (s.status === INIT_STATE) {
+
+    if (s.wrap === 2) { // GZIP header
+      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
+      put_byte(s, 31);
+      put_byte(s, 139);
+      put_byte(s, 8);
+      if (!s.gzhead) { // s->gzhead == Z_NULL
+        put_byte(s, 0);
+        put_byte(s, 0);
+        put_byte(s, 0);
+        put_byte(s, 0);
+        put_byte(s, 0);
+        put_byte(s, s.level === 9 ? 2 :
+                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
+                     4 : 0));
+        put_byte(s, OS_CODE);
+        s.status = BUSY_STATE;
+      }
+      else {
+        put_byte(s, (s.gzhead.text ? 1 : 0) +
+                    (s.gzhead.hcrc ? 2 : 0) +
+                    (!s.gzhead.extra ? 0 : 4) +
+                    (!s.gzhead.name ? 0 : 8) +
+                    (!s.gzhead.comment ? 0 : 16)
+                );
+        put_byte(s, s.gzhead.time & 0xff);
+        put_byte(s, (s.gzhead.time >> 8) & 0xff);
+        put_byte(s, (s.gzhead.time >> 16) & 0xff);
+        put_byte(s, (s.gzhead.time >> 24) & 0xff);
+        put_byte(s, s.level === 9 ? 2 :
+                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
+                     4 : 0));
+        put_byte(s, s.gzhead.os & 0xff);
+        if (s.gzhead.extra && s.gzhead.extra.length) {
+          put_byte(s, s.gzhead.extra.length & 0xff);
+          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
+        }
+        if (s.gzhead.hcrc) {
+          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
+        }
+        s.gzindex = 0;
+        s.status = EXTRA_STATE;
+      }
+    }
+    else // DEFLATE header
+    {
+      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
+      var level_flags = -1;
+
+      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
+        level_flags = 0;
+      } else if (s.level < 6) {
+        level_flags = 1;
+      } else if (s.level === 6) {
+        level_flags = 2;
+      } else {
+        level_flags = 3;
+      }
+      header |= (level_flags << 6);
+      if (s.strstart !== 0) { header |= PRESET_DICT; }
+      header += 31 - (header % 31);
+
+      s.status = BUSY_STATE;
+      putShortMSB(s, header);
+
+      /* Save the adler32 of the preset dictionary: */
+      if (s.strstart !== 0) {
+        putShortMSB(s, strm.adler >>> 16);
+        putShortMSB(s, strm.adler & 0xffff);
+      }
+      strm.adler = 1; // adler32(0L, Z_NULL, 0);
+    }
+  }
+
+//#ifdef GZIP
+  if (s.status === EXTRA_STATE) {
+    if (s.gzhead.extra/* != Z_NULL*/) {
+      beg = s.pending;  /* start of bytes to update crc */
+
+      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
+        if (s.pending === s.pending_buf_size) {
+          if (s.gzhead.hcrc && s.pending > beg) {
+            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
+          }
+          flush_pending(strm);
+          beg = s.pending;
+          if (s.pending === s.pending_buf_size) {
+            break;
+          }
+        }
+        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
+        s.gzindex++;
+      }
+      if (s.gzhead.hcrc && s.pending > beg) {
+        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
+      }
+      if (s.gzindex === s.gzhead.extra.length) {
+        s.gzindex = 0;
+        s.status = NAME_STATE;
+      }
+    }
+    else {
+      s.status = NAME_STATE;
+    }
+  }
+  if (s.status === NAME_STATE) {
+    if (s.gzhead.name/* != Z_NULL*/) {
+      beg = s.pending;  /* start of bytes to update crc */
+      //int val;
+
+      do {
+        if (s.pending === s.pending_buf_size) {
+          if (s.gzhead.hcrc && s.pending > beg) {
+            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
+          }
+          flush_pending(strm);
+          beg = s.pending;
+          if (s.pending === s.pending_buf_size) {
+            val = 1;
+            break;
+          }
+        }
+        // JS specific: little magic to add zero terminator to end of string
+        if (s.gzindex < s.gzhead.name.length) {
+          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
+        } else {
+          val = 0;
+        }
+        put_byte(s, val);
+      } while (val !== 0);
+
+      if (s.gzhead.hcrc && s.pending > beg) {
+        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
+      }
+      if (val === 0) {
+        s.gzindex = 0;
+        s.status = COMMENT_STATE;
+      }
+    }
+    else {
+      s.status = COMMENT_STATE;
+    }
+  }
+  if (s.status === COMMENT_STATE) {
+    if (s.gzhead.comment/* != Z_NULL*/) {
+      beg = s.pending;  /* start of bytes to update crc */
+      //int val;
+
+      do {
+        if (s.pending === s.pending_buf_size) {
+          if (s.gzhead.hcrc && s.pending > beg) {
+            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
+          }
+          flush_pending(strm);
+          beg = s.pending;
+          if (s.pending === s.pending_buf_size) {
+            val = 1;
+            break;
+          }
+        }
+        // JS specific: little magic to add zero terminator to end of string
+        if (s.gzindex < s.gzhead.comment.length) {
+          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
+        } else {
+          val = 0;
+        }
+        put_byte(s, val);
+      } while (val !== 0);
+
+      if (s.gzhead.hcrc && s.pending > beg) {
+        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
+      }
+      if (val === 0) {
+        s.status = HCRC_STATE;
+      }
+    }
+    else {
+      s.status = HCRC_STATE;
+    }
+  }
+  if (s.status === HCRC_STATE) {
+    if (s.gzhead.hcrc) {
+      if (s.pending + 2 > s.pending_buf_size) {
+        flush_pending(strm);
+      }
+      if (s.pending + 2 <= s.pending_buf_size) {
+        put_byte(s, strm.adler & 0xff);
+        put_byte(s, (strm.adler >> 8) & 0xff);
+        strm.adler = 0; //crc32(0L, Z_NULL, 0);
+        s.status = BUSY_STATE;
+      }
+    }
+    else {
+      s.status = BUSY_STATE;
+    }
+  }
+//#endif
+
+  /* Flush as much pending output as possible */
+  if (s.pending !== 0) {
+    flush_pending(strm);
+    if (strm.avail_out === 0) {
+      /* Since avail_out is 0, deflate will be called again with
+       * more output space, but possibly with both pending and
+       * avail_in equal to zero. There won't be anything to do,
+       * but this is not an error situation so make sure we
+       * return OK instead of BUF_ERROR at next call of deflate:
+       */
+      s.last_flush = -1;
+      return Z_OK;
+    }
+
+    /* Make sure there is something to do and avoid duplicate consecutive
+     * flushes. For repeated and useless calls with Z_FINISH, we keep
+     * returning Z_STREAM_END instead of Z_BUF_ERROR.
+     */
+  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
+    flush !== Z_FINISH) {
+    return err(strm, Z_BUF_ERROR);
+  }
+
+  /* User must not provide more input after the first FINISH: */
+  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
+    return err(strm, Z_BUF_ERROR);
+  }
+
+  /* Start a new block or continue the current one.
+   */
+  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
+    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
+    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
+      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
+        configuration_table[s.level].func(s, flush));
+
+    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
+      s.status = FINISH_STATE;
+    }
+    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
+      if (strm.avail_out === 0) {
+        s.last_flush = -1;
+        /* avoid BUF_ERROR next call, see above */
+      }
+      return Z_OK;
+      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
+       * of deflate should use the same flush parameter to make sure
+       * that the flush is complete. So we don't have to output an
+       * empty block here, this will be done at next call. This also
+       * ensures that for a very small output buffer, we emit at most
+       * one empty block.
+       */
+    }
+    if (bstate === BS_BLOCK_DONE) {
+      if (flush === Z_PARTIAL_FLUSH) {
+        trees._tr_align(s);
+      }
+      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
+
+        trees._tr_stored_block(s, 0, 0, false);
+        /* For a full flush, this empty block will be recognized
+         * as a special marker by inflate_sync().
+         */
+        if (flush === Z_FULL_FLUSH) {
+          /*** CLEAR_HASH(s); ***/             /* forget history */
+          zero(s.head); // Fill with NIL (= 0);
+
+          if (s.lookahead === 0) {
+            s.strstart = 0;
+            s.block_start = 0;
+            s.insert = 0;
+          }
+        }
+      }
+      flush_pending(strm);
+      if (strm.avail_out === 0) {
+        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
+        return Z_OK;
+      }
+    }
+  }
+  //Assert(strm->avail_out > 0, "bug2");
+  //if (strm.avail_out <= 0) { throw new Error("bug2");}
+
+  if (flush !== Z_FINISH) { return Z_OK; }
+  if (s.wrap <= 0) { return Z_STREAM_END; }
+
+  /* Write the trailer */
+  if (s.wrap === 2) {
+    put_byte(s, strm.adler & 0xff);
+    put_byte(s, (strm.adler >> 8) & 0xff);
+    put_byte(s, (strm.adler >> 16) & 0xff);
+    put_byte(s, (strm.adler >> 24) & 0xff);
+    put_byte(s, strm.total_in & 0xff);
+    put_byte(s, (strm.total_in >> 8) & 0xff);
+    put_byte(s, (strm.total_in >> 16) & 0xff);
+    put_byte(s, (strm.total_in >> 24) & 0xff);
+  }
+  else
+  {
+    putShortMSB(s, strm.adler >>> 16);
+    putShortMSB(s, strm.adler & 0xffff);
+  }
+
+  flush_pending(strm);
+  /* If avail_out is zero, the application will call deflate again
+   * to flush the rest.
+   */
+  if (s.wrap > 0) { s.wrap = -s.wrap; }
+  /* write the trailer only once! */
+  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
+}
+
+function deflateEnd(strm) {
+  var status;
+
+  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
+    return Z_STREAM_ERROR;
+  }
+
+  status = strm.state.status;
+  if (status !== INIT_STATE &&
+    status !== EXTRA_STATE &&
+    status !== NAME_STATE &&
+    status !== COMMENT_STATE &&
+    status !== HCRC_STATE &&
+    status !== BUSY_STATE &&
+    status !== FINISH_STATE
+  ) {
+    return err(strm, Z_STREAM_ERROR);
+  }
+
+  strm.state = null;
+
+  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
+}
+
+
+/* =========================================================================
+ * Initializes the compression dictionary from the given byte
+ * sequence without producing any compressed output.
+ */
+function deflateSetDictionary(strm, dictionary) {
+  var dictLength = dictionary.length;
+
+  var s;
+  var str, n;
+  var wrap;
+  var avail;
+  var next;
+  var input;
+  var tmpDict;
+
+  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
+    return Z_STREAM_ERROR;
+  }
+
+  s = strm.state;
+  wrap = s.wrap;
+
+  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
+    return Z_STREAM_ERROR;
+  }
+
+  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
+  if (wrap === 1) {
+    /* adler32(strm->adler, dictionary, dictLength); */
+    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
+  }
+
+  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */
+
+  /* if dictionary would fill window, just replace the history */
+  if (dictLength >= s.w_size) {
+    if (wrap === 0) {            /* already empty otherwise */
+      /*** CLEAR_HASH(s); ***/
+      zero(s.head); // Fill with NIL (= 0);
+      s.strstart = 0;
+      s.block_start = 0;
+      s.insert = 0;
+    }
+    /* use the tail */
+    // dictionary = dictionary.slice(dictLength - s.w_size);
+    tmpDict = new utils.Buf8(s.w_size);
+    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
+    dictionary = tmpDict;
+    dictLength = s.w_size;
+  }
+  /* insert dictionary into window and hash */
+  avail = strm.avail_in;
+  next = strm.next_in;
+  input = strm.input;
+  strm.avail_in = dictLength;
+  strm.next_in = 0;
+  strm.input = dictionary;
+  fill_window(s);
+  while (s.lookahead >= MIN_MATCH) {
+    str = s.strstart;
+    n = s.lookahead - (MIN_MATCH - 1);
+    do {
+      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
+      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
+
+      s.prev[str & s.w_mask] = s.head[s.ins_h];
+
+      s.head[s.ins_h] = str;
+      str++;
+    } while (--n);
+    s.strstart = str;
+    s.lookahead = MIN_MATCH - 1;
+    fill_window(s);
+  }
+  s.strstart += s.lookahead;
+  s.block_start = s.strstart;
+  s.insert = s.lookahead;
+  s.lookahead = 0;
+  s.match_length = s.prev_length = MIN_MATCH - 1;
+  s.match_available = 0;
+  strm.next_in = next;
+  strm.input = input;
+  strm.avail_in = avail;
+  s.wrap = wrap;
+  return Z_OK;
+}
+
+
+export { deflateInit, deflateInit2, deflateReset, deflateResetKeep, deflateSetHeader, deflate, deflateEnd, deflateSetDictionary };
+export var deflateInfo = 'pako deflate (from Nodeca project)';
+
+/* Not implemented
+exports.deflateBound = deflateBound;
+exports.deflateCopy = deflateCopy;
+exports.deflateParams = deflateParams;
+exports.deflatePending = deflatePending;
+exports.deflatePrime = deflatePrime;
+exports.deflateTune = deflateTune;
+*/
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static-production/novnc/vendor/pako/lib/zlib/gzheader.js
@@ -0,0 +1,35 @@
+export default function GZheader() {
+  /* true if compressed data believed to be text */
+  this.text       = 0;
+  /* modification time */
+  this.time       = 0;
+  /* extra flags (not used when writing a gzip file) */
+  this.xflags     = 0;
+  /* operating system */
+  this.os         = 0;
+  /* pointer to extra field or Z_NULL if none */
+  this.extra      = null;
+  /* extra field length (valid if extra != Z_NULL) */
+  this.extra_len  = 0; // Actually, we don't need it in JS,
+                       // but leave for few code modifications
+
+  //
+  // Setup limits is not necessary because in js we should not preallocate memory
+  // for inflate use constant limit in 65536 bytes
+  //
+
+  /* space at extra (only when reading header) */
+  // this.extra_max  = 0;
+  /* pointer to zero-terminated file name or Z_NULL */
+  this.name       = '';
+  /* space at name (only when reading header) */
+  // this.name_max   = 0;
+  /* pointer to zero-terminated comment or Z_NULL */
+  this.comment    = '';
+  /* space at comment (only when reading header) */
+  // this.comm_max   = 0;
+  /* true if there was or will be a header crc */
+  this.hcrc       = 0;
+  /* true when done reading gzip header (not used when writing a gzip file) */
+  this.done       = false;
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static-production/novnc/vendor/pako/lib/zlib/inffast.js
@@ -0,0 +1,324 @@
+// See state defs from inflate.js
+var BAD = 30;       /* got a data error -- remain here until reset */
+var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
+
+/*
+   Decode literal, length, and distance codes and write out the resulting
+   literal and match bytes until either not enough input or output is
+   available, an end-of-block is encountered, or a data error is encountered.
+   When large enough input and output buffers are supplied to inflate(), for
+   example, a 16K input buffer and a 64K output buffer, more than 95% of the
+   inflate execution time is spent in this routine.
+
+   Entry assumptions:
+
+        state.mode === LEN
+        strm.avail_in >= 6
+        strm.avail_out >= 258
+        start >= strm.avail_out
+        state.bits < 8
+
+   On return, state.mode is one of:
+
+        LEN -- ran out of enough output space or enough available input
+        TYPE -- reached end of block code, inflate() to interpret next block
+        BAD -- error in block data
+
+   Notes:
+
+    - The maximum input bits used by a length/distance pair is 15 bits for the
+      length code, 5 bits for the length extra, 15 bits for the distance code,
+      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
+      Therefore if strm.avail_in >= 6, then there is enough input to avoid
+      checking for available input while decoding.
+
+    - The maximum bytes that a single length/distance pair can output is 258
+      bytes, which is the maximum length that can be coded.  inflate_fast()
+      requires strm.avail_out >= 258 for each loop to avoid checking for
+      output space.
+ */
+export default function inflate_fast(strm, start) {
+  var state;
+  var _in;                    /* local strm.input */
+  var last;                   /* have enough input while in < last */
+  var _out;                   /* local strm.output */
+  var beg;                    /* inflate()'s initial strm.output */
+  var end;                    /* while out < end, enough space available */
+//#ifdef INFLATE_STRICT
+  var dmax;                   /* maximum distance from zlib header */
+//#endif
+  var wsize;                  /* window size or zero if not using window */
+  var whave;                  /* valid bytes in the window */
+  var wnext;                  /* window write index */
+  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
+  var s_window;               /* allocated sliding window, if wsize != 0 */
+  var hold;                   /* local strm.hold */
+  var bits;                   /* local strm.bits */
+  var lcode;                  /* local strm.lencode */
+  var dcode;                  /* local strm.distcode */
+  var lmask;                  /* mask for first level of length codes */
+  var dmask;                  /* mask for first level of distance codes */
+  var here;                   /* retrieved table entry */
+  var op;                     /* code bits, operation, extra bits, or */
+                              /*  window position, window bytes to copy */
+  var len;                    /* match length, unused bytes */
+  var dist;                   /* match distance */
+  var from;                   /* where to copy match from */
+  var from_source;
+
+
+  var input, output; // JS specific, because we have no pointers
+
+  /* copy state to local variables */
+  state = strm.state;
+  //here = state.here;
+  _in = strm.next_in;
+  input = strm.input;
+  last = _in + (strm.avail_in - 5);
+  _out = strm.next_out;
+  output = strm.output;
+  beg = _out - (start - strm.avail_out);
+  end = _out + (strm.avail_out - 257);
+//#ifdef INFLATE_STRICT
+  dmax = state.dmax;
+//#endif
+  wsize = state.wsize;
+  whave = state.whave;
+  wnext = state.wnext;
+  s_window = state.window;
+  hold = state.hold;
+  bits = state.bits;
+  lcode = state.lencode;
+  dcode = state.distcode;
+  lmask = (1 << state.lenbits) - 1;
+  dmask = (1 << state.distbits) - 1;
+
+
+  /* decode literals and length/distances until end-of-block or not enough
+     input data or output space */
+
+  top:
+  do {
+    if (bits < 15) {
+      hold += input[_in++] << bits;
+      bits += 8;
+      hold += input[_in++] << bits;
+      bits += 8;
+    }
+
+    here = lcode[hold & lmask];
+
+    dolen:
+    for (;;) { // Goto emulation
+      op = here >>> 24/*here.bits*/;
+      hold >>>= op;
+      bits -= op;
+      op = (here >>> 16) & 0xff/*here.op*/;
+      if (op === 0) {                          /* literal */
+        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
+        //        "inflate:         literal '%c'\n" :
+        //        "inflate:         literal 0x%02x\n", here.val));
+        output[_out++] = here & 0xffff/*here.val*/;
+      }
+      else if (op & 16) {                     /* length base */
+        len = here & 0xffff/*here.val*/;
+        op &= 15;                           /* number of extra bits */
+        if (op) {
+          if (bits < op) {
+            hold += input[_in++] << bits;
+            bits += 8;
+          }
+          len += hold & ((1 << op) - 1);
+          hold >>>= op;
+          bits -= op;
+        }
+        //Tracevv((stderr, "inflate:         length %u\n", len));
+        if (bits < 15) {
+          hold += input[_in++] << bits;
+          bits += 8;
+          hold += input[_in++] << bits;
+          bits += 8;
+        }
+        here = dcode[hold & dmask];
+
+        dodist:
+        for (;;) { // goto emulation
+          op = here >>> 24/*here.bits*/;
+          hold >>>= op;
+          bits -= op;
+          op = (here >>> 16) & 0xff/*here.op*/;
+
+          if (op & 16) {                      /* distance base */
+            dist = here & 0xffff/*here.val*/;
+            op &= 15;                       /* number of extra bits */
+            if (bits < op) {
+              hold += input[_in++] << bits;
+              bits += 8;
+              if (bits < op) {
+                hold += input[_in++] << bits;
+                bits += 8;
+              }
+            }
+            dist += hold & ((1 << op) - 1);
+//#ifdef INFLATE_STRICT
+            if (dist > dmax) {
+              strm.msg = 'invalid distance too far back';
+              state.mode = BAD;
+              break top;
+            }
+//#endif
+            hold >>>= op;
+            bits -= op;
+            //Tracevv((stderr, "inflate:         distance %u\n", dist));
+            op = _out - beg;                /* max distance in output */
+            if (dist > op) {                /* see if copy from window */
+              op = dist - op;               /* distance back in window */
+              if (op > whave) {
+                if (state.sane) {
+                  strm.msg = 'invalid distance too far back';
+                  state.mode = BAD;
+                  break top;
+                }
+
+// (!) This block is disabled in zlib defailts,
+// don't enable it for binary compatibility
+//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
+//                if (len <= op - whave) {
+//                  do {
+//                    output[_out++] = 0;
+//                  } while (--len);
+//                  continue top;
+//                }
+//                len -= op - whave;
+//                do {
+//                  output[_out++] = 0;
+//                } while (--op > whave);
+//                if (op === 0) {
+//                  from = _out - dist;
+//                  do {
+//                    output[_out++] = output[from++];
+//                  } while (--len);
+//                  continue top;
+//                }
+//#endif
+              }
+              from = 0; // window index
+              from_source = s_window;
+              if (wnext === 0) {           /* very common case */
+                from += wsize - op;
+                if (op < len) {         /* some from window */
+                  len -= op;
+                  do {
+                    output[_out++] = s_window[from++];
+                  } while (--op);
+                  from = _out - dist;  /* rest from output */
+                  from_source = output;
+                }
+              }
+              else if (wnext < op) {      /* wrap around window */
+                from += wsize + wnext - op;
+                op -= wnext;
+                if (op < len) {         /* some from end of window */
+                  len -= op;
+                  do {
+                    output[_out++] = s_window[from++];
+                  } while (--op);
+                  from = 0;
+                  if (wnext < len) {  /* some from start of window */
+                    op = wnext;
+                    len -= op;
+                    do {
+                      output[_out++] = s_window[from++];
+                    } while (--op);
+                    from = _out - dist;      /* rest from output */
+                    from_source = output;
+                  }
+                }
+              }
+              else {                      /* contiguous in window */
+                from += wnext - op;
+                if (op < len) {         /* some from window */
+                  len -= op;
+                  do {
+                    output[_out++] = s_window[from++];
+                  } while (--op);
+                  from = _out - dist;  /* rest from output */
+                  from_source = output;
+                }
+              }
+              while (len > 2) {
+                output[_out++] = from_source[from++];
+                output[_out++] = from_source[from++];
+                output[_out++] = from_source[from++];
+                len -= 3;
+              }
+              if (len) {
+                output[_out++] = from_source[from++];
+                if (len > 1) {
+                  output[_out++] = from_source[from++];
+                }
+              }
+            }
+            else {
+              from = _out - dist;          /* copy direct from output */
+              do {                        /* minimum length is three */
+                output[_out++] = output[from++];
+                output[_out++] = output[from++];
+                output[_out++] = output[from++];
+                len -= 3;
+              } while (len > 2);
+              if (len) {
+                output[_out++] = output[from++];
+                if (len > 1) {
+                  output[_out++] = output[from++];
+                }
+              }
+            }
+          }
+          else if ((op & 64) === 0) {          /* 2nd level distance code */
+            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
+            continue dodist;
+          }
+          else {
+            strm.msg = 'invalid distance code';
+            state.mode = BAD;
+            break top;
+          }
+
+          break; // need to emulate goto via "continue"
+        }
+      }
+      else if ((op & 64) === 0) {              /* 2nd level length code */
+        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
+        continue dolen;
+      }
+      else if (op & 32) {                     /* end-of-block */
+        //Tracevv((stderr, "inflate:         end of block\n"));
+        state.mode = TYPE;
+        break top;
+      }
+      else {
+        strm.msg = 'invalid literal/length code';
+        state.mode = BAD;
+        break top;
+      }
+
+      break; // need to emulate goto via "continue"
+    }
+  } while (_in < last && _out < end);
+
+  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
+  len = bits >> 3;
+  _in -= len;
+  bits -= len << 3;
+  hold &= (1 << bits) - 1;
+
+  /* update state and return */
+  strm.next_in = _in;
+  strm.next_out = _out;
+  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
+  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
+  state.hold = hold;
+  state.bits = bits;
+  return;
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static-production/novnc/vendor/pako/lib/zlib/inflate.js
@@ -0,0 +1,1527 @@
+import * as utils from "../utils/common.js";
+import adler32 from "./adler32.js";
+import crc32 from "./crc32.js";
+import inflate_fast from "./inffast.js";
+import inflate_table from "./inftrees.js";
+
+var CODES = 0;
+var LENS = 1;
+var DISTS = 2;
+
+/* Public constants ==========================================================*/
+/* ===========================================================================*/
+
+
+/* Allowed flush values; see deflate() and inflate() below for details */
+//export const Z_NO_FLUSH      = 0;
+//export const Z_PARTIAL_FLUSH = 1;
+//export const Z_SYNC_FLUSH    = 2;
+//export const Z_FULL_FLUSH    = 3;
+export const Z_FINISH        = 4;
+export const Z_BLOCK         = 5;
+export const Z_TREES         = 6;
+
+
+/* Return codes for the compression/decompression functions. Negative values
+ * are errors, positive values are used for special but normal events.
+ */
+export const Z_OK            = 0;
+export const Z_STREAM_END    = 1;
+export const Z_NEED_DICT     = 2;
+//export const Z_ERRNO         = -1;
+export const Z_STREAM_ERROR  = -2;
+export const Z_DATA_ERROR    = -3;
+export const Z_MEM_ERROR     = -4;
+export const Z_BUF_ERROR     = -5;
+//export const Z_VERSION_ERROR = -6;
+
+/* The deflate compression method */
+export const Z_DEFLATED  = 8;
+
+
+/* STATES ====================================================================*/
+/* ===========================================================================*/
+
+
+var    HEAD = 1;       /* i: waiting for magic header */
+var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
+var    TIME = 3;       /* i: waiting for modification time (gzip) */
+var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
+var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
+var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
+var    NAME = 7;       /* i: waiting for end of file name (gzip) */
+var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
+var    HCRC = 9;       /* i: waiting for header crc (gzip) */
+var    DICTID = 10;    /* i: waiting for dictionary check value */
+var    DICT = 11;      /* waiting for inflateSetDictionary() call */
+var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
+var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
+var        STORED = 14;    /* i: waiting for stored size (length and complement) */
+var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
+var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
+var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
+var        LENLENS = 18;   /* i: waiting for code length code lengths */
+var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
+var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
+var            LEN = 21;       /* i: waiting for length/lit/eob code */
+var            LENEXT = 22;    /* i: waiting for length extra bits */
+var            DIST = 23;      /* i: waiting for distance code */
+var            DISTEXT = 24;   /* i: waiting for distance extra bits */
+var            MATCH = 25;     /* o: waiting for output space to copy string */
+var            LIT = 26;       /* o: waiting for output space to write literal */
+var    CHECK = 27;     /* i: waiting for 32-bit check value */
+var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
+var    DONE = 29;      /* finished check, done -- remain here until reset */
+var    BAD = 30;       /* got a data error -- remain here until reset */
+var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
+var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */
+
+/* ===========================================================================*/
+
+
+
+var ENOUGH_LENS = 852;
+var ENOUGH_DISTS = 592;
+//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);
+
+var MAX_WBITS = 15;
+/* 32K LZ77 window */
+var DEF_WBITS = MAX_WBITS;
+
+
+function zswap32(q) {
+  return  (((q >>> 24) & 0xff) +
+          ((q >>> 8) & 0xff00) +
+          ((q & 0xff00) << 8) +
+          ((q & 0xff) << 24));
+}
+
+
+function InflateState() {
+  this.mode = 0;             /* current inflate mode */
+  this.last = false;          /* true if processing last block */
+  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
+  this.havedict = false;      /* true if dictionary provided */
+  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
+  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
+  this.check = 0;             /* protected copy of check value */
+  this.total = 0;             /* protected copy of output count */
+  // TODO: may be {}
+  this.head = null;           /* where to save gzip header information */
+
+  /* sliding window */
+  this.wbits = 0;             /* log base 2 of requested window size */
+  this.wsize = 0;             /* window size or zero if not using window */
+  this.whave = 0;             /* valid bytes in the window */
+  this.wnext = 0;             /* window write index */
+  this.window = null;         /* allocated sliding window, if needed */
+
+  /* bit accumulator */
+  this.hold = 0;              /* input bit accumulator */
+  this.bits = 0;              /* number of bits in "in" */
+
+  /* for string and stored block copying */
+  this.length = 0;            /* literal or length of data to copy */
+  this.offset = 0;            /* distance back to copy string from */
+
+  /* for table and code decoding */
+  this.extra = 0;             /* extra bits needed */
+
+  /* fixed and dynamic code tables */
+  this.lencode = null;          /* starting table for length/literal codes */
+  this.distcode = null;         /* starting table for distance codes */
+  this.lenbits = 0;           /* index bits for lencode */
+  this.distbits = 0;          /* index bits for distcode */
+
+  /* dynamic table building */
+  this.ncode = 0;             /* number of code length code lengths */
+  this.nlen = 0;              /* number of length code lengths */
+  this.ndist = 0;             /* number of distance code lengths */
+  this.have = 0;              /* number of code lengths in lens[] */
+  this.next = null;              /* next available space in codes[] */
+
+  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
+  this.work = new utils.Buf16(288); /* work area for code table building */
+
+  /*
+   because we don't have pointers in js, we use lencode and distcode directly
+   as buffers so we don't need codes
+  */
+  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
+  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
+  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
+  this.sane = 0;                   /* if false, allow invalid distance too far */
+  this.back = 0;                   /* bits back of last unprocessed length/lit */
+  this.was = 0;                    /* initial length of match */
+}
+
+function inflateResetKeep(strm) {
+  var state;
+
+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
+  state = strm.state;
+  strm.total_in = strm.total_out = state.total = 0;
+  strm.msg = ''; /*Z_NULL*/
+  if (state.wrap) {       /* to support ill-conceived Java test suite */
+    strm.adler = state.wrap & 1;
+  }
+  state.mode = HEAD;
+  state.last = 0;
+  state.havedict = 0;
+  state.dmax = 32768;
+  state.head = null/*Z_NULL*/;
+  state.hold = 0;
+  state.bits = 0;
+  //state.lencode = state.distcode = state.next = state.codes;
+  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
+  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
+
+  state.sane = 1;
+  state.back = -1;
+  //Tracev((stderr, "inflate: reset\n"));
+  return Z_OK;
+}
+
+function inflateReset(strm) {
+  var state;
+
+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
+  state = strm.state;
+  state.wsize = 0;
+  state.whave = 0;
+  state.wnext = 0;
+  return inflateResetKeep(strm);
+
+}
+
+function inflateReset2(strm, windowBits) {
+  var wrap;
+  var state;
+
+  /* get the state */
+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
+  state = strm.state;
+
+  /* extract wrap request from windowBits parameter */
+  if (windowBits < 0) {
+    wrap = 0;
+    windowBits = -windowBits;
+  }
+  else {
+    wrap = (windowBits >> 4) + 1;
+    if (windowBits < 48) {
+      windowBits &= 15;
+    }
+  }
+
+  /* set number of window bits, free window if different */
+  if (windowBits && (windowBits < 8 || windowBits > 15)) {
+    return Z_STREAM_ERROR;
+  }
+  if (state.window !== null && state.wbits !== windowBits) {
+    state.window = null;
+  }
+
+  /* update state and reset the rest of it */
+  state.wrap = wrap;
+  state.wbits = windowBits;
+  return inflateReset(strm);
+}
+
+function inflateInit2(strm, windowBits) {
+  var ret;
+  var state;
+
+  if (!strm) { return Z_STREAM_ERROR; }
+  //strm.msg = Z_NULL;                 /* in case we return an error */
+
+  state = new InflateState();
+
+  //if (state === Z_NULL) return Z_MEM_ERROR;
+  //Tracev((stderr, "inflate: allocated\n"));
+  strm.state = state;
+  state.window = null/*Z_NULL*/;
+  ret = inflateReset2(strm, windowBits);
+  if (ret !== Z_OK) {
+    strm.state = null/*Z_NULL*/;
+  }
+  return ret;
+}
+
+function inflateInit(strm) {
+  return inflateInit2(strm, DEF_WBITS);
+}
+
+
+/*
+ Return state with length and distance decoding tables and index sizes set to
+ fixed code decoding.  Normally this returns fixed tables from inffixed.h.
+ If BUILDFIXED is defined, then instead this routine builds the tables the
+ first time it's called, and returns those tables the first time and
+ thereafter.  This reduces the size of the code by about 2K bytes, in
+ exchange for a little execution time.  However, BUILDFIXED should not be
+ used for threaded applications, since the rewriting of the tables and virgin
+ may not be thread-safe.
+ */
+var virgin = true;
+
+var lenfix, distfix; // We have no pointers in JS, so keep tables separate
+
+function fixedtables(state) {
+  /* build fixed huffman tables if first call (may not be thread safe) */
+  if (virgin) {
+    var sym;
+
+    lenfix = new utils.Buf32(512);
+    distfix = new utils.Buf32(32);
+
+    /* literal/length table */
+    sym = 0;
+    while (sym < 144) { state.lens[sym++] = 8; }
+    while (sym < 256) { state.lens[sym++] = 9; }
+    while (sym < 280) { state.lens[sym++] = 7; }
+    while (sym < 288) { state.lens[sym++] = 8; }
+
+    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });
+
+    /* distance table */
+    sym = 0;
+    while (sym < 32) { state.lens[sym++] = 5; }
+
+    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });
+
+    /* do this just once */
+    virgin = false;
+  }
+
+  state.lencode = lenfix;
+  state.lenbits = 9;
+  state.distcode = distfix;
+  state.distbits = 5;
+}
+
+
+/*
+ Update the window with the last wsize (normally 32K) bytes written before
+ returning.  If window does not exist yet, create it.  This is only called
+ when a window is already in use, or when output has been written during this
+ inflate call, but the end of the deflate stream has not been reached yet.
+ It is also called to create a window for dictionary data when a dictionary
+ is loaded.
+
+ Providing output buffers larger than 32K to inflate() should provide a speed
+ advantage, since only the last 32K of output is copied to the sliding window
+ upon return from inflate(), and since all distances after the first 32K of
+ output will fall in the output data, making match copies simpler and faster.
+ The advantage may be dependent on the size of the processor's data caches.
+ */
+function updatewindow(strm, src, end, copy) {
+  var dist;
+  var state = strm.state;
+
+  /* if it hasn't been done already, allocate space for the window */
+  if (state.window === null) {
+    state.wsize = 1 << state.wbits;
+    state.wnext = 0;
+    state.whave = 0;
+
+    state.window = new utils.Buf8(state.wsize);
+  }
+
+  /* copy state->wsize or less output bytes into the circular window */
+  if (copy >= state.wsize) {
+    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
+    state.wnext = 0;
+    state.whave = state.wsize;
+  }
+  else {
+    dist = state.wsize - state.wnext;
+    if (dist > copy) {
+      dist = copy;
+    }
+    //zmemcpy(state->window + state->wnext, end - copy, dist);
+    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
+    copy -= dist;
+    if (copy) {
+      //zmemcpy(state->window, end - copy, copy);
+      utils.arraySet(state.window, src, end - copy, copy, 0);
+      state.wnext = copy;
+      state.whave = state.wsize;
+    }
+    else {
+      state.wnext += dist;
+      if (state.wnext === state.wsize) { state.wnext = 0; }
+      if (state.whave < state.wsize) { state.whave += dist; }
+    }
+  }
+  return 0;
+}
+
+function inflate(strm, flush) {
+  var state;
+  var input, output;          // input/output buffers
+  var next;                   /* next input INDEX */
+  var put;                    /* next output INDEX */
+  var have, left;             /* available input and output */
+  var hold;                   /* bit buffer */
+  var bits;                   /* bits in bit buffer */
+  var _in, _out;              /* save starting available input and output */
+  var copy;                   /* number of stored or match bytes to copy */
+  var from;                   /* where to copy match bytes from */
+  var from_source;
+  var here = 0;               /* current decoding table entry */
+  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
+  //var last;                   /* parent table entry */
+  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
+  var len;                    /* length to copy for repeats, bits to drop */
+  var ret;                    /* return code */
+  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
+  var opts;
+
+  var n; // temporary var for NEED_BITS
+
+  var order = /* permutation of code lengths */
+    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
+
+
+  if (!strm || !strm.state || !strm.output ||
+      (!strm.input && strm.avail_in !== 0)) {
+    return Z_STREAM_ERROR;
+  }
+
+  state = strm.state;
+  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */
+
+
+  //--- LOAD() ---
+  put = strm.next_out;
+  output = strm.output;
+  left = strm.avail_out;
+  next = strm.next_in;
+  input = strm.input;
+  have = strm.avail_in;
+  hold = state.hold;
+  bits = state.bits;
+  //---
+
+  _in = have;
+  _out = left;
+  ret = Z_OK;
+
+  inf_leave: // goto emulation
+  for (;;) {
+    switch (state.mode) {
+    case HEAD:
+      if (state.wrap === 0) {
+        state.mode = TYPEDO;
+        break;
+      }
+      //=== NEEDBITS(16);
+      while (bits < 16) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
+        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
+        //=== CRC2(state.check, hold);
+        hbuf[0] = hold & 0xff;
+        hbuf[1] = (hold >>> 8) & 0xff;
+        state.check = crc32(state.check, hbuf, 2, 0);
+        //===//
+
+        //=== INITBITS();
+        hold = 0;
+        bits = 0;
+        //===//
+        state.mode = FLAGS;
+        break;
+      }
+      state.flags = 0;           /* expect zlib header */
+      if (state.head) {
+        state.head.done = false;
+      }
+      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
+        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
+        strm.msg = 'incorrect header check';
+        state.mode = BAD;
+        break;
+      }
+      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
+        strm.msg = 'unknown compression method';
+        state.mode = BAD;
+        break;
+      }
+      //--- DROPBITS(4) ---//
+      hold >>>= 4;
+      bits -= 4;
+      //---//
+      len = (hold & 0x0f)/*BITS(4)*/ + 8;
+      if (state.wbits === 0) {
+        state.wbits = len;
+      }
+      else if (len > state.wbits) {
+        strm.msg = 'invalid window size';
+        state.mode = BAD;
+        break;
+      }
+      state.dmax = 1 << len;
+      //Tracev((stderr, "inflate:   zlib header ok\n"));
+      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
+      state.mode = hold & 0x200 ? DICTID : TYPE;
+      //=== INITBITS();
+      hold = 0;
+      bits = 0;
+      //===//
+      break;
+    case FLAGS:
+      //=== NEEDBITS(16); */
+      while (bits < 16) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      state.flags = hold;
+      if ((state.flags & 0xff) !== Z_DEFLATED) {
+        strm.msg = 'unknown compression method';
+        state.mode = BAD;
+        break;
+      }
+      if (state.flags & 0xe000) {
+        strm.msg = 'unknown header flags set';
+        state.mode = BAD;
+        break;
+      }
+      if (state.head) {
+        state.head.text = ((hold >> 8) & 1);
+      }
+      if (state.flags & 0x0200) {
+        //=== CRC2(state.check, hold);
+        hbuf[0] = hold & 0xff;
+        hbuf[1] = (hold >>> 8) & 0xff;
+        state.check = crc32(state.check, hbuf, 2, 0);
+        //===//
+      }
+      //=== INITBITS();
+      hold = 0;
+      bits = 0;
+      //===//
+      state.mode = TIME;
+      /* falls through */
+    case TIME:
+      //=== NEEDBITS(32); */
+      while (bits < 32) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      if (state.head) {
+        state.head.time = hold;
+      }
+      if (state.flags & 0x0200) {
+        //=== CRC4(state.check, hold)
+        hbuf[0] = hold & 0xff;
+        hbuf[1] = (hold >>> 8) & 0xff;
+        hbuf[2] = (hold >>> 16) & 0xff;
+        hbuf[3] = (hold >>> 24) & 0xff;
+        state.check = crc32(state.check, hbuf, 4, 0);
+        //===
+      }
+      //=== INITBITS();
+      hold = 0;
+      bits = 0;
+      //===//
+      state.mode = OS;
+      /* falls through */
+    case OS:
+      //=== NEEDBITS(16); */
+      while (bits < 16) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      if (state.head) {
+        state.head.xflags = (hold & 0xff);
+        state.head.os = (hold >> 8);
+      }
+      if (state.flags & 0x0200) {
+        //=== CRC2(state.check, hold);
+        hbuf[0] = hold & 0xff;
+        hbuf[1] = (hold >>> 8) & 0xff;
+        state.check = crc32(state.check, hbuf, 2, 0);
+        //===//
+      }
+      //=== INITBITS();
+      hold = 0;
+      bits = 0;
+      //===//
+      state.mode = EXLEN;
+      /* falls through */
+    case EXLEN:
+      if (state.flags & 0x0400) {
+        //=== NEEDBITS(16); */
+        while (bits < 16) {
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+        }
+        //===//
+        state.length = hold;
+        if (state.head) {
+          state.head.extra_len = hold;
+        }
+        if (state.flags & 0x0200) {
+          //=== CRC2(state.check, hold);
+          hbuf[0] = hold & 0xff;
+          hbuf[1] = (hold >>> 8) & 0xff;
+          state.check = crc32(state.check, hbuf, 2, 0);
+          //===//
+        }
+        //=== INITBITS();
+        hold = 0;
+        bits = 0;
+        //===//
+      }
+      else if (state.head) {
+        state.head.extra = null/*Z_NULL*/;
+      }
+      state.mode = EXTRA;
+      /* falls through */
+    case EXTRA:
+      if (state.flags & 0x0400) {
+        copy = state.length;
+        if (copy > have) { copy = have; }
+        if (copy) {
+          if (state.head) {
+            len = state.head.extra_len - state.length;
+            if (!state.head.extra) {
+              // Use untyped array for more conveniend processing later
+              state.head.extra = new Array(state.head.extra_len);
+            }
+            utils.arraySet(
+              state.head.extra,
+              input,
+              next,
+              // extra field is limited to 65536 bytes
+              // - no need for additional size check
+              copy,
+              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
+              len
+            );
+            //zmemcpy(state.head.extra + len, next,
+            //        len + copy > state.head.extra_max ?
+            //        state.head.extra_max - len : copy);
+          }
+          if (state.flags & 0x0200) {
+            state.check = crc32(state.check, input, copy, next);
+          }
+          have -= copy;
+          next += copy;
+          state.length -= copy;
+        }
+        if (state.length) { break inf_leave; }
+      }
+      state.length = 0;
+      state.mode = NAME;
+      /* falls through */
+    case NAME:
+      if (state.flags & 0x0800) {
+        if (have === 0) { break inf_leave; }
+        copy = 0;
+        do {
+          // TODO: 2 or 1 bytes?
+          len = input[next + copy++];
+          /* use constant limit because in js we should not preallocate memory */
+          if (state.head && len &&
+              (state.length < 65536 /*state.head.name_max*/)) {
+            state.head.name += String.fromCharCode(len);
+          }
+        } while (len && copy < have);
+
+        if (state.flags & 0x0200) {
+          state.check = crc32(state.check, input, copy, next);
+        }
+        have -= copy;
+        next += copy;
+        if (len) { break inf_leave; }
+      }
+      else if (state.head) {
+        state.head.name = null;
+      }
+      state.length = 0;
+      state.mode = COMMENT;
+      /* falls through */
+    case COMMENT:
+      if (state.flags & 0x1000) {
+        if (have === 0) { break inf_leave; }
+        copy = 0;
+        do {
+          len = input[next + copy++];
+          /* use constant limit because in js we should not preallocate memory */
+          if (state.head && len &&
+              (state.length < 65536 /*state.head.comm_max*/)) {
+            state.head.comment += String.fromCharCode(len);
+          }
+        } while (len && copy < have);
+        if (state.flags & 0x0200) {
+          state.check = crc32(state.check, input, copy, next);
+        }
+        have -= copy;
+        next += copy;
+        if (len) { break inf_leave; }
+      }
+      else if (state.head) {
+        state.head.comment = null;
+      }
+      state.mode = HCRC;
+      /* falls through */
+    case HCRC:
+      if (state.flags & 0x0200) {
+        //=== NEEDBITS(16); */
+        while (bits < 16) {
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+        }
+        //===//
+        if (hold !== (state.check & 0xffff)) {
+          strm.msg = 'header crc mismatch';
+          state.mode = BAD;
+          break;
+        }
+        //=== INITBITS();
+        hold = 0;
+        bits = 0;
+        //===//
+      }
+      if (state.head) {
+        state.head.hcrc = ((state.flags >> 9) & 1);
+        state.head.done = true;
+      }
+      strm.adler = state.check = 0;
+      state.mode = TYPE;
+      break;
+    case DICTID:
+      //=== NEEDBITS(32); */
+      while (bits < 32) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      strm.adler = state.check = zswap32(hold);
+      //=== INITBITS();
+      hold = 0;
+      bits = 0;
+      //===//
+      state.mode = DICT;
+      /* falls through */
+    case DICT:
+      if (state.havedict === 0) {
+        //--- RESTORE() ---
+        strm.next_out = put;
+        strm.avail_out = left;
+        strm.next_in = next;
+        strm.avail_in = have;
+        state.hold = hold;
+        state.bits = bits;
+        //---
+        return Z_NEED_DICT;
+      }
+      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
+      state.mode = TYPE;
+      /* falls through */
+    case TYPE:
+      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
+      /* falls through */
+    case TYPEDO:
+      if (state.last) {
+        //--- BYTEBITS() ---//
+        hold >>>= bits & 7;
+        bits -= bits & 7;
+        //---//
+        state.mode = CHECK;
+        break;
+      }
+      //=== NEEDBITS(3); */
+      while (bits < 3) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      state.last = (hold & 0x01)/*BITS(1)*/;
+      //--- DROPBITS(1) ---//
+      hold >>>= 1;
+      bits -= 1;
+      //---//
+
+      switch ((hold & 0x03)/*BITS(2)*/) {
+      case 0:                             /* stored block */
+        //Tracev((stderr, "inflate:     stored block%s\n",
+        //        state.last ? " (last)" : ""));
+        state.mode = STORED;
+        break;
+      case 1:                             /* fixed block */
+        fixedtables(state);
+        //Tracev((stderr, "inflate:     fixed codes block%s\n",
+        //        state.last ? " (last)" : ""));
+        state.mode = LEN_;             /* decode codes */
+        if (flush === Z_TREES) {
+          //--- DROPBITS(2) ---//
+          hold >>>= 2;
+          bits -= 2;
+          //---//
+          break inf_leave;
+        }
+        break;
+      case 2:                             /* dynamic block */
+        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
+        //        state.last ? " (last)" : ""));
+        state.mode = TABLE;
+        break;
+      case 3:
+        strm.msg = 'invalid block type';
+        state.mode = BAD;
+      }
+      //--- DROPBITS(2) ---//
+      hold >>>= 2;
+      bits -= 2;
+      //---//
+      break;
+    case STORED:
+      //--- BYTEBITS() ---// /* go to byte boundary */
+      hold >>>= bits & 7;
+      bits -= bits & 7;
+      //---//
+      //=== NEEDBITS(32); */
+      while (bits < 32) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
+        strm.msg = 'invalid stored block lengths';
+        state.mode = BAD;
+        break;
+      }
+      state.length = hold & 0xffff;
+      //Tracev((stderr, "inflate:       stored length %u\n",
+      //        state.length));
+      //=== INITBITS();
+      hold = 0;
+      bits = 0;
+      //===//
+      state.mode = COPY_;
+      if (flush === Z_TREES) { break inf_leave; }
+      /* falls through */
+    case COPY_:
+      state.mode = COPY;
+      /* falls through */
+    case COPY:
+      copy = state.length;
+      if (copy) {
+        if (copy > have) { copy = have; }
+        if (copy > left) { copy = left; }
+        if (copy === 0) { break inf_leave; }
+        //--- zmemcpy(put, next, copy); ---
+        utils.arraySet(output, input, next, copy, put);
+        //---//
+        have -= copy;
+        next += copy;
+        left -= copy;
+        put += copy;
+        state.length -= copy;
+        break;
+      }
+      //Tracev((stderr, "inflate:       stored end\n"));
+      state.mode = TYPE;
+      break;
+    case TABLE:
+      //=== NEEDBITS(14); */
+      while (bits < 14) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
+      //--- DROPBITS(5) ---//
+      hold >>>= 5;
+      bits -= 5;
+      //---//
+      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
+      //--- DROPBITS(5) ---//
+      hold >>>= 5;
+      bits -= 5;
+      //---//
+      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
+      //--- DROPBITS(4) ---//
+      hold >>>= 4;
+      bits -= 4;
+      //---//
+//#ifndef PKZIP_BUG_WORKAROUND
+      if (state.nlen > 286 || state.ndist > 30) {
+        strm.msg = 'too many length or distance symbols';
+        state.mode = BAD;
+        break;
+      }
+//#endif
+      //Tracev((stderr, "inflate:       table sizes ok\n"));
+      state.have = 0;
+      state.mode = LENLENS;
+      /* falls through */
+    case LENLENS:
+      while (state.have < state.ncode) {
+        //=== NEEDBITS(3);
+        while (bits < 3) {
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+        }
+        //===//
+        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
+        //--- DROPBITS(3) ---//
+        hold >>>= 3;
+        bits -= 3;
+        //---//
+      }
+      while (state.have < 19) {
+        state.lens[order[state.have++]] = 0;
+      }
+      // We have separate tables & no pointers. 2 commented lines below not needed.
+      //state.next = state.codes;
+      //state.lencode = state.next;
+      // Switch to use dynamic table
+      state.lencode = state.lendyn;
+      state.lenbits = 7;
+
+      opts = { bits: state.lenbits };
+      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
+      state.lenbits = opts.bits;
+
+      if (ret) {
+        strm.msg = 'invalid code lengths set';
+        state.mode = BAD;
+        break;
+      }
+      //Tracev((stderr, "inflate:       code lengths ok\n"));
+      state.have = 0;
+      state.mode = CODELENS;
+      /* falls through */
+    case CODELENS:
+      while (state.have < state.nlen + state.ndist) {
+        for (;;) {
+          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
+          here_bits = here >>> 24;
+          here_op = (here >>> 16) & 0xff;
+          here_val = here & 0xffff;
+
+          if ((here_bits) <= bits) { break; }
+          //--- PULLBYTE() ---//
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+          //---//
+        }
+        if (here_val < 16) {
+          //--- DROPBITS(here.bits) ---//
+          hold >>>= here_bits;
+          bits -= here_bits;
+          //---//
+          state.lens[state.have++] = here_val;
+        }
+        else {
+          if (here_val === 16) {
+            //=== NEEDBITS(here.bits + 2);
+            n = here_bits + 2;
+            while (bits < n) {
+              if (have === 0) { break inf_leave; }
+              have--;
+              hold += input[next++] << bits;
+              bits += 8;
+            }
+            //===//
+            //--- DROPBITS(here.bits) ---//
+            hold >>>= here_bits;
+            bits -= here_bits;
+            //---//
+            if (state.have === 0) {
+              strm.msg = 'invalid bit length repeat';
+              state.mode = BAD;
+              break;
+            }
+            len = state.lens[state.have - 1];
+            copy = 3 + (hold & 0x03);//BITS(2);
+            //--- DROPBITS(2) ---//
+            hold >>>= 2;
+            bits -= 2;
+            //---//
+          }
+          else if (here_val === 17) {
+            //=== NEEDBITS(here.bits + 3);
+            n = here_bits + 3;
+            while (bits < n) {
+              if (have === 0) { break inf_leave; }
+              have--;
+              hold += input[next++] << bits;
+              bits += 8;
+            }
+            //===//
+            //--- DROPBITS(here.bits) ---//
+            hold >>>= here_bits;
+            bits -= here_bits;
+            //---//
+            len = 0;
+            copy = 3 + (hold & 0x07);//BITS(3);
+            //--- DROPBITS(3) ---//
+            hold >>>= 3;
+            bits -= 3;
+            //---//
+          }
+          else {
+            //=== NEEDBITS(here.bits + 7);
+            n = here_bits + 7;
+            while (bits < n) {
+              if (have === 0) { break inf_leave; }
+              have--;
+              hold += input[next++] << bits;
+              bits += 8;
+            }
+            //===//
+            //--- DROPBITS(here.bits) ---//
+            hold >>>= here_bits;
+            bits -= here_bits;
+            //---//
+            len = 0;
+            copy = 11 + (hold & 0x7f);//BITS(7);
+            //--- DROPBITS(7) ---//
+            hold >>>= 7;
+            bits -= 7;
+            //---//
+          }
+          if (state.have + copy > state.nlen + state.ndist) {
+            strm.msg = 'invalid bit length repeat';
+            state.mode = BAD;
+            break;
+          }
+          while (copy--) {
+            state.lens[state.have++] = len;
+          }
+        }
+      }
+
+      /* handle error breaks in while */
+      if (state.mode === BAD) { break; }
+
+      /* check for end-of-block code (better have one) */
+      if (state.lens[256] === 0) {
+        strm.msg = 'invalid code -- missing end-of-block';
+        state.mode = BAD;
+        break;
+      }
+
+      /* build code tables -- note: do not change the lenbits or distbits
+         values here (9 and 6) without reading the comments in inftrees.h
+         concerning the ENOUGH constants, which depend on those values */
+      state.lenbits = 9;
+
+      opts = { bits: state.lenbits };
+      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
+      // We have separate tables & no pointers. 2 commented lines below not needed.
+      // state.next_index = opts.table_index;
+      state.lenbits = opts.bits;
+      // state.lencode = state.next;
+
+      if (ret) {
+        strm.msg = 'invalid literal/lengths set';
+        state.mode = BAD;
+        break;
+      }
+
+      state.distbits = 6;
+      //state.distcode.copy(state.codes);
+      // Switch to use dynamic table
+      state.distcode = state.distdyn;
+      opts = { bits: state.distbits };
+      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
+      // We have separate tables & no pointers. 2 commented lines below not needed.
+      // state.next_index = opts.table_index;
+      state.distbits = opts.bits;
+      // state.distcode = state.next;
+
+      if (ret) {
+        strm.msg = 'invalid distances set';
+        state.mode = BAD;
+        break;
+      }
+      //Tracev((stderr, 'inflate:       codes ok\n'));
+      state.mode = LEN_;
+      if (flush === Z_TREES) { break inf_leave; }
+      /* falls through */
+    case LEN_:
+      state.mode = LEN;
+      /* falls through */
+    case LEN:
+      if (have >= 6 && left >= 258) {
+        //--- RESTORE() ---
+        strm.next_out = put;
+        strm.avail_out = left;
+        strm.next_in = next;
+        strm.avail_in = have;
+        state.hold = hold;
+        state.bits = bits;
+        //---
+        inflate_fast(strm, _out);
+        //--- LOAD() ---
+        put = strm.next_out;
+        output = strm.output;
+        left = strm.avail_out;
+        next = strm.next_in;
+        input = strm.input;
+        have = strm.avail_in;
+        hold = state.hold;
+        bits = state.bits;
+        //---
+
+        if (state.mode === TYPE) {
+          state.back = -1;
+        }
+        break;
+      }
+      state.back = 0;
+      for (;;) {
+        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
+        here_bits = here >>> 24;
+        here_op = (here >>> 16) & 0xff;
+        here_val = here & 0xffff;
+
+        if (here_bits <= bits) { break; }
+        //--- PULLBYTE() ---//
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+        //---//
+      }
+      if (here_op && (here_op & 0xf0) === 0) {
+        last_bits = here_bits;
+        last_op = here_op;
+        last_val = here_val;
+        for (;;) {
+          here = state.lencode[last_val +
+                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
+          here_bits = here >>> 24;
+          here_op = (here >>> 16) & 0xff;
+          here_val = here & 0xffff;
+
+          if ((last_bits + here_bits) <= bits) { break; }
+          //--- PULLBYTE() ---//
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+          //---//
+        }
+        //--- DROPBITS(last.bits) ---//
+        hold >>>= last_bits;
+        bits -= last_bits;
+        //---//
+        state.back += last_bits;
+      }
+      //--- DROPBITS(here.bits) ---//
+      hold >>>= here_bits;
+      bits -= here_bits;
+      //---//
+      state.back += here_bits;
+      state.length = here_val;
+      if (here_op === 0) {
+        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
+        //        "inflate:         literal '%c'\n" :
+        //        "inflate:         literal 0x%02x\n", here.val));
+        state.mode = LIT;
+        break;
+      }
+      if (here_op & 32) {
+        //Tracevv((stderr, "inflate:         end of block\n"));
+        state.back = -1;
+        state.mode = TYPE;
+        break;
+      }
+      if (here_op & 64) {
+        strm.msg = 'invalid literal/length code';
+        state.mode = BAD;
+        break;
+      }
+      state.extra = here_op & 15;
+      state.mode = LENEXT;
+      /* falls through */
+    case LENEXT:
+      if (state.extra) {
+        //=== NEEDBITS(state.extra);
+        n = state.extra;
+        while (bits < n) {
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+        }
+        //===//
+        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
+        //--- DROPBITS(state.extra) ---//
+        hold >>>= state.extra;
+        bits -= state.extra;
+        //---//
+        state.back += state.extra;
+      }
+      //Tracevv((stderr, "inflate:         length %u\n", state.length));
+      state.was = state.length;
+      state.mode = DIST;
+      /* falls through */
+    case DIST:
+      for (;;) {
+        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
+        here_bits = here >>> 24;
+        here_op = (here >>> 16) & 0xff;
+        here_val = here & 0xffff;
+
+        if ((here_bits) <= bits) { break; }
+        //--- PULLBYTE() ---//
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+        //---//
+      }
+      if ((here_op & 0xf0) === 0) {
+        last_bits = here_bits;
+        last_op = here_op;
+        last_val = here_val;
+        for (;;) {
+          here = state.distcode[last_val +
+                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
+          here_bits = here >>> 24;
+          here_op = (here >>> 16) & 0xff;
+          here_val = here & 0xffff;
+
+          if ((last_bits + here_bits) <= bits) { break; }
+          //--- PULLBYTE() ---//
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+          //---//
+        }
+        //--- DROPBITS(last.bits) ---//
+        hold >>>= last_bits;
+        bits -= last_bits;
+        //---//
+        state.back += last_bits;
+      }
+      //--- DROPBITS(here.bits) ---//
+      hold >>>= here_bits;
+      bits -= here_bits;
+      //---//
+      state.back += here_bits;
+      if (here_op & 64) {
+        strm.msg = 'invalid distance code';
+        state.mode = BAD;
+        break;
+      }
+      state.offset = here_val;
+      state.extra = (here_op) & 15;
+      state.mode = DISTEXT;
+      /* falls through */
+    case DISTEXT:
+      if (state.extra) {
+        //=== NEEDBITS(state.extra);
+        n = state.extra;
+        while (bits < n) {
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+        }
+        //===//
+        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
+        //--- DROPBITS(state.extra) ---//
+        hold >>>= state.extra;
+        bits -= state.extra;
+        //---//
+        state.back += state.extra;
+      }
+//#ifdef INFLATE_STRICT
+      if (state.offset > state.dmax) {
+        strm.msg = 'invalid distance too far back';
+        state.mode = BAD;
+        break;
+      }
+//#endif
+      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
+      state.mode = MATCH;
+      /* falls through */
+    case MATCH:
+      if (left === 0) { break inf_leave; }
+      copy = _out - left;
+      if (state.offset > copy) {         /* copy from window */
+        copy = state.offset - copy;
+        if (copy > state.whave) {
+          if (state.sane) {
+            strm.msg = 'invalid distance too far back';
+            state.mode = BAD;
+            break;
+          }
+// (!) This block is disabled in zlib defailts,
+// don't enable it for binary compatibility
+//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
+//          Trace((stderr, "inflate.c too far\n"));
+//          copy -= state.whave;
+//          if (copy > state.length) { copy = state.length; }
+//          if (copy > left) { copy = left; }
+//          left -= copy;
+//          state.length -= copy;
+//          do {
+//            output[put++] = 0;
+//          } while (--copy);
+//          if (state.length === 0) { state.mode = LEN; }
+//          break;
+//#endif
+        }
+        if (copy > state.wnext) {
+          copy -= state.wnext;
+          from = state.wsize - copy;
+        }
+        else {
+          from = state.wnext - copy;
+        }
+        if (copy > state.length) { copy = state.length; }
+        from_source = state.window;
+      }
+      else {                              /* copy from output */
+        from_source = output;
+        from = put - state.offset;
+        copy = state.length;
+      }
+      if (copy > left) { copy = left; }
+      left -= copy;
+      state.length -= copy;
+      do {
+        output[put++] = from_source[from++];
+      } while (--copy);
+      if (state.length === 0) { state.mode = LEN; }
+      break;
+    case LIT:
+      if (left === 0) { break inf_leave; }
+      output[put++] = state.length;
+      left--;
+      state.mode = LEN;
+      break;
+    case CHECK:
+      if (state.wrap) {
+        //=== NEEDBITS(32);
+        while (bits < 32) {
+          if (have === 0) { break inf_leave; }
+          have--;
+          // Use '|' insdead of '+' to make sure that result is signed
+          hold |= input[next++] << bits;
+          bits += 8;
+        }
+        //===//
+        _out -= left;
+        strm.total_out += _out;
+        state.total += _out;
+        if (_out) {
+          strm.adler = state.check =
+              /*UPDATE(state.check, put - _out, _out);*/
+              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));
+
+        }
+        _out = left;
+        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
+        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
+          strm.msg = 'incorrect data check';
+          state.mode = BAD;
+          break;
+        }
+        //=== INITBITS();
+        hold = 0;
+        bits = 0;
+        //===//
+        //Tracev((stderr, "inflate:   check matches trailer\n"));
+      }
+      state.mode = LENGTH;
+      /* falls through */
+    case LENGTH:
+      if (state.wrap && state.flags) {
+        //=== NEEDBITS(32);
+        while (bits < 32) {
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+        }
+        //===//
+        if (hold !== (state.total & 0xffffffff)) {
+          strm.msg = 'incorrect length check';
+          state.mode = BAD;
+          break;
+        }
+        //=== INITBITS();
+        hold = 0;
+        bits = 0;
+        //===//
+        //Tracev((stderr, "inflate:   length matches trailer\n"));
+      }
+      state.mode = DONE;
+      /* falls through */
+    case DONE:
+      ret = Z_STREAM_END;
+      break inf_leave;
+    case BAD:
+      ret = Z_DATA_ERROR;
+      break inf_leave;
+    case MEM:
+      return Z_MEM_ERROR;
+    case SYNC:
+      /* falls through */
+    default:
+      return Z_STREAM_ERROR;
+    }
+  }
+
+  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"
+
+  /*
+     Return from inflate(), updating the total counts and the check value.
+     If there was no progress during the inflate() call, return a buffer
+     error.  Call updatewindow() to create and/or update the window state.
+     Note: a memory error from inflate() is non-recoverable.
+   */
+
+  //--- RESTORE() ---
+  strm.next_out = put;
+  strm.avail_out = left;
+  strm.next_in = next;
+  strm.avail_in = have;
+  state.hold = hold;
+  state.bits = bits;
+  //---
+
+  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
+                      (state.mode < CHECK || flush !== Z_FINISH))) {
+    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
+      state.mode = MEM;
+      return Z_MEM_ERROR;
+    }
+  }
+  _in -= strm.avail_in;
+  _out -= strm.avail_out;
+  strm.total_in += _in;
+  strm.total_out += _out;
+  state.total += _out;
+  if (state.wrap && _out) {
+    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
+      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
+  }
+  strm.data_type = state.bits + (state.last ? 64 : 0) +
+                    (state.mode === TYPE ? 128 : 0) +
+                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
+  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
+    ret = Z_BUF_ERROR;
+  }
+  return ret;
+}
+
+function inflateEnd(strm) {
+
+  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
+    return Z_STREAM_ERROR;
+  }
+
+  var state = strm.state;
+  if (state.window) {
+    state.window = null;
+  }
+  strm.state = null;
+  return Z_OK;
+}
+
+function inflateGetHeader(strm, head) {
+  var state;
+
+  /* check state */
+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
+  state = strm.state;
+  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }
+
+  /* save header structure */
+  state.head = head;
+  head.done = false;
+  return Z_OK;
+}
+
+function inflateSetDictionary(strm, dictionary) {
+  var dictLength = dictionary.length;
+
+  var state;
+  var dictid;
+  var ret;
+
+  /* check state */
+  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
+  state = strm.state;
+
+  if (state.wrap !== 0 && state.mode !== DICT) {
+    return Z_STREAM_ERROR;
+  }
+
+  /* check for correct dictionary identifier */
+  if (state.mode === DICT) {
+    dictid = 1; /* adler32(0, null, 0)*/
+    /* dictid = adler32(dictid, dictionary, dictLength); */
+    dictid = adler32(dictid, dictionary, dictLength, 0);
+    if (dictid !== state.check) {
+      return Z_DATA_ERROR;
+    }
+  }
+  /* copy dictionary to window using updatewindow(), which will amend the
+   existing dictionary if appropriate */
+  ret = updatewindow(strm, dictionary, dictLength, dictLength);
+  if (ret) {
+    state.mode = MEM;
+    return Z_MEM_ERROR;
+  }
+  state.havedict = 1;
+  // Tracev((stderr, "inflate:   dictionary set\n"));
+  return Z_OK;
+}
+
+export { inflateReset, inflateReset2, inflateResetKeep, inflateInit, inflateInit2, inflate, inflateEnd, inflateGetHeader, inflateSetDictionary };
+export var inflateInfo = 'pako inflate (from Nodeca project)';
+
+/* Not implemented
+exports.inflateCopy = inflateCopy;
+exports.inflateGetDictionary = inflateGetDictionary;
+exports.inflateMark = inflateMark;
+exports.inflatePrime = inflatePrime;
+exports.inflateSync = inflateSync;
+exports.inflateSyncPoint = inflateSyncPoint;
+exports.inflateUndermine = inflateUndermine;
+*/
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static-production/novnc/vendor/pako/lib/zlib/inftrees.js
@@ -0,0 +1,322 @@
+import * as utils from "../utils/common.js";
+
+var MAXBITS = 15;
+var ENOUGH_LENS = 852;
+var ENOUGH_DISTS = 592;
+//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);
+
+var CODES = 0;
+var LENS = 1;
+var DISTS = 2;
+
+var lbase = [ /* Length codes 257..285 base */
+  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
+  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
+];
+
+var lext = [ /* Length codes 257..285 extra */
+  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
+  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
+];
+
+var dbase = [ /* Distance codes 0..29 base */
+  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
+  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
+  8193, 12289, 16385, 24577, 0, 0
+];
+
+var dext = [ /* Distance codes 0..29 extra */
+  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
+  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
+  28, 28, 29, 29, 64, 64
+];
+
+export default function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
+{
+  var bits = opts.bits;
+      //here = opts.here; /* table entry for duplication */
+
+  var len = 0;               /* a code's length in bits */
+  var sym = 0;               /* index of code symbols */
+  var min = 0, max = 0;          /* minimum and maximum code lengths */
+  var root = 0;              /* number of index bits for root table */
+  var curr = 0;              /* number of index bits for current table */
+  var drop = 0;              /* code bits to drop for sub-table */
+  var left = 0;                   /* number of prefix codes available */
+  var used = 0;              /* code entries in table used */
+  var huff = 0;              /* Huffman code */
+  var incr;              /* for incrementing code, index */
+  var fill;              /* index for replicating entries */
+  var low;               /* low bits for current root entry */
+  var mask;              /* mask for low root bits */
+  var next;             /* next available space in table */
+  var base = null;     /* base value table to use */
+  var base_index = 0;
+//  var shoextra;    /* extra bits table to use */
+  var end;                    /* use base and extra for symbol > end */
+  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
+  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
+  var extra = null;
+  var extra_index = 0;
+
+  var here_bits, here_op, here_val;
+
+  /*
+   Process a set of code lengths to create a canonical Huffman code.  The
+   code lengths are lens[0..codes-1].  Each length corresponds to the
+   symbols 0..codes-1.  The Huffman code is generated by first sorting the
+   symbols by length from short to long, and retaining the symbol order
+   for codes with equal lengths.  Then the code starts with all zero bits
+   for the first code of the shortest length, and the codes are integer
+   increments for the same length, and zeros are appended as the length
+   increases.  For the deflate format, these bits are stored backwards
+   from their more natural integer increment ordering, and so when the
+   decoding tables are built in the large loop below, the integer codes
+   are incremented backwards.
+
+   This routine assumes, but does not check, that all of the entries in
+   lens[] are in the range 0..MAXBITS.  The caller must assure this.
+   1..MAXBITS is interpreted as that code length.  zero means that that
+   symbol does not occur in this code.
+
+   The codes are sorted by computing a count of codes for each length,
+   creating from that a table of starting indices for each length in the
+   sorted table, and then entering the symbols in order in the sorted
+   table.  The sorted table is work[], with that space being provided by
+   the caller.
+
+   The length counts are used for other purposes as well, i.e. finding
+   the minimum and maximum length codes, determining if there are any
+   codes at all, checking for a valid set of lengths, and looking ahead
+   at length counts to determine sub-table sizes when building the
+   decoding tables.
+   */
+
+  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
+  for (len = 0; len <= MAXBITS; len++) {
+    count[len] = 0;
+  }
+  for (sym = 0; sym < codes; sym++) {
+    count[lens[lens_index + sym]]++;
+  }
+
+  /* bound code lengths, force root to be within code lengths */
+  root = bits;
+  for (max = MAXBITS; max >= 1; max--) {
+    if (count[max] !== 0) { break; }
+  }
+  if (root > max) {
+    root = max;
+  }
+  if (max === 0) {                     /* no symbols to code at all */
+    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
+    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
+    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
+    table[table_index++] = (1 << 24) | (64 << 16) | 0;
+
+
+    //table.op[opts.table_index] = 64;
+    //table.bits[opts.table_index] = 1;
+    //table.val[opts.table_index++] = 0;
+    table[table_index++] = (1 << 24) | (64 << 16) | 0;
+
+    opts.bits = 1;
+    return 0;     /* no symbols, but wait for decoding to report error */
+  }
+  for (min = 1; min < max; min++) {
+    if (count[min] !== 0) { break; }
+  }
+  if (root < min) {
+    root = min;
+  }
+
+  /* check for an over-subscribed or incomplete set of lengths */
+  left = 1;
+  for (len = 1; len <= MAXBITS; len++) {
+    left <<= 1;
+    left -= count[len];
+    if (left < 0) {
+      return -1;
+    }        /* over-subscribed */
+  }
+  if (left > 0 && (type === CODES || max !== 1)) {
+    return -1;                      /* incomplete set */
+  }
+
+  /* generate offsets into symbol table for each length for sorting */
+  offs[1] = 0;
+  for (len = 1; len < MAXBITS; len++) {
+    offs[len + 1] = offs[len] + count[len];
+  }
+
+  /* sort symbols by length, by symbol order within each length */
+  for (sym = 0; sym < codes; sym++) {
+    if (lens[lens_index + sym] !== 0) {
+      work[offs[lens[lens_index + sym]]++] = sym;
+    }
+  }
+
+  /*
+   Create and fill in decoding tables.  In this loop, the table being
+   filled is at next and has curr index bits.  The code being used is huff
+   with length len.  That code is converted to an index by dropping drop
+   bits off of the bottom.  For codes where len is less than drop + curr,
+   those top drop + curr - len bits are incremented through all values to
+   fill the table with replicated entries.
+
+   root is the number of index bits for the root table.  When len exceeds
+   root, sub-tables are created pointed to by the root entry with an index
+   of the low root bits of huff.  This is saved in low to check for when a
+   new sub-table should be started.  drop is zero when the root table is
+   being filled, and drop is root when sub-tables are being filled.
+
+   When a new sub-table is needed, it is necessary to look ahead in the
+   code lengths to determine what size sub-table is needed.  The length
+   counts are used for this, and so count[] is decremented as codes are
+   entered in the tables.
+
+   used keeps track of how many table entries have been allocated from the
+   provided *table space.  It is checked for LENS and DIST tables against
+   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
+   the initial root table size constants.  See the comments in inftrees.h
+   for more information.
+
+   sym increments through all symbols, and the loop terminates when
+   all codes of length max, i.e. all codes, have been processed.  This
+   routine permits incomplete codes, so another loop after this one fills
+   in the rest of the decoding tables with invalid code markers.
+   */
+
+  /* set up for code type */
+  // poor man optimization - use if-else instead of switch,
+  // to avoid deopts in old v8
+  if (type === CODES) {
+    base = extra = work;    /* dummy value--not used */
+    end = 19;
+
+  } else if (type === LENS) {
+    base = lbase;
+    base_index -= 257;
+    extra = lext;
+    extra_index -= 257;
+    end = 256;
+
+  } else {                    /* DISTS */
+    base = dbase;
+    extra = dext;
+    end = -1;
+  }
+
+  /* initialize opts for loop */
+  huff = 0;                   /* starting code */
+  sym = 0;                    /* starting code symbol */
+  len = min;                  /* starting code length */
+  next = table_index;              /* current table to fill in */
+  curr = root;                /* current table index bits */
+  drop = 0;                   /* current bits to drop from code for index */
+  low = -1;                   /* trigger new sub-table when len > root */
+  used = 1 << root;          /* use root table entries */
+  mask = used - 1;            /* mask for comparing low */
+
+  /* check available table space */
+  if ((type === LENS && used > ENOUGH_LENS) ||
+    (type === DISTS && used > ENOUGH_DISTS)) {
+    return 1;
+  }
+
+  /* process all codes and make table entries */
+  for (;;) {
+    /* create table entry */
+    here_bits = len - drop;
+    if (work[sym] < end) {
+      here_op = 0;
+      here_val = work[sym];
+    }
+    else if (work[sym] > end) {
+      here_op = extra[extra_index + work[sym]];
+      here_val = base[base_index + work[sym]];
+    }
+    else {
+      here_op = 32 + 64;         /* end of block */
+      here_val = 0;
+    }
+
+    /* replicate for those indices with low len bits equal to huff */
+    incr = 1 << (len - drop);
+    fill = 1 << curr;
+    min = fill;                 /* save offset to next table */
+    do {
+      fill -= incr;
+      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
+    } while (fill !== 0);
+
+    /* backwards increment the len-bit code huff */
+    incr = 1 << (len - 1);
+    while (huff & incr) {
+      incr >>= 1;
+    }
+    if (incr !== 0) {
+      huff &= incr - 1;
+      huff += incr;
+    } else {
+      huff = 0;
+    }
+
+    /* go to next symbol, update count, len */
+    sym++;
+    if (--count[len] === 0) {
+      if (len === max) { break; }
+      len = lens[lens_index + work[sym]];
+    }
+
+    /* create new sub-table if needed */
+    if (len > root && (huff & mask) !== low) {
+      /* if first time, transition to sub-tables */
+      if (drop === 0) {
+        drop = root;
+      }
+
+      /* increment past last table */
+      next += min;            /* here min is 1 << curr */
+
+      /* determine length of next table */
+      curr = len - drop;
+      left = 1 << curr;
+      while (curr + drop < max) {
+        left -= count[curr + drop];
+        if (left <= 0) { break; }
+        curr++;
+        left <<= 1;
+      }
+
+      /* check for enough space */
+      used += 1 << curr;
+      if ((type === LENS && used > ENOUGH_LENS) ||
+        (type === DISTS && used > ENOUGH_DISTS)) {
+        return 1;
+      }
+
+      /* point entry in root table to sub-table */
+      low = huff & mask;
+      /*table.op[low] = curr;
+      table.bits[low] = root;
+      table.val[low] = next - opts.table_index;*/
+      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
+    }
+  }
+
+  /* fill in remaining table entry if code is incomplete (guaranteed to have
+   at most one remaining entry, since if the code is incomplete, the
+   maximum code length that was allowed to get this far is one bit) */
+  if (huff !== 0) {
+    //table.op[next + huff] = 64;            /* invalid code marker */
+    //table.bits[next + huff] = len - drop;
+    //table.val[next + huff] = 0;
+    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
+  }
+
+  /* set return parameters */
+  //opts.table_index += used;
+  opts.bits = root;
+  return 0;
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static-production/novnc/vendor/pako/lib/zlib/messages.js
@@ -0,0 +1,11 @@
+export default {
+  2:      'need dictionary',     /* Z_NEED_DICT       2  */
+  1:      'stream end',          /* Z_STREAM_END      1  */
+  0:      '',                    /* Z_OK              0  */
+  '-1':   'file error',          /* Z_ERRNO         (-1) */
+  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
+  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
+  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
+  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
+  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static-production/novnc/vendor/pako/lib/zlib/trees.js
@@ -0,0 +1,1195 @@
+import * as utils from "../utils/common.js";
+
+/* Public constants ==========================================================*/
+/* ===========================================================================*/
+
+
+//var Z_FILTERED          = 1;
+//var Z_HUFFMAN_ONLY      = 2;
+//var Z_RLE               = 3;
+var Z_FIXED               = 4;
+//var Z_DEFAULT_STRATEGY  = 0;
+
+/* Possible values of the data_type field (though see inflate()) */
+var Z_BINARY              = 0;
+var Z_TEXT                = 1;
+//var Z_ASCII             = 1; // = Z_TEXT
+var Z_UNKNOWN             = 2;
+
+/*============================================================================*/
+
+
+function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }
+
+// From zutil.h
+
+var STORED_BLOCK = 0;
+var STATIC_TREES = 1;
+var DYN_TREES    = 2;
+/* The three kinds of block type */
+
+var MIN_MATCH    = 3;
+var MAX_MATCH    = 258;
+/* The minimum and maximum match lengths */
+
+// From deflate.h
+/* ===========================================================================
+ * Internal compression state.
+ */
+
+var LENGTH_CODES  = 29;
+/* number of length codes, not counting the special END_BLOCK code */
+
+var LITERALS      = 256;
+/* number of literal bytes 0..255 */
+
+var L_CODES       = LITERALS + 1 + LENGTH_CODES;
+/* number of Literal or Length codes, including the END_BLOCK code */
+
+var D_CODES       = 30;
+/* number of distance codes */
+
+var BL_CODES      = 19;
+/* number of codes used to transfer the bit lengths */
+
+var HEAP_SIZE     = 2 * L_CODES + 1;
+/* maximum heap size */
+
+var MAX_BITS      = 15;
+/* All codes must not exceed MAX_BITS bits */
+
+var Buf_size      = 16;
+/* size of bit buffer in bi_buf */
+
+
+/* ===========================================================================
+ * Constants
+ */
+
+var MAX_BL_BITS = 7;
+/* Bit length codes must not exceed MAX_BL_BITS bits */
+
+var END_BLOCK   = 256;
+/* end of block literal code */
+
+var REP_3_6     = 16;
+/* repeat previous bit length 3-6 times (2 bits of repeat count) */
+
+var REPZ_3_10   = 17;
+/* repeat a zero length 3-10 times  (3 bits of repeat count) */
+
+var REPZ_11_138 = 18;
+/* repeat a zero length 11-138 times  (7 bits of repeat count) */
+
+/* eslint-disable comma-spacing,array-bracket-spacing */
+var extra_lbits =   /* extra bits for each length code */
+  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];
+
+var extra_dbits =   /* extra bits for each distance code */
+  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];
+
+var extra_blbits =  /* extra bits for each bit length code */
+  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];
+
+var bl_order =
+  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
+/* eslint-enable comma-spacing,array-bracket-spacing */
+
+/* The lengths of the bit length codes are sent in order of decreasing
+ * probability, to avoid transmitting the lengths for unused bit length codes.
+ */
+
+/* ===========================================================================
+ * Local data. These are initialized only once.
+ */
+
+// We pre-fill arrays with 0 to avoid uninitialized gaps
+
+var DIST_CODE_LEN = 512; /* see definition of array dist_code below */
+
+// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
+var static_ltree  = new Array((L_CODES + 2) * 2);
+zero(static_ltree);
+/* The static literal tree. Since the bit lengths are imposed, there is no
+ * need for the L_CODES extra codes used during heap construction. However
+ * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
+ * below).
+ */
+
+var static_dtree  = new Array(D_CODES * 2);
+zero(static_dtree);
+/* The static distance tree. (Actually a trivial tree since all codes use
+ * 5 bits.)
+ */
+
+var _dist_code    = new Array(DIST_CODE_LEN);
+zero(_dist_code);
+/* Distance codes. The first 256 values correspond to the distances
+ * 3 .. 258, the last 256 values correspond to the top 8 bits of
+ * the 15 bit distances.
+ */
+
+var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
+zero(_length_code);
+/* length code for each normalized match length (0 == MIN_MATCH) */
+
+var base_length   = new Array(LENGTH_CODES);
+zero(base_length);
+/* First normalized length for each code (0 = MIN_MATCH) */
+
+var base_dist     = new Array(D_CODES);
+zero(base_dist);
+/* First normalized distance for each code (0 = distance of 1) */
+
+
+function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
+
+  this.static_tree  = static_tree;  /* static tree or NULL */
+  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
+  this.extra_base   = extra_base;   /* base index for extra_bits */
+  this.elems        = elems;        /* max number of elements in the tree */
+  this.max_length   = max_length;   /* max bit length for the codes */
+
+  // show if `static_tree` has data or dummy - needed for monomorphic objects
+  this.has_stree    = static_tree && static_tree.length;
+}
+
+
+var static_l_desc;
+var static_d_desc;
+var static_bl_desc;
+
+
+function TreeDesc(dyn_tree, stat_desc) {
+  this.dyn_tree = dyn_tree;     /* the dynamic tree */
+  this.max_code = 0;            /* largest code with non zero frequency */
+  this.stat_desc = stat_desc;   /* the corresponding static tree */
+}
+
+
+
+function d_code(dist) {
+  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
+}
+
+
+/* ===========================================================================
+ * Output a short LSB first on the stream.
+ * IN assertion: there is enough room in pendingBuf.
+ */
+function put_short(s, w) {
+//    put_byte(s, (uch)((w) & 0xff));
+//    put_byte(s, (uch)((ush)(w) >> 8));
+  s.pending_buf[s.pending++] = (w) & 0xff;
+  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
+}
+
+
+/* ===========================================================================
+ * Send a value on a given number of bits.
+ * IN assertion: length <= 16 and value fits in length bits.
+ */
+function send_bits(s, value, length) {
+  if (s.bi_valid > (Buf_size - length)) {
+    s.bi_buf |= (value << s.bi_valid) & 0xffff;
+    put_short(s, s.bi_buf);
+    s.bi_buf = value >> (Buf_size - s.bi_valid);
+    s.bi_valid += length - Buf_size;
+  } else {
+    s.bi_buf |= (value << s.bi_valid) & 0xffff;
+    s.bi_valid += length;
+  }
+}
+
+
+function send_code(s, c, tree) {
+  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
+}
+
+
+/* ===========================================================================
+ * Reverse the first len bits of a code, using straightforward code (a faster
+ * method would use a table)
+ * IN assertion: 1 <= len <= 15
+ */
+function bi_reverse(code, len) {
+  var res = 0;
+  do {
+    res |= code & 1;
+    code >>>= 1;
+    res <<= 1;
+  } while (--len > 0);
+  return res >>> 1;
+}
+
+
+/* ===========================================================================
+ * Flush the bit buffer, keeping at most 7 bits in it.
+ */
+function bi_flush(s) {
+  if (s.bi_valid === 16) {
+    put_short(s, s.bi_buf);
+    s.bi_buf = 0;
+    s.bi_valid = 0;
+
+  } else if (s.bi_valid >= 8) {
+    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
+    s.bi_buf >>= 8;
+    s.bi_valid -= 8;
+  }
+}
+
+
+/* ===========================================================================
+ * Compute the optimal bit lengths for a tree and update the total bit length
+ * for the current block.
+ * IN assertion: the fields freq and dad are set, heap[heap_max] and
+ *    above are the tree nodes sorted by increasing frequency.
+ * OUT assertions: the field len is set to the optimal bit length, the
+ *     array bl_count contains the frequencies for each bit length.
+ *     The length opt_len is updated; static_len is also updated if stree is
+ *     not null.
+ */
+function gen_bitlen(s, desc)
+//    deflate_state *s;
+//    tree_desc *desc;    /* the tree descriptor */
+{
+  var tree            = desc.dyn_tree;
+  var max_code        = desc.max_code;
+  var stree           = desc.stat_desc.static_tree;
+  var has_stree       = desc.stat_desc.has_stree;
+  var extra           = desc.stat_desc.extra_bits;
+  var base            = desc.stat_desc.extra_base;
+  var max_length      = desc.stat_desc.max_length;
+  var h;              /* heap index */
+  var n, m;           /* iterate over the tree elements */
+  var bits;           /* bit length */
+  var xbits;          /* extra bits */
+  var f;              /* frequency */
+  var overflow = 0;   /* number of elements with bit length too large */
+
+  for (bits = 0; bits <= MAX_BITS; bits++) {
+    s.bl_count[bits] = 0;
+  }
+
+  /* In a first pass, compute the optimal bit lengths (which may
+   * overflow in the case of the bit length tree).
+   */
+  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */
+
+  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
+    n = s.heap[h];
+    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
+    if (bits > max_length) {
+      bits = max_length;
+      overflow++;
+    }
+    tree[n * 2 + 1]/*.Len*/ = bits;
+    /* We overwrite tree[n].Dad which is no longer needed */
+
+    if (n > max_code) { continue; } /* not a leaf node */
+
+    s.bl_count[bits]++;
+    xbits = 0;
+    if (n >= base) {
+      xbits = extra[n - base];
+    }
+    f = tree[n * 2]/*.Freq*/;
+    s.opt_len += f * (bits + xbits);
+    if (has_stree) {
+      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
+    }
+  }
+  if (overflow === 0) { return; }
+
+  // Trace((stderr,"\nbit length overflow\n"));
+  /* This happens for example on obj2 and pic of the Calgary corpus */
+
+  /* Find the first bit length which could increase: */
+  do {
+    bits = max_length - 1;
+    while (s.bl_count[bits] === 0) { bits--; }
+    s.bl_count[bits]--;      /* move one leaf down the tree */
+    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
+    s.bl_count[max_length]--;
+    /* The brother of the overflow item also moves one step up,
+     * but this does not affect bl_count[max_length]
+     */
+    overflow -= 2;
+  } while (overflow > 0);
+
+  /* Now recompute all bit lengths, scanning in increasing frequency.
+   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
+   * lengths instead of fixing only the wrong ones. This idea is taken
+   * from 'ar' written by Haruhiko Okumura.)
+   */
+  for (bits = max_length; bits !== 0; bits--) {
+    n = s.bl_count[bits];
+    while (n !== 0) {
+      m = s.heap[--h];
+      if (m > max_code) { continue; }
+      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
+        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
+        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
+        tree[m * 2 + 1]/*.Len*/ = bits;
+      }
+      n--;
+    }
+  }
+}
+
+
+/* ===========================================================================
+ * Generate the codes for a given tree and bit counts (which need not be
+ * optimal).
+ * IN assertion: the array bl_count contains the bit length statistics for
+ * the given tree and the field len is set for all tree elements.
+ * OUT assertion: the field code is set for all tree elements of non
+ *     zero code length.
+ */
+function gen_codes(tree, max_code, bl_count)
+//    ct_data *tree;             /* the tree to decorate */
+//    int max_code;              /* largest code with non zero frequency */
+//    ushf *bl_count;            /* number of codes at each bit length */
+{
+  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
+  var code = 0;              /* running code value */
+  var bits;                  /* bit index */
+  var n;                     /* code index */
+
+  /* The distribution counts are first used to generate the code values
+   * without bit reversal.
+   */
+  for (bits = 1; bits <= MAX_BITS; bits++) {
+    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
+  }
+  /* Check that the bit counts in bl_count are consistent. The last code
+   * must be all ones.
+   */
+  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
+  //        "inconsistent bit counts");
+  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
+
+  for (n = 0;  n <= max_code; n++) {
+    var len = tree[n * 2 + 1]/*.Len*/;
+    if (len === 0) { continue; }
+    /* Now reverse the bits */
+    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);
+
+    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
+    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
+  }
+}
+
+
+/* ===========================================================================
+ * Initialize the various 'constant' tables.
+ */
+function tr_static_init() {
+  var n;        /* iterates over tree elements */
+  var bits;     /* bit counter */
+  var length;   /* length value */
+  var code;     /* code value */
+  var dist;     /* distance index */
+  var bl_count = new Array(MAX_BITS + 1);
+  /* number of codes at each bit length for an optimal tree */
+
+  // do check in _tr_init()
+  //if (static_init_done) return;
+
+  /* For some embedded targets, global variables are not initialized: */
+/*#ifdef NO_INIT_GLOBAL_POINTERS
+  static_l_desc.static_tree = static_ltree;
+  static_l_desc.extra_bits = extra_lbits;
+  static_d_desc.static_tree = static_dtree;
+  static_d_desc.extra_bits = extra_dbits;
+  static_bl_desc.extra_bits = extra_blbits;
+#endif*/
+
+  /* Initialize the mapping length (0..255) -> length code (0..28) */
+  length = 0;
+  for (code = 0; code < LENGTH_CODES - 1; code++) {
+    base_length[code] = length;
+    for (n = 0; n < (1 << extra_lbits[code]); n++) {
+      _length_code[length++] = code;
+    }
+  }
+  //Assert (length == 256, "tr_static_init: length != 256");
+  /* Note that the length 255 (match length 258) can be represented
+   * in two different ways: code 284 + 5 bits or code 285, so we
+   * overwrite length_code[255] to use the best encoding:
+   */
+  _length_code[length - 1] = code;
+
+  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
+  dist = 0;
+  for (code = 0; code < 16; code++) {
+    base_dist[code] = dist;
+    for (n = 0; n < (1 << extra_dbits[code]); n++) {
+      _dist_code[dist++] = code;
+    }
+  }
+  //Assert (dist == 256, "tr_static_init: dist != 256");
+  dist >>= 7; /* from now on, all distances are divided by 128 */
+  for (; code < D_CODES; code++) {
+    base_dist[code] = dist << 7;
+    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
+      _dist_code[256 + dist++] = code;
+    }
+  }
+  //Assert (dist == 256, "tr_static_init: 256+dist != 512");
+
+  /* Construct the codes of the static literal tree */
+  for (bits = 0; bits <= MAX_BITS; bits++) {
+    bl_count[bits] = 0;
+  }
+
+  n = 0;
+  while (n <= 143) {
+    static_ltree[n * 2 + 1]/*.Len*/ = 8;
+    n++;
+    bl_count[8]++;
+  }
+  while (n <= 255) {
+    static_ltree[n * 2 + 1]/*.Len*/ = 9;
+    n++;
+    bl_count[9]++;
+  }
+  while (n <= 279) {
+    static_ltree[n * 2 + 1]/*.Len*/ = 7;
+    n++;
+    bl_count[7]++;
+  }
+  while (n <= 287) {
+    static_ltree[n * 2 + 1]/*.Len*/ = 8;
+    n++;
+    bl_count[8]++;
+  }
+  /* Codes 286 and 287 do not exist, but we must include them in the
+   * tree construction to get a canonical Huffman tree (longest code
+   * all ones)
+   */
+  gen_codes(static_ltree, L_CODES + 1, bl_count);
+
+  /* The static distance tree is trivial: */
+  for (n = 0; n < D_CODES; n++) {
+    static_dtree[n * 2 + 1]/*.Len*/ = 5;
+    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
+  }
+
+  // Now data ready and we can init static trees
+  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
+  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
+  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);
+
+  //static_init_done = true;
+}
+
+
+/* ===========================================================================
+ * Initialize a new block.
+ */
+function init_block(s) {
+  var n; /* iterates over tree elements */
+
+  /* Initialize the trees. */
+  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
+  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
+  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }
+
+  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
+  s.opt_len = s.static_len = 0;
+  s.last_lit = s.matches = 0;
+}
+
+
+/* ===========================================================================
+ * Flush the bit buffer and align the output on a byte boundary
+ */
+function bi_windup(s)
+{
+  if (s.bi_valid > 8) {
+    put_short(s, s.bi_buf);
+  } else if (s.bi_valid > 0) {
+    //put_byte(s, (Byte)s->bi_buf);
+    s.pending_buf[s.pending++] = s.bi_buf;
+  }
+  s.bi_buf = 0;
+  s.bi_valid = 0;
+}
+
+/* ===========================================================================
+ * Copy a stored block, storing first the length and its
+ * one's complement if requested.
+ */
+function copy_block(s, buf, len, header)
+//DeflateState *s;
+//charf    *buf;    /* the input data */
+//unsigned len;     /* its length */
+//int      header;  /* true if block header must be written */
+{
+  bi_windup(s);        /* align on byte boundary */
+
+  if (header) {
+    put_short(s, len);
+    put_short(s, ~len);
+  }
+//  while (len--) {
+//    put_byte(s, *buf++);
+//  }
+  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
+  s.pending += len;
+}
+
+/* ===========================================================================
+ * Compares to subtrees, using the tree depth as tie breaker when
+ * the subtrees have equal frequency. This minimizes the worst case length.
+ */
+function smaller(tree, n, m, depth) {
+  var _n2 = n * 2;
+  var _m2 = m * 2;
+  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
+         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
+}
+
+/* ===========================================================================
+ * Restore the heap property by moving down the tree starting at node k,
+ * exchanging a node with the smallest of its two sons if necessary, stopping
+ * when the heap property is re-established (each father smaller than its
+ * two sons).
+ */
+function pqdownheap(s, tree, k)
+//    deflate_state *s;
+//    ct_data *tree;  /* the tree to restore */
+//    int k;               /* node to move down */
+{
+  var v = s.heap[k];
+  var j = k << 1;  /* left son of k */
+  while (j <= s.heap_len) {
+    /* Set j to the smallest of the two sons: */
+    if (j < s.heap_len &&
+      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
+      j++;
+    }
+    /* Exit if v is smaller than both sons */
+    if (smaller(tree, v, s.heap[j], s.depth)) { break; }
+
+    /* Exchange v with the smallest son */
+    s.heap[k] = s.heap[j];
+    k = j;
+
+    /* And continue down the tree, setting j to the left son of k */
+    j <<= 1;
+  }
+  s.heap[k] = v;
+}
+
+
+// inlined manually
+// var SMALLEST = 1;
+
+/* ===========================================================================
+ * Send the block data compressed using the given Huffman trees
+ */
+function compress_block(s, ltree, dtree)
+//    deflate_state *s;
+//    const ct_data *ltree; /* literal tree */
+//    const ct_data *dtree; /* distance tree */
+{
+  var dist;           /* distance of matched string */
+  var lc;             /* match length or unmatched char (if dist == 0) */
+  var lx = 0;         /* running index in l_buf */
+  var code;           /* the code to send */
+  var extra;          /* number of extra bits to send */
+
+  if (s.last_lit !== 0) {
+    do {
+      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
+      lc = s.pending_buf[s.l_buf + lx];
+      lx++;
+
+      if (dist === 0) {
+        send_code(s, lc, ltree); /* send a literal byte */
+        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
+      } else {
+        /* Here, lc is the match length - MIN_MATCH */
+        code = _length_code[lc];
+        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
+        extra = extra_lbits[code];
+        if (extra !== 0) {
+          lc -= base_length[code];
+          send_bits(s, lc, extra);       /* send the extra length bits */
+        }
+        dist--; /* dist is now the match distance - 1 */
+        code = d_code(dist);
+        //Assert (code < D_CODES, "bad d_code");
+
+        send_code(s, code, dtree);       /* send the distance code */
+        extra = extra_dbits[code];
+        if (extra !== 0) {
+          dist -= base_dist[code];
+          send_bits(s, dist, extra);   /* send the extra distance bits */
+        }
+      } /* literal or match pair ? */
+
+      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
+      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
+      //       "pendingBuf overflow");
+
+    } while (lx < s.last_lit);
+  }
+
+  send_code(s, END_BLOCK, ltree);
+}
+
+
+/* ===========================================================================
+ * Construct one Huffman tree and assigns the code bit strings and lengths.
+ * Update the total bit length for the current block.
+ * IN assertion: the field freq is set for all tree elements.
+ * OUT assertions: the fields len and code are set to the optimal bit length
+ *     and corresponding code. The length opt_len is updated; static_len is
+ *     also updated if stree is not null. The field max_code is set.
+ */
+function build_tree(s, desc)
+//    deflate_state *s;
+//    tree_desc *desc; /* the tree descriptor */
+{
+  var tree     = desc.dyn_tree;
+  var stree    = desc.stat_desc.static_tree;
+  var has_stree = desc.stat_desc.has_stree;
+  var elems    = desc.stat_desc.elems;
+  var n, m;          /* iterate over heap elements */
+  var max_code = -1; /* largest code with non zero frequency */
+  var node;          /* new node being created */
+
+  /* Construct the initial heap, with least frequent element in
+   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
+   * heap[0] is not used.
+   */
+  s.heap_len = 0;
+  s.heap_max = HEAP_SIZE;
+
+  for (n = 0; n < elems; n++) {
+    if (tree[n * 2]/*.Freq*/ !== 0) {
+      s.heap[++s.heap_len] = max_code = n;
+      s.depth[n] = 0;
+
+    } else {
+      tree[n * 2 + 1]/*.Len*/ = 0;
+    }
+  }
+
+  /* The pkzip format requires that at least one distance code exists,
+   * and that at least one bit should be sent even if there is only one
+   * possible code. So to avoid special checks later on we force at least
+   * two codes of non zero frequency.
+   */
+  while (s.heap_len < 2) {
+    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
+    tree[node * 2]/*.Freq*/ = 1;
+    s.depth[node] = 0;
+    s.opt_len--;
+
+    if (has_stree) {
+      s.static_len -= stree[node * 2 + 1]/*.Len*/;
+    }
+    /* node is 0 or 1 so it does not have extra bits */
+  }
+  desc.max_code = max_code;
+
+  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
+   * establish sub-heaps of increasing lengths:
+   */
+  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }
+
+  /* Construct the Huffman tree by repeatedly combining the least two
+   * frequent nodes.
+   */
+  node = elems;              /* next internal node of the tree */
+  do {
+    //pqremove(s, tree, n);  /* n = node of least frequency */
+    /*** pqremove ***/
+    n = s.heap[1/*SMALLEST*/];
+    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
+    pqdownheap(s, tree, 1/*SMALLEST*/);
+    /***/
+
+    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */
+
+    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
+    s.heap[--s.heap_max] = m;
+
+    /* Create a new node father of n and m */
+    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
+    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
+    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;
+
+    /* and insert the new node in the heap */
+    s.heap[1/*SMALLEST*/] = node++;
+    pqdownheap(s, tree, 1/*SMALLEST*/);
+
+  } while (s.heap_len >= 2);
+
+  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];
+
+  /* At this point, the fields freq and dad are set. We can now
+   * generate the bit lengths.
+   */
+  gen_bitlen(s, desc);
+
+  /* The field len is now set, we can generate the bit codes */
+  gen_codes(tree, max_code, s.bl_count);
+}
+
+
+/* ===========================================================================
+ * Scan a literal or distance tree to determine the frequencies of the codes
+ * in the bit length tree.
+ */
+function scan_tree(s, tree, max_code)
+//    deflate_state *s;
+//    ct_data *tree;   /* the tree to be scanned */
+//    int max_code;    /* and its largest code of non zero frequency */
+{
+  var n;                     /* iterates over all tree elements */
+  var prevlen = -1;          /* last emitted length */
+  var curlen;                /* length of current code */
+
+  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */
+
+  var count = 0;             /* repeat count of the current code */
+  var max_count = 7;         /* max repeat count */
+  var min_count = 4;         /* min repeat count */
+
+  if (nextlen === 0) {
+    max_count = 138;
+    min_count = 3;
+  }
+  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */
+
+  for (n = 0; n <= max_code; n++) {
+    curlen = nextlen;
+    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;
+
+    if (++count < max_count && curlen === nextlen) {
+      continue;
+
+    } else if (count < min_count) {
+      s.bl_tree[curlen * 2]/*.Freq*/ += count;
+
+    } else if (curlen !== 0) {
+
+      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
+      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;
+
+    } else if (count <= 10) {
+      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;
+
+    } else {
+      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
+    }
+
+    count = 0;
+    prevlen = curlen;
+
+    if (nextlen === 0) {
+      max_count = 138;
+      min_count = 3;
+
+    } else if (curlen === nextlen) {
+      max_count = 6;
+      min_count = 3;
+
+    } else {
+      max_count = 7;
+      min_count = 4;
+    }
+  }
+}
+
+
+/* ===========================================================================
+ * Send a literal or distance tree in compressed form, using the codes in
+ * bl_tree.
+ */
+function send_tree(s, tree, max_code)
+//    deflate_state *s;
+//    ct_data *tree; /* the tree to be scanned */
+//    int max_code;       /* and its largest code of non zero frequency */
+{
+  var n;                     /* iterates over all tree elements */
+  var prevlen = -1;          /* last emitted length */
+  var curlen;                /* length of current code */
+
+  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */
+
+  var count = 0;             /* repeat count of the current code */
+  var max_count = 7;         /* max repeat count */
+  var min_count = 4;         /* min repeat count */
+
+  /* tree[max_code+1].Len = -1; */  /* guard already set */
+  if (nextlen === 0) {
+    max_count = 138;
+    min_count = 3;
+  }
+
+  for (n = 0; n <= max_code; n++) {
+    curlen = nextlen;
+    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;
+
+    if (++count < max_count && curlen === nextlen) {
+      continue;
+
+    } else if (count < min_count) {
+      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);
+
+    } else if (curlen !== 0) {
+      if (curlen !== prevlen) {
+        send_code(s, curlen, s.bl_tree);
+        count--;
+      }
+      //Assert(count >= 3 && count <= 6, " 3_6?");
+      send_code(s, REP_3_6, s.bl_tree);
+      send_bits(s, count - 3, 2);
+
+    } else if (count <= 10) {
+      send_code(s, REPZ_3_10, s.bl_tree);
+      send_bits(s, count - 3, 3);
+
+    } else {
+      send_code(s, REPZ_11_138, s.bl_tree);
+      send_bits(s, count - 11, 7);
+    }
+
+    count = 0;
+    prevlen = curlen;
+    if (nextlen === 0) {
+      max_count = 138;
+      min_count = 3;
+
+    } else if (curlen === nextlen) {
+      max_count = 6;
+      min_count = 3;
+
+    } else {
+      max_count = 7;
+      min_count = 4;
+    }
+  }
+}
+
+
+/* ===========================================================================
+ * Construct the Huffman tree for the bit lengths and return the index in
+ * bl_order of the last bit length code to send.
+ */
+function build_bl_tree(s) {
+  var max_blindex;  /* index of last bit length code of non zero freq */
+
+  /* Determine the bit length frequencies for literal and distance trees */
+  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
+  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
+
+  /* Build the bit length tree: */
+  build_tree(s, s.bl_desc);
+  /* opt_len now includes the length of the tree representations, except
+   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
+   */
+
+  /* Determine the number of bit length codes to send. The pkzip format
+   * requires that at least 4 bit length codes be sent. (appnote.txt says
+   * 3 but the actual value used is 4.)
+   */
+  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
+    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
+      break;
+    }
+  }
+  /* Update opt_len to include the bit length tree and counts */
+  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
+  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
+  //        s->opt_len, s->static_len));
+
+  return max_blindex;
+}
+
+
+/* ===========================================================================
+ * Send the header for a block using dynamic Huffman trees: the counts, the
+ * lengths of the bit length codes, the literal tree and the distance tree.
+ * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
+ */
+function send_all_trees(s, lcodes, dcodes, blcodes)
+//    deflate_state *s;
+//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
+{
+  var rank;                    /* index in bl_order */
+
+  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
+  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
+  //        "too many codes");
+  //Tracev((stderr, "\nbl counts: "));
+  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
+  send_bits(s, dcodes - 1,   5);
+  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
+  for (rank = 0; rank < blcodes; rank++) {
+    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
+    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
+  }
+  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
+
+  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
+  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
+
+  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
+  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
+}
+
+
+/* ===========================================================================
+ * Check if the data type is TEXT or BINARY, using the following algorithm:
+ * - TEXT if the two conditions below are satisfied:
+ *    a) There are no non-portable control characters belonging to the
+ *       "black list" (0..6, 14..25, 28..31).
+ *    b) There is at least one printable character belonging to the
+ *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
+ * - BINARY otherwise.
+ * - The following partially-portable control characters form a
+ *   "gray list" that is ignored in this detection algorithm:
+ *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
+ * IN assertion: the fields Freq of dyn_ltree are set.
+ */
+function detect_data_type(s) {
+  /* black_mask is the bit mask of black-listed bytes
+   * set bits 0..6, 14..25, and 28..31
+   * 0xf3ffc07f = binary 11110011111111111100000001111111
+   */
+  var black_mask = 0xf3ffc07f;
+  var n;
+
+  /* Check for non-textual ("black-listed") bytes. */
+  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
+    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
+      return Z_BINARY;
+    }
+  }
+
+  /* Check for textual ("white-listed") bytes. */
+  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
+      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
+    return Z_TEXT;
+  }
+  for (n = 32; n < LITERALS; n++) {
+    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
+      return Z_TEXT;
+    }
+  }
+
+  /* There are no "black-listed" or "white-listed" bytes:
+   * this stream either is empty or has tolerated ("gray-listed") bytes only.
+   */
+  return Z_BINARY;
+}
+
+
+var static_init_done = false;
+
+/* ===========================================================================
+ * Initialize the tree data structures for a new zlib stream.
+ */
+function _tr_init(s)
+{
+
+  if (!static_init_done) {
+    tr_static_init();
+    static_init_done = true;
+  }
+
+  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
+  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
+  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
+
+  s.bi_buf = 0;
+  s.bi_valid = 0;
+
+  /* Initialize the first block of the first file: */
+  init_block(s);
+}
+
+
+/* ===========================================================================
+ * Send a stored block
+ */
+function _tr_stored_block(s, buf, stored_len, last)
+//DeflateState *s;
+//charf *buf;       /* input block */
+//ulg stored_len;   /* length of input block */
+//int last;         /* one if this is the last block for a file */
+{
+  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
+  copy_block(s, buf, stored_len, true); /* with header */
+}
+
+
+/* ===========================================================================
+ * Send one empty static block to give enough lookahead for inflate.
+ * This takes 10 bits, of which 7 may remain in the bit buffer.
+ */
+function _tr_align(s) {
+  send_bits(s, STATIC_TREES << 1, 3);
+  send_code(s, END_BLOCK, static_ltree);
+  bi_flush(s);
+}
+
+
+/* ===========================================================================
+ * Determine the best encoding for the current block: dynamic trees, static
+ * trees or store, and output the encoded block to the zip file.
+ */
+function _tr_flush_block(s, buf, stored_len, last)
+//DeflateState *s;
+//charf *buf;       /* input block, or NULL if too old */
+//ulg stored_len;   /* length of input block */
+//int last;         /* one if this is the last block for a file */
+{
+  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
+  var max_blindex = 0;        /* index of last bit length code of non zero freq */
+
+  /* Build the Huffman trees unless a stored block is forced */
+  if (s.level > 0) {
+
+    /* Check if the file is binary or text */
+    if (s.strm.data_type === Z_UNKNOWN) {
+      s.strm.data_type = detect_data_type(s);
+    }
+
+    /* Construct the literal and distance trees */
+    build_tree(s, s.l_desc);
+    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
+    //        s->static_len));
+
+    build_tree(s, s.d_desc);
+    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
+    //        s->static_len));
+    /* At this point, opt_len and static_len are the total bit lengths of
+     * the compressed block data, excluding the tree representations.
+     */
+
+    /* Build the bit length tree for the above two trees, and get the index
+     * in bl_order of the last bit length code to send.
+     */
+    max_blindex = build_bl_tree(s);
+
+    /* Determine the best encoding. Compute the block lengths in bytes. */
+    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
+    static_lenb = (s.static_len + 3 + 7) >>> 3;
+
+    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
+    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
+    //        s->last_lit));
+
+    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }
+
+  } else {
+    // Assert(buf != (char*)0, "lost buf");
+    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
+  }
+
+  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
+    /* 4: two words for the lengths */
+
+    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
+     * Otherwise we can't have processed more than WSIZE input bytes since
+     * the last block flush, because compression would have been
+     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
+     * transform a block into a stored block.
+     */
+    _tr_stored_block(s, buf, stored_len, last);
+
+  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
+
+    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
+    compress_block(s, static_ltree, static_dtree);
+
+  } else {
+    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
+    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
+    compress_block(s, s.dyn_ltree, s.dyn_dtree);
+  }
+  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
+  /* The above check is made mod 2^32, for files larger than 512 MB
+   * and uLong implemented on 32 bits.
+   */
+  init_block(s);
+
+  if (last) {
+    bi_windup(s);
+  }
+  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
+  //       s->compressed_len-7*last));
+}
+
+/* ===========================================================================
+ * Save the match info and tally the frequency counts. Return true if
+ * the current block must be flushed.
+ */
+function _tr_tally(s, dist, lc)
+//    deflate_state *s;
+//    unsigned dist;  /* distance of matched string */
+//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
+{
+  //var out_length, in_length, dcode;
+
+  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
+  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
+
+  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
+  s.last_lit++;
+
+  if (dist === 0) {
+    /* lc is the unmatched char */
+    s.dyn_ltree[lc * 2]/*.Freq*/++;
+  } else {
+    s.matches++;
+    /* Here, lc is the match length - MIN_MATCH */
+    dist--;             /* dist = match distance - 1 */
+    //Assert((ush)dist < (ush)MAX_DIST(s) &&
+    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
+    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
+
+    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
+    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
+  }
+
+// (!) This block is disabled in zlib defailts,
+// don't enable it for binary compatibility
+
+//#ifdef TRUNCATE_BLOCK
+//  /* Try to guess if it is profitable to stop the current block here */
+//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
+//    /* Compute an upper bound for the compressed length */
+//    out_length = s.last_lit*8;
+//    in_length = s.strstart - s.block_start;
+//
+//    for (dcode = 0; dcode < D_CODES; dcode++) {
+//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
+//    }
+//    out_length >>>= 3;
+//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
+//    //       s->last_lit, in_length, out_length,
+//    //       100L - out_length*100L/in_length));
+//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
+//      return true;
+//    }
+//  }
+//#endif
+
+  return (s.last_lit === s.lit_bufsize - 1);
+  /* We avoid equality with lit_bufsize because of wraparound at 64K
+   * on 16 bit machines and because stored blocks are restricted to
+   * 64K-1 bytes.
+   */
+}
+
+export { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align };
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static-production/novnc/vendor/pako/lib/zlib/zstream.js
@@ -0,0 +1,24 @@
+export default function ZStream() {
+  /* next input byte */
+  this.input = null; // JS specific, because we have no pointers
+  this.next_in = 0;
+  /* number of bytes available at input */
+  this.avail_in = 0;
+  /* total number of input bytes read so far */
+  this.total_in = 0;
+  /* next output byte should be put there */
+  this.output = null; // JS specific, because we have no pointers
+  this.next_out = 0;
+  /* remaining free space at output */
+  this.avail_out = 0;
+  /* total number of bytes output so far */
+  this.total_out = 0;
+  /* last error message, NULL if no error */
+  this.msg = ''/*Z_NULL*/;
+  /* not visible by applications */
+  this.state = null;
+  /* best guess about the data type: binary or text */
+  this.data_type = 2/*Z_UNKNOWN*/;
+  /* adler32 value of the uncompressed data */
+  this.adler = 0;
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/.eslintignore
@@ -0,0 +1 @@
+**/xtscancodes.js
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/.eslintrc
@@ -0,0 +1,51 @@
+{
+    "env": {
+        "browser": true,
+        "es2020": true
+    },
+    "parserOptions": {
+        "sourceType": "module",
+        "ecmaVersion": 2020
+    },
+    "extends": "eslint:recommended",
+    "rules": {
+        // Unsafe or confusing stuff that we forbid
+
+        "no-unused-vars": ["error", { "vars": "all", "args": "none", "ignoreRestSiblings": true }],
+        "no-constant-condition": ["error", { "checkLoops": false }],
+        "no-var": "error",
+        "no-useless-constructor": "error",
+        "object-shorthand": ["error", "methods", { "avoidQuotes": true }],
+        "prefer-arrow-callback": "error",
+        "arrow-body-style": ["error", "as-needed", { "requireReturnForObjectLiteral": false } ],
+        "arrow-parens": ["error", "as-needed", { "requireForBlockBody": true }],
+        "arrow-spacing": ["error"],
+        "no-confusing-arrow": ["error", { "allowParens": true }],
+
+        // Enforced coding style
+
+        "brace-style": ["error", "1tbs", { "allowSingleLine": true }],
+        "indent": ["error", 4, { "SwitchCase": 1,
+                                 "FunctionDeclaration": { "parameters": "first" },
+                                 "CallExpression": { "arguments": "first" },
+                                 "ArrayExpression": "first",
+                                 "ObjectExpression": "first",
+                                 "ignoreComments": true }],
+        "comma-spacing": ["error"],
+        "comma-style": ["error"],
+        "curly": ["error", "multi-line"],
+        "func-call-spacing": ["error"],
+        "func-names": ["error"],
+        "func-style": ["error", "declaration", { "allowArrowFunctions": true }],
+        "key-spacing": ["error"],
+        "keyword-spacing": ["error"],
+        "no-trailing-spaces": ["error"],
+        "semi": ["error"],
+        "space-before-blocks": ["error"],
+        "space-before-function-paren": ["error", { "anonymous": "always",
+                                                   "named": "never",
+                                                   "asyncArrow": "always" }],
+        "switch-colon-spacing": ["error"],
+        "camelcase": ["error", { allow: ["^XK_", "^XF86XK_"] }],
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/AUTHORS
@@ -0,0 +1,13 @@
+maintainers:
+- Joel Martin (@kanaka)
+- Solly Ross (@directxman12)
+- Samuel Mannehed for Cendio AB (@samhed)
+- Pierre Ossman for Cendio AB (@CendioOssman)
+maintainersEmeritus:
+- @astrand 
+contributors:
+# There are a bunch of people that should be here.
+# If you want to be on this list, feel free send a PR
+# to add yourself.
+- jalf <git@jalf.dk>
+- NTT corp.
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/LICENSE.txt
@@ -0,0 +1,62 @@
+noVNC is Copyright (C) 2019 The noVNC Authors
+(./AUTHORS)
+
+The noVNC core library files are licensed under the MPL 2.0 (Mozilla
+Public License 2.0). The noVNC core library is composed of the
+Javascript code necessary for full noVNC operation. This includes (but
+is not limited to):
+
+    core/**/*.js
+    app/*.js
+    test/playback.js
+
+The HTML, CSS, font and images files that included with the noVNC
+source distibution (or repository) are not considered part of the
+noVNC core library and are licensed under more permissive licenses.
+The intent is to allow easy integration of noVNC into existing web
+sites and web applications.
+
+The HTML, CSS, font and image files are licensed as follows:
+
+    *.html                     : 2-Clause BSD license
+
+    app/styles/*.css           : 2-Clause BSD license
+
+    app/styles/Orbitron*       : SIL Open Font License 1.1
+                                 (Copyright 2009 Matt McInerney)
+
+    app/images/                : Creative Commons Attribution-ShareAlike
+                                 http://creativecommons.org/licenses/by-sa/3.0/
+
+Some portions of noVNC are copyright to their individual authors.
+Please refer to the individual source files and/or to the noVNC commit
+history: https://github.com/novnc/noVNC/commits/master
+
+The are several files and projects that have been incorporated into
+the noVNC core library. Here is a list of those files and the original
+licenses (all MPL 2.0 compatible):
+
+    core/base64.js          : MPL 2.0
+
+    core/des.js             : Various BSD style licenses
+
+    vendor/pako/            : MIT
+
+Any other files not mentioned above are typically marked with
+a copyright/license header at the top of the file. The default noVNC
+license is MPL-2.0.
+
+The following license texts are included:
+
+    docs/LICENSE.MPL-2.0
+    docs/LICENSE.OFL-1.1
+    docs/LICENSE.BSD-3-Clause (New BSD)
+    docs/LICENSE.BSD-2-Clause (Simplified BSD / FreeBSD)
+    vendor/pako/LICENSE (MIT)
+
+Or alternatively the license texts may be found here:
+
+    http://www.mozilla.org/MPL/2.0/
+    http://scripts.sil.org/OFL
+    http://en.wikipedia.org/wiki/BSD_licenses
+    https://opensource.org/licenses/MIT
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/README.md
@@ -0,0 +1,224 @@
+## noVNC: HTML VNC Client Library and Application
+
+[![Test Status](https://github.com/novnc/noVNC/workflows/Test/badge.svg)](https://github.com/novnc/noVNC/actions?query=workflow%3ATest)
+[![Lint Status](https://github.com/novnc/noVNC/workflows/Lint/badge.svg)](https://github.com/novnc/noVNC/actions?query=workflow%3ALint)
+
+### Description
+
+noVNC is both a HTML VNC client JavaScript library and an application built on
+top of that library. noVNC runs well in any modern browser including mobile
+browsers (iOS and Android).
+
+Many companies, projects and products have integrated noVNC including
+[OpenStack](http://www.openstack.org),
+[OpenNebula](http://opennebula.org/),
+[LibVNCServer](http://libvncserver.sourceforge.net), and
+[ThinLinc](https://cendio.com/thinlinc). See
+[the Projects and Companies wiki page](https://github.com/novnc/noVNC/wiki/Projects-and-companies-using-noVNC)
+for a more complete list with additional info and links.
+
+### Table of Contents
+
+- [News/help/contact](#newshelpcontact)
+- [Features](#features)
+- [Screenshots](#screenshots)
+- [Browser Requirements](#browser-requirements)
+- [Server Requirements](#server-requirements)
+- [Quick Start](#quick-start)
+- [Installation from Snap Package](#installation-from-snap-package)
+- [Integration and Deployment](#integration-and-deployment)
+- [Authors/Contributors](#authorscontributors)
+
+### News/help/contact
+
+The project website is found at [novnc.com](http://novnc.com).
+Notable commits, announcements and news are posted to
+[@noVNC](http://www.twitter.com/noVNC).
+
+If you are a noVNC developer/integrator/user (or want to be) please join the
+[noVNC discussion group](https://groups.google.com/forum/?fromgroups#!forum/novnc).
+
+Bugs and feature requests can be submitted via
+[github issues](https://github.com/novnc/noVNC/issues). If you have questions
+about using noVNC then please first use the
+[discussion group](https://groups.google.com/forum/?fromgroups#!forum/novnc).
+We also have a [wiki](https://github.com/novnc/noVNC/wiki/) with lots of
+helpful information.
+
+If you are looking for a place to start contributing to noVNC, a good place to
+start would be the issues that are marked as
+["patchwelcome"](https://github.com/novnc/noVNC/issues?labels=patchwelcome).
+Please check our
+[contribution guide](https://github.com/novnc/noVNC/wiki/Contributing) though.
+
+If you want to show appreciation for noVNC you could donate to a great non-
+profits such as:
+[Compassion International](http://www.compassion.com/),
+[SIL](http://www.sil.org),
+[Habitat for Humanity](http://www.habitat.org),
+[Electronic Frontier Foundation](https://www.eff.org/),
+[Against Malaria Foundation](http://www.againstmalaria.com/),
+[Nothing But Nets](http://www.nothingbutnets.net/), etc.
+Please tweet [@noVNC](http://www.twitter.com/noVNC) if you do.
+
+
+### Features
+
+* Supports all modern browsers including mobile (iOS, Android)
+* Supported VNC encodings: raw, copyrect, rre, hextile, tight, tightPNG
+* Supports scaling, clipping and resizing the desktop
+* Local cursor rendering
+* Clipboard copy/paste
+* Translations
+* Touch gestures for emulating common mouse actions
+* Licensed mainly under the [MPL 2.0](http://www.mozilla.org/MPL/2.0/), see
+  [the license document](LICENSE.txt) for details
+
+### Screenshots
+
+Running in Firefox before and after connecting:
+
+<img src="http://novnc.com/img/noVNC-1-login.png" width=400>&nbsp;
+<img src="http://novnc.com/img/noVNC-3-connected.png" width=400>
+
+See more screenshots
+[here](http://novnc.com/screenshots.html).
+
+
+### Browser Requirements
+
+noVNC uses many modern web technologies so a formal requirement list is
+not available. However these are the minimum versions we are currently
+aware of:
+
+* Chrome 64, Firefox 79, Safari 13.4, Opera 51, Edge 79
+
+
+### Server Requirements
+
+noVNC follows the standard VNC protocol, but unlike other VNC clients it does
+require WebSockets support. Many servers include support (e.g.
+[x11vnc/libvncserver](http://libvncserver.sourceforge.net/),
+[QEMU](http://www.qemu.org/), and
+[MobileVNC](http://www.smartlab.at/mobilevnc/)), but for the others you need to
+use a WebSockets to TCP socket proxy. noVNC has a sister project
+[websockify](https://github.com/novnc/websockify) that provides a simple such
+proxy.
+
+
+### Quick Start
+
+* Use the `novnc_proxy` script to automatically download and start websockify, which
+  includes a mini-webserver and the WebSockets proxy. The `--vnc` option is
+  used to specify the location of a running VNC server:
+
+    `./utils/novnc_proxy --vnc localhost:5901`
+    
+* If you don't need to expose the web server to public internet, you can
+  bind to localhost:
+  
+    `./utils/novnc_proxy --vnc localhost:5901 --listen localhost:6081`
+
+* Point your browser to the cut-and-paste URL that is output by the `novnc_proxy`
+  script. Hit the Connect button, enter a password if the VNC server has one
+  configured, and enjoy!
+
+### Installation from Snap Package
+Running the command below will install the latest release of noVNC from Snap:
+
+`sudo snap install novnc`
+
+#### Running noVNC from Snap Directly
+
+You can run the Snap-package installed novnc directly with, for example:
+
+`novnc --listen 6081 --vnc localhost:5901 # /snap/bin/novnc if /snap/bin is not in your PATH`
+
+If you want to use certificate files, due to standard Snap confinement restrictions you need to have them in the /home/\<user\>/snap/novnc/current/ directory. If your username is jsmith an example command would be:
+  
+  `novnc --listen 8443 --cert ~jsmith/snap/novnc/current/self.crt --key ~jsmith/snap/novnc/current/self.key --vnc ubuntu.example.com:5901`
+
+#### Running noVNC from Snap as a Service (Daemon)
+The Snap package also has the capability to run a 'novnc' service which can be 
+configured to listen on multiple ports connecting to multiple VNC servers 
+(effectively a service runing multiple instances of novnc).
+Instructions (with example values):
+
+List current services (out-of-box this will be blank):
+
+```
+sudo snap get novnc services
+Key             Value
+services.n6080  {...}
+services.n6081  {...}
+```
+
+Create a new service that listens on port 6082 and connects to the VNC server 
+running on port 5902 on localhost:
+
+`sudo snap set novnc services.n6082.listen=6082 services.n6082.vnc=localhost:5902`
+
+(Any services you define with 'snap set' will be automatically started)
+Note that the name of the service, 'n6082' in this example, can be anything 
+as long as it doesn't start with a number or contain spaces/special characters.
+
+View the configuration of the service just created:
+
+```
+sudo snap get novnc services.n6082
+Key                    Value
+services.n6082.listen  6082
+services.n6082.vnc     localhost:5902
+```
+
+Disable a service (note that because of a limitation in  Snap it's currently not 
+possible to unset config variables, setting them to blank values is the way 
+to disable a service):
+
+`sudo snap set novnc services.n6082.listen='' services.n6082.vnc=''`
+
+(Any services you set to blank with 'snap set' like this will be automatically stopped)
+
+Verify that the service is disabled (blank values):
+
+```
+sudo snap get novnc services.n6082
+Key                    Value
+services.n6082.listen  
+services.n6082.vnc
+```
+
+### Integration and Deployment
+
+Please see our other documents for how to integrate noVNC in your own software,
+or deploying the noVNC application in production environments:
+
+* [Embedding](docs/EMBEDDING.md) - For the noVNC application
+* [Library](docs/LIBRARY.md) - For the noVNC JavaScript library
+
+
+### Authors/Contributors
+
+See [AUTHORS](AUTHORS) for a (full-ish) list of authors.  If you're not on
+that list and you think you should be, feel free to send a PR to fix that.
+
+* Core team:
+    * [Joel Martin](https://github.com/kanaka)
+    * [Samuel Mannehed](https://github.com/samhed) (Cendio)
+    * [Solly Ross](https://github.com/DirectXMan12) (Red Hat / OpenStack)
+    * [Pierre Ossman](https://github.com/CendioOssman) (Cendio)
+
+* Notable contributions:
+    * UI and Icons : Pierre Ossman, Chris Gordon
+    * Original Logo : Michael Sersen
+    * tight encoding : Michael Tinglof (Mercuri.ca)
+    * RealVNC RSA AES authentication : USTC Vlab Team
+
+* Included libraries:
+    * base64 : Martijn Pieters (Digital Creations 2), Samuel Sieb (sieb.net)
+    * DES : Dave Zimmerman (Widget Workshop), Jef Poskanzer (ACME Labs)
+    * Pako : Vitaly Puzrin (https://github.com/nodeca/pako)
+
+Do you want to be on this list? Check out our
+[contribution guide](https://github.com/novnc/noVNC/wiki/Contributing) and
+start hacking!
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/error-handler.js
@@ -0,0 +1,79 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+// Fallback for all uncought errors
+function handleError(event, err) {
+    try {
+        const msg = document.getElementById('noVNC_fallback_errormsg');
+
+        // Work around Firefox bug:
+        // https://bugzilla.mozilla.org/show_bug.cgi?id=1685038
+        if (event.message === "ResizeObserver loop completed with undelivered notifications.") {
+            return false;
+        }
+
+        // Only show the initial error
+        if (msg.hasChildNodes()) {
+            return false;
+        }
+
+        let div = document.createElement("div");
+        div.classList.add('noVNC_message');
+        div.appendChild(document.createTextNode(event.message));
+        msg.appendChild(div);
+
+        if (event.filename) {
+            div = document.createElement("div");
+            div.className = 'noVNC_location';
+            let text = event.filename;
+            if (event.lineno !== undefined) {
+                text += ":" + event.lineno;
+                if (event.colno !== undefined) {
+                    text += ":" + event.colno;
+                }
+            }
+            div.appendChild(document.createTextNode(text));
+            msg.appendChild(div);
+        }
+
+        if (err && err.stack) {
+            div = document.createElement("div");
+            div.className = 'noVNC_stack';
+            div.appendChild(document.createTextNode(err.stack));
+            msg.appendChild(div);
+        }
+
+        document.getElementById('noVNC_fallback_error')
+            .classList.add("noVNC_open");
+
+    } catch (exc) {
+        document.write("noVNC encountered an error.");
+    }
+
+    // Try to disable keyboard interaction, best effort
+    try {
+        // Remove focus from the currently focused element in order to
+        // prevent keyboard interaction from continuing
+        if (document.activeElement) { document.activeElement.blur(); }
+
+        // Don't let any element be focusable when showing the error
+        let keyboardFocusable = 'a[href], button, input, textarea, select, details, [tabindex]';
+        document.querySelectorAll(keyboardFocusable).forEach((elem) => {
+            elem.setAttribute("tabindex", "-1");
+        });
+    } catch (exc) {
+        // Do nothing
+    }
+
+    // Don't return true since this would prevent the error
+    // from being printed to the browser console.
+    return false;
+}
+
+window.addEventListener('error', evt => handleError(evt, evt.error));
+window.addEventListener('unhandledrejection', evt => handleError(evt.reason, evt.reason));
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/alt.svg
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="alt.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="16"
+     inkscape:cx="18.205425"
+     inkscape:cy="17.531398"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="true"
+     inkscape:snap-global="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <g
+       style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:48px;line-height:125%;font-family:'DejaVu Sans';-inkscape-font-specification:'Sans Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       id="text5290">
+      <path
+         d="m 9.9560547,1042.3329 -2.9394531,0 -0.4638672,1.3281 -1.8896485,0 2.7001953,-7.29 2.241211,0 2.7001958,7.29 -1.889649,0 -0.4589843,-1.3281 z m -2.4707031,-1.3526 1.9970703,0 -0.9960938,-2.9003 -1.0009765,2.9003 z"
+         style="font-size:10px;fill:#ffffff;fill-opacity:1"
+         id="path5340" />
+      <path
+         d="m 13.188477,1036.0634 1.748046,0 0,7.5976 -1.748046,0 0,-7.5976 z"
+         style="font-size:10px;fill:#ffffff;fill-opacity:1"
+         id="path5342" />
+      <path
+         d="m 18.535156,1036.6395 0,1.5528 1.801758,0 0,1.25 -1.801758,0 0,2.3193 q 0,0.3809 0.151367,0.5176 0.151368,0.1318 0.600586,0.1318 l 0.898438,0 0,1.25 -1.499024,0 q -1.035156,0 -1.469726,-0.4297 -0.429688,-0.4345 -0.429688,-1.4697 l 0,-2.3193 -0.86914,0 0,-1.25 0.86914,0 0,-1.5528 1.748047,0 z"
+         style="font-size:10px;fill:#ffffff;fill-opacity:1"
+         id="path5344" />
+    </g>
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/clipboard.svg
@@ -0,0 +1,106 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="clipboard.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1"
+     inkscape:cx="15.366606"
+     inkscape:cy="16.42981"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="true"
+     inkscape:snap-global="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <path
+       style="opacity:1;fill:none;fill-opacity:1;stroke:#ffffff;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       d="M 9,6 6,6 C 5.4459889,6 5,6.4459889 5,7 l 0,13 c 0,0.554011 0.4459889,1 1,1 l 13,0 c 0.554011,0 1,-0.445989 1,-1 L 20,7 C 20,6.4459889 19.554011,6 19,6 l -3,0"
+       transform="translate(0,1027.3622)"
+       id="rect6083"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cssssssssc" />
+    <rect
+       style="opacity:1;fill:none;fill-opacity:1;stroke:#ffffff;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="rect6085"
+       width="7"
+       height="4"
+       x="9"
+       y="1031.3622"
+       ry="1.00002" />
+    <path
+       style="fill:none;fill-rule:evenodd;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:0.50196081"
+       d="m 8.5071212,1038.8622 7.9999998,0"
+       id="path6087"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;fill-rule:evenodd;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:0.50196081"
+       d="m 8.5071212,1041.8622 3.9999998,0"
+       id="path6089"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;fill-rule:evenodd;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:0.50196081"
+       d="m 8.5071212,1044.8622 5.9999998,0"
+       id="path6091"
+       inkscape:connector-curvature="0" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/configurevm.svg
@@ -0,0 +1,74 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   zoomAndPan="magnify"
+   viewBox="0 0 388.75 388.75"
+   height="25"
+   preserveAspectRatio="xMidYMid meet"
+   version="1.0"
+   id="svg952"
+   sodipodi:docname="configurevm.svg"
+   inkscape:version="1.0.2 (e86c870879, 2021-01-15, custom)">
+  <metadata
+     id="metadata956">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <sodipodi:namedview
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1"
+     objecttolerance="10"
+     gridtolerance="10"
+     guidetolerance="10"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:window-width="1920"
+     inkscape:window-height="1001"
+     id="namedview954"
+     showgrid="false"
+     scale-x="15.55"
+     inkscape:zoom="1.66"
+     inkscape:cx="107.74703"
+     inkscape:cy="146.30425"
+     inkscape:window-x="-9"
+     inkscape:window-y="-9"
+     inkscape:window-maximized="1"
+     inkscape:current-layer="svg952" />
+  <defs
+     id="defs946">
+    <clipPath
+       id="672aaa7d5a">
+      <path
+         d="M 6.105469,6.105469 H 372 V 372 H 6.105469 Z m 0,0"
+         clip-rule="nonzero"
+         id="path943" />
+    </clipPath>
+  </defs>
+  <g
+     clip-path="url(#672aaa7d5a)"
+     id="g950"
+     style="fill:#ffffff">
+    <path
+       fill="#ffffff"
+       d="m 307.23047,209.70312 -1.32813,5.66797 c -1.9414,8.61719 -4.85547,17.00391 -8.61328,25.00391 l -27.01562,-27.01172 c 8.25781,-29.05469 0.19531,-60.3125 -21.08594,-81.75781 -15.90625,-16.03125 -37.73828,-24.80859 -60.28125,-24.25781 -7.64453,0.0937 -14.47656,4.75781 -17.35938,11.82031 -2.88281,6.96484 -1.23437,14.99609 4.14454,20.24609 l 23.03125,23.02735 c 10.23437,9.84765 10.91406,26.01171 1.55468,36.69921 -9.71875,10.30079 -25.94531,10.82032 -36.28125,1.13672 -0.1914,-0.19531 -0.35547,-0.35937 -0.54687,-0.55078 l -24.03516,-24.03515 c -5.25,-5.37891 -13.25,-6.9961 -20.21484,-4.14454 -7.09375,2.78516 -11.78906,9.58594 -11.88672,17.19922 -0.58203,25.87891 10.94922,50.52735 31.19531,66.66016 21.11719,16.71484 48.97266,22.25391 74.88672,14.86719 l 26.98047,27.01562 c -7.96875,3.75781 -16.38672,6.67188 -25.00391,8.61328 l -5.66797,1.29688 v 48.75 c -13.50781,1.58594 -27.17578,1.58594 -40.71875,0.0312 v -48.78125 l -5.66796,-1.29688 c -13.44141,-3.01172 -26.26954,-8.32422 -37.92969,-15.70703 l -4.92188,-3.14453 -34.531246,34.49609 C 75.179688,313.16016 65.527344,303.47266 57.140625,292.75391 l 34.496094,-34.53125 -3.140625,-4.92188 C 81.140625,241.64062 75.796875,228.8125 72.753906,215.37109 l -1.265625,-5.66797 h -48.75 c -1.617187,-13.50781 -1.617187,-27.17578 0,-40.71875 h 48.75 l 1.265625,-5.66796 C 75.796875,149.875 81.140625,137.04687 88.496094,125.38672 L 91.636719,120.46484 57.140625,85.933594 C 65.527344,75.179688 75.179688,65.527344 85.933594,57.140625 l 34.531246,34.496094 4.92188,-3.140625 C 137.04687,81.140625 149.875,75.796875 163.31641,72.785156 l 5.66796,-1.328125 v -48.71875 c 13.54297,-1.585937 27.21094,-1.617187 40.71875,0 v 48.71875 l 5.66797,1.328125 c 13.44141,3.011719 26.26953,8.355469 37.92969,15.710938 l 4.92188,3.140625 34.53125,-34.496094 c 10.7539,8.386719 20.40625,18.039063 28.79296,28.792969 l -34.49609,34.531246 3.14453,4.92188 c 7.35156,11.66015 12.69531,24.48828 15.70703,37.92969 l 1.32813,5.66796 h 48.71875 c 1.61719,13.54297 1.61719,27.21094 0,40.71875 z m 42.43359,103.6836 c 9.97656,10.03906 9.94531,26.26953 -0.0976,36.27734 -10.03907,9.94531 -26.23829,9.94531 -36.2461,-0.0664 l -95.97265,-96.00391 -4.3086,1.48828 c -22.2539,7.70703 -46.90234,3.53125 -65.39844,-11.04687 -16.67968,-13.3125 -26.20312,-33.6211 -25.71874,-54.96485 -0.0312,-1.75 1.07031,-3.37109 2.72265,-3.98437 1.51953,-0.67969 3.30078,-0.29297 4.4375,0.9375 l 24.03125,24.0039 c 7.64453,7.77344 18.14063,12.04688 29.05469,11.78907 10.88672,-0.12891 21.28125,-4.73047 28.73047,-12.66407 14.70703,-16.45703 13.89843,-41.55859 -1.84375,-57.00781 l -23.03125,-23.0625 c -1.23047,-1.10156 -1.61719,-2.88281 -0.9375,-4.4375 0.64843,-1.65234 2.26562,-2.7539 4.07812,-2.72265 18.625,-0.48438 36.60547,6.73828 49.69141,20.01953 18.6875,18.52734 25.03515,46.21875 16.22656,71.03125 l -1.48828,4.33984 z m 9.23047,-89.10938 c 5.57422,-0.0312 10.33203,-4.11328 11.14453,-9.65234 2.29688,-16.8125 2.29688,-33.87891 -0.0351,-50.69141 -0.8711,-5.47265 -5.57032,-9.52343 -11.10938,-9.52343 h -40.16406 c -3.01172,-11.10938 -7.44922,-21.80079 -13.1836,-31.8086 l 28.3086,-28.339841 c 4.01953,-3.953125 4.5039,-10.238281 1.16797,-14.738281 -10.23438,-13.605469 -22.31641,-25.6875 -35.92188,-35.890626 -4.46875,-3.304687 -10.65625,-2.816406 -14.57422,1.101563 l -28.4414,28.40625 C 246.10937,67.40625 235.38672,62.96875 224.27734,59.957031 V 19.792969 C 224.24609,14.222656 220.16406,9.460938 214.625,8.648438 197.8125,6.351562 180.74609,6.351562 163.93359,8.683594 c -5.47265,0.839844 -9.52343,5.570312 -9.52343,11.109375 v 40.164062 c -11.14063,3.011719 -21.83204,7.449219 -31.8086,13.183594 L 94.261719,44.832031 C 90.308594,40.816406 84.023438,40.328125 79.523438,43.664062 65.917969,53.902344 53.835938,65.980469 43.632812,79.585938 c -3.304687,4.46875 -2.816406,10.65625 1.101563,14.578124 l 28.40625,28.437498 C 67.40625,132.60937 62.96875,143.30078 59.957031,154.41016 H 19.792969 c -5.605469,0.0312 -10.300781,4.11328 -11.144531,9.65234 -2.296876,16.8125 -2.296876,33.88281 0,50.69141 0.875,5.47656 5.605468,9.52343 11.144531,9.52343 h 40.164062 c 3.011719,11.10938 7.449219,21.83203 13.183594,31.8086 l -28.308594,28.375 c -4.015625,3.91797 -4.503906,10.20312 -1.167969,14.70703 10.238282,13.60156 22.316407,25.65234 35.921876,35.88672 4.472656,3.30468 10.65625,2.82031 14.578124,-1.10157 l 28.437498,-28.40625 c 9.97656,5.73438 20.66797,10.17188 31.8086,13.1836 v 40.16406 c 0.0312,5.60547 4.11328,10.30078 9.65234,11.14453 16.8125,2.29688 33.84766,2.26563 50.69141,-0.0351 5.47656,-0.83985 9.52343,-5.57032 9.52343,-11.10938 v -40.16406 c 9.36328,-2.5586 18.36719,-6.1211 26.98047,-10.59375 l 51.76172,51.79687 c 15.67969,15.74219 41.13672,15.80469 56.91406,0.12891 15.74219,-15.67969 15.80469,-41.17188 0.12891,-56.91406 -0.0352,-0.0312 -0.0664,-0.0625 -0.0977,-0.0937 l -51.82812,-51.82813 c 4.47265,-8.58203 8.03515,-17.58594 10.59375,-26.94922 h 40.16406"
+       fill-opacity="1"
+       fill-rule="nonzero"
+       id="path948"
+       style="fill:#ffffff" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/connect.svg
@@ -0,0 +1,96 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="connect.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1"
+     inkscape:cx="37.14834"
+     inkscape:cy="1.9525926"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <g
+       id="g5103"
+       transform="matrix(0.70710678,-0.70710678,0.70710678,0.70710678,-729.15757,315.8823)">
+      <path
+         sodipodi:nodetypes="cssssc"
+         inkscape:connector-curvature="0"
+         id="rect5096"
+         d="m 11,1040.3622 -5,0 c -1.108,0 -2,-0.892 -2,-2 l 0,-4 c 0,-1.108 0.892,-2 2,-2 l 5,0"
+         style="opacity:1;fill:none;fill-opacity:1;stroke:#ffffff;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
+      <path
+         style="opacity:1;fill:none;fill-opacity:1;stroke:#ffffff;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+         d="m 14,1032.3622 5,0 c 1.108,0 2,0.892 2,2 l 0,4 c 0,1.108 -0.892,2 -2,2 l -5,0"
+         id="path5099"
+         inkscape:connector-curvature="0"
+         sodipodi:nodetypes="cssssc" />
+      <path
+         inkscape:connector-curvature="0"
+         id="path5101"
+         d="m 9,1036.3622 7,0"
+         style="fill:none;fill-rule:evenodd;stroke:#ffffff;stroke-width:2;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" />
+    </g>
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/ctrl.svg
@@ -0,0 +1,96 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="ctrl.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="16"
+     inkscape:cx="18.205425"
+     inkscape:cy="17.531398"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="true"
+     inkscape:snap-global="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <g
+       style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:48px;line-height:125%;font-family:'DejaVu Sans';-inkscape-font-specification:'Sans Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       id="text5290">
+      <path
+         d="m 9.1210938,1043.1898 q -0.5175782,0.2686 -1.0791016,0.4053 -0.5615235,0.1367 -1.171875,0.1367 -1.8212891,0 -2.8857422,-1.0156 -1.0644531,-1.0205 -1.0644531,-2.7637 0,-1.748 1.0644531,-2.7637 1.0644531,-1.0205 2.8857422,-1.0205 0.6103515,0 1.171875,0.1368 0.5615234,0.1367 1.0791016,0.4052 l 0,1.5088 q -0.522461,-0.3564 -1.0302735,-0.5224 -0.5078125,-0.1661 -1.0693359,-0.1661 -1.0058594,0 -1.5820313,0.6446 -0.5761719,0.6445 -0.5761719,1.7773 0,1.1279 0.5761719,1.7725 0.5761719,0.6445 1.5820313,0.6445 0.5615234,0 1.0693359,-0.166 0.5078125,-0.166 1.0302735,-0.5225 l 0,1.5088 z"
+         style="font-size:10px;fill:#ffffff;fill-opacity:1"
+         id="path5370" />
+      <path
+         d="m 12.514648,1036.5687 0,1.5528 1.801758,0 0,1.25 -1.801758,0 0,2.3193 q 0,0.3809 0.151368,0.5176 0.151367,0.1318 0.600586,0.1318 l 0.898437,0 0,1.25 -1.499023,0 q -1.035157,0 -1.469727,-0.4297 -0.429687,-0.4345 -0.429687,-1.4697 l 0,-2.3193 -0.8691411,0 0,-1.25 0.8691411,0 0,-1.5528 1.748046,0 z"
+         style="font-size:10px;fill:#ffffff;fill-opacity:1"
+         id="path5372" />
+      <path
+         d="m 19.453125,1039.6107 q -0.229492,-0.1074 -0.458984,-0.1562 -0.22461,-0.054 -0.454102,-0.054 -0.673828,0 -1.040039,0.4345 -0.361328,0.4297 -0.361328,1.2354 l 0,2.5195 -1.748047,0 0,-5.4687 1.748047,0 0,0.8984 q 0.336914,-0.5371 0.771484,-0.7813 0.439453,-0.249 1.049805,-0.249 0.08789,0 0.19043,0.01 0.102539,0 0.297851,0.029 l 0.0049,1.582 z"
+         style="font-size:10px;fill:#ffffff;fill-opacity:1"
+         id="path5374" />
+      <path
+         d="m 20.332031,1035.9926 1.748047,0 0,7.5976 -1.748047,0 0,-7.5976 z"
+         style="font-size:10px;fill:#ffffff;fill-opacity:1"
+         id="path5376" />
+    </g>
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/ctrlaltdel.svg
@@ -0,0 +1,100 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="ctrlaltdel.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="8"
+     inkscape:cx="11.135667"
+     inkscape:cy="16.407428"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="true"
+     inkscape:snap-global="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <rect
+       style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="rect5253"
+       width="5"
+       height="5.0000172"
+       x="16"
+       y="1031.3622"
+       ry="1.0000174" />
+    <rect
+       y="1043.3622"
+       x="4"
+       height="5.0000172"
+       width="5"
+       id="rect5255"
+       style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       ry="1.0000174" />
+    <rect
+       style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="rect5257"
+       width="5"
+       height="5.0000172"
+       x="13"
+       y="1043.3622"
+       ry="1.0000174" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/disconnect.svg
@@ -0,0 +1,94 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="disconnect.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="16"
+     inkscape:cx="25.05707"
+     inkscape:cy="11.594858"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="true"
+     inkscape:snap-global="false">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <g
+       id="g5171"
+       transform="translate(-24.062499,-6.15775e-4)">
+      <path
+         id="path5110"
+         transform="translate(0,1027.3622)"
+         d="m 39.744141,3.4960938 c -0.769923,0 -1.539607,0.2915468 -2.121094,0.8730468 l -2.566406,2.5664063 1.414062,1.4140625 2.566406,-2.5664063 c 0.403974,-0.404 1.010089,-0.404 1.414063,0 l 2.828125,2.828125 c 0.40398,0.4039 0.403907,1.0101621 0,1.4140629 l -2.566406,2.566406 1.414062,1.414062 2.566406,-2.566406 c 1.163041,-1.1629 1.162968,-3.0791874 0,-4.2421874 L 41.865234,4.3691406 C 41.283747,3.7876406 40.514063,3.4960937 39.744141,3.4960938 Z M 39.017578,9.015625 a 1.0001,1.0001 0 0 0 -0.6875,0.3027344 l -0.445312,0.4453125 1.414062,1.4140621 0.445313,-0.445312 A 1.0001,1.0001 0 0 0 39.017578,9.015625 Z m -6.363281,0.7070312 a 1.0001,1.0001 0 0 0 -0.6875,0.3027348 L 28.431641,13.5625 c -1.163042,1.163 -1.16297,3.079187 0,4.242188 l 2.828125,2.828124 c 1.162974,1.163101 3.079213,1.163101 4.242187,0 l 3.535156,-3.535156 a 1.0001,1.0001 0 1 0 -1.414062,-1.414062 l -3.535156,3.535156 c -0.403974,0.404 -1.010089,0.404 -1.414063,0 l -2.828125,-2.828125 c -0.403981,-0.404 -0.403908,-1.010162 0,-1.414063 l 3.535156,-3.537109 A 1.0001,1.0001 0 0 0 32.654297,9.7226562 Z m 3.109375,2.1621098 -2.382813,2.384765 a 1.0001,1.0001 0 1 0 1.414063,1.414063 l 2.382812,-2.384766 -1.414062,-1.414062 z"
+         style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;white-space:normal;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
+         inkscape:connector-curvature="0" />
+      <rect
+         transform="matrix(0.70710678,-0.70710678,0.70710678,0.70710678,0,0)"
+         y="752.29541"
+         x="-712.31262"
+         height="18.000017"
+         width="3"
+         id="rect5116"
+         style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
+    </g>
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/drag.svg
@@ -0,0 +1,76 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="drag.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="22.627417"
+     inkscape:cx="9.8789407"
+     inkscape:cy="9.5008608"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="true"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="false"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <path
+       style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       d="m 7.039733,1049.3037 c -0.4309106,-0.1233 -0.7932634,-0.4631 -0.9705434,-0.9103 -0.04922,-0.1241 -0.057118,-0.2988 -0.071321,-1.5771 l -0.015972,-1.4375 -0.328125,-0.082 c -0.7668138,-0.1927 -1.1897046,-0.4275 -1.7031253,-0.9457 -0.4586773,-0.4629 -0.6804297,-0.8433 -0.867034,-1.4875 -0.067215,-0.232 -0.068001,-0.2642 -0.078682,-3.2188 -0.012078,-3.341 -0.020337,-3.2012 0.2099452,-3.5555 0.2246623,-0.3458 0.5798271,-0.5892 0.9667343,-0.6626 0.092506,-0.017 0.531898,-0.032 0.9764271,-0.032 l 0.8082347,0 1.157e-4,1.336 c 1.125e-4,1.2779 0.00281,1.3403 0.062214,1.4378 0.091785,0.1505 0.2357707,0.226 0.4314082,0.2261 0.285389,2e-4 0.454884,-0.1352 0.5058962,-0.4042 0.019355,-0.102 0.031616,-0.982 0.031616,-2.269 0,-1.9756 0.00357,-2.1138 0.059205,-2.2926 0.1645475,-0.5287 0.6307616,-0.9246 1.19078,-1.0113 0.8000572,-0.1238 1.5711277,0.4446 1.6860387,1.2429 0.01732,0.1203 0.03177,0.8248 0.03211,1.5657 6.19e-4,1.3449 7.22e-4,1.347 0.07093,1.4499 0.108355,0.1587 0.255268,0.2248 0.46917,0.2108 0.204069,-0.013 0.316116,-0.08 0.413642,-0.2453 0.06028,-0.1024 0.06307,-0.1778 0.07862,-2.1218 0.01462,-1.8283 0.02124,-2.0285 0.07121,-2.1549 0.260673,-0.659 0.934894,-1.0527 1.621129,-0.9465 0.640523,0.099 1.152269,0.6104 1.243187,1.2421 0.01827,0.1269 0.03175,0.9943 0.03211,2.0657 l 6.19e-4,1.8469 0.07031,0.103 c 0.108355,0.1587 0.255267,0.2248 0.46917,0.2108 0.204069,-0.013 0.316115,-0.08 0.413642,-0.2453 0.05951,-0.1011 0.06329,-0.1786 0.07907,-1.6218 0.01469,-1.3438 0.02277,-1.5314 0.07121,-1.6549 0.257975,-0.6576 0.934425,-1.0527 1.620676,-0.9465 0.640522,0.099 1.152269,0.6104 1.243186,1.2421 0.0186,0.1292 0.03179,1.0759 0.03222,2.3125 7.15e-4,2.0335 0.0025,2.0966 0.06283,2.1956 0.09178,0.1505 0.235771,0.226 0.431409,0.2261 0.285388,2e-4 0.454884,-0.1352 0.505897,-0.4042 0.01874,-0.099 0.03161,-0.8192 0.03161,-1.769 0,-1.4848 0.0043,-1.6163 0.0592,-1.7926 0.164548,-0.5287 0.630762,-0.9246 1.19078,-1.0113 0.800057,-0.1238 1.571128,0.4446 1.686039,1.2429 0.04318,0.2999 0.04372,9.1764 5.78e-4,9.4531 -0.04431,0.2841 -0.217814,0.6241 -0.420069,0.8232 -0.320102,0.315 -0.63307,0.4268 -1.194973,0.4268 l -0.35281,0 -2.51e-4,1.2734 c -1.25e-4,0.7046 -0.01439,1.3642 -0.03191,1.4766 -0.06665,0.4274 -0.372966,0.8704 -0.740031,1.0702 -0.349999,0.1905 0.01748,0.18 -6.242199,0.1776 -5.3622439,0 -5.7320152,-0.01 -5.9121592,-0.057 l 1.4e-5,0 z"
+       id="path4379"
+       inkscape:connector-curvature="0" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/error.svg
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="error.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1"
+     inkscape:cx="14.00357"
+     inkscape:cy="12.443398"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="true"
+     inkscape:snap-global="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <path
+       style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       d="M 7 3 C 4.7839905 3 3 4.7839905 3 7 L 3 18 C 3 20.21601 4.7839905 22 7 22 L 18 22 C 20.21601 22 22 20.21601 22 18 L 22 7 C 22 4.7839905 20.21601 3 18 3 L 7 3 z M 7.6992188 6 A 1.6916875 1.6924297 0 0 1 8.9121094 6.5117188 L 12.5 10.101562 L 16.087891 6.5117188 A 1.6916875 1.6924297 0 0 1 17.251953 6 A 1.6916875 1.6924297 0 0 1 18.480469 8.90625 L 14.892578 12.496094 L 18.480469 16.085938 A 1.6916875 1.6924297 0 1 1 16.087891 18.478516 L 12.5 14.888672 L 8.9121094 18.478516 A 1.6916875 1.6924297 0 1 1 6.5214844 16.085938 L 10.109375 12.496094 L 6.5214844 8.90625 A 1.6916875 1.6924297 0 0 1 7.6992188 6 z "
+       transform="translate(0,1027.3622)"
+       id="rect4135" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/esc.svg
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="esc.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="16"
+     inkscape:cx="18.205425"
+     inkscape:cy="17.531398"
+     inkscape:document-units="px"
+     inkscape:current-layer="text5290"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="true"
+     inkscape:snap-global="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <g
+       style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:48px;line-height:125%;font-family:'DejaVu Sans';-inkscape-font-specification:'Sans Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       id="text5290">
+      <path
+         d="m 3.9331055,1036.1464 5.0732422,0 0,1.4209 -3.1933594,0 0,1.3574 3.0029297,0 0,1.4209 -3.0029297,0 0,1.6699 3.3007812,0 0,1.4209 -5.180664,0 0,-7.29 z"
+         style="font-size:10px;fill:#ffffff;fill-opacity:1"
+         id="path5314" />
+      <path
+         d="m 14.963379,1038.1385 0,1.3282 q -0.561524,-0.2344 -1.083984,-0.3516 -0.522461,-0.1172 -0.986329,-0.1172 -0.498046,0 -0.742187,0.127 -0.239258,0.122 -0.239258,0.3808 0,0.21 0.180664,0.3223 0.185547,0.1123 0.65918,0.166 l 0.307617,0.044 q 1.342773,0.1709 1.806641,0.5615 0.463867,0.3906 0.463867,1.2256 0,0.874 -0.644531,1.3134 -0.644532,0.4395 -1.923829,0.4395 -0.541992,0 -1.123046,-0.088 -0.576172,-0.083 -1.186524,-0.2539 l 0,-1.3281 q 0.522461,0.2539 1.069336,0.3808 0.551758,0.127 1.118164,0.127 0.512695,0 0.771485,-0.1416 0.258789,-0.1416 0.258789,-0.4199 0,-0.2344 -0.180664,-0.3467 -0.175782,-0.1172 -0.708008,-0.1807 l -0.307617,-0.039 q -1.166993,-0.1465 -1.635743,-0.542 -0.46875,-0.3955 -0.46875,-1.2012 0,-0.8691 0.595703,-1.2891 0.595704,-0.4199 1.826172,-0.4199 0.483399,0 1.015625,0.073 0.532227,0.073 1.157227,0.2294 z"
+         style="font-size:10px;fill:#ffffff;fill-opacity:1"
+         id="path5316" />
+      <path
+         d="m 21.066895,1038.1385 0,1.4258 q -0.356446,-0.2441 -0.717774,-0.3613 -0.356445,-0.1172 -0.742187,-0.1172 -0.732422,0 -1.142579,0.4297 -0.405273,0.4248 -0.405273,1.1914 0,0.7666 0.405273,1.1963 0.410157,0.4248 1.142579,0.4248 0.410156,0 0.776367,-0.1221 0.371094,-0.122 0.683594,-0.3613 l 0,1.4307 q -0.410157,0.1513 -0.834961,0.2246 -0.419922,0.078 -0.844727,0.078 -1.479492,0 -2.314453,-0.7568 -0.834961,-0.7618 -0.834961,-2.1143 0,-1.3525 0.834961,-2.1094 0.834961,-0.7617 2.314453,-0.7617 0.429688,0 0.844727,0.078 0.419921,0.073 0.834961,0.2246 z"
+         style="font-size:10px;fill:#ffffff;fill-opacity:1"
+         id="path5318" />
+    </g>
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/expander.svg
@@ -0,0 +1,69 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="9"
+   height="10"
+   viewBox="0 0 9 10"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="expander.svg">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="45.254834"
+     inkscape:cx="9.8737281"
+     inkscape:cy="6.4583132"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="true"
+     units="px"
+     inkscape:snap-object-midpoints="false"
+     inkscape:object-nodes="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="0"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1042.3622)">
+    <path
+       style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;white-space:normal;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:4;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
+       d="M 2.0800781,1042.3633 A 2.0002,2.0002 0 0 0 0,1044.3613 l 0,6 a 2.0002,2.0002 0 0 0 3.0292969,1.7168 l 5,-3 a 2.0002,2.0002 0 0 0 0,-3.4316 l -5,-3 a 2.0002,2.0002 0 0 0 -0.9492188,-0.2832 z"
+       id="path4138"
+       inkscape:connector-curvature="0" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/fullscreen.svg
@@ -0,0 +1,93 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="fullscreen.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1"
+     inkscape:cx="16.400723"
+     inkscape:cy="15.083758"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="false"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="false">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <rect
+       style="opacity:1;fill:none;fill-opacity:1;stroke:#ffffff;stroke-width:2;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="rect5006"
+       width="17"
+       height="17.000017"
+       x="4"
+       y="1031.3622"
+       ry="3.0000174" />
+    <path
+       style="fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#ffffff;stroke-width:1px;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1"
+       d="m 7.5,1044.8622 4,0 -1.5,-1.5 1.5,-1.5 -1,-1 -1.5,1.5 -1.5,-1.5 0,4 z"
+       id="path5017"
+       inkscape:connector-curvature="0" />
+    <path
+       inkscape:connector-curvature="0"
+       id="path5025"
+       d="m 17.5,1034.8622 -4,0 1.5,1.5 -1.5,1.5 1,1 1.5,-1.5 1.5,1.5 0,-4 z"
+       style="fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#ffffff;stroke-width:1px;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/handle.svg
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="5"
+   height="6"
+   viewBox="0 0 5 6"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="handle.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="32"
+     inkscape:cx="1.3551778"
+     inkscape:cy="8.7800329"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="true"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="false"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="true"
+     inkscape:snap-global="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1046.3622)">
+    <path
+       style="fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#ffffff;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       d="m 4.0000803,1049.3622 -3,-2 0,4 z"
+       id="path4247"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cccc" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/handle_bg.svg
@@ -0,0 +1,172 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="15"
+   height="50"
+   viewBox="0 0 15 50"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="handle_bg.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="16"
+     inkscape:cx="-10.001409"
+     inkscape:cy="24.512566"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="true"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="false"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="true"
+     inkscape:snap-global="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1002.3622)">
+    <rect
+       style="opacity:0.25;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="rect4249"
+       width="1"
+       height="1.0000174"
+       x="9.5"
+       y="1008.8622"
+       ry="1.7382812e-05" />
+    <rect
+       ry="1.7382812e-05"
+       y="1013.8622"
+       x="9.5"
+       height="1.0000174"
+       width="1"
+       id="rect4255"
+       style="opacity:0.25;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
+    <rect
+       ry="1.7382812e-05"
+       y="1008.8622"
+       x="4.5"
+       height="1.0000174"
+       width="1"
+       id="rect4261"
+       style="opacity:0.25;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
+    <rect
+       style="opacity:0.25;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="rect4263"
+       width="1"
+       height="1.0000174"
+       x="4.5"
+       y="1013.8622"
+       ry="1.7382812e-05" />
+    <rect
+       ry="1.7382812e-05"
+       y="1039.8622"
+       x="9.5"
+       height="1.0000174"
+       width="1"
+       id="rect4265"
+       style="opacity:0.25;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
+    <rect
+       style="opacity:0.25;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="rect4267"
+       width="1"
+       height="1.0000174"
+       x="9.5"
+       y="1044.8622"
+       ry="1.7382812e-05" />
+    <rect
+       style="opacity:0.25;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="rect4269"
+       width="1"
+       height="1.0000174"
+       x="4.5"
+       y="1039.8622"
+       ry="1.7382812e-05" />
+    <rect
+       ry="1.7382812e-05"
+       y="1044.8622"
+       x="4.5"
+       height="1.0000174"
+       width="1"
+       id="rect4271"
+       style="opacity:0.25;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
+    <rect
+       style="opacity:0.25;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="rect4273"
+       width="1"
+       height="1.0000174"
+       x="9.5"
+       y="1018.8622"
+       ry="1.7382812e-05" />
+    <rect
+       ry="1.7382812e-05"
+       y="1018.8622"
+       x="4.5"
+       height="1.0000174"
+       width="1"
+       id="rect4275"
+       style="opacity:0.25;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
+    <rect
+       style="opacity:0.25;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="rect4277"
+       width="1"
+       height="1.0000174"
+       x="9.5"
+       y="1034.8622"
+       ry="1.7382812e-05" />
+    <rect
+       ry="1.7382812e-05"
+       y="1034.8622"
+       x="4.5"
+       height="1.0000174"
+       width="1"
+       id="rect4279"
+       style="opacity:0.25;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/icons/Makefile
@@ -0,0 +1,42 @@
+ICONS := \
+	novnc-16x16.png \
+	novnc-24x24.png \
+	novnc-32x32.png \
+	novnc-48x48.png \
+	novnc-64x64.png
+
+ANDROID_LAUNCHER := \
+	novnc-48x48.png \
+	novnc-72x72.png \
+	novnc-96x96.png \
+	novnc-144x144.png \
+	novnc-192x192.png
+
+IPHONE_LAUNCHER := \
+	novnc-60x60.png \
+	novnc-120x120.png
+
+IPAD_LAUNCHER := \
+	novnc-76x76.png \
+	novnc-152x152.png
+
+ALL_ICONS := $(ICONS) $(ANDROID_LAUNCHER) $(IPHONE_LAUNCHER) $(IPAD_LAUNCHER)
+
+all: $(ALL_ICONS)
+
+novnc-16x16.png: novnc-icon-sm.svg
+	convert -density 90 \
+		-background transparent "$<" "$@"
+novnc-24x24.png: novnc-icon-sm.svg
+	convert -density 135 \
+		-background transparent "$<" "$@"
+novnc-32x32.png: novnc-icon-sm.svg
+	convert -density 180 \
+		-background transparent "$<" "$@"
+
+novnc-%.png: novnc-icon.svg
+	convert -density $$[`echo $* | cut -d x -f 1` * 90 / 48] \
+		-background transparent "$<" "$@"
+
+clean:
+	rm -f *.png
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/icons/novnc-icon-sm.svg
@@ -0,0 +1,163 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="16"
+   height="16"
+   viewBox="0 0 16 16"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="novnc-icon-sm.svg">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="45.254834"
+     inkscape:cx="9.722703"
+     inkscape:cy="5.5311896"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:object-nodes="true"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:snap-midpoints="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4169" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1036.3621)">
+    <rect
+       style="opacity:1;fill:#494949;fill-opacity:1;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="rect4167"
+       width="16"
+       height="15.999992"
+       x="0"
+       y="1036.3622"
+       ry="2.6666584" />
+    <path
+       style="opacity:1;fill:#313131;fill-opacity:1;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       d="M 2.6666667,1036.3621 C 1.1893373,1036.3621 0,1037.5515 0,1039.0288 l 0,10.6666 c 0,1.4774 1.1893373,2.6667 2.6666667,2.6667 l 4,0 C 11.837333,1052.3621 16,1046.7128 16,1039.6955 l 0,-0.6667 c 0,-1.4773 -1.189337,-2.6667 -2.666667,-2.6667 l -10.6666663,0 z"
+       id="rect4173"
+       inkscape:connector-curvature="0" />
+    <g
+       id="g4381">
+      <g
+         transform="translate(0.25,0.25)"
+         style="fill:#000000;fill-opacity:1"
+         id="g4365">
+        <g
+           style="fill:#000000;fill-opacity:1"
+           id="g4367">
+          <path
+             inkscape:connector-curvature="0"
+             id="path4369"
+             style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+             d="m 4.3289754,1039.3621 c 0.1846149,0 0.3419956,0.071 0.4716623,0.2121 C 4.933546,1039.7121 5,1039.8793 5,1040.0759 l 0,3.2862 -1,0 0,-2.964 c 0,-0.024 -0.011592,-0.036 -0.034038,-0.036 l -1.931924,0 C 2.011349,1040.3621 2,1040.3741 2,1040.3981 l 0,2.964 -1,0 0,-4 z"
+             sodipodi:nodetypes="scsccsssscccs" />
+          <path
+             inkscape:connector-curvature="0"
+             id="path4371"
+             style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+             d="m 6.6710244,1039.3621 2.6579513,0 c 0.184775,0 0.3419957,0.071 0.471662,0.2121 C 9.933546,1039.7121 10,1039.8793 10,1040.0759 l 0,2.5724 c 0,0.1966 -0.066454,0.3655 -0.1993623,0.5069 -0.1296663,0.1379 -0.286887,0.2069 -0.471662,0.2069 l -2.6579513,0 c -0.184775,0 -0.3436164,-0.069 -0.4765247,-0.2069 C 6.0648334,1043.0138 6,1042.8449 6,1042.6483 l 0,-2.5724 c 0,-0.1966 0.064833,-0.3638 0.1944997,-0.5017 0.1329083,-0.1414 0.2917497,-0.2121 0.4765247,-0.2121 z m 2.2949386,1 -1.931926,0 C 7.011344,1040.3621 7,1040.3741 7,1040.3981 l 0,1.928 c 0,0.024 0.011347,0.036 0.034037,0.036 l 1.931926,0 c 0.02269,0 0.034037,-0.012 0.034037,-0.036 l 0,-1.928 c 0,-0.024 -0.011347,-0.036 -0.034037,-0.036 z"
+             sodipodi:nodetypes="sscsscsscsscssssssssss" />
+        </g>
+        <g
+           style="fill:#000000;fill-opacity:1"
+           id="g4373">
+          <path
+             inkscape:connector-curvature="0"
+             id="path4375"
+             style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+             d="m 3,1047.1121 1,-2.75 1,0 -1.5,4 -1,0 -1.5,-4 1,0 z"
+             sodipodi:nodetypes="cccccccc" />
+          <path
+             inkscape:connector-curvature="0"
+             id="path4377"
+             style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+             d="m 9,1046.8621 0,-2.5 1,0 0,4 -1,0 -2,-2.5 0,2.5 -1,0 0,-4 1,0 z"
+             sodipodi:nodetypes="ccccccccccc" />
+          <path
+             inkscape:connector-curvature="0"
+             id="path4379"
+             style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+             d="m 15,1045.3621 -2.96596,0 c -0.02269,0 -0.03404,0.012 -0.03404,0.036 l 0,1.928 c 0,0.024 0.01135,0.036 0.03404,0.036 l 2.96596,0 0,1 -3.324113,0 c -0.188017,0 -0.348479,-0.068 -0.481388,-0.2037 C 11.064833,1048.0192 11,1047.8511 11,1047.6542 l 0,-2.5842 c 0,-0.1969 0.06483,-0.3633 0.194499,-0.4991 0.132909,-0.1392 0.293371,-0.2088 0.481388,-0.2088 l 3.324113,0 z"
+             sodipodi:nodetypes="cssssccscsscscc" />
+        </g>
+      </g>
+      <g
+         id="g4356">
+        <g
+           id="g4347">
+          <path
+             sodipodi:nodetypes="scsccsssscccs"
+             d="m 4.3289754,1039.3621 c 0.1846149,0 0.3419956,0.071 0.4716623,0.2121 C 4.933546,1039.7121 5,1039.8793 5,1040.0759 l 0,3.2862 -1,0 0,-2.964 c 0,-0.024 -0.011592,-0.036 -0.034038,-0.036 l -1.931924,0 c -0.022689,0 -0.034038,0.012 -0.034038,0.036 l 0,2.964 -1,0 0,-4 z"
+             style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#008000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+             id="path4143"
+             inkscape:connector-curvature="0" />
+          <path
+             sodipodi:nodetypes="sscsscsscsscssssssssss"
+             d="m 6.6710244,1039.3621 2.6579513,0 c 0.184775,0 0.3419957,0.071 0.471662,0.2121 C 9.933546,1039.7121 10,1039.8793 10,1040.0759 l 0,2.5724 c 0,0.1966 -0.066454,0.3655 -0.1993623,0.5069 -0.1296663,0.1379 -0.286887,0.2069 -0.471662,0.2069 l -2.6579513,0 c -0.184775,0 -0.3436164,-0.069 -0.4765247,-0.2069 C 6.0648334,1043.0138 6,1042.8449 6,1042.6483 l 0,-2.5724 c 0,-0.1966 0.064833,-0.3638 0.1944997,-0.5017 0.1329083,-0.1414 0.2917497,-0.2121 0.4765247,-0.2121 z m 2.2949386,1 -1.931926,0 C 7.011344,1040.3621 7,1040.3741 7,1040.3981 l 0,1.928 c 0,0.024 0.011347,0.036 0.034037,0.036 l 1.931926,0 c 0.02269,0 0.034037,-0.012 0.034037,-0.036 l 0,-1.928 c 0,-0.024 -0.011347,-0.036 -0.034037,-0.036 z"
+             style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#008000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+             id="path4145"
+             inkscape:connector-curvature="0" />
+        </g>
+        <g
+           id="g4351">
+          <path
+             sodipodi:nodetypes="cccccccc"
+             d="m 3,1047.1121 1,-2.75 1,0 -1.5,4 -1,0 -1.5,-4 1,0 z"
+             style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#ffff00;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+             id="path4147"
+             inkscape:connector-curvature="0" />
+          <path
+             sodipodi:nodetypes="ccccccccccc"
+             d="m 9,1046.8621 0,-2.5 1,0 0,4 -1,0 -2,-2.5 0,2.5 -1,0 0,-4 1,0 z"
+             style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#ffff00;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+             id="path4149"
+             inkscape:connector-curvature="0" />
+          <path
+             sodipodi:nodetypes="cssssccscsscscc"
+             d="m 15,1045.3621 -2.96596,0 c -0.02269,0 -0.03404,0.012 -0.03404,0.036 l 0,1.928 c 0,0.024 0.01135,0.036 0.03404,0.036 l 2.96596,0 0,1 -3.324113,0 c -0.188017,0 -0.348479,-0.068 -0.481388,-0.2037 C 11.064833,1048.0192 11,1047.8511 11,1047.6542 l 0,-2.5842 c 0,-0.1969 0.06483,-0.3633 0.194499,-0.4991 0.132909,-0.1392 0.293371,-0.2088 0.481388,-0.2088 l 3.324113,0 z"
+             style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#ffff00;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+             id="path4151"
+             inkscape:connector-curvature="0" />
+        </g>
+      </g>
+    </g>
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/icons/novnc-icon.svg
@@ -0,0 +1,163 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="48"
+   height="48"
+   viewBox="0 0 48 48.000001"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="novnc-icon.svg">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="11.313708"
+     inkscape:cx="27.187245"
+     inkscape:cy="17.700974"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:object-nodes="true"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:snap-midpoints="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4169" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1004.3621)">
+    <rect
+       style="opacity:1;fill:#494949;fill-opacity:1;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="rect4167"
+       width="48"
+       height="48"
+       x="0"
+       y="1004.3621"
+       ry="7.9999785" />
+    <path
+       style="opacity:1;fill:#313131;fill-opacity:1;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       d="m 8,1004.3621 c -4.4319881,0 -8,3.568 -8,8 l 0,32 c 0,4.432 3.5680119,8 8,8 l 12,0 c 15.512,0 28,-16.948 28,-38 l 0,-2 c 0,-4.432 -3.568012,-8 -8,-8 l -32,0 z"
+       id="rect4173"
+       inkscape:connector-curvature="0" />
+    <g
+       id="g4300"
+       style="fill:#000000;fill-opacity:1;stroke:none"
+       transform="translate(0.5,0.5)">
+      <g
+         id="g4302"
+         style="fill:#000000;fill-opacity:1;stroke:none">
+        <path
+           sodipodi:nodetypes="scsccsssscccs"
+           d="m 11.986926,1016.3621 c 0.554325,0 1.025987,0.2121 1.414987,0.6362 0.398725,0.4138 0.600909,0.9155 0.598087,1.5052 l 0,6.8586 -2,0 0,-6.8914 c 0,-0.072 -0.03404,-0.1086 -0.102113,-0.1086 l -4.7957745,0 C 7.0340375,1018.3621 7,1018.3983 7,1018.4707 l 0,6.8914 -2,0 0,-9 z"
+           style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+           id="path4304"
+           inkscape:connector-curvature="0" />
+        <path
+           sodipodi:nodetypes="sscsscsscsscssssssssss"
+           d="m 17.013073,1016.3621 4.973854,0 c 0.554325,0 1.025987,0.2121 1.414986,0.6362 0.398725,0.4138 0.598087,0.9155 0.598087,1.5052 l 0,4.7172 c 0,0.5897 -0.199362,1.0966 -0.598087,1.5207 -0.388999,0.4138 -0.860661,0.6207 -1.414986,0.6207 l -4.973854,0 c -0.554325,0 -1.030849,-0.2069 -1.429574,-0.6207 C 15.1945,1024.3173 15,1023.8104 15,1023.2207 l 0,-4.7172 c 0,-0.5897 0.1945,-1.0914 0.583499,-1.5052 0.398725,-0.4241 0.875249,-0.6362 1.429574,-0.6362 z m 4.884815,2 -4.795776,0 c -0.06808,0 -0.102112,0.036 -0.102112,0.1086 l 0,4.7828 c 0,0.072 0.03404,0.1086 0.102112,0.1086 l 4.795776,0 c 0.06807,0 0.102112,-0.036 0.102112,-0.1086 l 0,-4.7828 c 0,-0.072 -0.03404,-0.1086 -0.102112,-0.1086 z"
+           style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+           id="path4306"
+           inkscape:connector-curvature="0" />
+      </g>
+      <g
+         id="g4308"
+         style="fill:#000000;fill-opacity:1;stroke:none">
+        <path
+           sodipodi:nodetypes="cccccccc"
+           d="m 12,1036.9177 4.768114,-8.5556 2.231886,0 -6,11 -2,0 -6,-11 2.2318854,0 z"
+           style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+           id="path4310"
+           inkscape:connector-curvature="0" />
+        <path
+           sodipodi:nodetypes="ccccccccccc"
+           d="m 29,1036.3621 0,-8 2,0 0,11 -2,0 -7,-8 0,8 -2,0 0,-11 2,0 z"
+           style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+           id="path4312"
+           inkscape:connector-curvature="0" />
+        <path
+           sodipodi:nodetypes="cssssccscsscscc"
+           d="m 43,1030.3621 -8.897887,0 c -0.06808,0 -0.102113,0.036 -0.102113,0.1069 l 0,6.7862 c 0,0.071 0.03404,0.1069 0.102113,0.1069 l 8.897887,0 0,2 -8.972339,0 c -0.56405,0 -1.045437,-0.2037 -1.444162,-0.6111 C 32.1945,1038.3334 32,1037.8292 32,1037.2385 l 0,-6.7528 c 0,-0.5907 0.1945,-1.0898 0.583499,-1.4972 0.398725,-0.4176 0.880112,-0.6264 1.444162,-0.6264 l 8.972339,0 z"
+           style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+           id="path4314"
+           inkscape:connector-curvature="0" />
+      </g>
+    </g>
+    <g
+       id="g4291"
+       style="stroke:none">
+      <g
+         id="g4282"
+         style="stroke:none">
+        <path
+           inkscape:connector-curvature="0"
+           id="path4143"
+           style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#008000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+           d="m 11.986926,1016.3621 c 0.554325,0 1.025987,0.2121 1.414987,0.6362 0.398725,0.4138 0.600909,0.9155 0.598087,1.5052 l 0,6.8586 -2,0 0,-6.8914 c 0,-0.072 -0.03404,-0.1086 -0.102113,-0.1086 l -4.7957745,0 C 7.0340375,1018.3621 7,1018.3983 7,1018.4707 l 0,6.8914 -2,0 0,-9 z"
+           sodipodi:nodetypes="scsccsssscccs" />
+        <path
+           inkscape:connector-curvature="0"
+           id="path4145"
+           style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#008000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+           d="m 17.013073,1016.3621 4.973854,0 c 0.554325,0 1.025987,0.2121 1.414986,0.6362 0.398725,0.4138 0.598087,0.9155 0.598087,1.5052 l 0,4.7172 c 0,0.5897 -0.199362,1.0966 -0.598087,1.5207 -0.388999,0.4138 -0.860661,0.6207 -1.414986,0.6207 l -4.973854,0 c -0.554325,0 -1.030849,-0.2069 -1.429574,-0.6207 C 15.1945,1024.3173 15,1023.8104 15,1023.2207 l 0,-4.7172 c 0,-0.5897 0.1945,-1.0914 0.583499,-1.5052 0.398725,-0.4241 0.875249,-0.6362 1.429574,-0.6362 z m 4.884815,2 -4.795776,0 c -0.06808,0 -0.102112,0.036 -0.102112,0.1086 l 0,4.7828 c 0,0.072 0.03404,0.1086 0.102112,0.1086 l 4.795776,0 c 0.06807,0 0.102112,-0.036 0.102112,-0.1086 l 0,-4.7828 c 0,-0.072 -0.03404,-0.1086 -0.102112,-0.1086 z"
+           sodipodi:nodetypes="sscsscsscsscssssssssss" />
+      </g>
+      <g
+         id="g4286"
+         style="stroke:none">
+        <path
+           inkscape:connector-curvature="0"
+           id="path4147"
+           style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#ffff00;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+           d="m 12,1036.9177 4.768114,-8.5556 2.231886,0 -6,11 -2,0 -6,-11 2.2318854,0 z"
+           sodipodi:nodetypes="cccccccc" />
+        <path
+           inkscape:connector-curvature="0"
+           id="path4149"
+           style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#ffff00;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+           d="m 29,1036.3621 0,-8 2,0 0,11 -2,0 -7,-8 0,8 -2,0 0,-11 2,0 z"
+           sodipodi:nodetypes="ccccccccccc" />
+        <path
+           inkscape:connector-curvature="0"
+           id="path4151"
+           style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Orbitron;-inkscape-font-specification:'Orbitron Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#ffff00;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+           d="m 43,1030.3621 -8.897887,0 c -0.06808,0 -0.102113,0.036 -0.102113,0.1069 l 0,6.7862 c 0,0.071 0.03404,0.1069 0.102113,0.1069 l 8.897887,0 0,2 -8.972339,0 c -0.56405,0 -1.045437,-0.2037 -1.444162,-0.6111 C 32.1945,1038.3334 32,1037.8292 32,1037.2385 l 0,-6.7528 c 0,-0.5907 0.1945,-1.0898 0.583499,-1.4972 0.398725,-0.4176 0.880112,-0.6264 1.444162,-0.6264 l 8.972339,0 z"
+           sodipodi:nodetypes="cssssccscsscscc" />
+      </g>
+    </g>
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/info.svg
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="info.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1"
+     inkscape:cx="15.720838"
+     inkscape:cy="8.9111233"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="false"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="true"
+     inkscape:snap-global="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <path
+       style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       d="M 12.5 3 A 9.5 9.4999914 0 0 0 3 12.5 A 9.5 9.4999914 0 0 0 12.5 22 A 9.5 9.4999914 0 0 0 22 12.5 A 9.5 9.4999914 0 0 0 12.5 3 z M 12.5 5 A 1.5 1.5000087 0 0 1 14 6.5 A 1.5 1.5000087 0 0 1 12.5 8 A 1.5 1.5000087 0 0 1 11 6.5 A 1.5 1.5000087 0 0 1 12.5 5 z M 10.521484 8.9785156 L 12.521484 8.9785156 A 1.50015 1.50015 0 0 1 14.021484 10.478516 L 14.021484 15.972656 A 1.50015 1.50015 0 0 1 14.498047 18.894531 C 14.498047 18.894531 13.74301 19.228309 12.789062 18.912109 C 12.312092 18.754109 11.776235 18.366625 11.458984 17.828125 C 11.141734 17.289525 11.021484 16.668469 11.021484 15.980469 L 11.021484 11.980469 L 10.521484 11.980469 A 1.50015 1.50015 0 1 1 10.521484 8.9804688 L 10.521484 8.9785156 z "
+       transform="translate(0,1027.3622)"
+       id="path4136" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/keyboard.svg
@@ -0,0 +1,88 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="keyboard.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/keyboard.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#717171"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1"
+     inkscape:cx="31.285341"
+     inkscape:cy="8.8028469"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:snap-bbox-midpoints="false"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:object-paths="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-midpoints="true"
+     inkscape:snap-smooth-nodes="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <path
+       style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;white-space:normal;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
+       d="M 7,3 C 4.8012876,3 3,4.8013 3,7 3,11.166667 3,15.333333 3,19.5 3,20.8764 4.1236413,22 5.5,22 l 14,0 C 20.876358,22 22,20.8764 22,19.5 22,15.333333 22,11.166667 22,7 22,4.8013 20.198712,3 18,3 Z m 0,2 11,0 c 1.125307,0 2,0.8747 2,2 L 20,12 5,12 5,7 C 5,5.8747 5.8746931,5 7,5 Z M 6.5,14 C 6.777,14 7,14.223 7,14.5 7,14.777 6.777,15 6.5,15 6.223,15 6,14.777 6,14.5 6,14.223 6.223,14 6.5,14 Z m 2,0 C 8.777,14 9,14.223 9,14.5 9,14.777 8.777,15 8.5,15 8.223,15 8,14.777 8,14.5 8,14.223 8.223,14 8.5,14 Z m 2,0 C 10.777,14 11,14.223 11,14.5 11,14.777 10.777,15 10.5,15 10.223,15 10,14.777 10,14.5 10,14.223 10.223,14 10.5,14 Z m 2,0 C 12.777,14 13,14.223 13,14.5 13,14.777 12.777,15 12.5,15 12.223,15 12,14.777 12,14.5 12,14.223 12.223,14 12.5,14 Z m 2,0 C 14.777,14 15,14.223 15,14.5 15,14.777 14.777,15 14.5,15 14.223,15 14,14.777 14,14.5 14,14.223 14.223,14 14.5,14 Z m 2,0 C 16.777,14 17,14.223 17,14.5 17,14.777 16.777,15 16.5,15 16.223,15 16,14.777 16,14.5 16,14.223 16.223,14 16.5,14 Z m 2,0 C 18.777,14 19,14.223 19,14.5 19,14.777 18.777,15 18.5,15 18.223,15 18,14.777 18,14.5 18,14.223 18.223,14 18.5,14 Z m -13,2 C 5.777,16 6,16.223 6,16.5 6,16.777 5.777,17 5.5,17 5.223,17 5,16.777 5,16.5 5,16.223 5.223,16 5.5,16 Z m 2,0 C 7.777,16 8,16.223 8,16.5 8,16.777 7.777,17 7.5,17 7.223,17 7,16.777 7,16.5 7,16.223 7.223,16 7.5,16 Z m 2,0 C 9.777,16 10,16.223 10,16.5 10,16.777 9.777,17 9.5,17 9.223,17 9,16.777 9,16.5 9,16.223 9.223,16 9.5,16 Z m 2,0 C 11.777,16 12,16.223 12,16.5 12,16.777 11.777,17 11.5,17 11.223,17 11,16.777 11,16.5 11,16.223 11.223,16 11.5,16 Z m 2,0 C 13.777,16 14,16.223 14,16.5 14,16.777 13.777,17 13.5,17 13.223,17 13,16.777 13,16.5 13,16.223 13.223,16 13.5,16 Z m 2,0 C 15.777,16 16,16.223 16,16.5 16,16.777 15.777,17 15.5,17 15.223,17 15,16.777 15,16.5 15,16.223 15.223,16 15.5,16 Z m 2,0 C 17.777,16 18,16.223 18,16.5 18,16.777 17.777,17 17.5,17 17.223,17 17,16.777 17,16.5 17,16.223 17.223,16 17.5,16 Z m 2,0 C 19.777,16 20,16.223 20,16.5 20,16.777 19.777,17 19.5,17 19.223,17 19,16.777 19,16.5 19,16.223 19.223,16 19.5,16 Z M 6,18 c 0.554,0 1,0.446 1,1 0,0.554 -0.446,1 -1,1 -0.554,0 -1,-0.446 -1,-1 0,-0.554 0.446,-1 1,-1 z m 2.8261719,0 7.3476561,0 C 16.631643,18 17,18.368372 17,18.826172 l 0,0.347656 C 17,19.631628 16.631643,20 16.173828,20 L 8.8261719,20 C 8.3683573,20 8,19.631628 8,19.173828 L 8,18.826172 C 8,18.368372 8.3683573,18 8.8261719,18 Z m 10.1113281,0 0.125,0 C 19.581551,18 20,18.4184 20,18.9375 l 0,0.125 C 20,19.5816 19.581551,20 19.0625,20 l -0.125,0 C 18.418449,20 18,19.5816 18,19.0625 l 0,-0.125 C 18,18.4184 18.418449,18 18.9375,18 Z"
+       transform="translate(0,1027.3622)"
+       id="rect4160"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="sccssccsssssccssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss" />
+    <path
+       style="fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#ffffff;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:round;stroke-opacity:1"
+       d="m 12.499929,1033.8622 -2,2 1.500071,0 0,2 1,0 0,-2 1.499929,0 z"
+       id="path4150"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cccccccc" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/power.svg
@@ -0,0 +1,87 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="power.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1"
+     inkscape:cx="9.3159849"
+     inkscape:cy="13.436208"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="true"
+     inkscape:snap-global="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <path
+       style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;white-space:normal;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
+       d="M 9 6.8183594 C 6.3418164 8.1213032 4.5 10.849161 4.5 14 C 4.5 18.4065 8.0935666 22 12.5 22 C 16.906433 22 20.5 18.4065 20.5 14 C 20.5 10.849161 18.658184 8.1213032 16 6.8183594 L 16 9.125 C 17.514327 10.211757 18.5 11.984508 18.5 14 C 18.5 17.3256 15.825553 20 12.5 20 C 9.1744469 20 6.5 17.3256 6.5 14 C 6.5 11.984508 7.4856727 10.211757 9 9.125 L 9 6.8183594 z "
+       transform="translate(0,1027.3622)"
+       id="path6140" />
+    <path
+       style="fill:none;fill-rule:evenodd;stroke:#ffffff;stroke-width:3;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       d="m 12.5,1031.8836 0,6.4786"
+       id="path6142"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/settings.svg
@@ -0,0 +1,76 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="settings.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="22.627417"
+     inkscape:cx="14.69683"
+     inkscape:cy="8.8039511"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="true"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="false"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <path
+       style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       d="M 11 3 L 11 5.1601562 A 7.5 7.5 0 0 0 8.3671875 6.2460938 L 6.84375 4.7226562 L 4.7226562 6.84375 L 6.2480469 8.3691406 A 7.5 7.5 0 0 0 5.1523438 11 L 3 11 L 3 14 L 5.1601562 14 A 7.5 7.5 0 0 0 6.2460938 16.632812 L 4.7226562 18.15625 L 6.84375 20.277344 L 8.3691406 18.751953 A 7.5 7.5 0 0 0 11 19.847656 L 11 22 L 14 22 L 14 19.839844 A 7.5 7.5 0 0 0 16.632812 18.753906 L 18.15625 20.277344 L 20.277344 18.15625 L 18.751953 16.630859 A 7.5 7.5 0 0 0 19.847656 14 L 22 14 L 22 11 L 19.839844 11 A 7.5 7.5 0 0 0 18.753906 8.3671875 L 20.277344 6.84375 L 18.15625 4.7226562 L 16.630859 6.2480469 A 7.5 7.5 0 0 0 14 5.1523438 L 14 3 L 11 3 z M 12.5 10 A 2.5 2.5 0 0 1 15 12.5 A 2.5 2.5 0 0 1 12.5 15 A 2.5 2.5 0 0 1 10 12.5 A 2.5 2.5 0 0 1 12.5 10 z "
+       transform="translate(0,1027.3622)"
+       id="rect4967" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/tab.svg
@@ -0,0 +1,86 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="tab.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="16"
+     inkscape:cx="11.67335"
+     inkscape:cy="17.881696"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="true"
+     inkscape:snap-global="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <path
+       style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       d="m 3,1031.3622 0,8 2,0 0,-4 0,-4 -2,0 z m 2,4 4,4 0,-3 13,0 0,-2 -13,0 0,-3 -4,4 z"
+       id="rect5194"
+       inkscape:connector-curvature="0" />
+    <path
+       id="path5211"
+       d="m 22,1048.3622 0,-8 -2,0 0,4 0,4 2,0 z m -2,-4 -4,-4 0,3 -13,0 0,2 13,0 0,3 4,-4 z"
+       style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       inkscape:connector-curvature="0" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/toggleextrakeys.svg
@@ -0,0 +1,90 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="extrakeys.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1"
+     inkscape:cx="15.234555"
+     inkscape:cy="9.9710826"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="false"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="false">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <path
+       style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;white-space:normal;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
+       d="m 8,1031.3622 c -2.1987124,0 -4,1.8013 -4,4 l 0,8.9996 c 0,2.1987 1.8012876,4 4,4 l 9,0 c 2.198712,0 4,-1.8013 4,-4 l 0,-8.9996 c 0,-2.1987 -1.801288,-4 -4,-4 z m 0,2 9,0 c 1.125307,0 2,0.8747 2,2 l 0,7.0005 c 0,1.1253 -0.874693,2 -2,2 l -9,0 c -1.1253069,0 -2,-0.8747 -2,-2 l 0,-7.0005 c 0,-1.1253 0.8746931,-2 2,-2 z"
+       id="rect5006"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ssssssssssssssssss" />
+    <g
+       style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:10px;line-height:125%;font-family:'DejaVu Sans';-inkscape-font-specification:'Sans Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       id="text4167"
+       transform="matrix(0.96021948,0,0,0.96021948,0.18921715,41.80659)">
+      <path
+         d="m 14.292969,1040.6791 -2.939453,0 -0.463868,1.3281 -1.889648,0 2.700195,-7.29 2.241211,0 2.700196,7.29 -1.889649,0 -0.458984,-1.3281 z m -2.470703,-1.3526 1.99707,0 -0.996094,-2.9004 -1.000976,2.9004 z"
+         id="path4172"
+         inkscape:connector-curvature="0" />
+    </g>
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/warning.svg
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="25"
+   height="25"
+   viewBox="0 0 25 25"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="warning.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#959595"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1"
+     inkscape:cx="16.457343"
+     inkscape:cy="12.179552"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-bbox-edge-midpoints="true"
+     inkscape:object-paths="true"
+     showguides="false"
+     inkscape:window-width="1920"
+     inkscape:window-height="1136"
+     inkscape:window-x="1920"
+     inkscape:window-y="27"
+     inkscape:window-maximized="1"
+     inkscape:snap-smooth-nodes="true"
+     inkscape:object-nodes="true"
+     inkscape:snap-intersection-paths="true"
+     inkscape:snap-nodes="true"
+     inkscape:snap-global="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4136" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1027.3622)">
+    <path
+       style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;white-space:normal;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:4;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
+       d="M 12.513672 3.0019531 C 11.751609 2.9919531 11.052563 3.4242687 10.710938 4.1054688 L 3.2109375 19.105469 C 2.5461937 20.435369 3.5132277 21.9999 5 22 L 20 22 C 21.486772 21.9999 22.453806 20.435369 21.789062 19.105469 L 14.289062 4.1054688 C 13.951849 3.4330688 13.265888 3.0066531 12.513672 3.0019531 z M 12.478516 6.9804688 A 1.50015 1.50015 0 0 1 14 8.5 L 14 14.5 A 1.50015 1.50015 0 1 1 11 14.5 L 11 8.5 A 1.50015 1.50015 0 0 1 12.478516 6.9804688 z M 12.5 17 A 1.5 1.5 0 0 1 14 18.5 A 1.5 1.5 0 0 1 12.5 20 A 1.5 1.5 0 0 1 11 18.5 A 1.5 1.5 0 0 1 12.5 17 z "
+       transform="translate(0,1027.3622)"
+       id="path4208" />
+  </g>
+</svg>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/images/windows.svg
@@ -0,0 +1,65 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Generator: Adobe Illustrator 19.1.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   version="1.1"
+   id="svg2"
+   inkscape:export-ydpi="90"
+   inkscape:export-xdpi="90"
+   sodipodi:docname="windows.svg"
+   inkscape:export-filename="/home/ossman/devel/noVNC/images/drag.png"
+   inkscape:version="0.92.4 (unknown)"
+   x="0px"
+   y="0px"
+   viewBox="-293 384 25 25"
+   xml:space="preserve"
+   width="25"
+   height="25"><metadata
+   id="metadata21"><rdf:RDF><cc:Work
+       rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type
+         rdf:resource="http://purl.org/dc/dcmitype/StillImage" /><dc:title></dc:title></cc:Work></rdf:RDF></metadata><defs
+   id="defs19" /><sodipodi:namedview
+   pagecolor="#959595"
+   bordercolor="#666666"
+   borderopacity="1"
+   objecttolerance="10"
+   gridtolerance="10"
+   guidetolerance="10"
+   inkscape:pageopacity="0"
+   inkscape:pageshadow="2"
+   inkscape:window-width="1920"
+   inkscape:window-height="1136"
+   id="namedview17"
+   showgrid="true"
+   inkscape:pagecheckerboard="false"
+   inkscape:zoom="32"
+   inkscape:cx="3.926913"
+   inkscape:cy="13.255959"
+   inkscape:window-x="1920"
+   inkscape:window-y="27"
+   inkscape:window-maximized="1"
+   inkscape:current-layer="svg2"><inkscape:grid
+     type="xygrid"
+     id="grid818" /></sodipodi:namedview>
+<style
+   type="text/css"
+   id="style2">
+	.st0{fill:#FFFFFF;}
+</style>
+
+<path
+   style="fill:#ffffff;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;fill-opacity:1"
+   d="M 21 4 L 11 5.1757812 L 11 12 L 21 12 L 21 4 z M 10 5.2949219 L 4 6 L 4 12 L 10 12 L 10 5.2949219 z "
+   transform="translate(-293,384)"
+   id="path853" /><path
+   id="path858"
+   d="m -272,405 -10,-1.17578 V 397 h 10 z M -283,403.70508 -289,403 v -6 h 6 z"
+   style="fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+   inkscape:connector-curvature="0" /></svg>
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/README
@@ -0,0 +1 @@
+DO NOT MODIFY THE FILES IN THIS FOLDER, THEY ARE AUTOMATICALLY GENERATED FROM THE PO-FILES.
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/cs.json
@@ -0,0 +1,71 @@
+{
+    "Connecting...": "Připojení...",
+    "Disconnecting...": "Odpojení...",
+    "Reconnecting...": "Obnova připojení...",
+    "Internal error": "Vnitřní chyba",
+    "Must set host": "Hostitel musí být nastavení",
+    "Connected (encrypted) to ": "Připojení (šifrované) k ",
+    "Connected (unencrypted) to ": "Připojení (nešifrované) k ",
+    "Something went wrong, connection is closed": "Něco se pokazilo, odpojeno",
+    "Failed to connect to server": "Chyba připojení k serveru",
+    "Disconnected": "Odpojeno",
+    "New connection has been rejected with reason: ": "Nové připojení bylo odmítnuto s odůvodněním: ",
+    "New connection has been rejected": "Nové připojení bylo odmítnuto",
+    "Password is required": "Je vyžadováno heslo",
+    "noVNC encountered an error:": "noVNC narazilo na chybu:",
+    "Hide/Show the control bar": "Skrýt/zobrazit ovládací panel",
+    "Move/Drag Viewport": "Přesunout/přetáhnout výřez",
+    "viewport drag": "přesun výřezu",
+    "Active Mouse Button": "Aktivní tlačítka myši",
+    "No mousebutton": "Žádné",
+    "Left mousebutton": "Levé tlačítko myši",
+    "Middle mousebutton": "Prostřední tlačítko myši",
+    "Right mousebutton": "Pravé tlačítko myši",
+    "Keyboard": "Klávesnice",
+    "Show Keyboard": "Zobrazit klávesnici",
+    "Extra keys": "Extra klávesy",
+    "Show Extra Keys": "Zobrazit extra klávesy",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Přepnout Ctrl",
+    "Alt": "Alt",
+    "Toggle Alt": "Přepnout Alt",
+    "Send Tab": "Odeslat tabulátor",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "Odeslat Esc",
+    "Ctrl+Alt+Del": "Ctrl+Alt+Del",
+    "Send Ctrl-Alt-Del": "Poslat Ctrl-Alt-Del",
+    "Shutdown/Reboot": "Vypnutí/Restart",
+    "Shutdown/Reboot...": "Vypnutí/Restart...",
+    "Power": "Napájení",
+    "Shutdown": "Vypnout",
+    "Reboot": "Restart",
+    "Reset": "Reset",
+    "Clipboard": "Schránka",
+    "Clear": "Vymazat",
+    "Fullscreen": "Celá obrazovka",
+    "Settings": "Nastavení",
+    "Shared Mode": "Sdílený režim",
+    "View Only": "Pouze prohlížení",
+    "Clip to Window": "Přizpůsobit oknu",
+    "Scaling Mode:": "Přizpůsobení velikosti",
+    "None": "Žádné",
+    "Local Scaling": "Místní",
+    "Remote Resizing": "Vzdálené",
+    "Advanced": "Pokročilé",
+    "Repeater ID:": "ID opakovače",
+    "WebSocket": "WebSocket",
+    "Encrypt": "Šifrování:",
+    "Host:": "Hostitel:",
+    "Port:": "Port:",
+    "Path:": "Cesta",
+    "Automatic Reconnect": "Automatická obnova připojení",
+    "Reconnect Delay (ms):": "Zpoždění připojení (ms)",
+    "Show Dot when No Cursor": "Tečka místo chybějícího kurzoru myši",
+    "Logging:": "Logování:",
+    "Disconnect": "Odpojit",
+    "Connect": "Připojit",
+    "Password:": "Heslo",
+    "Send Password": "Odeslat heslo",
+    "Cancel": "Zrušit"
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/de.json
@@ -0,0 +1,69 @@
+{
+    "Connecting...": "Verbinden...",
+    "Disconnecting...": "Verbindung trennen...",
+    "Reconnecting...": "Verbindung wiederherstellen...",
+    "Internal error": "Interner Fehler",
+    "Must set host": "Richten Sie den Server ein",
+    "Connected (encrypted) to ": "Verbunden mit (verschlüsselt) ",
+    "Connected (unencrypted) to ": "Verbunden mit (unverschlüsselt) ",
+    "Something went wrong, connection is closed": "Etwas lief schief, Verbindung wurde getrennt",
+    "Disconnected": "Verbindung zum Server getrennt",
+    "New connection has been rejected with reason: ": "Verbindung wurde aus folgendem Grund abgelehnt: ",
+    "New connection has been rejected": "Verbindung wurde abgelehnt",
+    "Password is required": "Passwort ist erforderlich",
+    "noVNC encountered an error:": "Ein Fehler ist aufgetreten:",
+    "Hide/Show the control bar": "Kontrollleiste verstecken/anzeigen",
+    "Move/Drag Viewport": "Ansichtsfenster verschieben/ziehen",
+    "viewport drag": "Ansichtsfenster ziehen",
+    "Active Mouse Button": "Aktive Maustaste",
+    "No mousebutton": "Keine Maustaste",
+    "Left mousebutton": "Linke Maustaste",
+    "Middle mousebutton": "Mittlere Maustaste",
+    "Right mousebutton": "Rechte Maustaste",
+    "Keyboard": "Tastatur",
+    "Show Keyboard": "Tastatur anzeigen",
+    "Extra keys": "Zusatztasten",
+    "Show Extra Keys": "Zusatztasten anzeigen",
+    "Ctrl": "Strg",
+    "Toggle Ctrl": "Strg umschalten",
+    "Alt": "Alt",
+    "Toggle Alt": "Alt umschalten",
+    "Send Tab": "Tab senden",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "Escape senden",
+    "Ctrl+Alt+Del": "Strg+Alt+Entf",
+    "Send Ctrl-Alt-Del": "Strg+Alt+Entf senden",
+    "Shutdown/Reboot": "Herunterfahren/Neustarten",
+    "Shutdown/Reboot...": "Herunterfahren/Neustarten...",
+    "Power": "Energie",
+    "Shutdown": "Herunterfahren",
+    "Reboot": "Neustarten",
+    "Reset": "Zurücksetzen",
+    "Clipboard": "Zwischenablage",
+    "Clear": "Löschen",
+    "Fullscreen": "Vollbild",
+    "Settings": "Einstellungen",
+    "Shared Mode": "Geteilter Modus",
+    "View Only": "Nur betrachten",
+    "Clip to Window": "Auf Fenster begrenzen",
+    "Scaling Mode:": "Skalierungsmodus:",
+    "None": "Keiner",
+    "Local Scaling": "Lokales skalieren",
+    "Remote Resizing": "Serverseitiges skalieren",
+    "Advanced": "Erweitert",
+    "Repeater ID:": "Repeater ID:",
+    "WebSocket": "WebSocket",
+    "Encrypt": "Verschlüsselt",
+    "Host:": "Server:",
+    "Port:": "Port:",
+    "Path:": "Pfad:",
+    "Automatic Reconnect": "Automatisch wiederverbinden",
+    "Reconnect Delay (ms):": "Wiederverbindungsverzögerung (ms):",
+    "Logging:": "Protokollierung:",
+    "Disconnect": "Verbindung trennen",
+    "Connect": "Verbinden",
+    "Password:": "Passwort:",
+    "Cancel": "Abbrechen",
+    "Canvas not supported.": "Canvas nicht unterstützt."
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/el.json
@@ -0,0 +1,69 @@
+{
+    "Connecting...": "Συνδέεται...",
+    "Disconnecting...": "Aποσυνδέεται...",
+    "Reconnecting...": "Επανασυνδέεται...",
+    "Internal error": "Εσωτερικό σφάλμα",
+    "Must set host": "Πρέπει να οριστεί ο διακομιστής",
+    "Connected (encrypted) to ": "Συνδέθηκε (κρυπτογραφημένα) με το ",
+    "Connected (unencrypted) to ": "Συνδέθηκε (μη κρυπτογραφημένα) με το ",
+    "Something went wrong, connection is closed": "Κάτι πήγε στραβά, η σύνδεση διακόπηκε",
+    "Disconnected": "Αποσυνδέθηκε",
+    "New connection has been rejected with reason: ": "Η νέα σύνδεση απορρίφθηκε διότι: ",
+    "New connection has been rejected": "Η νέα σύνδεση απορρίφθηκε ",
+    "Password is required": "Απαιτείται ο κωδικός πρόσβασης",
+    "noVNC encountered an error:": "το noVNC αντιμετώπισε ένα σφάλμα:",
+    "Hide/Show the control bar": "Απόκρυψη/Εμφάνιση γραμμής ελέγχου",
+    "Move/Drag Viewport": "Μετακίνηση/Σύρσιμο Θεατού πεδίου",
+    "viewport drag": "σύρσιμο θεατού πεδίου",
+    "Active Mouse Button": "Ενεργό Πλήκτρο Ποντικιού",
+    "No mousebutton": "Χωρίς Πλήκτρο Ποντικιού",
+    "Left mousebutton": "Αριστερό Πλήκτρο Ποντικιού",
+    "Middle mousebutton": "Μεσαίο Πλήκτρο Ποντικιού",
+    "Right mousebutton": "Δεξί Πλήκτρο Ποντικιού",
+    "Keyboard": "Πληκτρολόγιο",
+    "Show Keyboard": "Εμφάνιση Πληκτρολογίου",
+    "Extra keys": "Επιπλέον πλήκτρα",
+    "Show Extra Keys": "Εμφάνιση Επιπλέον Πλήκτρων",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Εναλλαγή Ctrl",
+    "Alt": "Alt",
+    "Toggle Alt": "Εναλλαγή Alt",
+    "Send Tab": "Αποστολή Tab",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "Αποστολή Escape",
+    "Ctrl+Alt+Del": "Ctrl+Alt+Del",
+    "Send Ctrl-Alt-Del": "Αποστολή Ctrl-Alt-Del",
+    "Shutdown/Reboot": "Κλείσιμο/Επανεκκίνηση",
+    "Shutdown/Reboot...": "Κλείσιμο/Επανεκκίνηση...",
+    "Power": "Απενεργοποίηση",
+    "Shutdown": "Κλείσιμο",
+    "Reboot": "Επανεκκίνηση",
+    "Reset": "Επαναφορά",
+    "Clipboard": "Πρόχειρο",
+    "Clear": "Καθάρισμα",
+    "Fullscreen": "Πλήρης Οθόνη",
+    "Settings": "Ρυθμίσεις",
+    "Shared Mode": "Κοινόχρηστη Λειτουργία",
+    "View Only": "Μόνο Θέαση",
+    "Clip to Window": "Αποκοπή στο όριο του Παράθυρου",
+    "Scaling Mode:": "Λειτουργία Κλιμάκωσης:",
+    "None": "Καμία",
+    "Local Scaling": "Τοπική Κλιμάκωση",
+    "Remote Resizing": "Απομακρυσμένη Αλλαγή μεγέθους",
+    "Advanced": "Για προχωρημένους",
+    "Repeater ID:": "Repeater ID:",
+    "WebSocket": "WebSocket",
+    "Encrypt": "Κρυπτογράφηση",
+    "Host:": "Όνομα διακομιστή:",
+    "Port:": "Πόρτα διακομιστή:",
+    "Path:": "Διαδρομή:",
+    "Automatic Reconnect": "Αυτόματη επανασύνδεση",
+    "Reconnect Delay (ms):": "Καθυστέρηση επανασύνδεσης (ms):",
+    "Logging:": "Καταγραφή:",
+    "Disconnect": "Αποσύνδεση",
+    "Connect": "Σύνδεση",
+    "Password:": "Κωδικός Πρόσβασης:",
+    "Cancel": "Ακύρωση",
+    "Canvas not supported.": "Δεν υποστηρίζεται το στοιχείο Canvas"
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/es.json
@@ -0,0 +1,68 @@
+{
+    "Connecting...": "Conectando...",
+    "Connected (encrypted) to ": "Conectado (con encriptación) a",
+    "Connected (unencrypted) to ": "Conectado (sin encriptación) a",
+    "Disconnecting...": "Desconectando...",
+    "Disconnected": "Desconectado",
+    "Must set host": "Se debe configurar el host",
+    "Reconnecting...": "Reconectando...",
+    "Password is required": "La contraseña es obligatoria",
+    "Disconnect timeout": "Tiempo de desconexión agotado",
+    "noVNC encountered an error:": "noVNC ha encontrado un error:",
+    "Hide/Show the control bar": "Ocultar/Mostrar la barra de control",
+    "Move/Drag Viewport": "Mover/Arrastrar la ventana",
+    "viewport drag": "Arrastrar la ventana",
+    "Active Mouse Button": "Botón activo del ratón",
+    "No mousebutton": "Ningún botón del ratón",
+    "Left mousebutton": "Botón izquierdo del ratón",
+    "Middle mousebutton": "Botón central del ratón",
+    "Right mousebutton": "Botón derecho del ratón",
+    "Keyboard": "Teclado",
+    "Show Keyboard": "Mostrar teclado",
+    "Extra keys": "Teclas adicionales",
+    "Show Extra Keys": "Mostrar Teclas Adicionales",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Pulsar/Soltar Ctrl",
+    "Alt": "Alt",
+    "Toggle Alt": "Pulsar/Soltar Alt",
+    "Send Tab": "Enviar Tabulación",
+    "Tab": "Tabulación",
+    "Esc": "Esc",
+    "Send Escape": "Enviar Escape",
+    "Ctrl+Alt+Del": "Ctrl+Alt+Del",
+    "Send Ctrl-Alt-Del": "Enviar Ctrl+Alt+Del",
+    "Shutdown/Reboot": "Apagar/Reiniciar",
+    "Shutdown/Reboot...": "Apagar/Reiniciar...",
+    "Power": "Encender",
+    "Shutdown": "Apagar",
+    "Reboot": "Reiniciar",
+    "Reset": "Restablecer",
+    "Clipboard": "Portapapeles",
+    "Clear": "Vaciar",
+    "Fullscreen": "Pantalla Completa",
+    "Settings": "Configuraciones",
+    "Encrypt": "Encriptar",
+    "Shared Mode": "Modo Compartido",
+    "View Only": "Solo visualización",
+    "Clip to Window": "Recortar al tamaño de la ventana",
+    "Scaling Mode:": "Modo de escalado:",
+    "None": "Ninguno",
+    "Local Scaling": "Escalado Local",
+    "Local Downscaling": "Reducción de escala local",
+    "Remote Resizing": "Cambio de tamaño remoto",
+    "Advanced": "Avanzado",
+    "Local Cursor": "Cursor Local",
+    "Repeater ID:": "ID del Repetidor:",
+    "WebSocket": "WebSocket",
+    "Host:": "Host:",
+    "Port:": "Puerto:",
+    "Path:": "Ruta:",
+    "Automatic Reconnect": "Reconexión automática",
+    "Reconnect Delay (ms):": "Retraso en la reconexión (ms):",
+    "Logging:": "Registrando:",
+    "Disconnect": "Desconectar",
+    "Connect": "Conectar",
+    "Password:": "Contraseña:",
+    "Cancel": "Cancelar",
+    "Canvas not supported.": "Canvas no soportado."
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/fr.json
@@ -0,0 +1,72 @@
+{
+    "Connecting...": "En cours de connexion...",
+    "Disconnecting...": "Déconnexion en cours...",
+    "Reconnecting...": "Reconnexion en cours...",
+    "Internal error": "Erreur interne",
+    "Must set host": "Doit définir l'hôte",
+    "Connected (encrypted) to ": "Connecté (crypté) à ",
+    "Connected (unencrypted) to ": "Connecté (non crypté) à ",
+    "Something went wrong, connection is closed": "Quelque chose est arrivé, la connexion est fermée",
+    "Failed to connect to server": "Échec de connexion au serveur",
+    "Disconnected": "Déconnecté",
+    "New connection has been rejected with reason: ": "Une nouvelle connexion a été rejetée avec raison: ",
+    "New connection has been rejected": "Une nouvelle connexion a été rejetée",
+    "Credentials are required": "Les identifiants sont requis",
+    "noVNC encountered an error:": "noVNC a rencontré une erreur:",
+    "Hide/Show the control bar": "Masquer/Afficher la barre de contrôle",
+    "Drag": "Faire glisser",
+    "Move/Drag Viewport": "Déplacer/faire glisser Viewport",
+    "Keyboard": "Clavier",
+    "Show Keyboard": "Afficher le clavier",
+    "Extra keys": "Touches supplémentaires",
+    "Show Extra Keys": "Afficher les touches supplémentaires",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Basculer Ctrl",
+    "Alt": "Alt",
+    "Toggle Alt": "Basculer Alt",
+    "Toggle Windows": "Basculer Windows",
+    "Windows": "Windows",
+    "Send Tab": "Envoyer l'onglet",
+    "Tab": "l'onglet",
+    "Esc": "Esc",
+    "Send Escape": "Envoyer Escape",
+    "Ctrl+Alt+Del": "Ctrl+Alt+Del",
+    "Send Ctrl-Alt-Del": "Envoyer Ctrl-Alt-Del",
+    "Shutdown/Reboot": "Arrêter/Redémarrer",
+    "Shutdown/Reboot...": "Arrêter/Redémarrer...",
+    "Power": "Alimentation",
+    "Shutdown": "Arrêter",
+    "Reboot": "Redémarrer",
+    "Reset": "Réinitialiser",
+    "Clipboard": "Presse-papiers",
+    "Clear": "Effacer",
+    "Fullscreen": "Plein écran",
+    "Settings": "Paramètres",
+    "Shared Mode": "Mode partagé",
+    "View Only": "Afficher uniquement",
+    "Clip to Window": "Clip à fenêtre",
+    "Scaling Mode:": "Mode mise à l'échelle:",
+    "None": "Aucun",
+    "Local Scaling": "Mise à l'échelle locale",
+    "Remote Resizing": "Redimensionnement à distance",
+    "Advanced": "Avancé",
+    "Quality:": "Qualité:",
+    "Compression level:": "Niveau de compression:",
+    "Repeater ID:": "ID Répéteur:",
+    "WebSocket": "WebSocket",
+    "Encrypt": "Crypter",
+    "Host:": "Hôte:",
+    "Port:": "Port:",
+    "Path:": "Chemin:",
+    "Automatic Reconnect": "Reconnecter automatiquemen",
+    "Reconnect Delay (ms):": "Délai de reconnexion (ms):",
+    "Show Dot when No Cursor": "Afficher le point lorsqu'il n'y a pas de curseur",
+    "Logging:": "Se connecter:",
+    "Version:": "Version:",
+    "Disconnect": "Déconnecter",
+    "Connect": "Connecter",
+    "Username:": "Nom d'utilisateur:",
+    "Password:": "Mot de passe:",
+    "Send Credentials": "Envoyer les identifiants",
+    "Cancel": "Annuler"
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/it.json
@@ -0,0 +1,72 @@
+{
+    "Connecting...": "Connessione in corso...",
+    "Disconnecting...": "Disconnessione...",
+    "Reconnecting...": "Riconnessione...",
+    "Internal error": "Errore interno",
+    "Must set host": "Devi impostare l'host",
+    "Connected (encrypted) to ": "Connesso (crittografato) a ",
+    "Connected (unencrypted) to ": "Connesso (non crittografato) a",
+    "Something went wrong, connection is closed": "Qualcosa è andato storto, la connessione è stata chiusa",
+    "Failed to connect to server": "Impossibile connettersi al server",
+    "Disconnected": "Disconnesso",
+    "New connection has been rejected with reason: ": "La nuova connessione è stata rifiutata con motivo: ",
+    "New connection has been rejected": "La nuova connessione è stata rifiutata",
+    "Credentials are required": "Le credenziali sono obbligatorie",
+    "noVNC encountered an error:": "noVNC ha riscontrato un errore:",
+    "Hide/Show the control bar": "Nascondi/Mostra la barra di controllo",
+    "Drag": "",
+    "Move/Drag Viewport": "",
+    "Keyboard": "Tastiera",
+    "Show Keyboard": "Mostra tastiera",
+    "Extra keys": "Tasti Aggiuntivi",
+    "Show Extra Keys": "Mostra Tasti Aggiuntivi",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Tieni premuto Ctrl",
+    "Alt": "Alt",
+    "Toggle Alt": "Tieni premuto Alt",
+    "Toggle Windows": "Tieni premuto Windows",
+    "Windows": "Windows",
+    "Send Tab": "Invia Tab",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "Invia Esc",
+    "Ctrl+Alt+Del": "Ctrl+Alt+Canc",
+    "Send Ctrl-Alt-Del": "Invia Ctrl-Alt-Canc",
+    "Shutdown/Reboot": "Spegnimento/Riavvio",
+    "Shutdown/Reboot...": "Spegnimento/Riavvio...",
+    "Power": "Alimentazione",
+    "Shutdown": "Spegnimento",
+    "Reboot": "Riavvio",
+    "Reset": "Reset",
+    "Clipboard": "Clipboard",
+    "Clear": "Pulisci",
+    "Fullscreen": "Schermo intero",
+    "Settings": "Impostazioni",
+    "Shared Mode": "Modalità condivisa",
+    "View Only": "Sola Visualizzazione",
+    "Clip to Window": "",
+    "Scaling Mode:": "Modalità di ridimensionamento:",
+    "None": "Nessuna",
+    "Local Scaling": "Ridimensionamento Locale",
+    "Remote Resizing": "Ridimensionamento Remoto",
+    "Advanced": "Avanzate",
+    "Quality:": "Qualità:",
+    "Compression level:": "Livello Compressione:",
+    "Repeater ID:": "ID Ripetitore:",
+    "WebSocket": "WebSocket",
+    "Encrypt": "Crittografa",
+    "Host:": "Host:",
+    "Port:": "Porta:",
+    "Path:": "Percorso:",
+    "Automatic Reconnect": "Riconnessione Automatica",
+    "Reconnect Delay (ms):": "Ritardo Riconnessione (ms):",
+    "Show Dot when No Cursor": "Mostra Punto quando Nessun Cursore",
+    "Logging:": "",
+    "Version:": "Versione:",
+    "Disconnect": "Disconnetti",
+    "Connect": "Connetti",
+    "Username:": "Utente:",
+    "Password:": "Password:",
+    "Send Credentials": "Invia Credenziale",
+    "Cancel": "Annulla"
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/ja.json
@@ -0,0 +1,72 @@
+{
+    "Connecting...": "接続しています...",
+    "Disconnecting...": "切断しています...",
+    "Reconnecting...": "再接続しています...",
+    "Internal error": "内部エラー",
+    "Must set host": "ホストを設定する必要があります",
+    "Connected (encrypted) to ": "接続しました (暗号化済み): ",
+    "Connected (unencrypted) to ": "接続しました (暗号化されていません): ",
+    "Something went wrong, connection is closed": "何らかの問題で、接続が閉じられました",
+    "Failed to connect to server": "サーバーへの接続に失敗しました",
+    "Disconnected": "切断しました",
+    "New connection has been rejected with reason: ": "新規接続は次の理由で拒否されました: ",
+    "New connection has been rejected": "新規接続は拒否されました",
+    "Credentials are required": "資格情報が必要です",
+    "noVNC encountered an error:": "noVNC でエラーが発生しました:",
+    "Hide/Show the control bar": "コントロールバーを隠す/表示する",
+    "Drag": "ドラッグ",
+    "Move/Drag Viewport": "ビューポートを移動/ドラッグ",
+    "Keyboard": "キーボード",
+    "Show Keyboard": "キーボードを表示",
+    "Extra keys": "追加キー",
+    "Show Extra Keys": "追加キーを表示",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Ctrl キーを切り替え",
+    "Alt": "Alt",
+    "Toggle Alt": "Alt キーを切り替え",
+    "Toggle Windows": "Windows キーを切り替え",
+    "Windows": "Windows",
+    "Send Tab": "Tab キーを送信",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "Escape キーを送信",
+    "Ctrl+Alt+Del": "Ctrl+Alt+Del",
+    "Send Ctrl-Alt-Del": "Ctrl-Alt-Del を送信",
+    "Shutdown/Reboot": "シャットダウン/再起動",
+    "Shutdown/Reboot...": "シャットダウン/再起動...",
+    "Power": "電源",
+    "Shutdown": "シャットダウン",
+    "Reboot": "再起動",
+    "Reset": "リセット",
+    "Clipboard": "クリップボード",
+    "Clear": "クリア",
+    "Fullscreen": "全画面表示",
+    "Settings": "設定",
+    "Shared Mode": "共有モード",
+    "View Only": "表示のみ",
+    "Clip to Window": "ウィンドウにクリップ",
+    "Scaling Mode:": "スケーリングモード:",
+    "None": "なし",
+    "Local Scaling": "ローカルスケーリング",
+    "Remote Resizing": "リモートでリサイズ",
+    "Advanced": "高度",
+    "Quality:": "品質:",
+    "Compression level:": "圧縮レベル:",
+    "Repeater ID:": "リピーター ID:",
+    "WebSocket": "WebSocket",
+    "Encrypt": "暗号化",
+    "Host:": "ホスト:",
+    "Port:": "ポート:",
+    "Path:": "パス:",
+    "Automatic Reconnect": "自動再接続",
+    "Reconnect Delay (ms):": "再接続する遅延 (ミリ秒):",
+    "Show Dot when No Cursor": "カーソルがないときにドットを表示",
+    "Logging:": "ロギング:",
+    "Version:": "バージョン:",
+    "Disconnect": "切断",
+    "Connect": "接続",
+    "Username:": "ユーザー名:",
+    "Password:": "パスワード:",
+    "Send Credentials": "資格情報を送信",
+    "Cancel": "キャンセル"
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/ko.json
@@ -0,0 +1,70 @@
+{
+    "Connecting...": "연결중...",
+    "Disconnecting...": "연결 해제중...",
+    "Reconnecting...": "재연결중...",
+    "Internal error": "내부 오류",
+    "Must set host": "호스트는 설정되어야 합니다.",
+    "Connected (encrypted) to ": "다음과 (암호화되어) 연결되었습니다:",
+    "Connected (unencrypted) to ": "다음과 (암호화 없이) 연결되었습니다:",
+    "Something went wrong, connection is closed": "무언가 잘못되었습니다, 연결이 닫혔습니다.",
+    "Failed to connect to server": "서버에 연결하지 못했습니다.",
+    "Disconnected": "연결이 해제되었습니다.",
+    "New connection has been rejected with reason: ": "새 연결이 다음 이유로 거부되었습니다:",
+    "New connection has been rejected": "새 연결이 거부되었습니다.",
+    "Password is required": "비밀번호가 필요합니다.",
+    "noVNC encountered an error:": "noVNC에 오류가 발생했습니다:",
+    "Hide/Show the control bar": "컨트롤 바 숨기기/보이기",
+    "Move/Drag Viewport": "움직이기/드래그 뷰포트",
+    "viewport drag": "뷰포트 드래그",
+    "Active Mouse Button": "마우스 버튼 활성화",
+    "No mousebutton": "마우스 버튼 없음",
+    "Left mousebutton": "왼쪽 마우스 버튼",
+    "Middle mousebutton": "중간 마우스 버튼",
+    "Right mousebutton": "오른쪽 마우스 버튼",
+    "Keyboard": "키보드",
+    "Show Keyboard": "키보드 보이기",
+    "Extra keys": "기타 키들",
+    "Show Extra Keys": "기타 키들 보이기",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Ctrl 켜기/끄기",
+    "Alt": "Alt",
+    "Toggle Alt": "Alt 켜기/끄기",
+    "Send Tab": "Tab 보내기",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "Esc 보내기",
+    "Ctrl+Alt+Del": "Ctrl+Alt+Del",
+    "Send Ctrl-Alt-Del": "Ctrl+Alt+Del 보내기",
+    "Shutdown/Reboot": "셧다운/리붓",
+    "Shutdown/Reboot...": "셧다운/리붓...",
+    "Power": "전원",
+    "Shutdown": "셧다운",
+    "Reboot": "리붓",
+    "Reset": "리셋",
+    "Clipboard": "클립보드",
+    "Clear": "지우기",
+    "Fullscreen": "전체화면",
+    "Settings": "설정",
+    "Shared Mode": "공유 모드",
+    "View Only": "보기 전용",
+    "Clip to Window": "창에 클립",
+    "Scaling Mode:": "스케일링 모드:",
+    "None": "없음",
+    "Local Scaling": "로컬 스케일링",
+    "Remote Resizing": "원격 크기 조절",
+    "Advanced": "고급",
+    "Repeater ID:": "중계 ID",
+    "WebSocket": "웹소켓",
+    "Encrypt": "암호화",
+    "Host:": "호스트:",
+    "Port:": "포트:",
+    "Path:": "위치:",
+    "Automatic Reconnect": "자동 재연결",
+    "Reconnect Delay (ms):": "재연결 지연 시간 (ms)",
+    "Logging:": "로깅",
+    "Disconnect": "연결 해제",
+    "Connect": "연결",
+    "Password:": "비밀번호:",
+    "Send Password": "비밀번호 전송",
+    "Cancel": "취소"
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/nl.json
@@ -0,0 +1,73 @@
+{
+    "Connecting...": "Verbinden...",
+    "Disconnecting...": "Verbinding verbreken...",
+    "Reconnecting...": "Opnieuw verbinding maken...",
+    "Internal error": "Interne fout",
+    "Must set host": "Host moeten worden ingesteld",
+    "Connected (encrypted) to ": "Verbonden (versleuteld) met ",
+    "Connected (unencrypted) to ": "Verbonden (onversleuteld) met ",
+    "Something went wrong, connection is closed": "Er iets fout gelopen, verbinding werd verbroken",
+    "Failed to connect to server": "Verbinding maken met server is mislukt",
+    "Disconnected": "Verbinding verbroken",
+    "New connection has been rejected with reason: ": "Nieuwe verbinding is geweigerd omwille van de volgende reden: ",
+    "New connection has been rejected": "Nieuwe verbinding is geweigerd",
+    "Password is required": "Wachtwoord is vereist",
+    "noVNC encountered an error:": "noVNC heeft een fout bemerkt:",
+    "Hide/Show the control bar": "Verberg/Toon de bedieningsbalk",
+    "Move/Drag Viewport": "Verplaats/Versleep Kijkvenster",
+    "viewport drag": "kijkvenster slepen",
+    "Active Mouse Button": "Actieve Muisknop",
+    "No mousebutton": "Geen muisknop",
+    "Left mousebutton": "Linker muisknop",
+    "Middle mousebutton": "Middelste muisknop",
+    "Right mousebutton": "Rechter muisknop",
+    "Keyboard": "Toetsenbord",
+    "Show Keyboard": "Toon Toetsenbord",
+    "Extra keys": "Extra toetsen",
+    "Show Extra Keys": "Toon Extra Toetsen",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Ctrl omschakelen",
+    "Alt": "Alt",
+    "Toggle Alt": "Alt omschakelen",
+    "Toggle Windows": "Windows omschakelen",
+    "Windows": "Windows",
+    "Send Tab": "Tab Sturen",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "Escape Sturen",
+    "Ctrl+Alt+Del": "Ctrl-Alt-Del",
+    "Send Ctrl-Alt-Del": "Ctrl-Alt-Del Sturen",
+    "Shutdown/Reboot": "Uitschakelen/Herstarten",
+    "Shutdown/Reboot...": "Uitschakelen/Herstarten...",
+    "Power": "Systeem",
+    "Shutdown": "Uitschakelen",
+    "Reboot": "Herstarten",
+    "Reset": "Resetten",
+    "Clipboard": "Klembord",
+    "Clear": "Wissen",
+    "Fullscreen": "Volledig Scherm",
+    "Settings": "Instellingen",
+    "Shared Mode": "Gedeelde Modus",
+    "View Only": "Alleen Kijken",
+    "Clip to Window": "Randen buiten venster afsnijden",
+    "Scaling Mode:": "Schaalmodus:",
+    "None": "Geen",
+    "Local Scaling": "Lokaal Schalen",
+    "Remote Resizing": "Op Afstand Formaat Wijzigen",
+    "Advanced": "Geavanceerd",
+    "Repeater ID:": "Repeater ID:",
+    "WebSocket": "WebSocket",
+    "Encrypt": "Versleutelen",
+    "Host:": "Host:",
+    "Port:": "Poort:",
+    "Path:": "Pad:",
+    "Automatic Reconnect": "Automatisch Opnieuw Verbinden",
+    "Reconnect Delay (ms):": "Vertraging voor Opnieuw Verbinden (ms):",
+    "Show Dot when No Cursor": "Geef stip weer indien geen cursor",
+    "Logging:": "Logmeldingen:",
+    "Disconnect": "Verbinding verbreken",
+    "Connect": "Verbinden",
+    "Password:": "Wachtwoord:",
+    "Send Password": "Verzend Wachtwoord:",
+    "Cancel": "Annuleren"
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/pl.json
@@ -0,0 +1,69 @@
+{
+    "Connecting...": "Łączenie...",
+    "Disconnecting...": "Rozłączanie...",
+    "Reconnecting...": "Łączenie...",
+    "Internal error": "Błąd wewnętrzny",
+    "Must set host": "Host i port są wymagane",
+    "Connected (encrypted) to ": "Połączenie (szyfrowane) z ",
+    "Connected (unencrypted) to ": "Połączenie (nieszyfrowane) z ",
+    "Something went wrong, connection is closed": "Coś poszło źle, połączenie zostało zamknięte",
+    "Disconnected": "Rozłączony",
+    "New connection has been rejected with reason: ": "Nowe połączenie zostało odrzucone z powodu: ",
+    "New connection has been rejected": "Nowe połączenie zostało odrzucone",
+    "Password is required": "Hasło jest wymagane",
+    "noVNC encountered an error:": "noVNC napotkało błąd:",
+    "Hide/Show the control bar": "Pokaż/Ukryj pasek ustawień",
+    "Move/Drag Viewport": "Ruszaj/Przeciągaj Viewport",
+    "viewport drag": "przeciągnij viewport",
+    "Active Mouse Button": "Aktywny Przycisk Myszy",
+    "No mousebutton": "Brak przycisku myszy",
+    "Left mousebutton": "Lewy przycisk myszy",
+    "Middle mousebutton": "Środkowy przycisk myszy",
+    "Right mousebutton": "Prawy przycisk myszy",
+    "Keyboard": "Klawiatura",
+    "Show Keyboard": "Pokaż klawiaturę",
+    "Extra keys": "Przyciski dodatkowe",
+    "Show Extra Keys": "Pokaż przyciski dodatkowe",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Przełącz Ctrl",
+    "Alt": "Alt",
+    "Toggle Alt": "Przełącz Alt",
+    "Send Tab": "Wyślij Tab",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "Wyślij Escape",
+    "Ctrl+Alt+Del": "Ctrl+Alt+Del",
+    "Send Ctrl-Alt-Del": "Wyślij Ctrl-Alt-Del",
+    "Shutdown/Reboot": "Wyłącz/Uruchom ponownie",
+    "Shutdown/Reboot...": "Wyłącz/Uruchom ponownie...",
+    "Power": "Włączony",
+    "Shutdown": "Wyłącz",
+    "Reboot": "Uruchom ponownie",
+    "Reset": "Resetuj",
+    "Clipboard": "Schowek",
+    "Clear": "Wyczyść",
+    "Fullscreen": "Pełny ekran",
+    "Settings": "Ustawienia",
+    "Shared Mode": "Tryb Współdzielenia",
+    "View Only": "Tylko Podgląd",
+    "Clip to Window": "Przytnij do Okna",
+    "Scaling Mode:": "Tryb Skalowania:",
+    "None": "Brak",
+    "Local Scaling": "Skalowanie lokalne",
+    "Remote Resizing": "Skalowanie zdalne",
+    "Advanced": "Zaawansowane",
+    "Repeater ID:": "ID Repeatera:",
+    "WebSocket": "WebSocket",
+    "Encrypt": "Szyfrowanie",
+    "Host:": "Host:",
+    "Port:": "Port:",
+    "Path:": "Ścieżka:",
+    "Automatic Reconnect": "Automatycznie wznawiaj połączenie",
+    "Reconnect Delay (ms):": "Opóźnienie wznawiania (ms):",
+    "Logging:": "Poziom logowania:",
+    "Disconnect": "Rozłącz",
+    "Connect": "Połącz",
+    "Password:": "Hasło:",
+    "Cancel": "Anuluj",
+    "Canvas not supported.": "Element Canvas nie jest wspierany."
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/pt.json
@@ -0,0 +1,72 @@
+{
+    "Connecting...": "Conectando...",
+    "Disconnecting...": "Desconectando...",
+    "Reconnecting...": "Reconectando...",
+    "Internal error": "Erro interno",
+    "Must set host": "É necessário definir o host",
+    "Connected (encrypted) to ": "Conectado (com criptografia) a ",
+    "Connected (unencrypted) to ": "Conectado (sem criptografia) a ",
+    "Something went wrong, connection is closed": "Algo deu errado. A conexão foi encerrada.",
+    "Failed to connect to server": "Falha ao conectar-se ao servidor",
+    "Disconnected": "Desconectado",
+    "New connection has been rejected with reason: ": "A nova conexão foi rejeitada pelo motivo: ",
+    "New connection has been rejected": "A nova conexão foi rejeitada",
+    "Credentials are required": "Credenciais são obrigatórias",
+    "noVNC encountered an error:": "O noVNC encontrou um erro:",
+    "Hide/Show the control bar": "Esconder/mostrar a barra de controles",
+    "Drag": "Arrastar",
+    "Move/Drag Viewport": "Mover/arrastar a janela",
+    "Keyboard": "Teclado",
+    "Show Keyboard": "Mostrar teclado",
+    "Extra keys": "Teclas adicionais",
+    "Show Extra Keys": "Mostar teclas adicionais",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Pressionar/soltar Ctrl",
+    "Alt": "Alt",
+    "Toggle Alt": "Pressionar/soltar Alt",
+    "Toggle Windows": "Pressionar/soltar Windows",
+    "Windows": "Windows",
+    "Send Tab": "Enviar Tab",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "Enviar Esc",
+    "Ctrl+Alt+Del": "Ctrl+Alt+Del",
+    "Send Ctrl-Alt-Del": "Enviar Ctrl-Alt-Del",
+    "Shutdown/Reboot": "Desligar/reiniciar",
+    "Shutdown/Reboot...": "Desligar/reiniciar...",
+    "Power": "Ligar",
+    "Shutdown": "Desligar",
+    "Reboot": "Reiniciar",
+    "Reset": "Reiniciar (forçado)",
+    "Clipboard": "Área de transferência",
+    "Clear": "Limpar",
+    "Fullscreen": "Tela cheia",
+    "Settings": "Configurações",
+    "Shared Mode": "Modo compartilhado",
+    "View Only": "Apenas visualizar",
+    "Clip to Window": "Recortar à janela",
+    "Scaling Mode:": "Modo de dimensionamento:",
+    "None": "Nenhum",
+    "Local Scaling": "Local",
+    "Remote Resizing": "Remoto",
+    "Advanced": "Avançado",
+    "Quality:": "Qualidade:",
+    "Compression level:": "Nível de compressão:",
+    "Repeater ID:": "ID do repetidor:",
+    "WebSocket": "WebSocket",
+    "Encrypt": "Criptografar",
+    "Host:": "Host:",
+    "Port:": "Porta:",
+    "Path:": "Caminho:",
+    "Automatic Reconnect": "Reconexão automática",
+    "Reconnect Delay (ms):": "Atraso da reconexão (ms)",
+    "Show Dot when No Cursor": "Mostrar ponto quando não há cursor",
+    "Logging:": "Registros:",
+    "Version:": "Versão:",
+    "Disconnect": "Desconectar",
+    "Connect": "Conectar",
+    "Username:": "Nome de usuário:",
+    "Password:": "Senha:",
+    "Send Credentials": "Enviar credenciais",
+    "Cancel": "Cancelar"
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/pt_BR.json
@@ -0,0 +1,72 @@
+{
+    "Connecting...": "Conectando...",
+    "Disconnecting...": "Desconectando...",
+    "Reconnecting...": "Reconectando...",
+    "Internal error": "Erro interno",
+    "Must set host": "É necessário definir o host",
+    "Connected (encrypted) to ": "Conectado (com criptografia) a ",
+    "Connected (unencrypted) to ": "Conectado (sem criptografia) a ",
+    "Something went wrong, connection is closed": "Algo deu errado. A conexão foi encerrada.",
+    "Failed to connect to server": "Falha ao conectar-se ao servidor",
+    "Disconnected": "Desconectado",
+    "New connection has been rejected with reason: ": "A nova conexão foi rejeitada pelo motivo: ",
+    "New connection has been rejected": "A nova conexão foi rejeitada",
+    "Credentials are required": "Credenciais são obrigatórias",
+    "noVNC encountered an error:": "O noVNC encontrou um erro:",
+    "Hide/Show the control bar": "Esconder/mostrar a barra de controles",
+    "Drag": "Arrastar",
+    "Move/Drag Viewport": "Mover/arrastar a janela",
+    "Keyboard": "Teclado",
+    "Show Keyboard": "Mostrar teclado",
+    "Extra keys": "Teclas adicionais",
+    "Show Extra Keys": "Mostar teclas adicionais",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Pressionar/soltar Ctrl",
+    "Alt": "Alt",
+    "Toggle Alt": "Pressionar/soltar Alt",
+    "Toggle Windows": "Pressionar/soltar Windows",
+    "Windows": "Windows",
+    "Send Tab": "Enviar Tab",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "Enviar Esc",
+    "Ctrl+Alt+Del": "Ctrl+Alt+Del",
+    "Send Ctrl-Alt-Del": "Enviar Ctrl-Alt-Del",
+    "Shutdown/Reboot": "Desligar/reiniciar",
+    "Shutdown/Reboot...": "Desligar/reiniciar...",
+    "Power": "Ligar",
+    "Shutdown": "Desligar",
+    "Reboot": "Reiniciar",
+    "Reset": "Reiniciar (forçado)",
+    "Clipboard": "Área de transferência",
+    "Clear": "Limpar",
+    "Fullscreen": "Tela cheia",
+    "Settings": "Configurações",
+    "Shared Mode": "Modo compartilhado",
+    "View Only": "Apenas visualizar",
+    "Clip to Window": "Recortar à janela",
+    "Scaling Mode:": "Modo de dimensionamento:",
+    "None": "Nenhum",
+    "Local Scaling": "Local",
+    "Remote Resizing": "Remoto",
+    "Advanced": "Avançado",
+    "Quality:": "Qualidade:",
+    "Compression level:": "Nível de compressão:",
+    "Repeater ID:": "ID do repetidor:",
+    "WebSocket": "WebSocket",
+    "Encrypt": "Criptografar",
+    "Host:": "Host:",
+    "Port:": "Porta:",
+    "Path:": "Caminho:",
+    "Automatic Reconnect": "Reconexão automática",
+    "Reconnect Delay (ms):": "Atraso da reconexão (ms)",
+    "Show Dot when No Cursor": "Mostrar ponto quando não há cursor",
+    "Logging:": "Registros:",
+    "Version:": "Versão:",
+    "Disconnect": "Desconectar",
+    "Connect": "Conectar",
+    "Username:": "Nome de usuário:",
+    "Password:": "Senha:",
+    "Send Credentials": "Enviar credenciais",
+    "Cancel": "Cancelar"
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/pt_PT.json
@@ -0,0 +1,72 @@
+{
+    "Connecting...": "Conectando...",
+    "Disconnecting...": "Desconectando...",
+    "Reconnecting...": "Reconectando...",
+    "Internal error": "Erro interno",
+    "Must set host": "É necessário definir o host",
+    "Connected (encrypted) to ": "Conectado (com criptografia) a ",
+    "Connected (unencrypted) to ": "Conectado (sem criptografia) a ",
+    "Something went wrong, connection is closed": "Algo deu errado. A conexão foi encerrada.",
+    "Failed to connect to server": "Falha ao conectar-se ao servidor",
+    "Disconnected": "Desconectado",
+    "New connection has been rejected with reason: ": "A nova conexão foi rejeitada pelo motivo: ",
+    "New connection has been rejected": "A nova conexão foi rejeitada",
+    "Credentials are required": "Credenciais são obrigatórias",
+    "noVNC encountered an error:": "O noVNC encontrou um erro:",
+    "Hide/Show the control bar": "Esconder/mostrar a barra de controles",
+    "Drag": "Arrastar",
+    "Move/Drag Viewport": "Mover/arrastar a janela",
+    "Keyboard": "Teclado",
+    "Show Keyboard": "Mostrar teclado",
+    "Extra keys": "Teclas adicionais",
+    "Show Extra Keys": "Mostar teclas adicionais",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Pressionar/soltar Ctrl",
+    "Alt": "Alt",
+    "Toggle Alt": "Pressionar/soltar Alt",
+    "Toggle Windows": "Pressionar/soltar Windows",
+    "Windows": "Windows",
+    "Send Tab": "Enviar Tab",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "Enviar Esc",
+    "Ctrl+Alt+Del": "Ctrl+Alt+Del",
+    "Send Ctrl-Alt-Del": "Enviar Ctrl-Alt-Del",
+    "Shutdown/Reboot": "Desligar/reiniciar",
+    "Shutdown/Reboot...": "Desligar/reiniciar...",
+    "Power": "Ligar",
+    "Shutdown": "Desligar",
+    "Reboot": "Reiniciar",
+    "Reset": "Reiniciar (forçado)",
+    "Clipboard": "Área de transferência",
+    "Clear": "Limpar",
+    "Fullscreen": "Tela cheia",
+    "Settings": "Configurações",
+    "Shared Mode": "Modo compartilhado",
+    "View Only": "Apenas visualizar",
+    "Clip to Window": "Recortar à janela",
+    "Scaling Mode:": "Modo de dimensionamento:",
+    "None": "Nenhum",
+    "Local Scaling": "Local",
+    "Remote Resizing": "Remoto",
+    "Advanced": "Avançado",
+    "Quality:": "Qualidade:",
+    "Compression level:": "Nível de compressão:",
+    "Repeater ID:": "ID do repetidor:",
+    "WebSocket": "WebSocket",
+    "Encrypt": "Criptografar",
+    "Host:": "Host:",
+    "Port:": "Porta:",
+    "Path:": "Caminho:",
+    "Automatic Reconnect": "Reconexão automática",
+    "Reconnect Delay (ms):": "Atraso da reconexão (ms)",
+    "Show Dot when No Cursor": "Mostrar ponto quando não há cursor",
+    "Logging:": "Registros:",
+    "Version:": "Versão:",
+    "Disconnect": "Desconectar",
+    "Connect": "Conectar",
+    "Username:": "Nome de usuário:",
+    "Password:": "Senha:",
+    "Send Credentials": "Enviar credenciais",
+    "Cancel": "Cancelar"
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/ru.json
@@ -0,0 +1,72 @@
+{
+    "Connecting...": "Подключение...",
+    "Disconnecting...": "Отключение...",
+    "Reconnecting...": "Переподключение...",
+    "Internal error": "Внутренняя ошибка",
+    "Must set host": "Задайте имя сервера или IP",
+    "Connected (encrypted) to ": "Подключено (с шифрованием) к ",
+    "Connected (unencrypted) to ": "Подключено (без шифрования) к ",
+    "Something went wrong, connection is closed": "Что-то пошло не так, подключение разорвано",
+    "Failed to connect to server": "Ошибка подключения к серверу",
+    "Disconnected": "Отключено",
+    "New connection has been rejected with reason: ": "Новое соединение отклонено по причине: ",
+    "New connection has been rejected": "Новое соединение отклонено",
+    "Credentials are required": "Требуются учетные данные",
+    "noVNC encountered an error:": "Ошибка noVNC: ",
+    "Hide/Show the control bar": "Скрыть/Показать контрольную панель",
+    "Drag": "Переместить",
+    "Move/Drag Viewport": "Переместить окно",
+    "Keyboard": "Клавиатура",
+    "Show Keyboard": "Показать клавиатуру",
+    "Extra keys": "Дополнительные Кнопки",
+    "Show Extra Keys": "Показать Дополнительные Кнопки",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Переключение нажатия Ctrl",
+    "Alt": "Alt",
+    "Toggle Alt": "Переключение нажатия Alt",
+    "Toggle Windows": "Переключение вкладок",
+    "Windows": "Вкладка",
+    "Send Tab": "Передать нажатие Tab",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "Передать нажатие Escape",
+    "Ctrl+Alt+Del": "Ctrl+Alt+Del",
+    "Send Ctrl-Alt-Del": "Передать нажатие Ctrl-Alt-Del",
+    "Shutdown/Reboot": "Выключить/Перезагрузить",
+    "Shutdown/Reboot...": "Выключить/Перезагрузить...",
+    "Power": "Питание",
+    "Shutdown": "Выключить",
+    "Reboot": "Перезагрузить",
+    "Reset": "Сброс",
+    "Clipboard": "Буфер обмена",
+    "Clear": "Очистить",
+    "Fullscreen": "Во весь экран",
+    "Settings": "Настройки",
+    "Shared Mode": "Общий режим",
+    "View Only": "Только Просмотр",
+    "Clip to Window": "В окно",
+    "Scaling Mode:": "Масштаб:",
+    "None": "Нет",
+    "Local Scaling": "Локльный масштаб",
+    "Remote Resizing": "Удаленная перенастройка размера",
+    "Advanced": "Дополнительно",
+    "Quality:": "Качество",
+    "Compression level:": "Уровень Сжатия",
+    "Repeater ID:": "Идентификатор ID:",
+    "WebSocket": "WebSocket",
+    "Encrypt": "Шифрование",
+    "Host:": "Сервер:",
+    "Port:": "Порт:",
+    "Path:": "Путь:",
+    "Automatic Reconnect": "Автоматическое переподключение",
+    "Reconnect Delay (ms):": "Задержка переподключения (мс):",
+    "Show Dot when No Cursor": "Показать точку вместо курсора",
+    "Logging:": "Лог:",
+    "Version:": "Версия",
+    "Disconnect": "Отключение",
+    "Connect": "Подключение",
+    "Username:": "Имя Пользователя",
+    "Password:": "Пароль:",
+    "Send Credentials": "Передача Учетных Данных",
+    "Cancel": "Выход"
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/sv.json
@@ -0,0 +1,72 @@
+{
+    "Connecting...": "Ansluter...",
+    "Disconnecting...": "Kopplar ner...",
+    "Reconnecting...": "Återansluter...",
+    "Internal error": "Internt fel",
+    "Must set host": "Du måste specifiera en värd",
+    "Connected (encrypted) to ": "Ansluten (krypterat) till ",
+    "Connected (unencrypted) to ": "Ansluten (okrypterat) till ",
+    "Something went wrong, connection is closed": "Något gick fel, anslutningen avslutades",
+    "Failed to connect to server": "Misslyckades att ansluta till servern",
+    "Disconnected": "Frånkopplad",
+    "New connection has been rejected with reason: ": "Ny anslutning har blivit nekad med följande skäl: ",
+    "New connection has been rejected": "Ny anslutning har blivit nekad",
+    "Credentials are required": "Användaruppgifter krävs",
+    "noVNC encountered an error:": "noVNC stötte på ett problem:",
+    "Hide/Show the control bar": "Göm/Visa kontrollbaren",
+    "Drag": "Dra",
+    "Move/Drag Viewport": "Flytta/Dra Vyn",
+    "Keyboard": "Tangentbord",
+    "Show Keyboard": "Visa Tangentbord",
+    "Extra keys": "Extraknappar",
+    "Show Extra Keys": "Visa Extraknappar",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Växla Ctrl",
+    "Alt": "Alt",
+    "Toggle Alt": "Växla Alt",
+    "Toggle Windows": "Växla Windows",
+    "Windows": "Windows",
+    "Send Tab": "Skicka Tab",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "Skicka Escape",
+    "Ctrl+Alt+Del": "Ctrl+Alt+Del",
+    "Send Ctrl-Alt-Del": "Skicka Ctrl-Alt-Del",
+    "Shutdown/Reboot": "Stäng av/Boota om",
+    "Shutdown/Reboot...": "Stäng av/Boota om...",
+    "Power": "Ström",
+    "Shutdown": "Stäng av",
+    "Reboot": "Boota om",
+    "Reset": "Återställ",
+    "Clipboard": "Urklipp",
+    "Clear": "Rensa",
+    "Fullscreen": "Fullskärm",
+    "Settings": "Inställningar",
+    "Shared Mode": "Delat Läge",
+    "View Only": "Endast Visning",
+    "Clip to Window": "Begränsa till Fönster",
+    "Scaling Mode:": "Skalningsläge:",
+    "None": "Ingen",
+    "Local Scaling": "Lokal Skalning",
+    "Remote Resizing": "Ändra Storlek",
+    "Advanced": "Avancerat",
+    "Quality:": "Kvalitet:",
+    "Compression level:": "Kompressionsnivå:",
+    "Repeater ID:": "Repeater-ID:",
+    "WebSocket": "WebSocket",
+    "Encrypt": "Kryptera",
+    "Host:": "Värd:",
+    "Port:": "Port:",
+    "Path:": "Sökväg:",
+    "Automatic Reconnect": "Automatisk Återanslutning",
+    "Reconnect Delay (ms):": "Fördröjning (ms):",
+    "Show Dot when No Cursor": "Visa prick när ingen muspekare finns",
+    "Logging:": "Loggning:",
+    "Version:": "Version:",
+    "Disconnect": "Koppla från",
+    "Connect": "Anslut",
+    "Username:": "Användarnamn:",
+    "Password:": "Lösenord:",
+    "Send Credentials": "Skicka Användaruppgifter",
+    "Cancel": "Avbryt"
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/tr.json
@@ -0,0 +1,69 @@
+{
+    "Connecting...": "Bağlanıyor...",
+    "Disconnecting...": "Bağlantı kesiliyor...",
+    "Reconnecting...": "Yeniden bağlantı kuruluyor...",
+    "Internal error": "İç hata",
+    "Must set host": "Sunucuyu kur",
+    "Connected (encrypted) to ": "Bağlı (şifrelenmiş)",
+    "Connected (unencrypted) to ": "Bağlandı (şifrelenmemiş)",
+    "Something went wrong, connection is closed": "Bir şeyler ters gitti, bağlantı kesildi",
+    "Disconnected": "Bağlantı kesildi",
+    "New connection has been rejected with reason: ": "Bağlantı aşağıdaki nedenlerden dolayı reddedildi: ",
+    "New connection has been rejected": "Bağlantı reddedildi",
+    "Password is required": "Şifre gerekli",
+    "noVNC encountered an error:": "Bir hata oluştu:",
+    "Hide/Show the control bar": "Denetim masasını Gizle/Göster",
+    "Move/Drag Viewport": "Görünümü Taşı/Sürükle",
+    "viewport drag": "Görüntü penceresini sürükle",
+    "Active Mouse Button": "Aktif Fare Düğmesi",
+    "No mousebutton": "Fare düğmesi yok",
+    "Left mousebutton": "Farenin sol düğmesi",
+    "Middle mousebutton": "Farenin orta düğmesi",
+    "Right mousebutton": "Farenin sağ düğmesi",
+    "Keyboard": "Klavye",
+    "Show Keyboard": "Klavye Düzenini Göster",
+    "Extra keys": "Ekstra tuşlar",
+    "Show Extra Keys": "Ekstra tuşları göster",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "Ctrl Değiştir ",
+    "Alt": "Alt",
+    "Toggle Alt": "Alt Değiştir",
+    "Send Tab": "Sekme Gönder",
+    "Tab": "Sekme",
+    "Esc": "Esc",
+    "Send Escape": "Boşluk Gönder",
+    "Ctrl+Alt+Del": "Ctrl + Alt + Del",
+    "Send Ctrl-Alt-Del": "Ctrl-Alt-Del Gönder",
+    "Shutdown/Reboot": "Kapat/Yeniden Başlat",
+    "Shutdown/Reboot...": "Kapat/Yeniden Başlat...",
+    "Power": "Güç",
+    "Shutdown": "Kapat",
+    "Reboot": "Yeniden Başlat",
+    "Reset": "Sıfırla",
+    "Clipboard": "Pano",
+    "Clear": "Temizle",
+    "Fullscreen": "Tam Ekran",
+    "Settings": "Ayarlar",
+    "Shared Mode": "Paylaşım Modu",
+    "View Only": "Sadece Görüntüle",
+    "Clip to Window": "Pencereye Tıkla",
+    "Scaling Mode:": "Ölçekleme Modu:",
+    "None": "Bilinmeyen",
+    "Local Scaling": "Yerel Ölçeklendirme",
+    "Remote Resizing": "Uzaktan Yeniden Boyutlandırma",
+    "Advanced": "Gelişmiş",
+    "Repeater ID:": "Tekralayıcı ID:",
+    "WebSocket": "WebSocket",
+    "Encrypt": "Şifrele",
+    "Host:": "Ana makine:",
+    "Port:": "Port:",
+    "Path:": "Yol:",
+    "Automatic Reconnect": "Otomatik Yeniden Bağlan",
+    "Reconnect Delay (ms):": "Yeniden Bağlanma Süreci (ms):",
+    "Logging:": "Giriş yapılıyor:",
+    "Disconnect": "Bağlantıyı Kes",
+    "Connect": "Bağlan",
+    "Password:": "Parola:",
+    "Cancel": "Vazgeç",
+    "Canvas not supported.": "Tuval desteklenmiyor."
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/zh_CN.json
@@ -0,0 +1,69 @@
+{
+    "Connecting...": "连接中...",
+    "Disconnecting...": "正在断开连接...",
+    "Reconnecting...": "重新连接中...",
+    "Internal error": "内部错误",
+    "Must set host": "请提供主机名",
+    "Connected (encrypted) to ": "已连接到（加密）",
+    "Connected (unencrypted) to ": "已连接到（未加密）",
+    "Something went wrong, connection is closed": "发生错误，连接已关闭",
+    "Failed to connect to server": "无法连接到服务器",
+    "Disconnected": "已断开连接",
+    "New connection has been rejected with reason: ": "连接被拒绝，原因：",
+    "New connection has been rejected": "连接被拒绝",
+    "Password is required": "请提供密码",
+    "noVNC encountered an error:": "noVNC 遇到一个错误：",
+    "Hide/Show the control bar": "显示/隐藏控制栏",
+    "Move/Drag Viewport": "拖放显示范围",
+    "viewport drag": "显示范围拖放",
+    "Active Mouse Button": "启动鼠标按鍵",
+    "No mousebutton": "禁用鼠标按鍵",
+    "Left mousebutton": "鼠标左鍵",
+    "Middle mousebutton": "鼠标中鍵",
+    "Right mousebutton": "鼠标右鍵",
+    "Keyboard": "键盘",
+    "Show Keyboard": "显示键盘",
+    "Extra keys": "额外按键",
+    "Show Extra Keys": "显示额外按键",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "切换 Ctrl",
+    "Alt": "Alt",
+    "Toggle Alt": "切换 Alt",
+    "Send Tab": "发送 Tab 键",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "发送 Escape 键",
+    "Ctrl+Alt+Del": "Ctrl-Alt-Del",
+    "Send Ctrl-Alt-Del": "发送 Ctrl-Alt-Del 键",
+    "Shutdown/Reboot": "关机/重新启动",
+    "Shutdown/Reboot...": "关机/重新启动...",
+    "Power": "电源",
+    "Shutdown": "关机",
+    "Reboot": "重新启动",
+    "Reset": "重置",
+    "Clipboard": "剪贴板",
+    "Clear": "清除",
+    "Fullscreen": "全屏",
+    "Settings": "设置",
+    "Shared Mode": "分享模式",
+    "View Only": "仅查看",
+    "Clip to Window": "限制/裁切窗口大小",
+    "Scaling Mode:": "缩放模式：",
+    "None": "无",
+    "Local Scaling": "本地缩放",
+    "Remote Resizing": "远程调整大小",
+    "Advanced": "高级",
+    "Repeater ID:": "中继站 ID",
+    "WebSocket": "WebSocket",
+    "Encrypt": "加密",
+    "Host:": "主机：",
+    "Port:": "端口：",
+    "Path:": "路径：",
+    "Automatic Reconnect": "自动重新连接",
+    "Reconnect Delay (ms):": "重新连接间隔 (ms)：",
+    "Logging:": "日志级别：",
+    "Disconnect": "中断连接",
+    "Connect": "连接",
+    "Password:": "密码：",
+    "Cancel": "取消"
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/locale/zh_TW.json
@@ -0,0 +1,69 @@
+{
+    "Connecting...": "連線中...",
+    "Disconnecting...": "正在中斷連線...",
+    "Reconnecting...": "重新連線中...",
+    "Internal error": "內部錯誤",
+    "Must set host": "請提供主機資訊",
+    "Connected (encrypted) to ": "已加密連線到",
+    "Connected (unencrypted) to ": "未加密連線到",
+    "Something went wrong, connection is closed": "發生錯誤，連線已關閉",
+    "Failed to connect to server": "無法連線到伺服器",
+    "Disconnected": "連線已中斷",
+    "New connection has been rejected with reason: ": "連線被拒絕，原因：",
+    "New connection has been rejected": "連線被拒絕",
+    "Password is required": "請提供密碼",
+    "noVNC encountered an error:": "noVNC 遇到一個錯誤：",
+    "Hide/Show the control bar": "顯示/隱藏控制列",
+    "Move/Drag Viewport": "拖放顯示範圍",
+    "viewport drag": "顯示範圍拖放",
+    "Active Mouse Button": "啟用滑鼠按鍵",
+    "No mousebutton": "無滑鼠按鍵",
+    "Left mousebutton": "滑鼠左鍵",
+    "Middle mousebutton": "滑鼠中鍵",
+    "Right mousebutton": "滑鼠右鍵",
+    "Keyboard": "鍵盤",
+    "Show Keyboard": "顯示鍵盤",
+    "Extra keys": "額外按鍵",
+    "Show Extra Keys": "顯示額外按鍵",
+    "Ctrl": "Ctrl",
+    "Toggle Ctrl": "切換 Ctrl",
+    "Alt": "Alt",
+    "Toggle Alt": "切換 Alt",
+    "Send Tab": "送出 Tab 鍵",
+    "Tab": "Tab",
+    "Esc": "Esc",
+    "Send Escape": "送出 Escape 鍵",
+    "Ctrl+Alt+Del": "Ctrl-Alt-Del",
+    "Send Ctrl-Alt-Del": "送出 Ctrl-Alt-Del 快捷鍵",
+    "Shutdown/Reboot": "關機/重新啟動",
+    "Shutdown/Reboot...": "關機/重新啟動...",
+    "Power": "電源",
+    "Shutdown": "關機",
+    "Reboot": "重新啟動",
+    "Reset": "重設",
+    "Clipboard": "剪貼簿",
+    "Clear": "清除",
+    "Fullscreen": "全螢幕",
+    "Settings": "設定",
+    "Shared Mode": "分享模式",
+    "View Only": "僅檢視",
+    "Clip to Window": "限制/裁切視窗大小",
+    "Scaling Mode:": "縮放模式：",
+    "None": "無",
+    "Local Scaling": "本機縮放",
+    "Remote Resizing": "遠端調整大小",
+    "Advanced": "進階",
+    "Repeater ID:": "中繼站 ID",
+    "WebSocket": "WebSocket",
+    "Encrypt": "加密",
+    "Host:": "主機：",
+    "Port:": "連接埠：",
+    "Path:": "路徑：",
+    "Automatic Reconnect": "自動重新連線",
+    "Reconnect Delay (ms):": "重新連線間隔 (ms)：",
+    "Logging:": "日誌級別：",
+    "Disconnect": "中斷連線",
+    "Connect": "連線",
+    "Password:": "密碼：",
+    "Cancel": "取消"
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/localization.js
@@ -0,0 +1,172 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2018 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+/*
+ * Localization Utilities
+ */
+
+export class Localizer {
+    constructor() {
+        // Currently configured language
+        this.language = 'en';
+
+        // Current dictionary of translations
+        this.dictionary = undefined;
+    }
+
+    // Configure suitable language based on user preferences
+    setup(supportedLanguages) {
+        this.language = 'en'; // Default: US English
+
+        /*
+         * Navigator.languages only available in Chrome (32+) and FireFox (32+)
+         * Fall back to navigator.language for other browsers
+         */
+        let userLanguages;
+        if (typeof window.navigator.languages == 'object') {
+            userLanguages = window.navigator.languages;
+        } else {
+            userLanguages = [navigator.language || navigator.userLanguage];
+        }
+
+        for (let i = 0;i < userLanguages.length;i++) {
+            const userLang = userLanguages[i]
+                .toLowerCase()
+                .replace("_", "-")
+                .split("-");
+
+            // Built-in default?
+            if ((userLang[0] === 'en') &&
+                ((userLang[1] === undefined) || (userLang[1] === 'us'))) {
+                return;
+            }
+
+            // First pass: perfect match
+            for (let j = 0; j < supportedLanguages.length; j++) {
+                const supLang = supportedLanguages[j]
+                    .toLowerCase()
+                    .replace("_", "-")
+                    .split("-");
+
+                if (userLang[0] !== supLang[0]) {
+                    continue;
+                }
+                if (userLang[1] !== supLang[1]) {
+                    continue;
+                }
+
+                this.language = supportedLanguages[j];
+                return;
+            }
+
+            // Second pass: fallback
+            for (let j = 0;j < supportedLanguages.length;j++) {
+                const supLang = supportedLanguages[j]
+                    .toLowerCase()
+                    .replace("_", "-")
+                    .split("-");
+
+                if (userLang[0] !== supLang[0]) {
+                    continue;
+                }
+                if (supLang[1] !== undefined) {
+                    continue;
+                }
+
+                this.language = supportedLanguages[j];
+                return;
+            }
+        }
+    }
+
+    // Retrieve localised text
+    get(id) {
+        if (typeof this.dictionary !== 'undefined' && this.dictionary[id]) {
+            return this.dictionary[id];
+        } else {
+            return id;
+        }
+    }
+
+    // Traverses the DOM and translates relevant fields
+    // See https://html.spec.whatwg.org/multipage/dom.html#attr-translate
+    translateDOM() {
+        const self = this;
+
+        function process(elem, enabled) {
+            function isAnyOf(searchElement, items) {
+                return items.indexOf(searchElement) !== -1;
+            }
+
+            function translateAttribute(elem, attr) {
+                const str = self.get(elem.getAttribute(attr));
+                elem.setAttribute(attr, str);
+            }
+
+            function translateTextNode(node) {
+                const str = self.get(node.data.trim());
+                node.data = str;
+            }
+
+            if (elem.hasAttribute("translate")) {
+                if (isAnyOf(elem.getAttribute("translate"), ["", "yes"])) {
+                    enabled = true;
+                } else if (isAnyOf(elem.getAttribute("translate"), ["no"])) {
+                    enabled = false;
+                }
+            }
+
+            if (enabled) {
+                if (elem.hasAttribute("abbr") &&
+                    elem.tagName === "TH") {
+                    translateAttribute(elem, "abbr");
+                }
+                if (elem.hasAttribute("alt") &&
+                    isAnyOf(elem.tagName, ["AREA", "IMG", "INPUT"])) {
+                    translateAttribute(elem, "alt");
+                }
+                if (elem.hasAttribute("download") &&
+                    isAnyOf(elem.tagName, ["A", "AREA"])) {
+                    translateAttribute(elem, "download");
+                }
+                if (elem.hasAttribute("label") &&
+                    isAnyOf(elem.tagName, ["MENUITEM", "MENU", "OPTGROUP",
+                                           "OPTION", "TRACK"])) {
+                    translateAttribute(elem, "label");
+                }
+                // FIXME: Should update "lang"
+                if (elem.hasAttribute("placeholder") &&
+                    isAnyOf(elem.tagName, ["INPUT", "TEXTAREA"])) {
+                    translateAttribute(elem, "placeholder");
+                }
+                if (elem.hasAttribute("title")) {
+                    translateAttribute(elem, "title");
+                }
+                if (elem.hasAttribute("value") &&
+                    elem.tagName === "INPUT" &&
+                    isAnyOf(elem.getAttribute("type"), ["reset", "button", "submit"])) {
+                    translateAttribute(elem, "value");
+                }
+            }
+
+            for (let i = 0; i < elem.childNodes.length; i++) {
+                const node = elem.childNodes[i];
+                if (node.nodeType === node.ELEMENT_NODE) {
+                    process(node, enabled);
+                } else if (node.nodeType === node.TEXT_NODE && enabled) {
+                    translateTextNode(node);
+                }
+            }
+        }
+
+        process(document.body, true);
+    }
+}
+
+export const l10n = new Localizer();
+export default l10n.get.bind(l10n);
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/sounds/CREDITS
@@ -0,0 +1,4 @@
+bell
+        Copyright: Dr. Richard Boulanger et al
+        URL: http://www.archive.org/details/Berklee44v12
+        License: CC-BY Attribution 3.0 Unported
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/styles/base.css
@@ -0,0 +1,888 @@
+/*
+ * noVNC base CSS
+ * Copyright (C) 2019 The noVNC Authors
+ * noVNC is licensed under the MPL 2.0 (see LICENSE.txt)
+ * This file is licensed under the 2-Clause BSD license (see LICENSE.txt).
+ */
+
+/*
+ * Z index layers:
+ *
+ * 0: Main screen
+ * 10: Control bar
+ * 50: Transition blocker
+ * 60: Connection popups
+ * 100: Status bar
+ * ...
+ * 1000: Javascript crash
+ * ...
+ * 10000: Max (used for polyfills)
+ */
+
+/*
+ * State variables (set on :root):
+ *
+ * noVNC_touch: Device has touch input
+ *
+ * noVNC_loading: Page is still loading
+ * noVNC_connecting: Connecting to server
+ * noVNC_reconnecting: Re-establishing a connection
+ * noVNC_connected: Connected to server (most common state)
+ * noVNC_disconnecting: Disconnecting from server
+ */
+
+:root {
+  font-family: sans-serif;
+}
+
+body {
+  margin:0;
+  padding:0;
+  /*Background image with light grey curve.*/
+  background-color:#000000;
+  background-repeat:no-repeat;
+  background-position:right bottom;
+  height:100%;
+  touch-action: none;
+}
+
+html {
+  height:100%;
+}
+
+.noVNC_only_touch.noVNC_hidden {
+  display: none;
+}
+
+.noVNC_disabled {
+  color: rgb(128, 128, 128);
+}
+
+/* ----------------------------------------
+ * Spinner
+ * ----------------------------------------
+ */
+
+.noVNC_spinner {
+  position: relative;
+}
+.noVNC_spinner, .noVNC_spinner::before, .noVNC_spinner::after {
+  width: 10px;
+  height: 10px;
+  border-radius: 2px;
+  box-shadow: -60px 10px 0 rgba(255, 255, 255, 0);
+  animation: noVNC_spinner 1.0s linear infinite;
+}
+.noVNC_spinner::before {
+  content: "";
+  position: absolute;
+  left: 0px;
+  top: 0px;
+  animation-delay: -0.1s;
+}
+.noVNC_spinner::after {
+  content: "";
+  position: absolute;
+  top: 0px;
+  left: 0px;
+  animation-delay: 0.1s;
+}
+@keyframes noVNC_spinner {
+  0% { box-shadow: -60px 10px 0 rgba(255, 255, 255, 0); width: 20px; }
+  25% { box-shadow: 20px 10px 0 rgba(255, 255, 255, 1); width: 10px; }
+  50% { box-shadow: 60px 10px 0 rgba(255, 255, 255, 0); width: 10px; }
+}
+
+/* ----------------------------------------
+ * WebKit centering hacks
+ * ----------------------------------------
+ */
+
+.noVNC_center {
+  /*
+   * This is a workaround because webkit misrenders transforms and
+   * uses non-integer coordinates, resulting in blurry content.
+   * Ideally we'd use "top: 50%; transform: translateY(-50%);" on
+   * the objects instead.
+   */
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  position: fixed;
+  top: 0;
+  left: 0;
+  width: 100%;
+  height: 100%;
+  pointer-events: none;
+}
+.noVNC_center > * {
+  pointer-events: auto;
+}
+.noVNC_vcenter {
+  display: flex !important;
+  flex-direction: column;
+  justify-content: center;
+  position: fixed;
+  top: 0;
+  left: 0;
+  height: 100%;
+  margin: 0 !important;
+  padding: 0 !important;
+  pointer-events: none;
+}
+.noVNC_vcenter > * {
+  pointer-events: auto;
+}
+
+/* ----------------------------------------
+ * Layering
+ * ----------------------------------------
+ */
+
+.noVNC_connect_layer {
+  z-index: 60;
+}
+
+/* ----------------------------------------
+ * Fallback error
+ * ----------------------------------------
+ */
+
+#noVNC_fallback_error {
+  z-index: 1000;
+  visibility: hidden;
+  /* Put a dark background in front of everything but the error,
+     and don't let mouse events pass through */
+  background: rgba(0, 0, 0, 0.8);
+  pointer-events: all;
+}
+#noVNC_fallback_error.noVNC_open {
+  visibility: visible;
+}
+
+#noVNC_fallback_error > div {
+  max-width: calc(100vw - 30px - 30px);
+  max-height: calc(100vh - 30px - 30px);
+  overflow: auto;
+
+  padding: 15px;
+
+  transition: 0.5s ease-in-out;
+
+  transform: translateY(-50px);
+  opacity: 0;
+
+  text-align: center;
+  font-weight: bold;
+  color: #fff;
+
+  border-radius: 10px;
+  box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.5);
+  background: rgba(200,55,55,0.8);
+}
+#noVNC_fallback_error.noVNC_open > div {
+  transform: translateY(0);
+  opacity: 1;
+}
+
+#noVNC_fallback_errormsg {
+  font-weight: normal;
+}
+
+#noVNC_fallback_errormsg .noVNC_message {
+  display: inline-block;
+  text-align: left;
+  font-family: monospace;
+  white-space: pre-wrap;
+}
+
+#noVNC_fallback_error .noVNC_location {
+  font-style: italic;
+  font-size: 0.8em;
+  color: rgba(255, 255, 255, 0.8);
+}
+
+#noVNC_fallback_error .noVNC_stack {
+  padding: 10px;
+  margin: 10px;
+  font-size: 0.8em;
+  text-align: left;
+  font-family: monospace;
+  white-space: pre;
+  border: 1px solid rgba(0, 0, 0, 0.5);
+  background: rgba(0, 0, 0, 0.2);
+  overflow: auto;
+}
+
+/* ----------------------------------------
+ * Control Bar
+ * ----------------------------------------
+ */
+
+#noVNC_control_bar_anchor {
+  /* The anchor is needed to get z-stacking to work */
+  position: fixed;
+  z-index: 10;
+
+  transition: 0.5s ease-in-out;
+
+  /* Edge misrenders animations wihthout this */
+  transform: translateX(0);
+}
+:root.noVNC_connected #noVNC_control_bar_anchor.noVNC_idle {
+  opacity: 0.8;
+}
+#noVNC_control_bar_anchor.noVNC_right {
+  left: auto;
+  right: 0;
+}
+
+#noVNC_control_bar {
+  position: relative;
+  left: -100%;
+
+  transition: 0.5s ease-in-out;
+
+  background-color: rgb(110, 132, 163);
+  border-radius: 0 10px 10px 0;
+
+}
+#noVNC_control_bar.noVNC_open {
+  box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.5);
+  left: 0;
+}
+#noVNC_control_bar::before {
+  /* This extra element is to get a proper shadow */
+  content: "";
+  position: absolute;
+  z-index: -1;
+  height: 100%;
+  width: 30px;
+  left: -30px;
+  transition: box-shadow 0.5s ease-in-out;
+}
+#noVNC_control_bar.noVNC_open::before {
+  box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.5);
+}
+.noVNC_right #noVNC_control_bar {
+  left: 100%;
+  border-radius: 10px 0 0 10px;
+}
+.noVNC_right #noVNC_control_bar.noVNC_open {
+  left: 0;
+}
+.noVNC_right #noVNC_control_bar::before {
+  visibility: hidden;
+}
+
+#noVNC_control_bar_handle {
+  position: absolute;
+  left: -15px;
+  top: 0;
+  transform: translateY(35px);
+  width: calc(100% + 30px);
+  height: 50px;
+  z-index: -1;
+  cursor: pointer;
+  border-radius: 5px;
+  background-color: rgb(83, 99, 122);
+  background-image: url("../images/handle_bg.svg");
+  background-repeat: no-repeat;
+  background-position: right;
+  box-shadow: 3px 3px 0px rgba(0, 0, 0, 0.5);
+}
+#noVNC_control_bar_handle:after {
+  content: "";
+  transition: transform 0.5s ease-in-out;
+  background: url("../images/handle.svg");
+  position: absolute;
+  top: 22px; /* (50px-6px)/2 */
+  right: 5px;
+  width: 5px;
+  height: 6px;
+}
+#noVNC_control_bar.noVNC_open #noVNC_control_bar_handle:after {
+  transform: translateX(1px) rotate(180deg);
+}
+:root:not(.noVNC_connected) #noVNC_control_bar_handle {
+  display: none;
+}
+.noVNC_right #noVNC_control_bar_handle {
+  background-position: left;
+}
+.noVNC_right #noVNC_control_bar_handle:after {
+  left: 5px;
+  right: 0;
+  transform: translateX(1px) rotate(180deg);
+}
+.noVNC_right #noVNC_control_bar.noVNC_open #noVNC_control_bar_handle:after {
+  transform: none;
+}
+#noVNC_control_bar_handle div {
+  position: absolute;
+  right: -35px;
+  top: 0;
+  width: 50px;
+  height: 100%;
+}
+:root:not(.noVNC_touch) #noVNC_control_bar_handle div {
+  display: none;
+}
+.noVNC_right #noVNC_control_bar_handle div {
+  left: -35px;
+  right: auto;
+}
+
+#noVNC_control_bar > .noVNC_scroll {
+  max-height: 100vh; /* Chrome is buggy with 100% */
+  overflow-x: hidden;
+  overflow-y: auto;
+  padding: 0 10px;
+}
+
+#noVNC_control_bar > .noVNC_scroll > * {
+  display: block;
+  margin: 10px auto;
+}
+
+/* Control bar hint */
+#noVNC_control_bar_hint {
+  position: fixed;
+  left: calc(100vw - 50px);
+  right: auto;
+  top: calc(50vh - 25%);
+  transform: scale(0);
+  width: 100px;
+  height: 50%;
+  max-height: 600px;
+
+  visibility: hidden;
+  opacity: 0;
+  transition: 0.2s ease-in-out;
+  background: transparent;
+  box-shadow: 0 0 10px black, inset 0 0 10px 10px rgba(110, 132, 163, 0.8);
+  border-radius: 10px;
+  transition-delay: 0s;
+}
+#noVNC_control_bar_anchor.noVNC_right #noVNC_control_bar_hint{
+  left: auto;
+  right: calc(100vw - 50px);
+}
+#noVNC_control_bar_hint.noVNC_active {
+  visibility: visible;
+  opacity: 1;
+  transition-delay: 0.2s;
+  transform: scale(1);
+}
+
+/* Control bar buttons */
+.noVNC_button {
+  padding: 4px 4px;
+  vertical-align: middle;
+  border:1px solid rgba(255, 255, 255, 0.2);
+  border-radius: 6px;
+}
+.noVNC_button.noVNC_selected {
+  border-color: rgba(0, 0, 0, 0.8);
+  background: rgba(0, 0, 0, 0.5);
+}
+.noVNC_button:disabled {
+  opacity: 0.4;
+}
+.noVNC_button:focus {
+  outline: none;
+}
+.noVNC_button:not(:disabled):active {
+  padding-top: 5px;
+  padding-bottom: 3px;
+}
+/* Android browsers don't properly update hover state if touch events
+ * are intercepted, but focus should be safe to display */
+:root:not(.noVNC_touch) .noVNC_button.noVNC_selected:not(:disabled):hover,
+.noVNC_button.noVNC_selected:not(:disabled):focus {
+  border-color: rgba(0, 0, 0, 0.4);
+  background: rgba(0, 0, 0, 0.2);
+}
+:root:not(.noVNC_touch) .noVNC_button:not(:disabled):hover,
+.noVNC_button:not(:disabled):focus {
+  background: rgba(255, 255, 255, 0.2);
+}
+.noVNC_button.noVNC_hidden {
+  display: none !important;
+}
+
+/* Panels */
+.noVNC_panel {
+  transform: translateX(25px);
+
+  transition: 0.5s ease-in-out;
+
+  max-height: 100vh; /* Chrome is buggy with 100% */
+  overflow-x: hidden;
+  overflow-y: auto;
+
+  visibility: hidden;
+  opacity: 0;
+
+  padding: 15px;
+
+  background: #fff;
+  border-radius: 10px;
+  color: #000;
+  border: 2px solid #E0E0E0;
+  box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.5);
+}
+.noVNC_panel.noVNC_open {
+  visibility: visible;
+  opacity: 1;
+  transform: translateX(75px);
+}
+.noVNC_right .noVNC_vcenter {
+  left: auto;
+  right: 0;
+}
+.noVNC_right .noVNC_panel {
+  transform: translateX(-25px);
+}
+.noVNC_right .noVNC_panel.noVNC_open {
+  transform: translateX(-75px);
+}
+
+.noVNC_panel > * {
+  display: block;
+  margin: 10px auto;
+}
+.noVNC_panel > *:first-child {
+  margin-top: 0 !important;
+}
+.noVNC_panel > *:last-child {
+  margin-bottom: 0 !important;
+}
+
+.noVNC_panel hr {
+  border: none;
+  border-top: 1px solid rgb(192, 192, 192);
+}
+
+.noVNC_panel label {
+  display: block;
+  white-space: nowrap;
+  margin: 5px;
+}
+
+.noVNC_panel li {
+  margin: 5px;
+}
+
+.noVNC_panel .noVNC_heading {
+  background-color: rgb(110, 132, 163);
+  border-radius: 5px;
+  padding: 5px;
+  /* Compensate for padding in image */
+  padding-right: 8px;
+  color: white;
+  font-size: 20px;
+  white-space: nowrap;
+}
+.noVNC_panel .noVNC_heading img {
+  vertical-align: bottom;
+}
+
+.noVNC_submit {
+  float: right;
+}
+
+/* Expanders */
+.noVNC_expander {
+  cursor: pointer;
+}
+.noVNC_expander::before {
+  content: url("../images/expander.svg");
+  display: inline-block;
+  margin-right: 5px;
+  transition: 0.2s ease-in-out;
+}
+.noVNC_expander.noVNC_open::before {
+  transform: rotateZ(90deg);
+}
+.noVNC_expander ~ * {
+  margin: 5px;
+  margin-left: 10px;
+  padding: 5px;
+  background: rgba(0, 0, 0, 0.05);
+  border-radius: 5px;
+}
+.noVNC_expander:not(.noVNC_open) ~ * {
+  display: none;
+}
+
+/* Control bar content */
+
+#noVNC_control_bar .noVNC_logo {
+  font-size: 13px;
+}
+
+:root:not(.noVNC_connected) #noVNC_view_drag_button {
+  display: none;
+}
+
+/* noVNC Touch Device only buttons */
+:root:not(.noVNC_connected) #noVNC_mobile_buttons {
+  display: none;
+}
+:root:not(.noVNC_touch) #noVNC_mobile_buttons {
+  display: none;
+}
+
+/* Extra manual keys */
+:root:not(.noVNC_connected) #noVNC_toggle_extra_keys_button {
+  display: none;
+}
+
+#noVNC_modifiers {
+  background-color: rgb(92, 92, 92);
+  border: none;
+  padding: 10px;
+}
+
+/* Shutdown/Reboot */
+:root:not(.noVNC_connected) #noVNC_power_button {
+  display: none;
+}
+#noVNC_power {
+}
+#noVNC_power_buttons {
+  display: none;
+}
+
+#noVNC_power input[type=button] {
+  width: 100%;
+}
+
+/* Clipboard */
+:root:not(.noVNC_connected) #noVNC_clipboard_button {
+  display: none;
+}
+#noVNC_clipboard {
+  /* Full screen, minus padding and left and right margins */
+  max-width: calc(100vw - 2*15px - 75px - 25px);
+}
+#noVNC_clipboard_text {
+  width: 500px;
+  max-width: 100%;
+}
+
+/* Settings */
+#noVNC_settings {
+}
+#noVNC_settings ul {
+  list-style: none;
+  padding: 0px;
+}
+#noVNC_setting_port {
+  width: 80px;
+}
+#noVNC_setting_path {
+  width: 100px;
+}
+
+/* Version */
+
+.noVNC_version_wrapper {
+  font-size: small;
+}
+
+.noVNC_version {
+  margin-left: 1rem;
+}
+
+/* Connection Controls */
+:root:not(.noVNC_connected) #noVNC_disconnect_button {
+  display: none;
+}
+
+/* ----------------------------------------
+ * Status Dialog
+ * ----------------------------------------
+ */
+
+#noVNC_status {
+  position: fixed;
+  top: 0;
+  left: 0;
+  width: 100%;
+  z-index: 100;
+  transform: translateY(-100%);
+
+  cursor: pointer;
+
+  transition: 0.5s ease-in-out;
+
+  visibility: hidden;
+  opacity: 0;
+
+  padding: 5px;
+
+  display: flex;
+  flex-direction: row;
+  justify-content: center;
+  align-content: center;
+
+  line-height: 25px;
+  word-wrap: break-word;
+  color: #fff;
+
+  border-bottom: 1px solid rgba(0, 0, 0, 0.9);
+}
+#noVNC_status.noVNC_open {
+  transform: translateY(0);
+  visibility: visible;
+  opacity: 1;
+}
+
+#noVNC_status::before {
+  content: "";
+  display: inline-block;
+  width: 25px;
+  height: 25px;
+  margin-right: 5px;
+}
+
+#noVNC_status.noVNC_status_normal {
+  background: rgba(128,128,128,0.9);
+}
+#noVNC_status.noVNC_status_normal::before {
+  content: url("../images/info.svg") " ";
+}
+#noVNC_status.noVNC_status_error {
+  background: rgba(200,55,55,0.9);
+}
+#noVNC_status.noVNC_status_error::before {
+  content: url("../images/error.svg") " ";
+}
+#noVNC_status.noVNC_status_warn {
+  background: rgba(180,180,30,0.9);
+}
+#noVNC_status.noVNC_status_warn::before {
+  content: url("../images/warning.svg") " ";
+}
+
+/* ----------------------------------------
+ * Connect Dialog
+ * ----------------------------------------
+ */
+
+#noVNC_connect_dlg {
+  transition: 0.5s ease-in-out;
+
+  transform: scale(0, 0);
+  visibility: hidden;
+  opacity: 0;
+}
+#noVNC_connect_dlg.noVNC_open {
+  transform: scale(1, 1);
+  visibility: visible;
+  opacity: 1;
+}
+#noVNC_connect_dlg .noVNC_logo {
+  transition: 0.5s ease-in-out;
+  padding: 10px;
+  margin-bottom: 10px;
+
+  font-size: 80px;
+  text-align: center;
+
+  border-radius: 5px;
+}
+@media (max-width: 440px) {
+  #noVNC_connect_dlg {
+    max-width: calc(100vw - 100px);
+  }
+  #noVNC_connect_dlg .noVNC_logo {
+    font-size: calc(25vw - 30px);
+  }
+}
+#noVNC_connect_button {
+  cursor: pointer;
+
+  padding: 10px;
+
+  color: white;
+  background-color: rgb(110, 132, 163);
+  border-radius: 12px;
+
+  text-align: center;
+  font-size: 20px;
+
+  box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.5);
+}
+#noVNC_connect_button div {
+  margin: 2px;
+  padding: 5px 30px;
+  border: 1px solid rgb(83, 99, 122);
+  border-bottom-width: 2px;
+  border-radius: 5px;
+  background: linear-gradient(to top, rgb(110, 132, 163), rgb(99, 119, 147));
+
+  /* This avoids it jumping around when :active */
+  vertical-align: middle;
+}
+#noVNC_connect_button div:active {
+  border-bottom-width: 1px;
+  margin-top: 3px;
+}
+:root:not(.noVNC_touch) #noVNC_connect_button div:hover {
+  background: linear-gradient(to top, rgb(110, 132, 163), rgb(105, 125, 155));
+}
+
+#noVNC_connect_button img {
+  vertical-align: bottom;
+  height: 1.3em;
+}
+
+/* ----------------------------------------
+ * Server verification Dialog
+ * ----------------------------------------
+ */
+
+#noVNC_verify_server_dlg {
+  position: relative;
+
+  transform: translateY(-50px);
+}
+#noVNC_verify_server_dlg.noVNC_open {
+  transform: translateY(0);
+}
+#noVNC_fingerprint_block {
+  margin: 10px;
+}
+
+/* ----------------------------------------
+ * Password Dialog
+ * ----------------------------------------
+ */
+
+#noVNC_credentials_dlg {
+  position: relative;
+
+  transform: translateY(-50px);
+}
+#noVNC_credentials_dlg.noVNC_open {
+  transform: translateY(0);
+}
+#noVNC_username_block.noVNC_hidden,
+#noVNC_password_block.noVNC_hidden {
+  display: none;
+}
+
+
+/* ----------------------------------------
+ * Main Area
+ * ----------------------------------------
+ */
+
+/* Transition screen */
+#noVNC_transition {
+  transition: 0.5s ease-in-out;
+
+  display: flex;
+  opacity: 0;
+  visibility: hidden;
+
+  position: fixed;
+  top: 0;
+  left: 0;
+  bottom: 0;
+  right: 0;
+
+  color: white;
+  background: rgba(0, 0, 0, 0.5);
+  z-index: 50;
+
+  /*display: flex;*/
+  align-items: center;
+  justify-content: center;
+  flex-direction: column;
+}
+:root.noVNC_loading #noVNC_transition,
+:root.noVNC_connecting #noVNC_transition,
+:root.noVNC_disconnecting #noVNC_transition,
+:root.noVNC_reconnecting #noVNC_transition {
+  opacity: 1;
+  visibility: visible;
+}
+:root:not(.noVNC_reconnecting) #noVNC_cancel_reconnect_button {
+  display: none;
+}
+#noVNC_transition_text {
+  font-size: 1.5em;
+}
+
+/* Main container */
+#noVNC_container {
+  width: 100%;
+  height: 100%;
+  background-color: #000000;
+  /*background-color: #313131;*/
+  border-bottom-right-radius: 800px 600px;
+  /*border-top-left-radius: 800px 600px;*/
+}
+
+#noVNC_keyboardinput {
+  width: 1px;
+  height: 1px;
+  background-color: #fff;
+  color: #fff;
+  border: 0;
+  position: absolute;
+  left: -40px;
+  z-index: -1;
+  ime-mode: disabled;
+}
+
+/*Default noVNC logo.*/
+/* From: http://fonts.googleapis.com/css?family=Orbitron:700 */
+@font-face {
+  font-family: 'Orbitron';
+  font-style: normal;
+  font-weight: 700;
+  src: local('?'), url('Orbitron700.woff') format('woff'),
+                   url('Orbitron700.ttf') format('truetype');
+}
+
+.noVNC_logo {
+  color:yellow;
+  font-family: 'Orbitron', 'OrbitronTTF', sans-serif;
+  line-height:90%;
+  text-shadow: 0.1em 0.1em 0 black;
+}
+.noVNC_logo span{
+  color:green;
+}
+
+#noVNC_bell {
+  display: none;
+}
+
+/* ----------------------------------------
+ * Media sizing
+ * ----------------------------------------
+ */
+
+@media screen and (max-width: 640px){
+  #noVNC_logo {
+    font-size: 150px;
+  }
+}
+
+@media screen and (min-width: 321px) and (max-width: 480px) {
+  #noVNC_logo {
+    font-size: 110px;
+  }
+}
+
+@media screen and (max-width: 320px) {
+  #noVNC_logo {
+    font-size: 90px;
+  }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/styles/input.css
@@ -0,0 +1,149 @@
+/*
+ * noVNC general input element CSS
+ * Copyright (C) 2022 The noVNC Authors
+ * noVNC is licensed under the MPL 2.0 (see LICENSE.txt)
+ * This file is licensed under the 2-Clause BSD license (see LICENSE.txt).
+ */
+
+input, select, textarea {
+  /* Respect standard font settings */
+  font: inherit;
+}
+
+input:not([type]),
+input[type=date],
+input[type=datetime-local],
+input[type=email],
+input[type=month],
+input[type=number],
+input[type=password],
+input[type=search],
+input[type=tel],
+input[type=text],
+input[type=time],
+input[type=url],
+input[type=week],
+textarea {
+  /* Disable default rendering */
+  -webkit-appearance: none;
+  -moz-appearance: none;
+  background: none;
+
+  padding: 5px;
+  border: 1px solid rgb(192, 192, 192);
+  border-radius: 5px;
+  color: black;
+  background: linear-gradient(to top, rgb(255, 255, 255) 80%, rgb(240, 240, 240));
+}
+
+input[type=button],
+input[type=color],
+input[type=reset],
+input[type=submit],
+button,
+select {
+  /* Disable default rendering */
+  -webkit-appearance: none;
+  -moz-appearance: none;
+  background: none;
+
+  padding: 5px;
+  border: 1px solid rgb(192, 192, 192);
+  border-bottom-width: 2px;
+  border-radius: 5px;
+  color: black;
+  background: linear-gradient(to top, rgb(255, 255, 255), rgb(240, 240, 240));
+
+  /* This avoids it jumping around when :active */
+  vertical-align: middle;
+}
+
+input[type=button],
+input[type=color],
+input[type=reset],
+input[type=submit],
+button {
+  padding-left: 20px;
+  padding-right: 20px;
+}
+
+option {
+  color: black;
+  background: white;
+}
+
+input:not([type]):focus,
+input[type=button]:focus,
+input[type=color]:focus,
+input[type=date]:focus,
+input[type=datetime-local]:focus,
+input[type=email]:focus,
+input[type=month]:focus,
+input[type=number]:focus,
+input[type=password]:focus,
+input[type=reset]:focus,
+input[type=search]:focus,
+input[type=submit]:focus,
+input[type=tel]:focus,
+input[type=text]:focus,
+input[type=time]:focus,
+input[type=url]:focus,
+input[type=week]:focus,
+button:focus,
+select:focus,
+textarea:focus {
+  box-shadow: 0px 0px 3px rgba(74, 144, 217, 0.5);
+  border-color: rgb(74, 144, 217);
+  outline: none;
+}
+
+input[type=button]::-moz-focus-inner,
+input[type=color]::-moz-focus-inner,
+input[type=reset]::-moz-focus-inner,
+input[type=submit]::-moz-focus-inner,
+button::-moz-focus-inner {
+  border: none;
+}
+
+input:not([type]):disabled,
+input[type=button]:disabled,
+input[type=color]:disabled,
+input[type=date]:disabled,
+input[type=datetime-local]:disabled,
+input[type=email]:disabled,
+input[type=month]:disabled,
+input[type=number]:disabled,
+input[type=password]:disabled,
+input[type=reset]:disabled,
+input[type=search]:disabled,
+input[type=submit]:disabled,
+input[type=tel]:disabled,
+input[type=text]:disabled,
+input[type=time]:disabled,
+input[type=url]:disabled,
+input[type=week]:disabled,
+button:disabled,
+select:disabled,
+textarea:disabled {
+  color: rgb(128, 128, 128);
+  background: rgb(240, 240, 240);
+}
+
+input[type=button]:active,
+input[type=color]:active,
+input[type=reset]:active,
+input[type=submit]:active,
+button:active,
+select:active {
+  border-bottom-width: 1px;
+  margin-top: 1px;
+}
+
+:root:not(.noVNC_touch) input[type=button]:hover:not(:disabled),
+:root:not(.noVNC_touch) input[type=color]:hover:not(:disabled),
+:root:not(.noVNC_touch) input[type=reset]:hover:not(:disabled),
+:root:not(.noVNC_touch) input[type=submit]:hover:not(:disabled),
+:root:not(.noVNC_touch) button:hover:not(:disabled),
+:root:not(.noVNC_touch) select:hover:not(:disabled) {
+  background: linear-gradient(to top, rgb(255, 255, 255), rgb(250, 250, 250));
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/ui.js
@@ -0,0 +1,1814 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+import * as Log from '../core/util/logging.js';
+import _, { l10n } from './localization.js';
+import { isTouchDevice, isSafari, hasScrollbarGutter, dragThreshold }
+    from '../core/util/browser.js';
+import { setCapture, getPointerEvent } from '../core/util/events.js';
+import KeyTable from "../core/input/keysym.js";
+import keysyms from "../core/input/keysymdef.js";
+import Keyboard from "../core/input/keyboard.js";
+import RFB from "../core/rfb.js";
+import * as WebUtil from "./webutil.js";
+
+/***
+ * NGAM: Change title
+ */
+const PAGE_TITLE = "ForensicVM";
+
+const UI = {
+
+    connected: false,
+    desktopName: "",
+
+    statusTimeout: null,
+    hideKeyboardTimeout: null,
+    idleControlbarTimeout: null,
+    closeControlbarTimeout: null,
+
+    controlbarGrabbed: false,
+    controlbarDrag: false,
+    controlbarMouseDownClientY: 0,
+    controlbarMouseDownOffsetY: 0,
+
+    lastKeyboardinput: null,
+    defaultKeyboardinputLen: 100,
+
+    inhibitReconnect: true,
+    reconnectCallback: null,
+    reconnectPassword: null,
+
+    prime() {
+        return WebUtil.initSettings().then(() => {
+            if (document.readyState === "interactive" || document.readyState === "complete") {
+                return UI.start();
+            }
+
+            return new Promise((resolve, reject) => {
+                document.addEventListener('DOMContentLoaded', () => UI.start().then(resolve).catch(reject));
+            });
+        });
+    },
+
+    // Render default UI and initialize settings menu
+    start() {
+
+        UI.initSettings();
+
+        // Translate the DOM
+        l10n.translateDOM();
+
+        // We rely on modern APIs which might not be available in an
+        // insecure context
+        if (!window.isSecureContext) {
+            // FIXME: This gets hidden when connecting
+            UI.showStatus(_("HTTPS is required for full functionality"), 'error');
+        }
+
+        // Try to fetch version number
+        fetch('./package.json')
+            .then((response) => {
+                if (!response.ok) {
+                    throw Error("" + response.status + " " + response.statusText);
+                }
+                return response.json();
+            })
+            .then((packageInfo) => {
+                Array.from(document.getElementsByClassName('noVNC_version')).forEach(el => el.innerText = packageInfo.version);
+            })
+            .catch((err) => {
+                Log.Error("Couldn't fetch package.json: " + err);
+                Array.from(document.getElementsByClassName('noVNC_version_wrapper'))
+                    .concat(Array.from(document.getElementsByClassName('noVNC_version_separator')))
+                    .forEach(el => el.style.display = 'none');
+            });
+
+        // Adapt the interface for touch screen devices
+        if (isTouchDevice) {
+            document.documentElement.classList.add("noVNC_touch");
+            // Remove the address bar
+            setTimeout(() => window.scrollTo(0, 1), 100);
+        }
+
+        // Restore control bar position
+        if (WebUtil.readSetting('controlbar_pos') === 'right') {
+            UI.toggleControlbarSide();
+        }
+
+        UI.initFullscreen();
+
+        // Setup event handlers
+        UI.addControlbarHandlers();
+        UI.addTouchSpecificHandlers();
+        UI.addExtraKeysHandlers();
+        UI.addMachineHandlers();
+        UI.addConnectionControlHandlers();
+        UI.addClipboardHandlers();
+        UI.addSettingsHandlers();
+        document.getElementById("noVNC_status")
+            .addEventListener('click', UI.hideStatus);
+
+        // Bootstrap fallback input handler
+        UI.keyboardinputReset();
+
+        UI.openControlbar();
+
+        UI.updateVisualState('init');
+
+        document.documentElement.classList.remove("noVNC_loading");
+
+        let autoconnect = WebUtil.getConfigVar('autoconnect', false);
+        if (autoconnect === 'true' || autoconnect == '1') {
+            autoconnect = true;
+            UI.connect();
+        } else {
+            autoconnect = false;
+            // Show the connect panel on first load unless autoconnecting
+            UI.openConnectPanel();
+        }
+
+        return Promise.resolve(UI.rfb);
+    },
+
+    initFullscreen() {
+        // Only show the button if fullscreen is properly supported
+        // * Safari doesn't support alphanumerical input while in fullscreen
+        if (!isSafari() &&
+            (document.documentElement.requestFullscreen ||
+             document.documentElement.mozRequestFullScreen ||
+             document.documentElement.webkitRequestFullscreen ||
+             document.body.msRequestFullscreen)) {
+            document.getElementById('noVNC_fullscreen_button')
+                .classList.remove("noVNC_hidden");
+            UI.addFullscreenHandlers();
+        }
+    },
+
+    initSettings() {
+        // Logging selection dropdown
+        const llevels = ['error', 'warn', 'info', 'debug'];
+        for (let i = 0; i < llevels.length; i += 1) {
+            UI.addOption(document.getElementById('noVNC_setting_logging'), llevels[i], llevels[i]);
+        }
+
+        // Settings with immediate effects
+        UI.initSetting('logging', 'warn');
+        UI.updateLogging();
+
+        // if port == 80 (or 443) then it won't be present and should be
+        // set manually
+        let port = window.location.port;
+        if (!port) {
+            if (window.location.protocol.substring(0, 5) == 'https') {
+                port = 443;
+            } else if (window.location.protocol.substring(0, 4) == 'http') {
+                port = 80;
+            }
+        }
+
+        /* Populate the controls if defaults are provided in the URL */
+        UI.initSetting('host', window.location.hostname);
+        /* NGAM: UI.initSetting('port', port); */
+        UI.initSetting('port', 5901);
+        UI.initSetting('encrypt', (window.location.protocol === "https:"));
+        UI.initSetting('view_clip', false);
+        UI.initSetting('resize', 'off');
+        UI.initSetting('quality', 6);
+        UI.initSetting('compression', 2);
+        UI.initSetting('shared', true);
+        UI.initSetting('view_only', false);
+        UI.initSetting('show_dot', false);
+        /* ngam: websockify */
+        UI.initSetting('path', '');
+        UI.initSetting('repeaterID', '');
+        UI.initSetting('reconnect', false);
+        UI.initSetting('reconnect_delay', 5000);
+
+        UI.setupSettingLabels();
+    },
+    // Adds a link to the label elements on the corresponding input elements
+    setupSettingLabels() {
+        const labels = document.getElementsByTagName('LABEL');
+        for (let i = 0; i < labels.length; i++) {
+            const htmlFor = labels[i].htmlFor;
+            if (htmlFor != '') {
+                const elem = document.getElementById(htmlFor);
+                if (elem) elem.label = labels[i];
+            } else {
+                // If 'for' isn't set, use the first input element child
+                const children = labels[i].children;
+                for (let j = 0; j < children.length; j++) {
+                    if (children[j].form !== undefined) {
+                        children[j].label = labels[i];
+                        break;
+                    }
+                }
+            }
+        }
+    },
+
+/* ------^-------
+*     /INIT
+* ==============
+* EVENT HANDLERS
+* ------v------*/
+
+    addControlbarHandlers() {
+        document.getElementById("noVNC_control_bar")
+            .addEventListener('mousemove', UI.activateControlbar);
+        document.getElementById("noVNC_control_bar")
+            .addEventListener('mouseup', UI.activateControlbar);
+        document.getElementById("noVNC_control_bar")
+            .addEventListener('mousedown', UI.activateControlbar);
+        document.getElementById("noVNC_control_bar")
+            .addEventListener('keydown', UI.activateControlbar);
+
+        document.getElementById("noVNC_control_bar")
+            .addEventListener('mousedown', UI.keepControlbar);
+        document.getElementById("noVNC_control_bar")
+            .addEventListener('keydown', UI.keepControlbar);
+
+        document.getElementById("noVNC_view_drag_button")
+            .addEventListener('click', UI.toggleViewDrag);
+
+        document.getElementById("noVNC_control_bar_handle")
+            .addEventListener('mousedown', UI.controlbarHandleMouseDown);
+        document.getElementById("noVNC_control_bar_handle")
+            .addEventListener('mouseup', UI.controlbarHandleMouseUp);
+        document.getElementById("noVNC_control_bar_handle")
+            .addEventListener('mousemove', UI.dragControlbarHandle);
+        // resize events aren't available for elements
+        window.addEventListener('resize', UI.updateControlbarHandle);
+
+        const exps = document.getElementsByClassName("noVNC_expander");
+        for (let i = 0;i < exps.length;i++) {
+            exps[i].addEventListener('click', UI.toggleExpander);
+        }
+    },
+
+    addTouchSpecificHandlers() {
+        document.getElementById("noVNC_keyboard_button")
+            .addEventListener('click', UI.toggleVirtualKeyboard);
+
+        UI.touchKeyboard = new Keyboard(document.getElementById('noVNC_keyboardinput'));
+        UI.touchKeyboard.onkeyevent = UI.keyEvent;
+        UI.touchKeyboard.grab();
+        document.getElementById("noVNC_keyboardinput")
+            .addEventListener('input', UI.keyInput);
+        document.getElementById("noVNC_keyboardinput")
+            .addEventListener('focus', UI.onfocusVirtualKeyboard);
+        document.getElementById("noVNC_keyboardinput")
+            .addEventListener('blur', UI.onblurVirtualKeyboard);
+        document.getElementById("noVNC_keyboardinput")
+            .addEventListener('submit', () => false);
+
+        document.documentElement
+            .addEventListener('mousedown', UI.keepVirtualKeyboard, true);
+
+        document.getElementById("noVNC_control_bar")
+            .addEventListener('touchstart', UI.activateControlbar);
+        document.getElementById("noVNC_control_bar")
+            .addEventListener('touchmove', UI.activateControlbar);
+        document.getElementById("noVNC_control_bar")
+            .addEventListener('touchend', UI.activateControlbar);
+        document.getElementById("noVNC_control_bar")
+            .addEventListener('input', UI.activateControlbar);
+
+        document.getElementById("noVNC_control_bar")
+            .addEventListener('touchstart', UI.keepControlbar);
+        document.getElementById("noVNC_control_bar")
+            .addEventListener('input', UI.keepControlbar);
+
+        document.getElementById("noVNC_control_bar_handle")
+            .addEventListener('touchstart', UI.controlbarHandleMouseDown);
+        document.getElementById("noVNC_control_bar_handle")
+            .addEventListener('touchend', UI.controlbarHandleMouseUp);
+        document.getElementById("noVNC_control_bar_handle")
+            .addEventListener('touchmove', UI.dragControlbarHandle);
+    },
+
+    addExtraKeysHandlers() {
+        document.getElementById("noVNC_toggle_extra_keys_button")
+            .addEventListener('click', UI.toggleExtraKeys);
+        document.getElementById("noVNC_toggle_ctrl_button")
+            .addEventListener('click', UI.toggleCtrl);
+        document.getElementById("noVNC_toggle_windows_button")
+            .addEventListener('click', UI.toggleWindows);
+        document.getElementById("noVNC_toggle_alt_button")
+            .addEventListener('click', UI.toggleAlt);
+        document.getElementById("noVNC_send_tab_button")
+            .addEventListener('click', UI.sendTab);
+        document.getElementById("noVNC_send_esc_button")
+            .addEventListener('click', UI.sendEsc);
+        document.getElementById("noVNC_send_ctrl_alt_del_button")
+            .addEventListener('click', UI.sendCtrlAltDel);
+    },
+
+    addMachineHandlers() {
+        
+        document.getElementById("noVNC_shutdown_button")
+            .addEventListener('click', () => UI.rfb.machineShutdown());
+        document.getElementById("noVNC_reboot_button")
+            .addEventListener('click', () => UI.rfb.machineReboot());
+        document.getElementById("noVNC_reset_button")
+            .addEventListener('click', () => UI.rfb.machineReset());
+        document.getElementById("noVNC_power_button")
+            .addEventListener('click', UI.togglePowerPanel);
+    },
+
+    addConnectionControlHandlers() {
+        document.getElementById("noVNC_disconnect_button")
+            .addEventListener('click', UI.disconnect);
+        document.getElementById("noVNC_connect_button")
+            .addEventListener('click', UI.connect);
+        document.getElementById("noVNC_cancel_reconnect_button")
+            .addEventListener('click', UI.cancelReconnect);
+
+        document.getElementById("noVNC_approve_server_button")
+            .addEventListener('click', UI.approveServer);
+        document.getElementById("noVNC_reject_server_button")
+            .addEventListener('click', UI.rejectServer);
+        document.getElementById("noVNC_credentials_button")
+            .addEventListener('click', UI.setCredentials);
+    },
+
+    addClipboardHandlers() {
+        document.getElementById("noVNC_clipboard_button")
+            .addEventListener('click', UI.toggleClipboardPanel);
+        document.getElementById("noVNC_clipboard_text")
+            .addEventListener('change', UI.clipboardSend);
+    },
+
+    // Add a call to save settings when the element changes,
+    // unless the optional parameter changeFunc is used instead.
+    addSettingChangeHandler(name, changeFunc) {
+        const settingElem = document.getElementById("noVNC_setting_" + name);
+        if (changeFunc === undefined) {
+            changeFunc = () => UI.saveSetting(name);
+        }
+        settingElem.addEventListener('change', changeFunc);
+    },
+
+    addSettingsHandlers() {
+        document.getElementById("noVNC_settings_button")
+            .addEventListener('click', UI.toggleSettingsPanel);
+
+        UI.addSettingChangeHandler('encrypt');
+        UI.addSettingChangeHandler('resize');
+        UI.addSettingChangeHandler('resize', UI.applyResizeMode);
+        UI.addSettingChangeHandler('resize', UI.updateViewClip);
+        UI.addSettingChangeHandler('quality');
+        UI.addSettingChangeHandler('quality', UI.updateQuality);
+        UI.addSettingChangeHandler('compression');
+        UI.addSettingChangeHandler('compression', UI.updateCompression);
+        UI.addSettingChangeHandler('view_clip');
+        UI.addSettingChangeHandler('view_clip', UI.updateViewClip);
+        UI.addSettingChangeHandler('shared');
+        UI.addSettingChangeHandler('view_only');
+        UI.addSettingChangeHandler('view_only', UI.updateViewOnly);
+        UI.addSettingChangeHandler('show_dot');
+        UI.addSettingChangeHandler('show_dot', UI.updateShowDotCursor);
+        UI.addSettingChangeHandler('host');
+        UI.addSettingChangeHandler('port');
+        UI.addSettingChangeHandler('path');
+        UI.addSettingChangeHandler('repeaterID');
+        UI.addSettingChangeHandler('logging');
+        UI.addSettingChangeHandler('logging', UI.updateLogging);
+        UI.addSettingChangeHandler('reconnect');
+        UI.addSettingChangeHandler('reconnect_delay');
+    },
+
+    addFullscreenHandlers() {
+        document.getElementById("noVNC_fullscreen_button")
+            .addEventListener('click', UI.toggleFullscreen);
+
+        window.addEventListener('fullscreenchange', UI.updateFullscreenButton);
+        window.addEventListener('mozfullscreenchange', UI.updateFullscreenButton);
+        window.addEventListener('webkitfullscreenchange', UI.updateFullscreenButton);
+        window.addEventListener('msfullscreenchange', UI.updateFullscreenButton);
+    },
+
+/* ------^-------
+ * /EVENT HANDLERS
+ * ==============
+ *     VISUAL
+ * ------v------*/
+
+    // Disable/enable controls depending on connection state
+    updateVisualState(state) {
+
+        document.documentElement.classList.remove("noVNC_connecting");
+        document.documentElement.classList.remove("noVNC_connected");
+        document.documentElement.classList.remove("noVNC_disconnecting");
+        document.documentElement.classList.remove("noVNC_reconnecting");
+
+        const transitionElem = document.getElementById("noVNC_transition_text");
+        switch (state) {
+            case 'init':
+                break;
+            case 'connecting':
+                transitionElem.textContent = _("Connecting...");
+                document.documentElement.classList.add("noVNC_connecting");
+                break;
+            case 'connected':
+                document.documentElement.classList.add("noVNC_connected");
+                break;
+            case 'disconnecting':
+                transitionElem.textContent = _("Disconnecting...");
+                document.documentElement.classList.add("noVNC_disconnecting");
+                break;
+            case 'disconnected':
+                break;
+            case 'reconnecting':
+                transitionElem.textContent = _("Reconnecting...");
+                document.documentElement.classList.add("noVNC_reconnecting");
+                break;
+            default:
+                Log.Error("Invalid visual state: " + state);
+                UI.showStatus(_("Internal error"), 'error');
+                return;
+        }
+
+        if (UI.connected) {
+            UI.updateViewClip();
+
+            UI.disableSetting('encrypt');
+            UI.disableSetting('shared');
+            UI.disableSetting('host');
+            UI.disableSetting('port');
+            UI.disableSetting('path');
+            UI.disableSetting('repeaterID');
+
+            // Hide the controlbar after 2 seconds
+            UI.closeControlbarTimeout = setTimeout(UI.closeControlbar, 2000);
+        } else {
+            UI.enableSetting('encrypt');
+            UI.enableSetting('shared');            
+            UI.enableSetting('host');
+            UI.enableSetting('port');
+            UI.enableSetting('path');
+            UI.enableSetting('repeaterID');
+            UI.updatePowerButton();
+            UI.keepControlbar();
+        }
+
+        // State change closes dialogs as they may not be relevant
+        // anymore
+        UI.closeAllPanels();
+        document.getElementById('noVNC_verify_server_dlg')
+            .classList.remove('noVNC_open');
+        document.getElementById('noVNC_credentials_dlg')
+            .classList.remove('noVNC_open');
+    },
+
+    showStatus(text, statusType, time) {
+        const statusElem = document.getElementById('noVNC_status');
+
+        if (typeof statusType === 'undefined') {
+            statusType = 'normal';
+        }
+
+        // Don't overwrite more severe visible statuses and never
+        // errors. Only shows the first error.
+        if (statusElem.classList.contains("noVNC_open")) {
+            if (statusElem.classList.contains("noVNC_status_error")) {
+                return;
+            }
+            if (statusElem.classList.contains("noVNC_status_warn") &&
+                statusType === 'normal') {
+                return;
+            }
+        }
+
+        clearTimeout(UI.statusTimeout);
+
+        switch (statusType) {
+            case 'error':
+                statusElem.classList.remove("noVNC_status_warn");
+                statusElem.classList.remove("noVNC_status_normal");
+                statusElem.classList.add("noVNC_status_error");
+                break;
+            case 'warning':
+            case 'warn':
+                statusElem.classList.remove("noVNC_status_error");
+                statusElem.classList.remove("noVNC_status_normal");
+                statusElem.classList.add("noVNC_status_warn");
+                break;
+            case 'normal':
+            case 'info':
+            default:
+                statusElem.classList.remove("noVNC_status_error");
+                statusElem.classList.remove("noVNC_status_warn");
+                statusElem.classList.add("noVNC_status_normal");
+                break;
+        }
+
+        statusElem.textContent = text;
+        statusElem.classList.add("noVNC_open");
+
+        // If no time was specified, show the status for 1.5 seconds
+        if (typeof time === 'undefined') {
+            time = 1500;
+        }
+
+        // Error messages do not timeout
+        if (statusType !== 'error') {
+            UI.statusTimeout = window.setTimeout(UI.hideStatus, time);
+        }
+    },
+
+    hideStatus() {
+        clearTimeout(UI.statusTimeout);
+        document.getElementById('noVNC_status').classList.remove("noVNC_open");
+    },
+
+    activateControlbar(event) {
+        clearTimeout(UI.idleControlbarTimeout);
+        // We manipulate the anchor instead of the actual control
+        // bar in order to avoid creating new a stacking group
+        document.getElementById('noVNC_control_bar_anchor')
+            .classList.remove("noVNC_idle");
+        UI.idleControlbarTimeout = window.setTimeout(UI.idleControlbar, 2000);
+    },
+
+    idleControlbar() {
+        // Don't fade if a child of the control bar has focus
+        if (document.getElementById('noVNC_control_bar')
+            .contains(document.activeElement) && document.hasFocus()) {
+            UI.activateControlbar();
+            return;
+        }
+
+        document.getElementById('noVNC_control_bar_anchor')
+            .classList.add("noVNC_idle");
+    },
+
+    keepControlbar() {
+        clearTimeout(UI.closeControlbarTimeout);
+    },
+
+    openControlbar() {
+        document.getElementById('noVNC_control_bar')
+            .classList.add("noVNC_open");
+    },
+
+    closeControlbar() {
+        UI.closeAllPanels();
+        document.getElementById('noVNC_control_bar')
+            .classList.remove("noVNC_open");
+        UI.rfb.focus();
+    },
+
+    toggleControlbar() {
+        if (document.getElementById('noVNC_control_bar')
+            .classList.contains("noVNC_open")) {
+            UI.closeControlbar();
+        } else {
+            UI.openControlbar();
+        }
+    },
+
+    toggleControlbarSide() {
+        // Temporarily disable animation, if bar is displayed, to avoid weird
+        // movement. The transitionend-event will not fire when display=none.
+        const bar = document.getElementById('noVNC_control_bar');
+        const barDisplayStyle = window.getComputedStyle(bar).display;
+        if (barDisplayStyle !== 'none') {
+            bar.style.transitionDuration = '0s';
+            bar.addEventListener('transitionend', () => bar.style.transitionDuration = '');
+        }
+
+        const anchor = document.getElementById('noVNC_control_bar_anchor');
+        if (anchor.classList.contains("noVNC_right")) {
+            WebUtil.writeSetting('controlbar_pos', 'left');
+            anchor.classList.remove("noVNC_right");
+        } else {
+            WebUtil.writeSetting('controlbar_pos', 'right');
+            anchor.classList.add("noVNC_right");
+        }
+
+        // Consider this a movement of the handle
+        UI.controlbarDrag = true;
+    },
+
+    showControlbarHint(show) {
+        const hint = document.getElementById('noVNC_control_bar_hint');
+        if (show) {
+            hint.classList.add("noVNC_active");
+        } else {
+            hint.classList.remove("noVNC_active");
+        }
+    },
+
+    dragControlbarHandle(e) {
+        if (!UI.controlbarGrabbed) return;
+
+        const ptr = getPointerEvent(e);
+
+        const anchor = document.getElementById('noVNC_control_bar_anchor');
+        if (ptr.clientX < (window.innerWidth * 0.1)) {
+            if (anchor.classList.contains("noVNC_right")) {
+                UI.toggleControlbarSide();
+            }
+        } else if (ptr.clientX > (window.innerWidth * 0.9)) {
+            if (!anchor.classList.contains("noVNC_right")) {
+                UI.toggleControlbarSide();
+            }
+        }
+
+        if (!UI.controlbarDrag) {
+            const dragDistance = Math.abs(ptr.clientY - UI.controlbarMouseDownClientY);
+
+            if (dragDistance < dragThreshold) return;
+
+            UI.controlbarDrag = true;
+        }
+
+        const eventY = ptr.clientY - UI.controlbarMouseDownOffsetY;
+
+        UI.moveControlbarHandle(eventY);
+
+        e.preventDefault();
+        e.stopPropagation();
+        UI.keepControlbar();
+        UI.activateControlbar();
+    },
+
+    // Move the handle but don't allow any position outside the bounds
+    moveControlbarHandle(viewportRelativeY) {
+        const handle = document.getElementById("noVNC_control_bar_handle");
+        const handleHeight = handle.getBoundingClientRect().height;
+        const controlbarBounds = document.getElementById("noVNC_control_bar")
+            .getBoundingClientRect();
+        const margin = 10;
+
+        // These heights need to be non-zero for the below logic to work
+        if (handleHeight === 0 || controlbarBounds.height === 0) {
+            return;
+        }
+
+        let newY = viewportRelativeY;
+
+        // Check if the coordinates are outside the control bar
+        if (newY < controlbarBounds.top + margin) {
+            // Force coordinates to be below the top of the control bar
+            newY = controlbarBounds.top + margin;
+
+        } else if (newY > controlbarBounds.top +
+                   controlbarBounds.height - handleHeight - margin) {
+            // Force coordinates to be above the bottom of the control bar
+            newY = controlbarBounds.top +
+                controlbarBounds.height - handleHeight - margin;
+        }
+
+        // Corner case: control bar too small for stable position
+        if (controlbarBounds.height < (handleHeight + margin * 2)) {
+            newY = controlbarBounds.top +
+                (controlbarBounds.height - handleHeight) / 2;
+        }
+
+        // The transform needs coordinates that are relative to the parent
+        const parentRelativeY = newY - controlbarBounds.top;
+        handle.style.transform = "translateY(" + parentRelativeY + "px)";
+    },
+
+    updateControlbarHandle() {
+        // Since the control bar is fixed on the viewport and not the page,
+        // the move function expects coordinates relative the the viewport.
+        const handle = document.getElementById("noVNC_control_bar_handle");
+        const handleBounds = handle.getBoundingClientRect();
+        UI.moveControlbarHandle(handleBounds.top);
+    },
+
+    controlbarHandleMouseUp(e) {
+        if ((e.type == "mouseup") && (e.button != 0)) return;
+
+        // mouseup and mousedown on the same place toggles the controlbar
+        if (UI.controlbarGrabbed && !UI.controlbarDrag) {
+            UI.toggleControlbar();
+            e.preventDefault();
+            e.stopPropagation();
+            UI.keepControlbar();
+            UI.activateControlbar();
+        }
+        UI.controlbarGrabbed = false;
+        UI.showControlbarHint(false);
+    },
+
+    controlbarHandleMouseDown(e) {
+        if ((e.type == "mousedown") && (e.button != 0)) return;
+
+        const ptr = getPointerEvent(e);
+
+        const handle = document.getElementById("noVNC_control_bar_handle");
+        const bounds = handle.getBoundingClientRect();
+
+        // Touch events have implicit capture
+        if (e.type === "mousedown") {
+            setCapture(handle);
+        }
+
+        UI.controlbarGrabbed = true;
+        UI.controlbarDrag = false;
+
+        UI.showControlbarHint(true);
+
+        UI.controlbarMouseDownClientY = ptr.clientY;
+        UI.controlbarMouseDownOffsetY = ptr.clientY - bounds.top;
+        e.preventDefault();
+        e.stopPropagation();
+        UI.keepControlbar();
+        UI.activateControlbar();
+    },
+
+    toggleExpander(e) {
+        if (this.classList.contains("noVNC_open")) {
+            this.classList.remove("noVNC_open");
+        } else {
+            this.classList.add("noVNC_open");
+        }
+    },
+
+/* ------^-------
+ *    /VISUAL
+ * ==============
+ *    SETTINGS
+ * ------v------*/
+
+    // Initial page load read/initialization of settings
+    initSetting(name, defVal) {
+        // Check Query string followed by cookie
+        let val = WebUtil.getConfigVar(name);
+        if (val === null) {
+            val = WebUtil.readSetting(name, defVal);
+        }
+        WebUtil.setSetting(name, val);
+        UI.updateSetting(name);
+        return val;
+    },
+
+    // Set the new value, update and disable form control setting
+    forceSetting(name, val) {
+        WebUtil.setSetting(name, val);
+        UI.updateSetting(name);
+        UI.disableSetting(name);
+    },
+
+    
+    // Update cookie and form control setting. If value is not set, then
+    // updates from control to current cookie setting.
+    updateSetting(name) {
+
+        // Update the settings control
+        let value = UI.getSetting(name);
+
+        const ctrl = document.getElementById('noVNC_setting_' + name);
+        if (ctrl.type === 'checkbox') {
+            ctrl.checked = value;
+
+        } else if (typeof ctrl.options !== 'undefined') {
+            for (let i = 0; i < ctrl.options.length; i += 1) {
+                if (ctrl.options[i].value === value) {
+                    ctrl.selectedIndex = i;
+                    break;
+                }
+            }
+        } else {
+            ctrl.value = value;
+        }
+    },
+
+    // Save control setting to cookie
+    saveSetting(name) {
+        const ctrl = document.getElementById('noVNC_setting_' + name);
+        let val;
+        if (ctrl.type === 'checkbox') {
+            val = ctrl.checked;
+        } else if (typeof ctrl.options !== 'undefined') {
+            val = ctrl.options[ctrl.selectedIndex].value;
+        } else {
+            val = ctrl.value;
+        }
+        WebUtil.writeSetting(name, val);
+        //Log.Debug("Setting saved '" + name + "=" + val + "'");
+        return val;
+    },
+
+    // Read form control compatible setting from cookie
+    getSetting(name) {
+        const ctrl = document.getElementById('noVNC_setting_' + name);
+        let val = WebUtil.readSetting(name);
+        if (typeof val !== 'undefined' && val !== null && ctrl.type === 'checkbox') {
+            if (val.toString().toLowerCase() in {'0': 1, 'no': 1, 'false': 1}) {
+                val = false;
+            } else {
+                val = true;
+            }
+        }
+        return val;
+    },
+
+    // These helpers compensate for the lack of parent-selectors and
+    // previous-sibling-selectors in CSS which are needed when we want to
+    // disable the labels that belong to disabled input elements.
+    disableSetting(name) {
+        const ctrl = document.getElementById('noVNC_setting_' + name);
+        ctrl.disabled = true;
+        ctrl.label.classList.add('noVNC_disabled');
+    },
+
+    enableSetting(name) {
+        const ctrl = document.getElementById('noVNC_setting_' + name);
+        ctrl.disabled = false;
+        ctrl.label.classList.remove('noVNC_disabled');
+    },
+
+/* ------^-------
+ *   /SETTINGS
+ * ==============
+ *    PANELS
+ * ------v------*/
+
+    closeAllPanels() {
+        UI.closeSettingsPanel();
+        UI.closePowerPanel();
+        UI.closeClipboardPanel();
+        UI.closeExtraKeys();
+    },
+
+/* ------^-------
+ *   /PANELS
+ * ==============
+ * SETTINGS (panel)
+ * ------v------*/
+
+    openSettingsPanel() {
+        UI.closeAllPanels();
+        UI.openControlbar();
+
+        // Refresh UI elements from saved cookies
+        UI.updateSetting('encrypt');
+        UI.updateSetting('view_clip');
+        UI.updateSetting('resize');
+        UI.updateSetting('quality');
+        UI.updateSetting('compression');
+        UI.updateSetting('shared');
+        UI.updateSetting('view_only');
+        UI.updateSetting('path');
+        UI.updateSetting('repeaterID');
+        UI.updateSetting('logging');
+        UI.updateSetting('reconnect');
+        UI.updateSetting('reconnect_delay');
+
+        document.getElementById('noVNC_settings')
+            .classList.add("noVNC_open");
+        document.getElementById('noVNC_settings_button')
+            .classList.add("noVNC_selected");
+    },
+
+    closeSettingsPanel() {
+        document.getElementById('noVNC_settings')
+            .classList.remove("noVNC_open");
+        document.getElementById('noVNC_settings_button')
+            .classList.remove("noVNC_selected");
+    },
+
+    toggleSettingsPanel() {
+        if (document.getElementById('noVNC_settings')
+            .classList.contains("noVNC_open")) {
+            UI.closeSettingsPanel();
+        } else {
+            UI.openSettingsPanel();
+        }
+    },
+
+/* ------^-------
+ *   /SETTINGS
+ * ==============
+ *     NGAM TEST
+ * ------v------*/
+
+
+    openNgamTestPanel() {
+        UI.closeAllPanels();
+        UI.openControlbar();
+
+        document.getElementById('ngam_power')
+            .classList.add("noVNC_open");
+        document.getElementById('ngam_power_button')
+            .classList.add("noVNC_selected");
+    },
+    closengamTestPanel() {
+        document.getElementById('noVNC_power')
+            .classList.remove("noVNC_open");
+        document.getElementById('noVNC_power_button')
+            .classList.remove("noVNC_selected");
+    },
+
+    togglengamTestPanel() {
+        if (document.getElementById('noVNC_power')
+            .classList.contains("noVNC_open")) {
+            UI.closePowerPanel();
+        } else {
+            UI.openPowerPanel();
+        }
+    },
+
+    // Disable/enable power button
+    updatePngamTestButton() {
+        if (UI.connected &&
+            !UI.rfb.viewOnly) {
+            document.getElementById('ngam_power_button')
+                .classList.remove("noVNC_hidden");
+        } else {
+            document.getElementById('ngam_power_button')
+                // NGAM: Always show power button when connected
+                //.classList.add("noVNC_hidden");
+                .classList.remove("ngam_hidden");
+            // Close power panel if open
+            UI.closengamTestPanel();
+        }
+    },
+
+/* ------^-------
+ *   /NGAM TEST
+ * ==============
+ *     POWER
+ * ------v------*/
+
+
+    openPowerPanel() {
+        UI.closeAllPanels();
+        UI.openControlbar();
+
+        document.getElementById('noVNC_power')
+            .classList.add("noVNC_open");
+        document.getElementById('noVNC_power_button')
+            .classList.add("noVNC_selected");
+    },
+
+    closePowerPanel() {
+        document.getElementById('noVNC_power')
+            .classList.remove("noVNC_open");
+        document.getElementById('noVNC_power_button')
+            .classList.remove("noVNC_selected");
+    },
+
+    togglePowerPanel() {
+        if (document.getElementById('noVNC_power')
+            .classList.contains("noVNC_open")) {
+            UI.closePowerPanel();
+        } else {
+            UI.openPowerPanel();
+        }
+    },
+
+    // Disable/enable power button
+    updatePowerButton() {
+        if (UI.connected &&
+            UI.rfb.capabilities.power &&
+            !UI.rfb.viewOnly) {
+            document.getElementById('noVNC_power_button')
+                .classList.remove("noVNC_hidden");
+        } else {
+            document.getElementById('noVNC_power_button')
+                // NGAM: Always show power button when connected
+                //.classList.add("noVNC_hidden");
+                .classList.remove("noVNC_hidden");
+            // Close power panel if open
+            UI.closePowerPanel();
+        }
+    },
+
+/* ------^-------
+ *    /POWER
+ * ==============
+ *   CLIPBOARD
+ * ------v------*/
+
+    openClipboardPanel() {
+        UI.closeAllPanels();
+        UI.openControlbar();
+
+        document.getElementById('noVNC_clipboard')
+            .classList.add("noVNC_open");
+        document.getElementById('noVNC_clipboard_button')
+            .classList.add("noVNC_selected");
+    },
+
+    closeClipboardPanel() {
+        document.getElementById('noVNC_clipboard')
+            .classList.remove("noVNC_open");
+        document.getElementById('noVNC_clipboard_button')
+            .classList.remove("noVNC_selected");
+    },
+
+    toggleClipboardPanel() {
+        if (document.getElementById('noVNC_clipboard')
+            .classList.contains("noVNC_open")) {
+            UI.closeClipboardPanel();
+        } else {
+            UI.openClipboardPanel();
+        }
+    },
+
+    clipboardReceive(e) {
+        Log.Debug(">> UI.clipboardReceive: " + e.detail.text.substr(0, 40) + "...");
+        document.getElementById('noVNC_clipboard_text').value = e.detail.text;
+        Log.Debug("<< UI.clipboardReceive");
+    },
+
+    clipboardSend() {
+        const text = document.getElementById('noVNC_clipboard_text').value;
+        Log.Debug(">> UI.clipboardSend: " + text.substr(0, 40) + "...");
+        UI.rfb.clipboardPasteFrom(text);
+        Log.Debug("<< UI.clipboardSend");
+    },
+
+/* ------^-------
+ *  /CLIPBOARD
+ * ==============
+ *  CONNECTION
+ * ------v------*/
+
+    openConnectPanel() {
+        document.getElementById('noVNC_connect_dlg')
+            .classList.add("noVNC_open");
+    },
+
+    closeConnectPanel() {
+        document.getElementById('noVNC_connect_dlg')
+            .classList.remove("noVNC_open");
+    },
+
+    connect(event, password) {
+
+        // Ignore when rfb already exists
+        if (typeof UI.rfb !== 'undefined') {
+            return;
+        }
+
+        const host = UI.getSetting('host');
+        const port = UI.getSetting('port');
+        const path = UI.getSetting('path');
+
+        if (typeof password === 'undefined') {
+            password = WebUtil.getConfigVar('password');
+            UI.reconnectPassword = password;
+        }
+
+        if (password === null) {
+            password = undefined;
+        }
+
+        UI.hideStatus();
+
+        if (!host) {
+            Log.Error("Can't connect when host is: " + host);
+            UI.showStatus(_("Must set host"), 'error');
+            return;
+        }
+
+        UI.closeConnectPanel();
+
+        UI.updateVisualState('connecting');
+
+        let url;
+
+        url = UI.getSetting('encrypt') ? 'wss' : 'ws';
+
+        url += '://' + host;
+        if (port) {
+            url += ':' + port;
+        }
+        url += '/' + path;
+
+        UI.rfb = new RFB(document.getElementById('noVNC_container'), url,
+                         { shared: UI.getSetting('shared'),
+                           repeaterID: UI.getSetting('repeaterID'),
+                           credentials: { password: password } });
+        UI.rfb.addEventListener("connect", UI.connectFinished);
+        UI.rfb.addEventListener("disconnect", UI.disconnectFinished);
+        UI.rfb.addEventListener("serververification", UI.serverVerify);
+        UI.rfb.addEventListener("credentialsrequired", UI.credentials);
+        UI.rfb.addEventListener("securityfailure", UI.securityFailed);
+        UI.rfb.addEventListener("capabilities", UI.updatePowerButton);
+        UI.rfb.addEventListener("clipboard", UI.clipboardReceive);
+        UI.rfb.addEventListener("bell", UI.bell);
+        UI.rfb.addEventListener("desktopname", UI.updateDesktopName);
+        UI.rfb.clipViewport = UI.getSetting('view_clip');
+        UI.rfb.scaleViewport = UI.getSetting('resize') === 'scale';
+        UI.rfb.resizeSession = UI.getSetting('resize') === 'remote';
+        UI.rfb.qualityLevel = parseInt(UI.getSetting('quality'));
+        UI.rfb.compressionLevel = parseInt(UI.getSetting('compression'));
+        UI.rfb.showDotCursor = UI.getSetting('show_dot');
+
+        UI.updateViewOnly(); // requires UI.rfb
+    },
+
+    disconnect() {
+        UI.rfb.disconnect();
+
+        UI.connected = false;
+
+        // Disable automatic reconnecting
+        UI.inhibitReconnect = true;
+
+        UI.updateVisualState('disconnecting');
+
+        // Don't display the connection settings until we're actually disconnected
+    },
+
+    reconnect() {
+        UI.reconnectCallback = null;
+
+        // if reconnect has been disabled in the meantime, do nothing.
+        if (UI.inhibitReconnect) {
+            return;
+        }
+
+        UI.connect(null, UI.reconnectPassword);
+    },
+
+    cancelReconnect() {
+        if (UI.reconnectCallback !== null) {
+            clearTimeout(UI.reconnectCallback);
+            UI.reconnectCallback = null;
+        }
+
+        UI.updateVisualState('disconnected');
+
+        UI.openControlbar();
+        UI.openConnectPanel();
+    },
+
+    connectFinished(e) {
+        UI.connected = true;
+        UI.inhibitReconnect = false;
+
+        let msg;
+        if (UI.getSetting('encrypt')) {
+            msg = _("Connected (encrypted) to ") + UI.desktopName;
+        } else {
+            msg = _("Connected (unencrypted) to ") + UI.desktopName;
+        }
+        UI.showStatus(msg);
+        UI.updateVisualState('connected');
+
+        // Do this last because it can only be used on rendered elements
+        UI.rfb.focus();
+    },
+
+    disconnectFinished(e) {
+        const wasConnected = UI.connected;
+
+        // This variable is ideally set when disconnection starts, but
+        // when the disconnection isn't clean or if it is initiated by
+        // the server, we need to do it here as well since
+        // UI.disconnect() won't be used in those cases.
+        UI.connected = false;
+
+        UI.rfb = undefined;
+
+        if (!e.detail.clean) {
+            UI.updateVisualState('disconnected');
+            if (wasConnected) {
+                UI.showStatus(_("Something went wrong, connection is closed"),
+                              'error');
+            } else {
+                UI.showStatus(_("Failed to connect to server"), 'error');
+            }
+        }
+        // If reconnecting is allowed process it now
+        if (UI.getSetting('reconnect', false) === true && !UI.inhibitReconnect) {
+            UI.updateVisualState('reconnecting');
+
+            const delay = parseInt(UI.getSetting('reconnect_delay'));
+            UI.reconnectCallback = setTimeout(UI.reconnect, delay);
+            return;
+        } else {
+            UI.updateVisualState('disconnected');
+            UI.showStatus(_("Disconnected"), 'normal');
+        }
+
+        document.title = PAGE_TITLE;
+
+        UI.openControlbar();
+        UI.openConnectPanel();
+    },
+
+    securityFailed(e) {
+        let msg = "";
+        // On security failures we might get a string with a reason
+        // directly from the server. Note that we can't control if
+        // this string is translated or not.
+        if ('reason' in e.detail) {
+            msg = _("New connection has been rejected with reason: ") +
+                e.detail.reason;
+        } else {
+            msg = _("New connection has been rejected");
+        }
+        UI.showStatus(msg, 'error');
+    },
+
+/* ------^-------
+ *  /CONNECTION
+ * ==============
+ * SERVER VERIFY
+ * ------v------*/
+
+    async serverVerify(e) {
+        const type = e.detail.type;
+        if (type === 'RSA') {
+            const publickey = e.detail.publickey;
+            let fingerprint = await window.crypto.subtle.digest("SHA-1", publickey);
+            // The same fingerprint format as RealVNC
+            fingerprint = Array.from(new Uint8Array(fingerprint).slice(0, 8)).map(
+                x => x.toString(16).padStart(2, '0')).join('-');
+            document.getElementById('noVNC_verify_server_dlg').classList.add('noVNC_open');
+            document.getElementById('noVNC_fingerprint').innerHTML = fingerprint;
+        }
+    },
+
+    approveServer(e) {
+        e.preventDefault();
+        document.getElementById('noVNC_verify_server_dlg').classList.remove('noVNC_open');
+        UI.rfb.approveServer();
+    },
+
+    rejectServer(e) {
+        e.preventDefault();
+        document.getElementById('noVNC_verify_server_dlg').classList.remove('noVNC_open');
+        UI.disconnect();
+    },
+
+/* ------^-------
+ * /SERVER VERIFY
+ * ==============
+ *   PASSWORD
+ * ------v------*/
+
+    credentials(e) {
+        // FIXME: handle more types
+
+        document.getElementById("noVNC_username_block").classList.remove("noVNC_hidden");
+        document.getElementById("noVNC_password_block").classList.remove("noVNC_hidden");
+
+        let inputFocus = "none";
+        if (e.detail.types.indexOf("username") === -1) {
+            document.getElementById("noVNC_username_block").classList.add("noVNC_hidden");
+        } else {
+            inputFocus = inputFocus === "none" ? "noVNC_username_input" : inputFocus;
+        }
+        if (e.detail.types.indexOf("password") === -1) {
+            document.getElementById("noVNC_password_block").classList.add("noVNC_hidden");
+        } else {
+            inputFocus = inputFocus === "none" ? "noVNC_password_input" : inputFocus;
+        }
+        document.getElementById('noVNC_credentials_dlg')
+            .classList.add('noVNC_open');
+
+        setTimeout(() => document
+            .getElementById(inputFocus).focus(), 100);
+
+        Log.Warn("Server asked for credentials");
+        UI.showStatus(_("Credentials are required"), "warning");
+    },
+
+    setCredentials(e) {
+        // Prevent actually submitting the form
+        e.preventDefault();
+
+        let inputElemUsername = document.getElementById('noVNC_username_input');
+        const username = inputElemUsername.value;
+
+        let inputElemPassword = document.getElementById('noVNC_password_input');
+        const password = inputElemPassword.value;
+        // Clear the input after reading the password
+        inputElemPassword.value = "";
+
+        UI.rfb.sendCredentials({ username: username, password: password });
+        UI.reconnectPassword = password;
+        document.getElementById('noVNC_credentials_dlg')
+            .classList.remove('noVNC_open');
+    },
+
+/* ------^-------
+ *  /PASSWORD
+ * ==============
+ *   FULLSCREEN
+ * ------v------*/
+
+    toggleFullscreen() {
+        if (document.fullscreenElement || // alternative standard method
+            document.mozFullScreenElement || // currently working methods
+            document.webkitFullscreenElement ||
+            document.msFullscreenElement) {
+            if (document.exitFullscreen) {
+                document.exitFullscreen();
+            } else if (document.mozCancelFullScreen) {
+                document.mozCancelFullScreen();
+            } else if (document.webkitExitFullscreen) {
+                document.webkitExitFullscreen();
+            } else if (document.msExitFullscreen) {
+                document.msExitFullscreen();
+            }
+        } else {
+            if (document.documentElement.requestFullscreen) {
+                document.documentElement.requestFullscreen();
+            } else if (document.documentElement.mozRequestFullScreen) {
+                document.documentElement.mozRequestFullScreen();
+            } else if (document.documentElement.webkitRequestFullscreen) {
+                document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
+            } else if (document.body.msRequestFullscreen) {
+                document.body.msRequestFullscreen();
+            }
+        }
+        UI.updateFullscreenButton();
+    },
+
+    updateFullscreenButton() {
+        if (document.fullscreenElement || // alternative standard method
+            document.mozFullScreenElement || // currently working methods
+            document.webkitFullscreenElement ||
+            document.msFullscreenElement ) {
+            document.getElementById('noVNC_fullscreen_button')
+                .classList.add("noVNC_selected");
+        } else {
+            document.getElementById('noVNC_fullscreen_button')
+                .classList.remove("noVNC_selected");
+        }
+    },
+
+/* ------^-------
+ *  /FULLSCREEN
+ * ==============
+ *     RESIZE
+ * ------v------*/
+
+    // Apply remote resizing or local scaling
+    applyResizeMode() {
+        if (!UI.rfb) return;
+
+        UI.rfb.scaleViewport = UI.getSetting('resize') === 'scale';
+        UI.rfb.resizeSession = UI.getSetting('resize') === 'remote';
+    },
+
+/* ------^-------
+ *    /RESIZE
+ * ==============
+ * VIEW CLIPPING
+ * ------v------*/
+
+    // Update viewport clipping property for the connection. The normal
+    // case is to get the value from the setting. There are special cases
+    // for when the viewport is scaled or when a touch device is used.
+    updateViewClip() {
+        if (!UI.rfb) return;
+
+        const scaling = UI.getSetting('resize') === 'scale';
+
+        if (scaling) {
+            // Can't be clipping if viewport is scaled to fit
+            UI.forceSetting('view_clip', false);
+            UI.rfb.clipViewport  = false;
+        } else if (!hasScrollbarGutter) {
+            // Some platforms have scrollbars that are difficult
+            // to use in our case, so we always use our own panning
+            UI.forceSetting('view_clip', true);
+            UI.rfb.clipViewport = true;
+        } else {
+            UI.enableSetting('view_clip');
+            UI.rfb.clipViewport = UI.getSetting('view_clip');
+        }
+
+        // Changing the viewport may change the state of
+        // the dragging button
+        UI.updateViewDrag();
+    },
+
+/* ------^-------
+ * /VIEW CLIPPING
+ * ==============
+ *    VIEWDRAG
+ * ------v------*/
+
+    toggleViewDrag() {
+        if (!UI.rfb) return;
+
+        UI.rfb.dragViewport = !UI.rfb.dragViewport;
+        UI.updateViewDrag();
+    },
+
+    updateViewDrag() {
+        if (!UI.connected) return;
+
+        const viewDragButton = document.getElementById('noVNC_view_drag_button');
+
+        if (!UI.rfb.clipViewport && UI.rfb.dragViewport) {
+            // We are no longer clipping the viewport. Make sure
+            // viewport drag isn't active when it can't be used.
+            UI.rfb.dragViewport = false;
+        }
+
+        if (UI.rfb.dragViewport) {
+            viewDragButton.classList.add("noVNC_selected");
+        } else {
+            viewDragButton.classList.remove("noVNC_selected");
+        }
+
+        if (UI.rfb.clipViewport) {
+            viewDragButton.classList.remove("noVNC_hidden");
+        } else {
+            viewDragButton.classList.add("noVNC_hidden");
+        }
+    },
+
+/* ------^-------
+ *   /VIEWDRAG
+ * ==============
+ *    QUALITY
+ * ------v------*/
+
+    updateQuality() {
+        if (!UI.rfb) return;
+
+        UI.rfb.qualityLevel = parseInt(UI.getSetting('quality'));
+    },
+
+/* ------^-------
+ *   /QUALITY
+ * ==============
+ *  COMPRESSION
+ * ------v------*/
+
+    updateCompression() {
+        if (!UI.rfb) return;
+
+        UI.rfb.compressionLevel = parseInt(UI.getSetting('compression'));
+    },
+
+/* ------^-------
+ *  /COMPRESSION
+ * ==============
+ *    KEYBOARD
+ * ------v------*/
+
+    showVirtualKeyboard() {
+        if (!isTouchDevice) return;
+
+        const input = document.getElementById('noVNC_keyboardinput');
+
+        if (document.activeElement == input) return;
+
+        input.focus();
+
+        try {
+            const l = input.value.length;
+            // Move the caret to the end
+            input.setSelectionRange(l, l);
+        } catch (err) {
+            // setSelectionRange is undefined in Google Chrome
+        }
+    },
+
+    hideVirtualKeyboard() {
+        if (!isTouchDevice) return;
+
+        const input = document.getElementById('noVNC_keyboardinput');
+
+        if (document.activeElement != input) return;
+
+        input.blur();
+    },
+
+    toggleVirtualKeyboard() {
+        if (document.getElementById('noVNC_keyboard_button')
+            .classList.contains("noVNC_selected")) {
+            UI.hideVirtualKeyboard();
+        } else {
+            UI.showVirtualKeyboard();
+        }
+    },
+
+    onfocusVirtualKeyboard(event) {
+        document.getElementById('noVNC_keyboard_button')
+            .classList.add("noVNC_selected");
+        if (UI.rfb) {
+            UI.rfb.focusOnClick = false;
+        }
+    },
+
+    onblurVirtualKeyboard(event) {
+        document.getElementById('noVNC_keyboard_button')
+            .classList.remove("noVNC_selected");
+        if (UI.rfb) {
+            UI.rfb.focusOnClick = true;
+        }
+    },
+
+    keepVirtualKeyboard(event) {
+        const input = document.getElementById('noVNC_keyboardinput');
+
+        // Only prevent focus change if the virtual keyboard is active
+        if (document.activeElement != input) {
+            return;
+        }
+
+        // Only allow focus to move to other elements that need
+        // focus to function properly
+        if (event.target.form !== undefined) {
+            switch (event.target.type) {
+                case 'text':
+                case 'email':
+                case 'search':
+                case 'password':
+                case 'tel':
+                case 'url':
+                case 'textarea':
+                case 'select-one':
+                case 'select-multiple':
+                    return;
+            }
+        }
+
+        event.preventDefault();
+    },
+
+    keyboardinputReset() {
+        const kbi = document.getElementById('noVNC_keyboardinput');
+        kbi.value = new Array(UI.defaultKeyboardinputLen).join("_");
+        UI.lastKeyboardinput = kbi.value;
+    },
+
+    keyEvent(keysym, code, down) {
+        if (!UI.rfb) return;
+
+        UI.rfb.sendKey(keysym, code, down);
+    },
+
+    // When normal keyboard events are left uncought, use the input events from
+    // the keyboardinput element instead and generate the corresponding key events.
+    // This code is required since some browsers on Android are inconsistent in
+    // sending keyCodes in the normal keyboard events when using on screen keyboards.
+    keyInput(event) {
+
+        if (!UI.rfb) return;
+
+        const newValue = event.target.value;
+
+        if (!UI.lastKeyboardinput) {
+            UI.keyboardinputReset();
+        }
+        const oldValue = UI.lastKeyboardinput;
+
+        let newLen;
+        try {
+            // Try to check caret position since whitespace at the end
+            // will not be considered by value.length in some browsers
+            newLen = Math.max(event.target.selectionStart, newValue.length);
+        } catch (err) {
+            // selectionStart is undefined in Google Chrome
+            newLen = newValue.length;
+        }
+        const oldLen = oldValue.length;
+
+        let inputs = newLen - oldLen;
+        let backspaces = inputs < 0 ? -inputs : 0;
+
+        // Compare the old string with the new to account for
+        // text-corrections or other input that modify existing text
+        for (let i = 0; i < Math.min(oldLen, newLen); i++) {
+            if (newValue.charAt(i) != oldValue.charAt(i)) {
+                inputs = newLen - i;
+                backspaces = oldLen - i;
+                break;
+            }
+        }
+
+        // Send the key events
+        for (let i = 0; i < backspaces; i++) {
+            UI.rfb.sendKey(KeyTable.XK_BackSpace, "Backspace");
+        }
+        for (let i = newLen - inputs; i < newLen; i++) {
+            UI.rfb.sendKey(keysyms.lookup(newValue.charCodeAt(i)));
+        }
+
+        // Control the text content length in the keyboardinput element
+        if (newLen > 2 * UI.defaultKeyboardinputLen) {
+            UI.keyboardinputReset();
+        } else if (newLen < 1) {
+            // There always have to be some text in the keyboardinput
+            // element with which backspace can interact.
+            UI.keyboardinputReset();
+            // This sometimes causes the keyboard to disappear for a second
+            // but it is required for the android keyboard to recognize that
+            // text has been added to the field
+            event.target.blur();
+            // This has to be ran outside of the input handler in order to work
+            setTimeout(event.target.focus.bind(event.target), 0);
+        } else {
+            UI.lastKeyboardinput = newValue;
+        }
+    },
+
+/* ------^-------
+ *   /KEYBOARD
+ * ==============
+ *   EXTRA KEYS
+ * ------v------*/
+
+    openExtraKeys() {
+        UI.closeAllPanels();
+        UI.openControlbar();
+
+        document.getElementById('noVNC_modifiers')
+            .classList.add("noVNC_open");
+        document.getElementById('noVNC_toggle_extra_keys_button')
+            .classList.add("noVNC_selected");
+    },
+
+    closeExtraKeys() {
+        document.getElementById('noVNC_modifiers')
+            .classList.remove("noVNC_open");
+        document.getElementById('noVNC_toggle_extra_keys_button')
+            .classList.remove("noVNC_selected");
+    },
+
+    toggleExtraKeys() {
+        if (document.getElementById('noVNC_modifiers')
+            .classList.contains("noVNC_open")) {
+            UI.closeExtraKeys();
+        } else  {
+            UI.openExtraKeys();
+        }
+    },
+
+    sendEsc() {
+        UI.sendKey(KeyTable.XK_Escape, "Escape");
+    },
+
+    sendTab() {
+        UI.sendKey(KeyTable.XK_Tab, "Tab");
+    },
+
+    toggleCtrl() {
+        const btn = document.getElementById('noVNC_toggle_ctrl_button');
+        if (btn.classList.contains("noVNC_selected")) {
+            UI.sendKey(KeyTable.XK_Control_L, "ControlLeft", false);
+            btn.classList.remove("noVNC_selected");
+        } else {
+            UI.sendKey(KeyTable.XK_Control_L, "ControlLeft", true);
+            btn.classList.add("noVNC_selected");
+        }
+    },
+
+    toggleWindows() {
+        const btn = document.getElementById('noVNC_toggle_windows_button');
+        if (btn.classList.contains("noVNC_selected")) {
+            UI.sendKey(KeyTable.XK_Super_L, "MetaLeft", false);
+            btn.classList.remove("noVNC_selected");
+        } else {
+            UI.sendKey(KeyTable.XK_Super_L, "MetaLeft", true);
+            btn.classList.add("noVNC_selected");
+        }
+    },
+
+    toggleAlt() {
+        const btn = document.getElementById('noVNC_toggle_alt_button');
+        if (btn.classList.contains("noVNC_selected")) {
+            UI.sendKey(KeyTable.XK_Alt_L, "AltLeft", false);
+            btn.classList.remove("noVNC_selected");
+        } else {
+            UI.sendKey(KeyTable.XK_Alt_L, "AltLeft", true);
+            btn.classList.add("noVNC_selected");
+        }
+    },
+
+    sendCtrlAltDel() {
+        UI.rfb.sendCtrlAltDel();
+        // See below
+        UI.rfb.focus();
+        UI.idleControlbar();
+    },
+
+    sendKey(keysym, code, down) {
+        UI.rfb.sendKey(keysym, code, down);
+
+        // Move focus to the screen in order to be able to use the
+        // keyboard right after these extra keys.
+        // The exception is when a virtual keyboard is used, because
+        // if we focus the screen the virtual keyboard would be closed.
+        // In this case we focus our special virtual keyboard input
+        // element instead.
+        if (document.getElementById('noVNC_keyboard_button')
+            .classList.contains("noVNC_selected")) {
+            document.getElementById('noVNC_keyboardinput').focus();
+        } else {
+            UI.rfb.focus();
+        }
+        // fade out the controlbar to highlight that
+        // the focus has been moved to the screen
+        UI.idleControlbar();
+    },
+
+/* ------^-------
+ *   /EXTRA KEYS
+ * ==============
+ *     MISC
+ * ------v------*/
+
+    updateViewOnly() {
+        if (!UI.rfb) return;
+        UI.rfb.viewOnly = UI.getSetting('view_only');
+
+        // Hide input related buttons in view only mode
+        if (UI.rfb.viewOnly) {
+            document.getElementById('noVNC_keyboard_button')
+                .classList.add('noVNC_hidden');
+            document.getElementById('noVNC_toggle_extra_keys_button')
+                .classList.add('noVNC_hidden');
+            document.getElementById('noVNC_clipboard_button')
+                .classList.add('noVNC_hidden');
+        } else {
+            document.getElementById('noVNC_keyboard_button')
+                .classList.remove('noVNC_hidden');
+            document.getElementById('noVNC_toggle_extra_keys_button')
+                .classList.remove('noVNC_hidden');
+            document.getElementById('noVNC_clipboard_button')
+                .classList.remove('noVNC_hidden');
+        }
+    },
+
+    updateShowDotCursor() {
+        if (!UI.rfb) return;
+        UI.rfb.showDotCursor = UI.getSetting('show_dot');
+    },
+
+    updateLogging() {
+        WebUtil.initLogging(UI.getSetting('logging'));
+    },
+
+    updateDesktopName(e) {
+        UI.desktopName = e.detail.name;
+        // Display the desktop name in the document title
+        // NGAM: document.title = e.detail.name + " - " + PAGE_TITLE;
+    },
+
+    bell(e) {
+        if (WebUtil.getConfigVar('bell', 'on') === 'on') {
+            const promise = document.getElementById('noVNC_bell').play();
+            // The standards disagree on the return value here
+            if (promise) {
+                promise.catch((e) => {
+                    if (e.name === "NotAllowedError") {
+                        // Ignore when the browser doesn't let us play audio.
+                        // It is common that the browsers require audio to be
+                        // initiated from a user action.
+                    } else {
+                        Log.Error("Unable to play bell: " + e);
+                    }
+                });
+            }
+        }
+    },
+
+    //Helper to add options to dropdown.
+    addOption(selectbox, text, value) {
+        const optn = document.createElement("OPTION");
+        optn.text = text;
+        optn.value = value;
+        selectbox.options.add(optn);
+    },
+
+/* ------^-------
+ *    /MISC
+ * ==============
+ */
+};
+
+// Set up translations
+const LINGUAS = ["cs", "de", "el", "es", "fr", "it", "ja", "ko", "nl", "pl", "pt_BR", "pt", "pt_PT", "ru", "sv", "tr", "zh_CN", "zh_TW"];
+l10n.setup(LINGUAS);
+if (l10n.language === "en" || l10n.dictionary !== undefined) {
+    UI.prime();
+} else {
+    fetch('app/locale/' + l10n.language + '.json')
+        .then((response) => {
+            if (!response.ok) {
+                throw Error("" + response.status + " " + response.statusText);
+            }
+            return response.json();
+        })
+        .then((translations) => { l10n.dictionary = translations; })
+        .catch(err => Log.Error("Failed to load translations: " + err))
+        .then(UI.prime);
+}
+
+export default UI;
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/app/webutil.js
@@ -0,0 +1,186 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+import { initLogging as mainInitLogging } from '../core/util/logging.js';
+
+// init log level reading the logging HTTP param
+export function initLogging(level) {
+    "use strict";
+    if (typeof level !== "undefined") {
+        mainInitLogging(level);
+    } else {
+        const param = document.location.href.match(/logging=([A-Za-z0-9._-]*)/);
+        mainInitLogging(param || undefined);
+    }
+}
+
+// Read a query string variable
+// A URL with a query parameter can look like this (But will most probably get logged on the http server):
+// https://www.example.com?myqueryparam=myvalue
+//
+// For privacy (Using a hastag #, the parameters will not be sent to the server)
+// the url can be requested in the following way:
+// https://www.example.com#myqueryparam=myvalue&password=secreatvalue
+//
+// Even Mixing public and non public parameters will work:
+// https://www.example.com?nonsecretparam=example.com#password=secreatvalue
+export function getQueryVar(name, defVal) {
+    "use strict";
+    const re = new RegExp('.*[?&]' + name + '=([^&#]*)'),
+        match = ''.concat(document.location.href, window.location.hash).match(re);
+    if (typeof defVal === 'undefined') { defVal = null; }
+
+    if (match) {
+        return decodeURIComponent(match[1]);
+    }
+
+    return defVal;
+}
+
+// Read a hash fragment variable
+export function getHashVar(name, defVal) {
+    "use strict";
+    const re = new RegExp('.*[&#]' + name + '=([^&]*)'),
+        match = document.location.hash.match(re);
+    if (typeof defVal === 'undefined') { defVal = null; }
+
+    if (match) {
+        return decodeURIComponent(match[1]);
+    }
+
+    return defVal;
+}
+
+// Read a variable from the fragment or the query string
+// Fragment takes precedence
+export function getConfigVar(name, defVal) {
+    "use strict";
+    const val = getHashVar(name);
+
+    if (val === null) {
+        return getQueryVar(name, defVal);
+    }
+
+    return val;
+}
+
+/*
+ * Cookie handling. Dervied from: http://www.quirksmode.org/js/cookies.html
+ */
+
+// No days means only for this browser session
+export function createCookie(name, value, days) {
+    "use strict";
+    let date, expires;
+    if (days) {
+        date = new Date();
+        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
+        expires = "; expires=" + date.toGMTString();
+    } else {
+        expires = "";
+    }
+
+    let secure;
+    if (document.location.protocol === "https:") {
+        secure = "; secure";
+    } else {
+        secure = "";
+    }
+    document.cookie = name + "=" + value + expires + "; path=/" + secure;
+}
+
+export function readCookie(name, defaultValue) {
+    "use strict";
+    const nameEQ = name + "=";
+    const ca = document.cookie.split(';');
+
+    for (let i = 0; i < ca.length; i += 1) {
+        let c = ca[i];
+        while (c.charAt(0) === ' ') {
+            c = c.substring(1, c.length);
+        }
+        if (c.indexOf(nameEQ) === 0) {
+            return c.substring(nameEQ.length, c.length);
+        }
+    }
+
+    return (typeof defaultValue !== 'undefined') ? defaultValue : null;
+}
+
+export function eraseCookie(name) {
+    "use strict";
+    createCookie(name, "", -1);
+}
+
+/*
+ * Setting handling.
+ */
+
+let settings = {};
+
+export function initSettings() {
+    if (!window.chrome || !window.chrome.storage) {
+        settings = {};
+        return Promise.resolve();
+    }
+
+    return new Promise(resolve => window.chrome.storage.sync.get(resolve))
+        .then((cfg) => { settings = cfg; });
+}
+
+// Update the settings cache, but do not write to permanent storage
+export function setSetting(name, value) {
+    settings[name] = value;
+}
+
+// No days means only for this browser session
+export function writeSetting(name, value) {
+    "use strict";
+    if (settings[name] === value) return;
+    settings[name] = value;
+    if (window.chrome && window.chrome.storage) {
+        window.chrome.storage.sync.set(settings);
+    } else {
+        localStorage.setItem(name, value);
+    }
+}
+
+export function readSetting(name, defaultValue) {
+    "use strict";
+    let value;
+    if ((name in settings) || (window.chrome && window.chrome.storage)) {
+        value = settings[name];
+    } else {
+        value = localStorage.getItem(name);
+        settings[name] = value;
+    }
+    if (typeof value === "undefined") {
+        value = null;
+    }
+
+    if (value === null && typeof defaultValue !== "undefined") {
+        return defaultValue;
+    }
+
+    return value;
+}
+
+export function eraseSetting(name) {
+    "use strict";
+    // Deleting here means that next time the setting is read when using local
+    // storage, it will be pulled from local storage again.
+    // If the setting in local storage is changed (e.g. in another tab)
+    // between this delete and the next read, it could lead to an unexpected
+    // value change.
+    delete settings[name];
+    if (window.chrome && window.chrome.storage) {
+        window.chrome.storage.sync.remove(name);
+    } else {
+        localStorage.removeItem(name);
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/base64.js
@@ -0,0 +1,104 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// From: http://hg.mozilla.org/mozilla-central/raw-file/ec10630b1a54/js/src/devtools/jint/sunspider/string-base64.js
+
+import * as Log from './util/logging.js';
+
+export default {
+    /* Convert data (an array of integers) to a Base64 string. */
+    toBase64Table: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split(''),
+    base64Pad: '=',
+
+    encode(data) {
+        "use strict";
+        let result = '';
+        const length = data.length;
+        const lengthpad = (length % 3);
+        // Convert every three bytes to 4 ascii characters.
+
+        for (let i = 0; i < (length - 2); i += 3) {
+            result += this.toBase64Table[data[i] >> 2];
+            result += this.toBase64Table[((data[i] & 0x03) << 4) + (data[i + 1] >> 4)];
+            result += this.toBase64Table[((data[i + 1] & 0x0f) << 2) + (data[i + 2] >> 6)];
+            result += this.toBase64Table[data[i + 2] & 0x3f];
+        }
+
+        // Convert the remaining 1 or 2 bytes, pad out to 4 characters.
+        const j = length - lengthpad;
+        if (lengthpad === 2) {
+            result += this.toBase64Table[data[j] >> 2];
+            result += this.toBase64Table[((data[j] & 0x03) << 4) + (data[j + 1] >> 4)];
+            result += this.toBase64Table[(data[j + 1] & 0x0f) << 2];
+            result += this.toBase64Table[64];
+        } else if (lengthpad === 1) {
+            result += this.toBase64Table[data[j] >> 2];
+            result += this.toBase64Table[(data[j] & 0x03) << 4];
+            result += this.toBase64Table[64];
+            result += this.toBase64Table[64];
+        }
+
+        return result;
+    },
+
+    /* Convert Base64 data to a string */
+    /* eslint-disable comma-spacing */
+    toBinaryTable: [
+        -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
+        -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
+        -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,62, -1,-1,-1,63,
+        52,53,54,55, 56,57,58,59, 60,61,-1,-1, -1, 0,-1,-1,
+        -1, 0, 1, 2,  3, 4, 5, 6,  7, 8, 9,10, 11,12,13,14,
+        15,16,17,18, 19,20,21,22, 23,24,25,-1, -1,-1,-1,-1,
+        -1,26,27,28, 29,30,31,32, 33,34,35,36, 37,38,39,40,
+        41,42,43,44, 45,46,47,48, 49,50,51,-1, -1,-1,-1,-1
+    ],
+    /* eslint-enable comma-spacing */
+
+    decode(data, offset = 0) {
+        let dataLength = data.indexOf('=') - offset;
+        if (dataLength < 0) { dataLength = data.length - offset; }
+
+        /* Every four characters is 3 resulting numbers */
+        const resultLength = (dataLength >> 2) * 3 + Math.floor((dataLength % 4) / 1.5);
+        const result = new Array(resultLength);
+
+        // Convert one by one.
+
+        let leftbits = 0; // number of bits decoded, but yet to be appended
+        let leftdata = 0; // bits decoded, but yet to be appended
+        for (let idx = 0, i = offset; i < data.length; i++) {
+            const c = this.toBinaryTable[data.charCodeAt(i) & 0x7f];
+            const padding = (data.charAt(i) === this.base64Pad);
+            // Skip illegal characters and whitespace
+            if (c === -1) {
+                Log.Error("Illegal character code " + data.charCodeAt(i) + " at position " + i);
+                continue;
+            }
+
+            // Collect data into leftdata, update bitcount
+            leftdata = (leftdata << 6) | c;
+            leftbits += 6;
+
+            // If we have 8 or more bits, append 8 bits to the result
+            if (leftbits >= 8) {
+                leftbits -= 8;
+                // Append if not padding.
+                if (!padding) {
+                    result[idx++] = (leftdata >> leftbits) & 0xff;
+                }
+                leftdata &= (1 << leftbits) - 1;
+            }
+        }
+
+        // If there are any bits left, the base64 string was corrupted
+        if (leftbits) {
+            const err = new Error('Corrupted base64 string');
+            err.name = 'Base64-Error';
+            throw err;
+        }
+
+        return result;
+    }
+}; /* End of Base64 namespace */
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/decoders/copyrect.js
@@ -0,0 +1,27 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ *
+ */
+
+export default class CopyRectDecoder {
+    decodeRect(x, y, width, height, sock, display, depth) {
+        if (sock.rQwait("COPYRECT", 4)) {
+            return false;
+        }
+
+        let deltaX = sock.rQshift16();
+        let deltaY = sock.rQshift16();
+
+        if ((width === 0) || (height === 0)) {
+            return true;
+        }
+
+        display.copyImage(deltaX, deltaY, x, y, width, height);
+
+        return true;
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/decoders/hextile.js
@@ -0,0 +1,191 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ *
+ */
+
+import * as Log from '../util/logging.js';
+
+export default class HextileDecoder {
+    constructor() {
+        this._tiles = 0;
+        this._lastsubencoding = 0;
+        this._tileBuffer = new Uint8Array(16 * 16 * 4);
+    }
+
+    decodeRect(x, y, width, height, sock, display, depth) {
+        if (this._tiles === 0) {
+            this._tilesX = Math.ceil(width / 16);
+            this._tilesY = Math.ceil(height / 16);
+            this._totalTiles = this._tilesX * this._tilesY;
+            this._tiles = this._totalTiles;
+        }
+
+        while (this._tiles > 0) {
+            let bytes = 1;
+
+            if (sock.rQwait("HEXTILE", bytes)) {
+                return false;
+            }
+
+            let rQ = sock.rQ;
+            let rQi = sock.rQi;
+
+            let subencoding = rQ[rQi];  // Peek
+            if (subencoding > 30) {  // Raw
+                throw new Error("Illegal hextile subencoding (subencoding: " +
+                            subencoding + ")");
+            }
+
+            const currTile = this._totalTiles - this._tiles;
+            const tileX = currTile % this._tilesX;
+            const tileY = Math.floor(currTile / this._tilesX);
+            const tx = x + tileX * 16;
+            const ty = y + tileY * 16;
+            const tw = Math.min(16, (x + width) - tx);
+            const th = Math.min(16, (y + height) - ty);
+
+            // Figure out how much we are expecting
+            if (subencoding & 0x01) {  // Raw
+                bytes += tw * th * 4;
+            } else {
+                if (subencoding & 0x02) {  // Background
+                    bytes += 4;
+                }
+                if (subencoding & 0x04) {  // Foreground
+                    bytes += 4;
+                }
+                if (subencoding & 0x08) {  // AnySubrects
+                    bytes++;  // Since we aren't shifting it off
+
+                    if (sock.rQwait("HEXTILE", bytes)) {
+                        return false;
+                    }
+
+                    let subrects = rQ[rQi + bytes - 1];  // Peek
+                    if (subencoding & 0x10) {  // SubrectsColoured
+                        bytes += subrects * (4 + 2);
+                    } else {
+                        bytes += subrects * 2;
+                    }
+                }
+            }
+
+            if (sock.rQwait("HEXTILE", bytes)) {
+                return false;
+            }
+
+            // We know the encoding and have a whole tile
+            rQi++;
+            if (subencoding === 0) {
+                if (this._lastsubencoding & 0x01) {
+                    // Weird: ignore blanks are RAW
+                    Log.Debug("     Ignoring blank after RAW");
+                } else {
+                    display.fillRect(tx, ty, tw, th, this._background);
+                }
+            } else if (subencoding & 0x01) {  // Raw
+                let pixels = tw * th;
+                // Max sure the image is fully opaque
+                for (let i = 0;i <  pixels;i++) {
+                    rQ[rQi + i * 4 + 3] = 255;
+                }
+                display.blitImage(tx, ty, tw, th, rQ, rQi);
+                rQi += bytes - 1;
+            } else {
+                if (subencoding & 0x02) {  // Background
+                    this._background = [rQ[rQi], rQ[rQi + 1], rQ[rQi + 2], rQ[rQi + 3]];
+                    rQi += 4;
+                }
+                if (subencoding & 0x04) {  // Foreground
+                    this._foreground = [rQ[rQi], rQ[rQi + 1], rQ[rQi + 2], rQ[rQi + 3]];
+                    rQi += 4;
+                }
+
+                this._startTile(tx, ty, tw, th, this._background);
+                if (subencoding & 0x08) {  // AnySubrects
+                    let subrects = rQ[rQi];
+                    rQi++;
+
+                    for (let s = 0; s < subrects; s++) {
+                        let color;
+                        if (subencoding & 0x10) {  // SubrectsColoured
+                            color = [rQ[rQi], rQ[rQi + 1], rQ[rQi + 2], rQ[rQi + 3]];
+                            rQi += 4;
+                        } else {
+                            color = this._foreground;
+                        }
+                        const xy = rQ[rQi];
+                        rQi++;
+                        const sx = (xy >> 4);
+                        const sy = (xy & 0x0f);
+
+                        const wh = rQ[rQi];
+                        rQi++;
+                        const sw = (wh >> 4) + 1;
+                        const sh = (wh & 0x0f) + 1;
+
+                        this._subTile(sx, sy, sw, sh, color);
+                    }
+                }
+                this._finishTile(display);
+            }
+            sock.rQi = rQi;
+            this._lastsubencoding = subencoding;
+            this._tiles--;
+        }
+
+        return true;
+    }
+
+    // start updating a tile
+    _startTile(x, y, width, height, color) {
+        this._tileX = x;
+        this._tileY = y;
+        this._tileW = width;
+        this._tileH = height;
+
+        const red = color[0];
+        const green = color[1];
+        const blue = color[2];
+
+        const data = this._tileBuffer;
+        for (let i = 0; i < width * height * 4; i += 4) {
+            data[i]     = red;
+            data[i + 1] = green;
+            data[i + 2] = blue;
+            data[i + 3] = 255;
+        }
+    }
+
+    // update sub-rectangle of the current tile
+    _subTile(x, y, w, h, color) {
+        const red = color[0];
+        const green = color[1];
+        const blue = color[2];
+        const xend = x + w;
+        const yend = y + h;
+
+        const data = this._tileBuffer;
+        const width = this._tileW;
+        for (let j = y; j < yend; j++) {
+            for (let i = x; i < xend; i++) {
+                const p = (i + (j * width)) * 4;
+                data[p]     = red;
+                data[p + 1] = green;
+                data[p + 2] = blue;
+                data[p + 3] = 255;
+            }
+        }
+    }
+
+    // draw the current tile to the screen
+    _finishTile(display) {
+        display.blitImage(this._tileX, this._tileY,
+                          this._tileW, this._tileH,
+                          this._tileBuffer, 0);
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/decoders/jpeg.js
@@ -0,0 +1,141 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ *
+ */
+
+export default class JPEGDecoder {
+    constructor() {
+        // RealVNC will reuse the quantization tables
+        // and Huffman tables, so we need to cache them.
+        this._quantTables = [];
+        this._huffmanTables = [];
+        this._cachedQuantTables = [];
+        this._cachedHuffmanTables = [];
+
+        this._jpegLength = 0;
+        this._segments = [];
+    }
+
+    decodeRect(x, y, width, height, sock, display, depth) {
+        // A rect of JPEG encodings is simply a JPEG file
+        if (!this._parseJPEG(sock.rQslice(0))) {
+            return false;
+        }
+        const data = sock.rQshiftBytes(this._jpegLength);
+        if (this._quantTables.length != 0 && this._huffmanTables.length != 0) {
+            // If there are quantization tables and Huffman tables in the JPEG
+            // image, we can directly render it.
+            display.imageRect(x, y, width, height, "image/jpeg", data);
+            return true;
+        } else {
+            // Otherwise we need to insert cached tables.
+            const sofIndex = this._segments.findIndex(
+                x => x[1] == 0xC0 || x[1] == 0xC2
+            );
+            if (sofIndex == -1) {
+                throw new Error("Illegal JPEG image without SOF");
+            }
+            let segments = this._segments.slice(0, sofIndex);
+            segments = segments.concat(this._quantTables.length ?
+                this._quantTables :
+                this._cachedQuantTables);
+            segments.push(this._segments[sofIndex]);
+            segments = segments.concat(this._huffmanTables.length ?
+                this._huffmanTables :
+                this._cachedHuffmanTables,
+                                       this._segments.slice(sofIndex + 1));
+            let length = 0;
+            for (let i = 0; i < segments.length; i++) {
+                length += segments[i].length;
+            }
+            const data = new Uint8Array(length);
+            length = 0;
+            for (let i = 0; i < segments.length; i++) {
+                data.set(segments[i], length);
+                length += segments[i].length;
+            }
+            display.imageRect(x, y, width, height, "image/jpeg", data);
+            return true;
+        }
+    }
+
+    _parseJPEG(buffer) {
+        if (this._quantTables.length != 0) {
+            this._cachedQuantTables = this._quantTables;
+        }
+        if (this._huffmanTables.length != 0) {
+            this._cachedHuffmanTables = this._huffmanTables;
+        }
+        this._quantTables = [];
+        this._huffmanTables = [];
+        this._segments = [];
+        let i = 0;
+        let bufferLength = buffer.length;
+        while (true) {
+            let j = i;
+            if (j + 2 > bufferLength) {
+                return false;
+            }
+            if (buffer[j] != 0xFF) {
+                throw new Error("Illegal JPEG marker received (byte: " +
+                                   buffer[j] + ")");
+            }
+            const type = buffer[j+1];
+            j += 2;
+            if (type == 0xD9) {
+                this._jpegLength = j;
+                this._segments.push(buffer.slice(i, j));
+                return true;
+            } else if (type == 0xDA) {
+                // start of scan
+                let hasFoundEndOfScan = false;
+                for (let k = j + 3; k + 1 < bufferLength; k++) {
+                    if (buffer[k] == 0xFF && buffer[k+1] != 0x00 &&
+                        !(buffer[k+1] >= 0xD0 && buffer[k+1] <= 0xD7)) {
+                        j = k;
+                        hasFoundEndOfScan = true;
+                        break;
+                    }
+                }
+                if (!hasFoundEndOfScan) {
+                    return false;
+                }
+                this._segments.push(buffer.slice(i, j));
+                i = j;
+                continue;
+            } else if (type >= 0xD0 && type < 0xD9 || type == 0x01) {
+                // No length after marker
+                this._segments.push(buffer.slice(i, j));
+                i = j;
+                continue;
+            }
+            if (j + 2 > bufferLength) {
+                return false;
+            }
+            const length = (buffer[j] << 8) + buffer[j+1] - 2;
+            if (length < 0) {
+                throw new Error("Illegal JPEG length received (length: " +
+                                   length + ")");
+            }
+            j += 2;
+            if (j + length > bufferLength) {
+                return false;
+            }
+            j += length;
+            const segment = buffer.slice(i, j);
+            if (type == 0xC4) {
+                // Huffman tables
+                this._huffmanTables.push(segment);
+            } else if (type == 0xDB) {
+                // Quantization tables
+                this._quantTables.push(segment);
+            }
+            this._segments.push(segment);
+            i = j;
+        }
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/decoders/raw.js
@@ -0,0 +1,66 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ *
+ */
+
+export default class RawDecoder {
+    constructor() {
+        this._lines = 0;
+    }
+
+    decodeRect(x, y, width, height, sock, display, depth) {
+        if ((width === 0) || (height === 0)) {
+            return true;
+        }
+
+        if (this._lines === 0) {
+            this._lines = height;
+        }
+
+        const pixelSize = depth == 8 ? 1 : 4;
+        const bytesPerLine = width * pixelSize;
+
+        if (sock.rQwait("RAW", bytesPerLine)) {
+            return false;
+        }
+
+        const curY = y + (height - this._lines);
+        const currHeight = Math.min(this._lines,
+                                    Math.floor(sock.rQlen / bytesPerLine));
+        const pixels = width * currHeight;
+
+        let data = sock.rQ;
+        let index = sock.rQi;
+
+        // Convert data if needed
+        if (depth == 8) {
+            const newdata = new Uint8Array(pixels * 4);
+            for (let i = 0; i < pixels; i++) {
+                newdata[i * 4 + 0] = ((data[index + i] >> 0) & 0x3) * 255 / 3;
+                newdata[i * 4 + 1] = ((data[index + i] >> 2) & 0x3) * 255 / 3;
+                newdata[i * 4 + 2] = ((data[index + i] >> 4) & 0x3) * 255 / 3;
+                newdata[i * 4 + 3] = 255;
+            }
+            data = newdata;
+            index = 0;
+        }
+
+        // Max sure the image is fully opaque
+        for (let i = 0; i < pixels; i++) {
+            data[index + i * 4 + 3] = 255;
+        }
+
+        display.blitImage(x, curY, width, currHeight, data, index);
+        sock.rQskipBytes(currHeight * bytesPerLine);
+        this._lines -= currHeight;
+        if (this._lines > 0) {
+            return false;
+        }
+
+        return true;
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/decoders/rre.js
@@ -0,0 +1,44 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ *
+ */
+
+export default class RREDecoder {
+    constructor() {
+        this._subrects = 0;
+    }
+
+    decodeRect(x, y, width, height, sock, display, depth) {
+        if (this._subrects === 0) {
+            if (sock.rQwait("RRE", 4 + 4)) {
+                return false;
+            }
+
+            this._subrects = sock.rQshift32();
+
+            let color = sock.rQshiftBytes(4);  // Background
+            display.fillRect(x, y, width, height, color);
+        }
+
+        while (this._subrects > 0) {
+            if (sock.rQwait("RRE", 4 + 8)) {
+                return false;
+            }
+
+            let color = sock.rQshiftBytes(4);
+            let sx = sock.rQshift16();
+            let sy = sock.rQshift16();
+            let swidth = sock.rQshift16();
+            let sheight = sock.rQshift16();
+            display.fillRect(x + sx, y + sy, swidth, sheight, color);
+
+            this._subrects--;
+        }
+
+        return true;
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/decoders/tight.js
@@ -0,0 +1,331 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * (c) 2012 Michael Tinglof, Joe Balaz, Les Piech (Mercuri.ca)
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ *
+ */
+
+import * as Log from '../util/logging.js';
+import Inflator from "../inflator.js";
+
+export default class TightDecoder {
+    constructor() {
+        this._ctl = null;
+        this._filter = null;
+        this._numColors = 0;
+        this._palette = new Uint8Array(1024);  // 256 * 4 (max palette size * max bytes-per-pixel)
+        this._len = 0;
+
+        this._zlibs = [];
+        for (let i = 0; i < 4; i++) {
+            this._zlibs[i] = new Inflator();
+        }
+    }
+
+    decodeRect(x, y, width, height, sock, display, depth) {
+        if (this._ctl === null) {
+            if (sock.rQwait("TIGHT compression-control", 1)) {
+                return false;
+            }
+
+            this._ctl = sock.rQshift8();
+
+            // Reset streams if the server requests it
+            for (let i = 0; i < 4; i++) {
+                if ((this._ctl >> i) & 1) {
+                    this._zlibs[i].reset();
+                    Log.Info("Reset zlib stream " + i);
+                }
+            }
+
+            // Figure out filter
+            this._ctl = this._ctl >> 4;
+        }
+
+        let ret;
+
+        if (this._ctl === 0x08) {
+            ret = this._fillRect(x, y, width, height,
+                                 sock, display, depth);
+        } else if (this._ctl === 0x09) {
+            ret = this._jpegRect(x, y, width, height,
+                                 sock, display, depth);
+        } else if (this._ctl === 0x0A) {
+            ret = this._pngRect(x, y, width, height,
+                                sock, display, depth);
+        } else if ((this._ctl & 0x08) == 0) {
+            ret = this._basicRect(this._ctl, x, y, width, height,
+                                  sock, display, depth);
+        } else {
+            throw new Error("Illegal tight compression received (ctl: " +
+                                   this._ctl + ")");
+        }
+
+        if (ret) {
+            this._ctl = null;
+        }
+
+        return ret;
+    }
+
+    _fillRect(x, y, width, height, sock, display, depth) {
+        if (sock.rQwait("TIGHT", 3)) {
+            return false;
+        }
+
+        const rQi = sock.rQi;
+        const rQ = sock.rQ;
+
+        display.fillRect(x, y, width, height,
+                         [rQ[rQi], rQ[rQi + 1], rQ[rQi + 2]], false);
+        sock.rQskipBytes(3);
+
+        return true;
+    }
+
+    _jpegRect(x, y, width, height, sock, display, depth) {
+        let data = this._readData(sock);
+        if (data === null) {
+            return false;
+        }
+
+        display.imageRect(x, y, width, height, "image/jpeg", data);
+
+        return true;
+    }
+
+    _pngRect(x, y, width, height, sock, display, depth) {
+        throw new Error("PNG received in standard Tight rect");
+    }
+
+    _basicRect(ctl, x, y, width, height, sock, display, depth) {
+        if (this._filter === null) {
+            if (ctl & 0x4) {
+                if (sock.rQwait("TIGHT", 1)) {
+                    return false;
+                }
+
+                this._filter = sock.rQshift8();
+            } else {
+                // Implicit CopyFilter
+                this._filter = 0;
+            }
+        }
+
+        let streamId = ctl & 0x3;
+
+        let ret;
+
+        switch (this._filter) {
+            case 0: // CopyFilter
+                ret = this._copyFilter(streamId, x, y, width, height,
+                                       sock, display, depth);
+                break;
+            case 1: // PaletteFilter
+                ret = this._paletteFilter(streamId, x, y, width, height,
+                                          sock, display, depth);
+                break;
+            case 2: // GradientFilter
+                ret = this._gradientFilter(streamId, x, y, width, height,
+                                           sock, display, depth);
+                break;
+            default:
+                throw new Error("Illegal tight filter received (ctl: " +
+                                       this._filter + ")");
+        }
+
+        if (ret) {
+            this._filter = null;
+        }
+
+        return ret;
+    }
+
+    _copyFilter(streamId, x, y, width, height, sock, display, depth) {
+        const uncompressedSize = width * height * 3;
+        let data;
+
+        if (uncompressedSize === 0) {
+            return true;
+        }
+
+        if (uncompressedSize < 12) {
+            if (sock.rQwait("TIGHT", uncompressedSize)) {
+                return false;
+            }
+
+            data = sock.rQshiftBytes(uncompressedSize);
+        } else {
+            data = this._readData(sock);
+            if (data === null) {
+                return false;
+            }
+
+            this._zlibs[streamId].setInput(data);
+            data = this._zlibs[streamId].inflate(uncompressedSize);
+            this._zlibs[streamId].setInput(null);
+        }
+
+        let rgbx = new Uint8Array(width * height * 4);
+        for (let i = 0, j = 0; i < width * height * 4; i += 4, j += 3) {
+            rgbx[i]     = data[j];
+            rgbx[i + 1] = data[j + 1];
+            rgbx[i + 2] = data[j + 2];
+            rgbx[i + 3] = 255;  // Alpha
+        }
+
+        display.blitImage(x, y, width, height, rgbx, 0, false);
+
+        return true;
+    }
+
+    _paletteFilter(streamId, x, y, width, height, sock, display, depth) {
+        if (this._numColors === 0) {
+            if (sock.rQwait("TIGHT palette", 1)) {
+                return false;
+            }
+
+            const numColors = sock.rQpeek8() + 1;
+            const paletteSize = numColors * 3;
+
+            if (sock.rQwait("TIGHT palette", 1 + paletteSize)) {
+                return false;
+            }
+
+            this._numColors = numColors;
+            sock.rQskipBytes(1);
+
+            sock.rQshiftTo(this._palette, paletteSize);
+        }
+
+        const bpp = (this._numColors <= 2) ? 1 : 8;
+        const rowSize = Math.floor((width * bpp + 7) / 8);
+        const uncompressedSize = rowSize * height;
+
+        let data;
+
+        if (uncompressedSize === 0) {
+            return true;
+        }
+
+        if (uncompressedSize < 12) {
+            if (sock.rQwait("TIGHT", uncompressedSize)) {
+                return false;
+            }
+
+            data = sock.rQshiftBytes(uncompressedSize);
+        } else {
+            data = this._readData(sock);
+            if (data === null) {
+                return false;
+            }
+
+            this._zlibs[streamId].setInput(data);
+            data = this._zlibs[streamId].inflate(uncompressedSize);
+            this._zlibs[streamId].setInput(null);
+        }
+
+        // Convert indexed (palette based) image data to RGB
+        if (this._numColors == 2) {
+            this._monoRect(x, y, width, height, data, this._palette, display);
+        } else {
+            this._paletteRect(x, y, width, height, data, this._palette, display);
+        }
+
+        this._numColors = 0;
+
+        return true;
+    }
+
+    _monoRect(x, y, width, height, data, palette, display) {
+        // Convert indexed (palette based) image data to RGB
+        // TODO: reduce number of calculations inside loop
+        const dest = this._getScratchBuffer(width * height * 4);
+        const w = Math.floor((width + 7) / 8);
+        const w1 = Math.floor(width / 8);
+
+        for (let y = 0; y < height; y++) {
+            let dp, sp, x;
+            for (x = 0; x < w1; x++) {
+                for (let b = 7; b >= 0; b--) {
+                    dp = (y * width + x * 8 + 7 - b) * 4;
+                    sp = (data[y * w + x] >> b & 1) * 3;
+                    dest[dp]     = palette[sp];
+                    dest[dp + 1] = palette[sp + 1];
+                    dest[dp + 2] = palette[sp + 2];
+                    dest[dp + 3] = 255;
+                }
+            }
+
+            for (let b = 7; b >= 8 - width % 8; b--) {
+                dp = (y * width + x * 8 + 7 - b) * 4;
+                sp = (data[y * w + x] >> b & 1) * 3;
+                dest[dp]     = palette[sp];
+                dest[dp + 1] = palette[sp + 1];
+                dest[dp + 2] = palette[sp + 2];
+                dest[dp + 3] = 255;
+            }
+        }
+
+        display.blitImage(x, y, width, height, dest, 0, false);
+    }
+
+    _paletteRect(x, y, width, height, data, palette, display) {
+        // Convert indexed (palette based) image data to RGB
+        const dest = this._getScratchBuffer(width * height * 4);
+        const total = width * height * 4;
+        for (let i = 0, j = 0; i < total; i += 4, j++) {
+            const sp = data[j] * 3;
+            dest[i]     = palette[sp];
+            dest[i + 1] = palette[sp + 1];
+            dest[i + 2] = palette[sp + 2];
+            dest[i + 3] = 255;
+        }
+
+        display.blitImage(x, y, width, height, dest, 0, false);
+    }
+
+    _gradientFilter(streamId, x, y, width, height, sock, display, depth) {
+        throw new Error("Gradient filter not implemented");
+    }
+
+    _readData(sock) {
+        if (this._len === 0) {
+            if (sock.rQwait("TIGHT", 3)) {
+                return null;
+            }
+
+            let byte;
+
+            byte = sock.rQshift8();
+            this._len = byte & 0x7f;
+            if (byte & 0x80) {
+                byte = sock.rQshift8();
+                this._len |= (byte & 0x7f) << 7;
+                if (byte & 0x80) {
+                    byte = sock.rQshift8();
+                    this._len |= byte << 14;
+                }
+            }
+        }
+
+        if (sock.rQwait("TIGHT", this._len)) {
+            return null;
+        }
+
+        let data = sock.rQshiftBytes(this._len);
+        this._len = 0;
+
+        return data;
+    }
+
+    _getScratchBuffer(size) {
+        if (!this._scratchBuffer || (this._scratchBuffer.length < size)) {
+            this._scratchBuffer = new Uint8Array(size);
+        }
+        return this._scratchBuffer;
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/decoders/tightpng.js
@@ -0,0 +1,27 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ *
+ */
+
+import TightDecoder from './tight.js';
+
+export default class TightPNGDecoder extends TightDecoder {
+    _pngRect(x, y, width, height, sock, display, depth) {
+        let data = this._readData(sock);
+        if (data === null) {
+            return false;
+        }
+
+        display.imageRect(x, y, width, height, "image/png", data);
+
+        return true;
+    }
+
+    _basicRect(ctl, x, y, width, height, sock, display, depth) {
+        throw new Error("BasicCompression received in TightPNG rect");
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/decoders/zrle.js
@@ -0,0 +1,185 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2021 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ *
+ */
+
+import Inflate from "../inflator.js";
+
+const ZRLE_TILE_WIDTH = 64;
+const ZRLE_TILE_HEIGHT = 64;
+
+export default class ZRLEDecoder {
+    constructor() {
+        this._length = 0;
+        this._inflator = new Inflate();
+
+        this._pixelBuffer = new Uint8Array(ZRLE_TILE_WIDTH * ZRLE_TILE_HEIGHT * 4);
+        this._tileBuffer = new Uint8Array(ZRLE_TILE_WIDTH * ZRLE_TILE_HEIGHT * 4);
+    }
+
+    decodeRect(x, y, width, height, sock, display, depth) {
+        if (this._length === 0) {
+            if (sock.rQwait("ZLib data length", 4)) {
+                return false;
+            }
+            this._length = sock.rQshift32();
+        }
+        if (sock.rQwait("Zlib data", this._length)) {
+            return false;
+        }
+
+        const data = sock.rQshiftBytes(this._length);
+
+        this._inflator.setInput(data);
+
+        for (let ty = y; ty < y + height; ty += ZRLE_TILE_HEIGHT) {
+            let th = Math.min(ZRLE_TILE_HEIGHT, y + height - ty);
+
+            for (let tx = x; tx < x + width; tx += ZRLE_TILE_WIDTH) {
+                let tw = Math.min(ZRLE_TILE_WIDTH, x + width - tx);
+
+                const tileSize = tw * th;
+                const subencoding = this._inflator.inflate(1)[0];
+                if (subencoding === 0) {
+                    // raw data
+                    const data = this._readPixels(tileSize);
+                    display.blitImage(tx, ty, tw, th, data, 0, false);
+                } else if (subencoding === 1) {
+                    // solid
+                    const background = this._readPixels(1);
+                    display.fillRect(tx, ty, tw, th, [background[0], background[1], background[2]]);
+                } else if (subencoding >= 2 && subencoding <= 16) {
+                    const data = this._decodePaletteTile(subencoding, tileSize, tw, th);
+                    display.blitImage(tx, ty, tw, th, data, 0, false);
+                } else if (subencoding === 128) {
+                    const data = this._decodeRLETile(tileSize);
+                    display.blitImage(tx, ty, tw, th, data, 0, false);
+                } else if (subencoding >= 130 && subencoding <= 255) {
+                    const data = this._decodeRLEPaletteTile(subencoding - 128, tileSize);
+                    display.blitImage(tx, ty, tw, th, data, 0, false);
+                } else {
+                    throw new Error('Unknown subencoding: ' + subencoding);
+                }
+            }
+        }
+        this._length = 0;
+        return true;
+    }
+
+    _getBitsPerPixelInPalette(paletteSize) {
+        if (paletteSize <= 2) {
+            return 1;
+        } else if (paletteSize <= 4) {
+            return 2;
+        } else if (paletteSize <= 16) {
+            return 4;
+        }
+    }
+
+    _readPixels(pixels) {
+        let data = this._pixelBuffer;
+        const buffer = this._inflator.inflate(3*pixels);
+        for (let i = 0, j = 0; i < pixels*4; i += 4, j += 3) {
+            data[i]     = buffer[j];
+            data[i + 1] = buffer[j + 1];
+            data[i + 2] = buffer[j + 2];
+            data[i + 3] = 255;  // Add the Alpha
+        }
+        return data;
+    }
+
+    _decodePaletteTile(paletteSize, tileSize, tilew, tileh) {
+        const data = this._tileBuffer;
+        const palette = this._readPixels(paletteSize);
+        const bitsPerPixel = this._getBitsPerPixelInPalette(paletteSize);
+        const mask = (1 << bitsPerPixel) - 1;
+
+        let offset = 0;
+        let encoded = this._inflator.inflate(1)[0];
+
+        for (let y=0; y<tileh; y++) {
+            let shift = 8-bitsPerPixel;
+            for (let x=0; x<tilew; x++) {
+                if (shift<0) {
+                    shift=8-bitsPerPixel;
+                    encoded = this._inflator.inflate(1)[0];
+                }
+                let indexInPalette = (encoded>>shift) & mask;
+
+                data[offset] = palette[indexInPalette * 4];
+                data[offset + 1] = palette[indexInPalette * 4 + 1];
+                data[offset + 2] = palette[indexInPalette * 4 + 2];
+                data[offset + 3] = palette[indexInPalette * 4 + 3];
+                offset += 4;
+                shift-=bitsPerPixel;
+            }
+            if (shift<8-bitsPerPixel && y<tileh-1) {
+                encoded =  this._inflator.inflate(1)[0];
+            }
+        }
+        return data;
+    }
+
+    _decodeRLETile(tileSize) {
+        const data = this._tileBuffer;
+        let i = 0;
+        while (i < tileSize) {
+            const pixel = this._readPixels(1);
+            const length = this._readRLELength();
+            for (let j = 0; j < length; j++) {
+                data[i * 4] = pixel[0];
+                data[i * 4 + 1] = pixel[1];
+                data[i * 4 + 2] = pixel[2];
+                data[i * 4 + 3] = pixel[3];
+                i++;
+            }
+        }
+        return data;
+    }
+
+    _decodeRLEPaletteTile(paletteSize, tileSize) {
+        const data = this._tileBuffer;
+
+        // palette
+        const palette = this._readPixels(paletteSize);
+
+        let offset = 0;
+        while (offset < tileSize) {
+            let indexInPalette = this._inflator.inflate(1)[0];
+            let length = 1;
+            if (indexInPalette >= 128) {
+                indexInPalette -= 128;
+                length = this._readRLELength();
+            }
+            if (indexInPalette > paletteSize) {
+                throw new Error('Too big index in palette: ' + indexInPalette + ', palette size: ' + paletteSize);
+            }
+            if (offset + length > tileSize) {
+                throw new Error('Too big rle length in palette mode: ' + length + ', allowed length is: ' + (tileSize - offset));
+            }
+
+            for (let j = 0; j < length; j++) {
+                data[offset * 4] = palette[indexInPalette * 4];
+                data[offset * 4 + 1] = palette[indexInPalette * 4 + 1];
+                data[offset * 4 + 2] = palette[indexInPalette * 4 + 2];
+                data[offset * 4 + 3] = palette[indexInPalette * 4 + 3];
+                offset++;
+            }
+        }
+        return data;
+    }
+
+    _readRLELength() {
+        let length = 0;
+        let current = 0;
+        do {
+            current = this._inflator.inflate(1)[0];
+            length += current;
+        } while (current === 255);
+        return length + 1;
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/deflator.js
@@ -0,0 +1,85 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2020 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+import { deflateInit, deflate } from "../vendor/pako/lib/zlib/deflate.js";
+import { Z_FULL_FLUSH } from "../vendor/pako/lib/zlib/deflate.js";
+import ZStream from "../vendor/pako/lib/zlib/zstream.js";
+
+export default class Deflator {
+    constructor() {
+        this.strm = new ZStream();
+        this.chunkSize = 1024 * 10 * 10;
+        this.outputBuffer = new Uint8Array(this.chunkSize);
+        this.windowBits = 5;
+
+        deflateInit(this.strm, this.windowBits);
+    }
+
+    deflate(inData) {
+        /* eslint-disable camelcase */
+        this.strm.input = inData;
+        this.strm.avail_in = this.strm.input.length;
+        this.strm.next_in = 0;
+        this.strm.output = this.outputBuffer;
+        this.strm.avail_out = this.chunkSize;
+        this.strm.next_out = 0;
+        /* eslint-enable camelcase */
+
+        let lastRet = deflate(this.strm, Z_FULL_FLUSH);
+        let outData = new Uint8Array(this.strm.output.buffer, 0, this.strm.next_out);
+
+        if (lastRet < 0) {
+            throw new Error("zlib deflate failed");
+        }
+
+        if (this.strm.avail_in > 0) {
+            // Read chunks until done
+
+            let chunks = [outData];
+            let totalLen = outData.length;
+            do {
+                /* eslint-disable camelcase */
+                this.strm.output = new Uint8Array(this.chunkSize);
+                this.strm.next_out = 0;
+                this.strm.avail_out = this.chunkSize;
+                /* eslint-enable camelcase */
+
+                lastRet = deflate(this.strm, Z_FULL_FLUSH);
+
+                if (lastRet < 0) {
+                    throw new Error("zlib deflate failed");
+                }
+
+                let chunk = new Uint8Array(this.strm.output.buffer, 0, this.strm.next_out);
+                totalLen += chunk.length;
+                chunks.push(chunk);
+            } while (this.strm.avail_in > 0);
+
+            // Combine chunks into a single data
+
+            let newData = new Uint8Array(totalLen);
+            let offset = 0;
+
+            for (let i = 0; i < chunks.length; i++) {
+                newData.set(chunks[i], offset);
+                offset += chunks[i].length;
+            }
+
+            outData = newData;
+        }
+
+        /* eslint-disable camelcase */
+        this.strm.input = null;
+        this.strm.avail_in = 0;
+        this.strm.next_in = 0;
+        /* eslint-enable camelcase */
+
+        return outData;
+    }
+
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/des.js
@@ -0,0 +1,266 @@
+/*
+ * Ported from Flashlight VNC ActionScript implementation:
+ *     http://www.wizhelp.com/flashlight-vnc/
+ *
+ * Full attribution follows:
+ *
+ * -------------------------------------------------------------------------
+ *
+ * This DES class has been extracted from package Acme.Crypto for use in VNC.
+ * The unnecessary odd parity code has been removed.
+ *
+ * These changes are:
+ *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
+ *
+ * This software is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+
+ * DesCipher - the DES encryption method
+ *
+ * The meat of this code is by Dave Zimmerman <dzimm@widget.com>, and is:
+ *
+ * Copyright (c) 1996 Widget Workshop, Inc. All Rights Reserved.
+ *
+ * Permission to use, copy, modify, and distribute this software
+ * and its documentation for NON-COMMERCIAL or COMMERCIAL purposes and
+ * without fee is hereby granted, provided that this copyright notice is kept
+ * intact.
+ *
+ * WIDGET WORKSHOP MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY
+ * OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+ * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+ * PARTICULAR PURPOSE, OR NON-INFRINGEMENT. WIDGET WORKSHOP SHALL NOT BE LIABLE
+ * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR
+ * DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
+ *
+ * THIS SOFTWARE IS NOT DESIGNED OR INTENDED FOR USE OR RESALE AS ON-LINE
+ * CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE
+ * PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT
+ * NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE
+ * SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF THE
+ * SOFTWARE COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE
+ * PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH RISK ACTIVITIES").  WIDGET WORKSHOP
+ * SPECIFICALLY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR
+ * HIGH RISK ACTIVITIES.
+ *
+ *
+ * The rest is:
+ *
+ * Copyright (C) 1996 by Jef Poskanzer <jef@acme.com>.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Visit the ACME Labs Java page for up-to-date versions of this and other
+ * fine Java utilities: http://www.acme.com/java/
+ */
+
+/* eslint-disable comma-spacing */
+
+// Tables, permutations, S-boxes, etc.
+const PC2 = [13,16,10,23, 0, 4, 2,27,14, 5,20, 9,22,18,11, 3,
+             25, 7,15, 6,26,19,12, 1,40,51,30,36,46,54,29,39,
+             50,44,32,47,43,48,38,55,33,52,45,41,49,35,28,31 ],
+    totrot = [ 1, 2, 4, 6, 8,10,12,14,15,17,19,21,23,25,27,28];
+
+const z = 0x0;
+let a,b,c,d,e,f;
+a=1<<16; b=1<<24; c=a|b; d=1<<2; e=1<<10; f=d|e;
+const SP1 = [c|e,z|z,a|z,c|f,c|d,a|f,z|d,a|z,z|e,c|e,c|f,z|e,b|f,c|d,b|z,z|d,
+             z|f,b|e,b|e,a|e,a|e,c|z,c|z,b|f,a|d,b|d,b|d,a|d,z|z,z|f,a|f,b|z,
+             a|z,c|f,z|d,c|z,c|e,b|z,b|z,z|e,c|d,a|z,a|e,b|d,z|e,z|d,b|f,a|f,
+             c|f,a|d,c|z,b|f,b|d,z|f,a|f,c|e,z|f,b|e,b|e,z|z,a|d,a|e,z|z,c|d];
+a=1<<20; b=1<<31; c=a|b; d=1<<5; e=1<<15; f=d|e;
+const SP2 = [c|f,b|e,z|e,a|f,a|z,z|d,c|d,b|f,b|d,c|f,c|e,b|z,b|e,a|z,z|d,c|d,
+             a|e,a|d,b|f,z|z,b|z,z|e,a|f,c|z,a|d,b|d,z|z,a|e,z|f,c|e,c|z,z|f,
+             z|z,a|f,c|d,a|z,b|f,c|z,c|e,z|e,c|z,b|e,z|d,c|f,a|f,z|d,z|e,b|z,
+             z|f,c|e,a|z,b|d,a|d,b|f,b|d,a|d,a|e,z|z,b|e,z|f,b|z,c|d,c|f,a|e];
+a=1<<17; b=1<<27; c=a|b; d=1<<3; e=1<<9; f=d|e;
+const SP3 = [z|f,c|e,z|z,c|d,b|e,z|z,a|f,b|e,a|d,b|d,b|d,a|z,c|f,a|d,c|z,z|f,
+             b|z,z|d,c|e,z|e,a|e,c|z,c|d,a|f,b|f,a|e,a|z,b|f,z|d,c|f,z|e,b|z,
+             c|e,b|z,a|d,z|f,a|z,c|e,b|e,z|z,z|e,a|d,c|f,b|e,b|d,z|e,z|z,c|d,
+             b|f,a|z,b|z,c|f,z|d,a|f,a|e,b|d,c|z,b|f,z|f,c|z,a|f,z|d,c|d,a|e];
+a=1<<13; b=1<<23; c=a|b; d=1<<0; e=1<<7; f=d|e;
+const SP4 = [c|d,a|f,a|f,z|e,c|e,b|f,b|d,a|d,z|z,c|z,c|z,c|f,z|f,z|z,b|e,b|d,
+             z|d,a|z,b|z,c|d,z|e,b|z,a|d,a|e,b|f,z|d,a|e,b|e,a|z,c|e,c|f,z|f,
+             b|e,b|d,c|z,c|f,z|f,z|z,z|z,c|z,a|e,b|e,b|f,z|d,c|d,a|f,a|f,z|e,
+             c|f,z|f,z|d,a|z,b|d,a|d,c|e,b|f,a|d,a|e,b|z,c|d,z|e,b|z,a|z,c|e];
+a=1<<25; b=1<<30; c=a|b; d=1<<8; e=1<<19; f=d|e;
+const SP5 = [z|d,a|f,a|e,c|d,z|e,z|d,b|z,a|e,b|f,z|e,a|d,b|f,c|d,c|e,z|f,b|z,
+             a|z,b|e,b|e,z|z,b|d,c|f,c|f,a|d,c|e,b|d,z|z,c|z,a|f,a|z,c|z,z|f,
+             z|e,c|d,z|d,a|z,b|z,a|e,c|d,b|f,a|d,b|z,c|e,a|f,b|f,z|d,a|z,c|e,
+             c|f,z|f,c|z,c|f,a|e,z|z,b|e,c|z,z|f,a|d,b|d,z|e,z|z,b|e,a|f,b|d];
+a=1<<22; b=1<<29; c=a|b; d=1<<4; e=1<<14; f=d|e;
+const SP6 = [b|d,c|z,z|e,c|f,c|z,z|d,c|f,a|z,b|e,a|f,a|z,b|d,a|d,b|e,b|z,z|f,
+             z|z,a|d,b|f,z|e,a|e,b|f,z|d,c|d,c|d,z|z,a|f,c|e,z|f,a|e,c|e,b|z,
+             b|e,z|d,c|d,a|e,c|f,a|z,z|f,b|d,a|z,b|e,b|z,z|f,b|d,c|f,a|e,c|z,
+             a|f,c|e,z|z,c|d,z|d,z|e,c|z,a|f,z|e,a|d,b|f,z|z,c|e,b|z,a|d,b|f];
+a=1<<21; b=1<<26; c=a|b; d=1<<1; e=1<<11; f=d|e;
+const SP7 = [a|z,c|d,b|f,z|z,z|e,b|f,a|f,c|e,c|f,a|z,z|z,b|d,z|d,b|z,c|d,z|f,
+             b|e,a|f,a|d,b|e,b|d,c|z,c|e,a|d,c|z,z|e,z|f,c|f,a|e,z|d,b|z,a|e,
+             b|z,a|e,a|z,b|f,b|f,c|d,c|d,z|d,a|d,b|z,b|e,a|z,c|e,z|f,a|f,c|e,
+             z|f,b|d,c|f,c|z,a|e,z|z,z|d,c|f,z|z,a|f,c|z,z|e,b|d,b|e,z|e,a|d];
+a=1<<18; b=1<<28; c=a|b; d=1<<6; e=1<<12; f=d|e;
+const SP8 = [b|f,z|e,a|z,c|f,b|z,b|f,z|d,b|z,a|d,c|z,c|f,a|e,c|e,a|f,z|e,z|d,
+             c|z,b|d,b|e,z|f,a|e,a|d,c|d,c|e,z|f,z|z,z|z,c|d,b|d,b|e,a|f,a|z,
+             a|f,a|z,c|e,z|e,z|d,c|d,z|e,a|f,b|e,z|d,b|d,c|z,c|d,b|z,a|z,b|f,
+             z|z,c|f,a|d,b|d,c|z,b|e,b|f,z|z,c|f,a|e,a|e,z|f,z|f,a|d,b|z,c|e];
+
+/* eslint-enable comma-spacing */
+
+export default class DES {
+    constructor(password) {
+        this.keys = [];
+
+        // Set the key.
+        const pc1m = [], pcr = [], kn = [];
+
+        for (let j = 0, l = 56; j < 56; ++j, l -= 8) {
+            l += l < -5 ? 65 : l < -3 ? 31 : l < -1 ? 63 : l === 27 ? 35 : 0; // PC1
+            const m = l & 0x7;
+            pc1m[j] = ((password[l >>> 3] & (1<<m)) !== 0) ? 1: 0;
+        }
+
+        for (let i = 0; i < 16; ++i) {
+            const m = i << 1;
+            const n = m + 1;
+            kn[m] = kn[n] = 0;
+            for (let o = 28; o < 59; o += 28) {
+                for (let j = o - 28; j < o; ++j) {
+                    const l = j + totrot[i];
+                    pcr[j] = l < o ? pc1m[l] : pc1m[l - 28];
+                }
+            }
+            for (let j = 0; j < 24; ++j) {
+                if (pcr[PC2[j]] !== 0) {
+                    kn[m] |= 1 << (23 - j);
+                }
+                if (pcr[PC2[j + 24]] !== 0) {
+                    kn[n] |= 1 << (23 - j);
+                }
+            }
+        }
+
+        // cookey
+        for (let i = 0, rawi = 0, KnLi = 0; i < 16; ++i) {
+            const raw0 = kn[rawi++];
+            const raw1 = kn[rawi++];
+            this.keys[KnLi] = (raw0 & 0x00fc0000) << 6;
+            this.keys[KnLi] |= (raw0 & 0x00000fc0) << 10;
+            this.keys[KnLi] |= (raw1 & 0x00fc0000) >>> 10;
+            this.keys[KnLi] |= (raw1 & 0x00000fc0) >>> 6;
+            ++KnLi;
+            this.keys[KnLi] = (raw0 & 0x0003f000) << 12;
+            this.keys[KnLi] |= (raw0 & 0x0000003f) << 16;
+            this.keys[KnLi] |= (raw1 & 0x0003f000) >>> 4;
+            this.keys[KnLi] |= (raw1 & 0x0000003f);
+            ++KnLi;
+        }
+    }
+
+    // Encrypt 8 bytes of text
+    enc8(text) {
+        const b = text.slice();
+        let i = 0, l, r, x; // left, right, accumulator
+
+        // Squash 8 bytes to 2 ints
+        l = b[i++]<<24 | b[i++]<<16 | b[i++]<<8 | b[i++];
+        r = b[i++]<<24 | b[i++]<<16 | b[i++]<<8 | b[i++];
+
+        x = ((l >>> 4) ^ r) & 0x0f0f0f0f;
+        r ^= x;
+        l ^= (x << 4);
+        x = ((l >>> 16) ^ r) & 0x0000ffff;
+        r ^= x;
+        l ^= (x << 16);
+        x = ((r >>> 2) ^ l) & 0x33333333;
+        l ^= x;
+        r ^= (x << 2);
+        x = ((r >>> 8) ^ l) & 0x00ff00ff;
+        l ^= x;
+        r ^= (x << 8);
+        r = (r << 1) | ((r >>> 31) & 1);
+        x = (l ^ r) & 0xaaaaaaaa;
+        l ^= x;
+        r ^= x;
+        l = (l << 1) | ((l >>> 31) & 1);
+
+        for (let i = 0, keysi = 0; i < 8; ++i) {
+            x = (r << 28) | (r >>> 4);
+            x ^= this.keys[keysi++];
+            let fval =  SP7[x & 0x3f];
+            fval |= SP5[(x >>> 8) & 0x3f];
+            fval |= SP3[(x >>> 16) & 0x3f];
+            fval |= SP1[(x >>> 24) & 0x3f];
+            x = r ^ this.keys[keysi++];
+            fval |= SP8[x & 0x3f];
+            fval |= SP6[(x >>> 8) & 0x3f];
+            fval |= SP4[(x >>> 16) & 0x3f];
+            fval |= SP2[(x >>> 24) & 0x3f];
+            l ^= fval;
+            x = (l << 28) | (l >>> 4);
+            x ^= this.keys[keysi++];
+            fval =  SP7[x & 0x3f];
+            fval |= SP5[(x >>> 8) & 0x3f];
+            fval |= SP3[(x >>> 16) & 0x3f];
+            fval |= SP1[(x >>> 24) & 0x3f];
+            x = l ^ this.keys[keysi++];
+            fval |= SP8[x & 0x0000003f];
+            fval |= SP6[(x >>> 8) & 0x3f];
+            fval |= SP4[(x >>> 16) & 0x3f];
+            fval |= SP2[(x >>> 24) & 0x3f];
+            r ^= fval;
+        }
+
+        r = (r << 31) | (r >>> 1);
+        x = (l ^ r) & 0xaaaaaaaa;
+        l ^= x;
+        r ^= x;
+        l = (l << 31) | (l >>> 1);
+        x = ((l >>> 8) ^ r) & 0x00ff00ff;
+        r ^= x;
+        l ^= (x << 8);
+        x = ((l >>> 2) ^ r) & 0x33333333;
+        r ^= x;
+        l ^= (x << 2);
+        x = ((r >>> 16) ^ l) & 0x0000ffff;
+        l ^= x;
+        r ^= (x << 16);
+        x = ((r >>> 4) ^ l) & 0x0f0f0f0f;
+        l ^= x;
+        r ^= (x << 4);
+
+        // Spread ints to bytes
+        x = [r, l];
+        for (i = 0; i < 8; i++) {
+            b[i] = (x[i>>>2] >>> (8 * (3 - (i % 4)))) % 256;
+            if (b[i] < 0) { b[i] += 256; } // unsigned
+        }
+        return b;
+    }
+
+    // Encrypt 16 bytes of text using passwd as key
+    encrypt(t) {
+        return this.enc8(t.slice(0, 8)).concat(this.enc8(t.slice(8, 16)));
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/display.js
@@ -0,0 +1,525 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+import * as Log from './util/logging.js';
+import Base64 from "./base64.js";
+import { toSigned32bit } from './util/int.js';
+
+export default class Display {
+    constructor(target) {
+        this._drawCtx = null;
+
+        this._renderQ = [];  // queue drawing actions for in-oder rendering
+        this._flushing = false;
+
+        // the full frame buffer (logical canvas) size
+        this._fbWidth = 0;
+        this._fbHeight = 0;
+
+        this._prevDrawStyle = "";
+
+        Log.Debug(">> Display.constructor");
+
+        // The visible canvas
+        this._target = target;
+
+        if (!this._target) {
+            throw new Error("Target must be set");
+        }
+
+        if (typeof this._target === 'string') {
+            throw new Error('target must be a DOM element');
+        }
+
+        if (!this._target.getContext) {
+            throw new Error("no getContext method");
+        }
+
+        this._targetCtx = this._target.getContext('2d');
+
+        // the visible canvas viewport (i.e. what actually gets seen)
+        this._viewportLoc = { 'x': 0, 'y': 0, 'w': this._target.width, 'h': this._target.height };
+
+        // The hidden canvas, where we do the actual rendering
+        this._backbuffer = document.createElement('canvas');
+        this._drawCtx = this._backbuffer.getContext('2d');
+
+        this._damageBounds = { left: 0, top: 0,
+                               right: this._backbuffer.width,
+                               bottom: this._backbuffer.height };
+
+        Log.Debug("User Agent: " + navigator.userAgent);
+
+        Log.Debug("<< Display.constructor");
+
+        // ===== PROPERTIES =====
+
+        this._scale = 1.0;
+        this._clipViewport = false;
+
+        // ===== EVENT HANDLERS =====
+
+        this.onflush = () => {}; // A flush request has finished
+    }
+
+    // ===== PROPERTIES =====
+
+    get scale() { return this._scale; }
+    set scale(scale) {
+        this._rescale(scale);
+    }
+
+    get clipViewport() { return this._clipViewport; }
+    set clipViewport(viewport) {
+        this._clipViewport = viewport;
+        // May need to readjust the viewport dimensions
+        const vp = this._viewportLoc;
+        this.viewportChangeSize(vp.w, vp.h);
+        this.viewportChangePos(0, 0);
+    }
+
+    get width() {
+        return this._fbWidth;
+    }
+
+    get height() {
+        return this._fbHeight;
+    }
+
+    // ===== PUBLIC METHODS =====
+
+    viewportChangePos(deltaX, deltaY) {
+        const vp = this._viewportLoc;
+        deltaX = Math.floor(deltaX);
+        deltaY = Math.floor(deltaY);
+
+        if (!this._clipViewport) {
+            deltaX = -vp.w;  // clamped later of out of bounds
+            deltaY = -vp.h;
+        }
+
+        const vx2 = vp.x + vp.w - 1;
+        const vy2 = vp.y + vp.h - 1;
+
+        // Position change
+
+        if (deltaX < 0 && vp.x + deltaX < 0) {
+            deltaX = -vp.x;
+        }
+        if (vx2 + deltaX >= this._fbWidth) {
+            deltaX -= vx2 + deltaX - this._fbWidth + 1;
+        }
+
+        if (vp.y + deltaY < 0) {
+            deltaY = -vp.y;
+        }
+        if (vy2 + deltaY >= this._fbHeight) {
+            deltaY -= (vy2 + deltaY - this._fbHeight + 1);
+        }
+
+        if (deltaX === 0 && deltaY === 0) {
+            return;
+        }
+        Log.Debug("viewportChange deltaX: " + deltaX + ", deltaY: " + deltaY);
+
+        vp.x += deltaX;
+        vp.y += deltaY;
+
+        this._damage(vp.x, vp.y, vp.w, vp.h);
+
+        this.flip();
+    }
+
+    viewportChangeSize(width, height) {
+
+        if (!this._clipViewport ||
+            typeof(width) === "undefined" ||
+            typeof(height) === "undefined") {
+
+            Log.Debug("Setting viewport to full display region");
+            width = this._fbWidth;
+            height = this._fbHeight;
+        }
+
+        width = Math.floor(width);
+        height = Math.floor(height);
+
+        if (width > this._fbWidth) {
+            width = this._fbWidth;
+        }
+        if (height > this._fbHeight) {
+            height = this._fbHeight;
+        }
+
+        const vp = this._viewportLoc;
+        if (vp.w !== width || vp.h !== height) {
+            vp.w = width;
+            vp.h = height;
+
+            const canvas = this._target;
+            canvas.width = width;
+            canvas.height = height;
+
+            // The position might need to be updated if we've grown
+            this.viewportChangePos(0, 0);
+
+            this._damage(vp.x, vp.y, vp.w, vp.h);
+            this.flip();
+
+            // Update the visible size of the target canvas
+            this._rescale(this._scale);
+        }
+    }
+
+    absX(x) {
+        if (this._scale === 0) {
+            return 0;
+        }
+        return toSigned32bit(x / this._scale + this._viewportLoc.x);
+    }
+
+    absY(y) {
+        if (this._scale === 0) {
+            return 0;
+        }
+        return toSigned32bit(y / this._scale + this._viewportLoc.y);
+    }
+
+    resize(width, height) {
+        this._prevDrawStyle = "";
+
+        this._fbWidth = width;
+        this._fbHeight = height;
+
+        const canvas = this._backbuffer;
+        if (canvas.width !== width || canvas.height !== height) {
+
+            // We have to save the canvas data since changing the size will clear it
+            let saveImg = null;
+            if (canvas.width > 0 && canvas.height > 0) {
+                saveImg = this._drawCtx.getImageData(0, 0, canvas.width, canvas.height);
+            }
+
+            if (canvas.width !== width) {
+                canvas.width = width;
+            }
+            if (canvas.height !== height) {
+                canvas.height = height;
+            }
+
+            if (saveImg) {
+                this._drawCtx.putImageData(saveImg, 0, 0);
+            }
+        }
+
+        // Readjust the viewport as it may be incorrectly sized
+        // and positioned
+        const vp = this._viewportLoc;
+        this.viewportChangeSize(vp.w, vp.h);
+        this.viewportChangePos(0, 0);
+    }
+
+    getImageData() {
+        return this._drawCtx.getImageData(0, 0, this.width, this.height);
+    }
+
+    toDataURL(type, encoderOptions) {
+        return this._backbuffer.toDataURL(type, encoderOptions);
+    }
+
+    toBlob(callback, type, quality) {
+        return this._backbuffer.toBlob(callback, type, quality);
+    }
+
+    // Track what parts of the visible canvas that need updating
+    _damage(x, y, w, h) {
+        if (x < this._damageBounds.left) {
+            this._damageBounds.left = x;
+        }
+        if (y < this._damageBounds.top) {
+            this._damageBounds.top = y;
+        }
+        if ((x + w) > this._damageBounds.right) {
+            this._damageBounds.right = x + w;
+        }
+        if ((y + h) > this._damageBounds.bottom) {
+            this._damageBounds.bottom = y + h;
+        }
+    }
+
+    // Update the visible canvas with the contents of the
+    // rendering canvas
+    flip(fromQueue) {
+        if (this._renderQ.length !== 0 && !fromQueue) {
+            this._renderQPush({
+                'type': 'flip'
+            });
+        } else {
+            let x = this._damageBounds.left;
+            let y = this._damageBounds.top;
+            let w = this._damageBounds.right - x;
+            let h = this._damageBounds.bottom - y;
+
+            let vx = x - this._viewportLoc.x;
+            let vy = y - this._viewportLoc.y;
+
+            if (vx < 0) {
+                w += vx;
+                x -= vx;
+                vx = 0;
+            }
+            if (vy < 0) {
+                h += vy;
+                y -= vy;
+                vy = 0;
+            }
+
+            if ((vx + w) > this._viewportLoc.w) {
+                w = this._viewportLoc.w - vx;
+            }
+            if ((vy + h) > this._viewportLoc.h) {
+                h = this._viewportLoc.h - vy;
+            }
+
+            if ((w > 0) && (h > 0)) {
+                // FIXME: We may need to disable image smoothing here
+                //        as well (see copyImage()), but we haven't
+                //        noticed any problem yet.
+                this._targetCtx.drawImage(this._backbuffer,
+                                          x, y, w, h,
+                                          vx, vy, w, h);
+            }
+
+            this._damageBounds.left = this._damageBounds.top = 65535;
+            this._damageBounds.right = this._damageBounds.bottom = 0;
+        }
+    }
+
+    pending() {
+        return this._renderQ.length > 0;
+    }
+
+    flush() {
+        if (this._renderQ.length === 0) {
+            this.onflush();
+        } else {
+            this._flushing = true;
+        }
+    }
+
+    fillRect(x, y, width, height, color, fromQueue) {
+        if (this._renderQ.length !== 0 && !fromQueue) {
+            this._renderQPush({
+                'type': 'fill',
+                'x': x,
+                'y': y,
+                'width': width,
+                'height': height,
+                'color': color
+            });
+        } else {
+            this._setFillColor(color);
+            this._drawCtx.fillRect(x, y, width, height);
+            this._damage(x, y, width, height);
+        }
+    }
+
+    copyImage(oldX, oldY, newX, newY, w, h, fromQueue) {
+        if (this._renderQ.length !== 0 && !fromQueue) {
+            this._renderQPush({
+                'type': 'copy',
+                'oldX': oldX,
+                'oldY': oldY,
+                'x': newX,
+                'y': newY,
+                'width': w,
+                'height': h,
+            });
+        } else {
+            // Due to this bug among others [1] we need to disable the image-smoothing to
+            // avoid getting a blur effect when copying data.
+            //
+            // 1. https://bugzilla.mozilla.org/show_bug.cgi?id=1194719
+            //
+            // We need to set these every time since all properties are reset
+            // when the the size is changed
+            this._drawCtx.mozImageSmoothingEnabled = false;
+            this._drawCtx.webkitImageSmoothingEnabled = false;
+            this._drawCtx.msImageSmoothingEnabled = false;
+            this._drawCtx.imageSmoothingEnabled = false;
+
+            this._drawCtx.drawImage(this._backbuffer,
+                                    oldX, oldY, w, h,
+                                    newX, newY, w, h);
+            this._damage(newX, newY, w, h);
+        }
+    }
+
+    imageRect(x, y, width, height, mime, arr) {
+        /* The internal logic cannot handle empty images, so bail early */
+        if ((width === 0) || (height === 0)) {
+            return;
+        }
+
+        const img = new Image();
+        img.src = "data: " + mime + ";base64," + Base64.encode(arr);
+
+        this._renderQPush({
+            'type': 'img',
+            'img': img,
+            'x': x,
+            'y': y,
+            'width': width,
+            'height': height
+        });
+    }
+
+    blitImage(x, y, width, height, arr, offset, fromQueue) {
+        if (this._renderQ.length !== 0 && !fromQueue) {
+            // NB(directxman12): it's technically more performant here to use preallocated arrays,
+            // but it's a lot of extra work for not a lot of payoff -- if we're using the render queue,
+            // this probably isn't getting called *nearly* as much
+            const newArr = new Uint8Array(width * height * 4);
+            newArr.set(new Uint8Array(arr.buffer, 0, newArr.length));
+            this._renderQPush({
+                'type': 'blit',
+                'data': newArr,
+                'x': x,
+                'y': y,
+                'width': width,
+                'height': height,
+            });
+        } else {
+            // NB(directxman12): arr must be an Type Array view
+            let data = new Uint8ClampedArray(arr.buffer,
+                                             arr.byteOffset + offset,
+                                             width * height * 4);
+            let img = new ImageData(data, width, height);
+            this._drawCtx.putImageData(img, x, y);
+            this._damage(x, y, width, height);
+        }
+    }
+
+    drawImage(img, x, y) {
+        this._drawCtx.drawImage(img, x, y);
+        this._damage(x, y, img.width, img.height);
+    }
+
+    autoscale(containerWidth, containerHeight) {
+        let scaleRatio;
+
+        if (containerWidth === 0 || containerHeight === 0) {
+            scaleRatio = 0;
+
+        } else {
+
+            const vp = this._viewportLoc;
+            const targetAspectRatio = containerWidth / containerHeight;
+            const fbAspectRatio = vp.w / vp.h;
+
+            if (fbAspectRatio >= targetAspectRatio) {
+                scaleRatio = containerWidth / vp.w;
+            } else {
+                scaleRatio = containerHeight / vp.h;
+            }
+        }
+
+        this._rescale(scaleRatio);
+    }
+
+    // ===== PRIVATE METHODS =====
+
+    _rescale(factor) {
+        this._scale = factor;
+        const vp = this._viewportLoc;
+
+        // NB(directxman12): If you set the width directly, or set the
+        //                   style width to a number, the canvas is cleared.
+        //                   However, if you set the style width to a string
+        //                   ('NNNpx'), the canvas is scaled without clearing.
+        const width = factor * vp.w + 'px';
+        const height = factor * vp.h + 'px';
+
+        if ((this._target.style.width !== width) ||
+            (this._target.style.height !== height)) {
+            this._target.style.width = width;
+            this._target.style.height = height;
+        }
+    }
+
+    _setFillColor(color) {
+        const newStyle = 'rgb(' + color[0] + ',' + color[1] + ',' + color[2] + ')';
+        if (newStyle !== this._prevDrawStyle) {
+            this._drawCtx.fillStyle = newStyle;
+            this._prevDrawStyle = newStyle;
+        }
+    }
+
+    _renderQPush(action) {
+        this._renderQ.push(action);
+        if (this._renderQ.length === 1) {
+            // If this can be rendered immediately it will be, otherwise
+            // the scanner will wait for the relevant event
+            this._scanRenderQ();
+        }
+    }
+
+    _resumeRenderQ() {
+        // "this" is the object that is ready, not the
+        // display object
+        this.removeEventListener('load', this._noVNCDisplay._resumeRenderQ);
+        this._noVNCDisplay._scanRenderQ();
+    }
+
+    _scanRenderQ() {
+        let ready = true;
+        while (ready && this._renderQ.length > 0) {
+            const a = this._renderQ[0];
+            switch (a.type) {
+                case 'flip':
+                    this.flip(true);
+                    break;
+                case 'copy':
+                    this.copyImage(a.oldX, a.oldY, a.x, a.y, a.width, a.height, true);
+                    break;
+                case 'fill':
+                    this.fillRect(a.x, a.y, a.width, a.height, a.color, true);
+                    break;
+                case 'blit':
+                    this.blitImage(a.x, a.y, a.width, a.height, a.data, 0, true);
+                    break;
+                case 'img':
+                    if (a.img.complete) {
+                        if (a.img.width !== a.width || a.img.height !== a.height) {
+                            Log.Error("Decoded image has incorrect dimensions. Got " +
+                                      a.img.width + "x" + a.img.height + ". Expected " +
+                                      a.width + "x" + a.height + ".");
+                            return;
+                        }
+                        this.drawImage(a.img, a.x, a.y);
+                    } else {
+                        a.img._noVNCDisplay = this;
+                        a.img.addEventListener('load', this._resumeRenderQ);
+                        // We need to wait for this image to 'load'
+                        // to keep things in-order
+                        ready = false;
+                    }
+                    break;
+            }
+
+            if (ready) {
+                this._renderQ.shift();
+            }
+        }
+
+        if (this._renderQ.length === 0 && this._flushing) {
+            this._flushing = false;
+            this.onflush();
+        }
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/encodings.js
@@ -0,0 +1,48 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+export const encodings = {
+    encodingRaw: 0,
+    encodingCopyRect: 1,
+    encodingRRE: 2,
+    encodingHextile: 5,
+    encodingTight: 7,
+    encodingZRLE: 16,
+    encodingTightPNG: -260,
+    encodingJPEG: 21,
+
+    pseudoEncodingQualityLevel9: -23,
+    pseudoEncodingQualityLevel0: -32,
+    pseudoEncodingDesktopSize: -223,
+    pseudoEncodingLastRect: -224,
+    pseudoEncodingCursor: -239,
+    pseudoEncodingQEMUExtendedKeyEvent: -258,
+    pseudoEncodingDesktopName: -307,
+    pseudoEncodingExtendedDesktopSize: -308,
+    pseudoEncodingXvp: -309,
+    pseudoEncodingFence: -312,
+    pseudoEncodingContinuousUpdates: -313,
+    pseudoEncodingCompressLevel9: -247,
+    pseudoEncodingCompressLevel0: -256,
+    pseudoEncodingVMwareCursor: 0x574d5664,
+    pseudoEncodingExtendedClipboard: 0xc0a1e5ce
+};
+
+export function encodingName(num) {
+    switch (num) {
+        case encodings.encodingRaw:      return "Raw";
+        case encodings.encodingCopyRect: return "CopyRect";
+        case encodings.encodingRRE:      return "RRE";
+        case encodings.encodingHextile:  return "Hextile";
+        case encodings.encodingTight:    return "Tight";
+        case encodings.encodingZRLE:     return "ZRLE";
+        case encodings.encodingTightPNG: return "TightPNG";
+        case encodings.encodingJPEG:     return "JPEG";
+        default:                         return "[unknown encoding " + num + "]";
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/inflator.js
@@ -0,0 +1,66 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2020 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+import { inflateInit, inflate, inflateReset } from "../vendor/pako/lib/zlib/inflate.js";
+import ZStream from "../vendor/pako/lib/zlib/zstream.js";
+
+export default class Inflate {
+    constructor() {
+        this.strm = new ZStream();
+        this.chunkSize = 1024 * 10 * 10;
+        this.strm.output = new Uint8Array(this.chunkSize);
+        this.windowBits = 5;
+
+        inflateInit(this.strm, this.windowBits);
+    }
+
+    setInput(data) {
+        if (!data) {
+            //FIXME: flush remaining data.
+            /* eslint-disable camelcase */
+            this.strm.input = null;
+            this.strm.avail_in = 0;
+            this.strm.next_in = 0;
+        } else {
+            this.strm.input = data;
+            this.strm.avail_in = this.strm.input.length;
+            this.strm.next_in = 0;
+            /* eslint-enable camelcase */
+        }
+    }
+
+    inflate(expected) {
+        // resize our output buffer if it's too small
+        // (we could just use multiple chunks, but that would cause an extra
+        // allocation each time to flatten the chunks)
+        if (expected > this.chunkSize) {
+            this.chunkSize = expected;
+            this.strm.output = new Uint8Array(this.chunkSize);
+        }
+
+        /* eslint-disable camelcase */
+        this.strm.next_out = 0;
+        this.strm.avail_out = expected;
+        /* eslint-enable camelcase */
+
+        let ret = inflate(this.strm, 0); // Flush argument not used.
+        if (ret < 0) {
+            throw new Error("zlib inflate failed");
+        }
+
+        if (this.strm.next_out != expected) {
+            throw new Error("Incomplete zlib block");
+        }
+
+        return new Uint8Array(this.strm.output.buffer, 0, this.strm.next_out);
+    }
+
+    reset() {
+        inflateReset(this.strm);
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/input/domkeytable.js
@@ -0,0 +1,311 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2018 The noVNC Authors
+ * Licensed under MPL 2.0 or any later version (see LICENSE.txt)
+ */
+
+import KeyTable from "./keysym.js";
+
+/*
+ * Mapping between HTML key values and VNC/X11 keysyms for "special"
+ * keys that cannot be handled via their Unicode codepoint.
+ *
+ * See https://www.w3.org/TR/uievents-key/ for possible values.
+ */
+
+const DOMKeyTable = {};
+
+function addStandard(key, standard) {
+    if (standard === undefined) throw new Error("Undefined keysym for key \"" + key + "\"");
+    if (key in DOMKeyTable) throw new Error("Duplicate entry for key \"" + key + "\"");
+    DOMKeyTable[key] = [standard, standard, standard, standard];
+}
+
+function addLeftRight(key, left, right) {
+    if (left === undefined) throw new Error("Undefined keysym for key \"" + key + "\"");
+    if (right === undefined) throw new Error("Undefined keysym for key \"" + key + "\"");
+    if (key in DOMKeyTable) throw new Error("Duplicate entry for key \"" + key + "\"");
+    DOMKeyTable[key] = [left, left, right, left];
+}
+
+function addNumpad(key, standard, numpad) {
+    if (standard === undefined) throw new Error("Undefined keysym for key \"" + key + "\"");
+    if (numpad === undefined) throw new Error("Undefined keysym for key \"" + key + "\"");
+    if (key in DOMKeyTable) throw new Error("Duplicate entry for key \"" + key + "\"");
+    DOMKeyTable[key] = [standard, standard, standard, numpad];
+}
+
+// 3.2. Modifier Keys
+
+addLeftRight("Alt", KeyTable.XK_Alt_L, KeyTable.XK_Alt_R);
+addStandard("AltGraph", KeyTable.XK_ISO_Level3_Shift);
+addStandard("CapsLock", KeyTable.XK_Caps_Lock);
+addLeftRight("Control", KeyTable.XK_Control_L, KeyTable.XK_Control_R);
+// - Fn
+// - FnLock
+addLeftRight("Meta", KeyTable.XK_Super_L, KeyTable.XK_Super_R);
+addStandard("NumLock", KeyTable.XK_Num_Lock);
+addStandard("ScrollLock", KeyTable.XK_Scroll_Lock);
+addLeftRight("Shift", KeyTable.XK_Shift_L, KeyTable.XK_Shift_R);
+// - Symbol
+// - SymbolLock
+// - Hyper
+// - Super
+
+// 3.3. Whitespace Keys
+
+addNumpad("Enter", KeyTable.XK_Return, KeyTable.XK_KP_Enter);
+addStandard("Tab", KeyTable.XK_Tab);
+addNumpad(" ", KeyTable.XK_space, KeyTable.XK_KP_Space);
+
+// 3.4. Navigation Keys
+
+addNumpad("ArrowDown", KeyTable.XK_Down, KeyTable.XK_KP_Down);
+addNumpad("ArrowLeft", KeyTable.XK_Left, KeyTable.XK_KP_Left);
+addNumpad("ArrowRight", KeyTable.XK_Right, KeyTable.XK_KP_Right);
+addNumpad("ArrowUp", KeyTable.XK_Up, KeyTable.XK_KP_Up);
+addNumpad("End", KeyTable.XK_End, KeyTable.XK_KP_End);
+addNumpad("Home", KeyTable.XK_Home, KeyTable.XK_KP_Home);
+addNumpad("PageDown", KeyTable.XK_Next, KeyTable.XK_KP_Next);
+addNumpad("PageUp", KeyTable.XK_Prior, KeyTable.XK_KP_Prior);
+
+// 3.5. Editing Keys
+
+addStandard("Backspace", KeyTable.XK_BackSpace);
+// Browsers send "Clear" for the numpad 5 without NumLock because
+// Windows uses VK_Clear for that key. But Unix expects KP_Begin for
+// that scenario.
+addNumpad("Clear", KeyTable.XK_Clear, KeyTable.XK_KP_Begin);
+addStandard("Copy", KeyTable.XF86XK_Copy);
+// - CrSel
+addStandard("Cut", KeyTable.XF86XK_Cut);
+addNumpad("Delete", KeyTable.XK_Delete, KeyTable.XK_KP_Delete);
+// - EraseEof
+// - ExSel
+addNumpad("Insert", KeyTable.XK_Insert, KeyTable.XK_KP_Insert);
+addStandard("Paste", KeyTable.XF86XK_Paste);
+addStandard("Redo", KeyTable.XK_Redo);
+addStandard("Undo", KeyTable.XK_Undo);
+
+// 3.6. UI Keys
+
+// - Accept
+// - Again (could just be XK_Redo)
+// - Attn
+addStandard("Cancel", KeyTable.XK_Cancel);
+addStandard("ContextMenu", KeyTable.XK_Menu);
+addStandard("Escape", KeyTable.XK_Escape);
+addStandard("Execute", KeyTable.XK_Execute);
+addStandard("Find", KeyTable.XK_Find);
+addStandard("Help", KeyTable.XK_Help);
+addStandard("Pause", KeyTable.XK_Pause);
+// - Play
+// - Props
+addStandard("Select", KeyTable.XK_Select);
+addStandard("ZoomIn", KeyTable.XF86XK_ZoomIn);
+addStandard("ZoomOut", KeyTable.XF86XK_ZoomOut);
+
+// 3.7. Device Keys
+
+addStandard("BrightnessDown", KeyTable.XF86XK_MonBrightnessDown);
+addStandard("BrightnessUp", KeyTable.XF86XK_MonBrightnessUp);
+addStandard("Eject", KeyTable.XF86XK_Eject);
+addStandard("LogOff", KeyTable.XF86XK_LogOff);
+addStandard("Power", KeyTable.XF86XK_PowerOff);
+addStandard("PowerOff", KeyTable.XF86XK_PowerDown);
+addStandard("PrintScreen", KeyTable.XK_Print);
+addStandard("Hibernate", KeyTable.XF86XK_Hibernate);
+addStandard("Standby", KeyTable.XF86XK_Standby);
+addStandard("WakeUp", KeyTable.XF86XK_WakeUp);
+
+// 3.8. IME and Composition Keys
+
+addStandard("AllCandidates", KeyTable.XK_MultipleCandidate);
+addStandard("Alphanumeric", KeyTable.XK_Eisu_toggle);
+addStandard("CodeInput", KeyTable.XK_Codeinput);
+addStandard("Compose", KeyTable.XK_Multi_key);
+addStandard("Convert", KeyTable.XK_Henkan);
+// - Dead
+// - FinalMode
+addStandard("GroupFirst", KeyTable.XK_ISO_First_Group);
+addStandard("GroupLast", KeyTable.XK_ISO_Last_Group);
+addStandard("GroupNext", KeyTable.XK_ISO_Next_Group);
+addStandard("GroupPrevious", KeyTable.XK_ISO_Prev_Group);
+// - ModeChange (XK_Mode_switch is often used for AltGr)
+// - NextCandidate
+addStandard("NonConvert", KeyTable.XK_Muhenkan);
+addStandard("PreviousCandidate", KeyTable.XK_PreviousCandidate);
+// - Process
+addStandard("SingleCandidate", KeyTable.XK_SingleCandidate);
+addStandard("HangulMode", KeyTable.XK_Hangul);
+addStandard("HanjaMode", KeyTable.XK_Hangul_Hanja);
+addStandard("JunjaMode", KeyTable.XK_Hangul_Jeonja);
+addStandard("Eisu", KeyTable.XK_Eisu_toggle);
+addStandard("Hankaku", KeyTable.XK_Hankaku);
+addStandard("Hiragana", KeyTable.XK_Hiragana);
+addStandard("HiraganaKatakana", KeyTable.XK_Hiragana_Katakana);
+addStandard("KanaMode", KeyTable.XK_Kana_Shift); // could also be _Kana_Lock
+addStandard("KanjiMode", KeyTable.XK_Kanji);
+addStandard("Katakana", KeyTable.XK_Katakana);
+addStandard("Romaji", KeyTable.XK_Romaji);
+addStandard("Zenkaku", KeyTable.XK_Zenkaku);
+addStandard("ZenkakuHankaku", KeyTable.XK_Zenkaku_Hankaku);
+
+// 3.9. General-Purpose Function Keys
+
+addStandard("F1", KeyTable.XK_F1);
+addStandard("F2", KeyTable.XK_F2);
+addStandard("F3", KeyTable.XK_F3);
+addStandard("F4", KeyTable.XK_F4);
+addStandard("F5", KeyTable.XK_F5);
+addStandard("F6", KeyTable.XK_F6);
+addStandard("F7", KeyTable.XK_F7);
+addStandard("F8", KeyTable.XK_F8);
+addStandard("F9", KeyTable.XK_F9);
+addStandard("F10", KeyTable.XK_F10);
+addStandard("F11", KeyTable.XK_F11);
+addStandard("F12", KeyTable.XK_F12);
+addStandard("F13", KeyTable.XK_F13);
+addStandard("F14", KeyTable.XK_F14);
+addStandard("F15", KeyTable.XK_F15);
+addStandard("F16", KeyTable.XK_F16);
+addStandard("F17", KeyTable.XK_F17);
+addStandard("F18", KeyTable.XK_F18);
+addStandard("F19", KeyTable.XK_F19);
+addStandard("F20", KeyTable.XK_F20);
+addStandard("F21", KeyTable.XK_F21);
+addStandard("F22", KeyTable.XK_F22);
+addStandard("F23", KeyTable.XK_F23);
+addStandard("F24", KeyTable.XK_F24);
+addStandard("F25", KeyTable.XK_F25);
+addStandard("F26", KeyTable.XK_F26);
+addStandard("F27", KeyTable.XK_F27);
+addStandard("F28", KeyTable.XK_F28);
+addStandard("F29", KeyTable.XK_F29);
+addStandard("F30", KeyTable.XK_F30);
+addStandard("F31", KeyTable.XK_F31);
+addStandard("F32", KeyTable.XK_F32);
+addStandard("F33", KeyTable.XK_F33);
+addStandard("F34", KeyTable.XK_F34);
+addStandard("F35", KeyTable.XK_F35);
+// - Soft1...
+
+// 3.10. Multimedia Keys
+
+// - ChannelDown
+// - ChannelUp
+addStandard("Close", KeyTable.XF86XK_Close);
+addStandard("MailForward", KeyTable.XF86XK_MailForward);
+addStandard("MailReply", KeyTable.XF86XK_Reply);
+addStandard("MailSend", KeyTable.XF86XK_Send);
+// - MediaClose
+addStandard("MediaFastForward", KeyTable.XF86XK_AudioForward);
+addStandard("MediaPause", KeyTable.XF86XK_AudioPause);
+addStandard("MediaPlay", KeyTable.XF86XK_AudioPlay);
+// - MediaPlayPause
+addStandard("MediaRecord", KeyTable.XF86XK_AudioRecord);
+addStandard("MediaRewind", KeyTable.XF86XK_AudioRewind);
+addStandard("MediaStop", KeyTable.XF86XK_AudioStop);
+addStandard("MediaTrackNext", KeyTable.XF86XK_AudioNext);
+addStandard("MediaTrackPrevious", KeyTable.XF86XK_AudioPrev);
+addStandard("New", KeyTable.XF86XK_New);
+addStandard("Open", KeyTable.XF86XK_Open);
+addStandard("Print", KeyTable.XK_Print);
+addStandard("Save", KeyTable.XF86XK_Save);
+addStandard("SpellCheck", KeyTable.XF86XK_Spell);
+
+// 3.11. Multimedia Numpad Keys
+
+// - Key11
+// - Key12
+
+// 3.12. Audio Keys
+
+// - AudioBalanceLeft
+// - AudioBalanceRight
+// - AudioBassBoostDown
+// - AudioBassBoostToggle
+// - AudioBassBoostUp
+// - AudioFaderFront
+// - AudioFaderRear
+// - AudioSurroundModeNext
+// - AudioTrebleDown
+// - AudioTrebleUp
+addStandard("AudioVolumeDown", KeyTable.XF86XK_AudioLowerVolume);
+addStandard("AudioVolumeUp", KeyTable.XF86XK_AudioRaiseVolume);
+addStandard("AudioVolumeMute", KeyTable.XF86XK_AudioMute);
+// - MicrophoneToggle
+// - MicrophoneVolumeDown
+// - MicrophoneVolumeUp
+addStandard("MicrophoneVolumeMute", KeyTable.XF86XK_AudioMicMute);
+
+// 3.13. Speech Keys
+
+// - SpeechCorrectionList
+// - SpeechInputToggle
+
+// 3.14. Application Keys
+
+addStandard("LaunchApplication1", KeyTable.XF86XK_MyComputer);
+addStandard("LaunchApplication2", KeyTable.XF86XK_Calculator);
+addStandard("LaunchCalendar", KeyTable.XF86XK_Calendar);
+// - LaunchContacts
+addStandard("LaunchMail", KeyTable.XF86XK_Mail);
+addStandard("LaunchMediaPlayer", KeyTable.XF86XK_AudioMedia);
+addStandard("LaunchMusicPlayer", KeyTable.XF86XK_Music);
+addStandard("LaunchPhone", KeyTable.XF86XK_Phone);
+addStandard("LaunchScreenSaver", KeyTable.XF86XK_ScreenSaver);
+addStandard("LaunchSpreadsheet", KeyTable.XF86XK_Excel);
+addStandard("LaunchWebBrowser", KeyTable.XF86XK_WWW);
+addStandard("LaunchWebCam", KeyTable.XF86XK_WebCam);
+addStandard("LaunchWordProcessor", KeyTable.XF86XK_Word);
+
+// 3.15. Browser Keys
+
+addStandard("BrowserBack", KeyTable.XF86XK_Back);
+addStandard("BrowserFavorites", KeyTable.XF86XK_Favorites);
+addStandard("BrowserForward", KeyTable.XF86XK_Forward);
+addStandard("BrowserHome", KeyTable.XF86XK_HomePage);
+addStandard("BrowserRefresh", KeyTable.XF86XK_Refresh);
+addStandard("BrowserSearch", KeyTable.XF86XK_Search);
+addStandard("BrowserStop", KeyTable.XF86XK_Stop);
+
+// 3.16. Mobile Phone Keys
+
+// - A whole bunch...
+
+// 3.17. TV Keys
+
+// - A whole bunch...
+
+// 3.18. Media Controller Keys
+
+// - A whole bunch...
+addStandard("Dimmer", KeyTable.XF86XK_BrightnessAdjust);
+addStandard("MediaAudioTrack", KeyTable.XF86XK_AudioCycleTrack);
+addStandard("RandomToggle", KeyTable.XF86XK_AudioRandomPlay);
+addStandard("SplitScreenToggle", KeyTable.XF86XK_SplitScreen);
+addStandard("Subtitle", KeyTable.XF86XK_Subtitle);
+addStandard("VideoModeNext", KeyTable.XF86XK_Next_VMode);
+
+// Extra: Numpad
+
+addNumpad("=", KeyTable.XK_equal, KeyTable.XK_KP_Equal);
+addNumpad("+", KeyTable.XK_plus, KeyTable.XK_KP_Add);
+addNumpad("-", KeyTable.XK_minus, KeyTable.XK_KP_Subtract);
+addNumpad("*", KeyTable.XK_asterisk, KeyTable.XK_KP_Multiply);
+addNumpad("/", KeyTable.XK_slash, KeyTable.XK_KP_Divide);
+addNumpad(".", KeyTable.XK_period, KeyTable.XK_KP_Decimal);
+addNumpad(",", KeyTable.XK_comma, KeyTable.XK_KP_Separator);
+addNumpad("0", KeyTable.XK_0, KeyTable.XK_KP_0);
+addNumpad("1", KeyTable.XK_1, KeyTable.XK_KP_1);
+addNumpad("2", KeyTable.XK_2, KeyTable.XK_KP_2);
+addNumpad("3", KeyTable.XK_3, KeyTable.XK_KP_3);
+addNumpad("4", KeyTable.XK_4, KeyTable.XK_KP_4);
+addNumpad("5", KeyTable.XK_5, KeyTable.XK_KP_5);
+addNumpad("6", KeyTable.XK_6, KeyTable.XK_KP_6);
+addNumpad("7", KeyTable.XK_7, KeyTable.XK_KP_7);
+addNumpad("8", KeyTable.XK_8, KeyTable.XK_KP_8);
+addNumpad("9", KeyTable.XK_9, KeyTable.XK_KP_9);
+
+export default DOMKeyTable;
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/input/fixedkeys.js
@@ -0,0 +1,129 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2018 The noVNC Authors
+ * Licensed under MPL 2.0 or any later version (see LICENSE.txt)
+ */
+
+/*
+ * Fallback mapping between HTML key codes (physical keys) and
+ * HTML key values. This only works for keys that don't vary
+ * between layouts. We also omit those who manage fine by mapping the
+ * Unicode representation.
+ *
+ * See https://www.w3.org/TR/uievents-code/ for possible codes.
+ * See https://www.w3.org/TR/uievents-key/ for possible values.
+ */
+
+/* eslint-disable key-spacing */
+
+export default {
+
+// 3.1.1.1. Writing System Keys
+
+    'Backspace':        'Backspace',
+
+// 3.1.1.2. Functional Keys
+
+    'AltLeft':          'Alt',
+    'AltRight':         'Alt', // This could also be 'AltGraph'
+    'CapsLock':         'CapsLock',
+    'ContextMenu':      'ContextMenu',
+    'ControlLeft':      'Control',
+    'ControlRight':     'Control',
+    'Enter':            'Enter',
+    'MetaLeft':         'Meta',
+    'MetaRight':        'Meta',
+    'ShiftLeft':        'Shift',
+    'ShiftRight':       'Shift',
+    'Tab':              'Tab',
+    // FIXME: Japanese/Korean keys
+
+// 3.1.2. Control Pad Section
+
+    'Delete':           'Delete',
+    'End':              'End',
+    'Help':             'Help',
+    'Home':             'Home',
+    'Insert':           'Insert',
+    'PageDown':         'PageDown',
+    'PageUp':           'PageUp',
+
+// 3.1.3. Arrow Pad Section
+
+    'ArrowDown':        'ArrowDown',
+    'ArrowLeft':        'ArrowLeft',
+    'ArrowRight':       'ArrowRight',
+    'ArrowUp':          'ArrowUp',
+
+// 3.1.4. Numpad Section
+
+    'NumLock':          'NumLock',
+    'NumpadBackspace':  'Backspace',
+    'NumpadClear':      'Clear',
+
+// 3.1.5. Function Section
+
+    'Escape':           'Escape',
+    'F1':               'F1',
+    'F2':               'F2',
+    'F3':               'F3',
+    'F4':               'F4',
+    'F5':               'F5',
+    'F6':               'F6',
+    'F7':               'F7',
+    'F8':               'F8',
+    'F9':               'F9',
+    'F10':              'F10',
+    'F11':              'F11',
+    'F12':              'F12',
+    'F13':              'F13',
+    'F14':              'F14',
+    'F15':              'F15',
+    'F16':              'F16',
+    'F17':              'F17',
+    'F18':              'F18',
+    'F19':              'F19',
+    'F20':              'F20',
+    'F21':              'F21',
+    'F22':              'F22',
+    'F23':              'F23',
+    'F24':              'F24',
+    'F25':              'F25',
+    'F26':              'F26',
+    'F27':              'F27',
+    'F28':              'F28',
+    'F29':              'F29',
+    'F30':              'F30',
+    'F31':              'F31',
+    'F32':              'F32',
+    'F33':              'F33',
+    'F34':              'F34',
+    'F35':              'F35',
+    'PrintScreen':      'PrintScreen',
+    'ScrollLock':       'ScrollLock',
+    'Pause':            'Pause',
+
+// 3.1.6. Media Keys
+
+    'BrowserBack':      'BrowserBack',
+    'BrowserFavorites': 'BrowserFavorites',
+    'BrowserForward':   'BrowserForward',
+    'BrowserHome':      'BrowserHome',
+    'BrowserRefresh':   'BrowserRefresh',
+    'BrowserSearch':    'BrowserSearch',
+    'BrowserStop':      'BrowserStop',
+    'Eject':            'Eject',
+    'LaunchApp1':       'LaunchMyComputer',
+    'LaunchApp2':       'LaunchCalendar',
+    'LaunchMail':       'LaunchMail',
+    'MediaPlayPause':   'MediaPlay',
+    'MediaStop':        'MediaStop',
+    'MediaTrackNext':   'MediaTrackNext',
+    'MediaTrackPrevious': 'MediaTrackPrevious',
+    'Power':            'Power',
+    'Sleep':            'Sleep',
+    'AudioVolumeDown':  'AudioVolumeDown',
+    'AudioVolumeMute':  'AudioVolumeMute',
+    'AudioVolumeUp':    'AudioVolumeUp',
+    'WakeUp':           'WakeUp',
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/input/gesturehandler.js
@@ -0,0 +1,567 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2020 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ *
+ */
+
+const GH_NOGESTURE = 0;
+const GH_ONETAP    = 1;
+const GH_TWOTAP    = 2;
+const GH_THREETAP  = 4;
+const GH_DRAG      = 8;
+const GH_LONGPRESS = 16;
+const GH_TWODRAG   = 32;
+const GH_PINCH     = 64;
+
+const GH_INITSTATE = 127;
+
+const GH_MOVE_THRESHOLD = 50;
+const GH_ANGLE_THRESHOLD = 90; // Degrees
+
+// Timeout when waiting for gestures (ms)
+const GH_MULTITOUCH_TIMEOUT = 250;
+
+// Maximum time between press and release for a tap (ms)
+const GH_TAP_TIMEOUT = 1000;
+
+// Timeout when waiting for longpress (ms)
+const GH_LONGPRESS_TIMEOUT = 1000;
+
+// Timeout when waiting to decide between PINCH and TWODRAG (ms)
+const GH_TWOTOUCH_TIMEOUT = 50;
+
+export default class GestureHandler {
+    constructor() {
+        this._target = null;
+
+        this._state = GH_INITSTATE;
+
+        this._tracked = [];
+        this._ignored = [];
+
+        this._waitingRelease = false;
+        this._releaseStart = 0.0;
+
+        this._longpressTimeoutId = null;
+        this._twoTouchTimeoutId = null;
+
+        this._boundEventHandler = this._eventHandler.bind(this);
+    }
+
+    attach(target) {
+        this.detach();
+
+        this._target = target;
+        this._target.addEventListener('touchstart',
+                                      this._boundEventHandler);
+        this._target.addEventListener('touchmove',
+                                      this._boundEventHandler);
+        this._target.addEventListener('touchend',
+                                      this._boundEventHandler);
+        this._target.addEventListener('touchcancel',
+                                      this._boundEventHandler);
+    }
+
+    detach() {
+        if (!this._target) {
+            return;
+        }
+
+        this._stopLongpressTimeout();
+        this._stopTwoTouchTimeout();
+
+        this._target.removeEventListener('touchstart',
+                                         this._boundEventHandler);
+        this._target.removeEventListener('touchmove',
+                                         this._boundEventHandler);
+        this._target.removeEventListener('touchend',
+                                         this._boundEventHandler);
+        this._target.removeEventListener('touchcancel',
+                                         this._boundEventHandler);
+        this._target = null;
+    }
+
+    _eventHandler(e) {
+        let fn;
+
+        e.stopPropagation();
+        e.preventDefault();
+
+        switch (e.type) {
+            case 'touchstart':
+                fn = this._touchStart;
+                break;
+            case 'touchmove':
+                fn = this._touchMove;
+                break;
+            case 'touchend':
+            case 'touchcancel':
+                fn = this._touchEnd;
+                break;
+        }
+
+        for (let i = 0; i < e.changedTouches.length; i++) {
+            let touch = e.changedTouches[i];
+            fn.call(this, touch.identifier, touch.clientX, touch.clientY);
+        }
+    }
+
+    _touchStart(id, x, y) {
+        // Ignore any new touches if there is already an active gesture,
+        // or we're in a cleanup state
+        if (this._hasDetectedGesture() || (this._state === GH_NOGESTURE)) {
+            this._ignored.push(id);
+            return;
+        }
+
+        // Did it take too long between touches that we should no longer
+        // consider this a single gesture?
+        if ((this._tracked.length > 0) &&
+            ((Date.now() - this._tracked[0].started) > GH_MULTITOUCH_TIMEOUT)) {
+            this._state = GH_NOGESTURE;
+            this._ignored.push(id);
+            return;
+        }
+
+        // If we're waiting for fingers to release then we should no longer
+        // recognize new touches
+        if (this._waitingRelease) {
+            this._state = GH_NOGESTURE;
+            this._ignored.push(id);
+            return;
+        }
+
+        this._tracked.push({
+            id: id,
+            started: Date.now(),
+            active: true,
+            firstX: x,
+            firstY: y,
+            lastX: x,
+            lastY: y,
+            angle: 0
+        });
+
+        switch (this._tracked.length) {
+            case 1:
+                this._startLongpressTimeout();
+                break;
+
+            case 2:
+                this._state &= ~(GH_ONETAP | GH_DRAG | GH_LONGPRESS);
+                this._stopLongpressTimeout();
+                break;
+
+            case 3:
+                this._state &= ~(GH_TWOTAP | GH_TWODRAG | GH_PINCH);
+                break;
+
+            default:
+                this._state = GH_NOGESTURE;
+        }
+    }
+
+    _touchMove(id, x, y) {
+        let touch = this._tracked.find(t => t.id === id);
+
+        // If this is an update for a touch we're not tracking, ignore it
+        if (touch === undefined) {
+            return;
+        }
+
+        // Update the touches last position with the event coordinates
+        touch.lastX = x;
+        touch.lastY = y;
+
+        let deltaX = x - touch.firstX;
+        let deltaY = y - touch.firstY;
+
+        // Update angle when the touch has moved
+        if ((touch.firstX !== touch.lastX) ||
+            (touch.firstY !== touch.lastY)) {
+            touch.angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
+        }
+
+        if (!this._hasDetectedGesture()) {
+            // Ignore moves smaller than the minimum threshold
+            if (Math.hypot(deltaX, deltaY) < GH_MOVE_THRESHOLD) {
+                return;
+            }
+
+            // Can't be a tap or long press as we've seen movement
+            this._state &= ~(GH_ONETAP | GH_TWOTAP | GH_THREETAP | GH_LONGPRESS);
+            this._stopLongpressTimeout();
+
+            if (this._tracked.length !== 1) {
+                this._state &= ~(GH_DRAG);
+            }
+            if (this._tracked.length !== 2) {
+                this._state &= ~(GH_TWODRAG | GH_PINCH);
+            }
+
+            // We need to figure out which of our different two touch gestures
+            // this might be
+            if (this._tracked.length === 2) {
+
+                // The other touch is the one where the id doesn't match
+                let prevTouch = this._tracked.find(t => t.id !== id);
+
+                // How far the previous touch point has moved since start
+                let prevDeltaMove = Math.hypot(prevTouch.firstX - prevTouch.lastX,
+                                               prevTouch.firstY - prevTouch.lastY);
+
+                // We know that the current touch moved far enough,
+                // but unless both touches moved further than their
+                // threshold we don't want to disqualify any gestures
+                if (prevDeltaMove > GH_MOVE_THRESHOLD) {
+
+                    // The angle difference between the direction of the touch points
+                    let deltaAngle = Math.abs(touch.angle - prevTouch.angle);
+                    deltaAngle = Math.abs(((deltaAngle + 180) % 360) - 180);
+
+                    // PINCH or TWODRAG can be eliminated depending on the angle
+                    if (deltaAngle > GH_ANGLE_THRESHOLD) {
+                        this._state &= ~GH_TWODRAG;
+                    } else {
+                        this._state &= ~GH_PINCH;
+                    }
+
+                    if (this._isTwoTouchTimeoutRunning()) {
+                        this._stopTwoTouchTimeout();
+                    }
+                } else if (!this._isTwoTouchTimeoutRunning()) {
+                    // We can't determine the gesture right now, let's
+                    // wait and see if more events are on their way
+                    this._startTwoTouchTimeout();
+                }
+            }
+
+            if (!this._hasDetectedGesture()) {
+                return;
+            }
+
+            this._pushEvent('gesturestart');
+        }
+
+        this._pushEvent('gesturemove');
+    }
+
+    _touchEnd(id, x, y) {
+        // Check if this is an ignored touch
+        if (this._ignored.indexOf(id) !== -1) {
+            // Remove this touch from ignored
+            this._ignored.splice(this._ignored.indexOf(id), 1);
+
+            // And reset the state if there are no more touches
+            if ((this._ignored.length === 0) &&
+                (this._tracked.length === 0)) {
+                this._state = GH_INITSTATE;
+                this._waitingRelease = false;
+            }
+            return;
+        }
+
+        // We got a touchend before the timer triggered,
+        // this cannot result in a gesture anymore.
+        if (!this._hasDetectedGesture() &&
+            this._isTwoTouchTimeoutRunning()) {
+            this._stopTwoTouchTimeout();
+            this._state = GH_NOGESTURE;
+        }
+
+        // Some gestures don't trigger until a touch is released
+        if (!this._hasDetectedGesture()) {
+            // Can't be a gesture that relies on movement
+            this._state &= ~(GH_DRAG | GH_TWODRAG | GH_PINCH);
+            // Or something that relies on more time
+            this._state &= ~GH_LONGPRESS;
+            this._stopLongpressTimeout();
+
+            if (!this._waitingRelease) {
+                this._releaseStart = Date.now();
+                this._waitingRelease = true;
+
+                // Can't be a tap that requires more touches than we current have
+                switch (this._tracked.length) {
+                    case 1:
+                        this._state &= ~(GH_TWOTAP | GH_THREETAP);
+                        break;
+
+                    case 2:
+                        this._state &= ~(GH_ONETAP | GH_THREETAP);
+                        break;
+                }
+            }
+        }
+
+        // Waiting for all touches to release? (i.e. some tap)
+        if (this._waitingRelease) {
+            // Were all touches released at roughly the same time?
+            if ((Date.now() - this._releaseStart) > GH_MULTITOUCH_TIMEOUT) {
+                this._state = GH_NOGESTURE;
+            }
+
+            // Did too long time pass between press and release?
+            if (this._tracked.some(t => (Date.now() - t.started) > GH_TAP_TIMEOUT)) {
+                this._state = GH_NOGESTURE;
+            }
+
+            let touch = this._tracked.find(t => t.id === id);
+            touch.active = false;
+
+            // Are we still waiting for more releases?
+            if (this._hasDetectedGesture()) {
+                this._pushEvent('gesturestart');
+            } else {
+                // Have we reached a dead end?
+                if (this._state !== GH_NOGESTURE) {
+                    return;
+                }
+            }
+        }
+
+        if (this._hasDetectedGesture()) {
+            this._pushEvent('gestureend');
+        }
+
+        // Ignore any remaining touches until they are ended
+        for (let i = 0; i < this._tracked.length; i++) {
+            if (this._tracked[i].active) {
+                this._ignored.push(this._tracked[i].id);
+            }
+        }
+        this._tracked = [];
+
+        this._state = GH_NOGESTURE;
+
+        // Remove this touch from ignored if it's in there
+        if (this._ignored.indexOf(id) !== -1) {
+            this._ignored.splice(this._ignored.indexOf(id), 1);
+        }
+
+        // We reset the state if ignored is empty
+        if ((this._ignored.length === 0)) {
+            this._state = GH_INITSTATE;
+            this._waitingRelease = false;
+        }
+    }
+
+    _hasDetectedGesture() {
+        if (this._state === GH_NOGESTURE) {
+            return false;
+        }
+        // Check to see if the bitmask value is a power of 2
+        // (i.e. only one bit set). If it is, we have a state.
+        if (this._state & (this._state - 1)) {
+            return false;
+        }
+
+        // For taps we also need to have all touches released
+        // before we've fully detected the gesture
+        if (this._state & (GH_ONETAP | GH_TWOTAP | GH_THREETAP)) {
+            if (this._tracked.some(t => t.active)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    _startLongpressTimeout() {
+        this._stopLongpressTimeout();
+        this._longpressTimeoutId = setTimeout(() => this._longpressTimeout(),
+                                              GH_LONGPRESS_TIMEOUT);
+    }
+
+    _stopLongpressTimeout() {
+        clearTimeout(this._longpressTimeoutId);
+        this._longpressTimeoutId = null;
+    }
+
+    _longpressTimeout() {
+        if (this._hasDetectedGesture()) {
+            throw new Error("A longpress gesture failed, conflict with a different gesture");
+        }
+
+        this._state = GH_LONGPRESS;
+        this._pushEvent('gesturestart');
+    }
+
+    _startTwoTouchTimeout() {
+        this._stopTwoTouchTimeout();
+        this._twoTouchTimeoutId = setTimeout(() => this._twoTouchTimeout(),
+                                             GH_TWOTOUCH_TIMEOUT);
+    }
+
+    _stopTwoTouchTimeout() {
+        clearTimeout(this._twoTouchTimeoutId);
+        this._twoTouchTimeoutId = null;
+    }
+
+    _isTwoTouchTimeoutRunning() {
+        return this._twoTouchTimeoutId !== null;
+    }
+
+    _twoTouchTimeout() {
+        if (this._tracked.length === 0) {
+            throw new Error("A pinch or two drag gesture failed, no tracked touches");
+        }
+
+        // How far each touch point has moved since start
+        let avgM = this._getAverageMovement();
+        let avgMoveH = Math.abs(avgM.x);
+        let avgMoveV = Math.abs(avgM.y);
+
+        // The difference in the distance between where
+        // the touch points started and where they are now
+        let avgD = this._getAverageDistance();
+        let deltaTouchDistance = Math.abs(Math.hypot(avgD.first.x, avgD.first.y) -
+                                          Math.hypot(avgD.last.x, avgD.last.y));
+
+        if ((avgMoveV < deltaTouchDistance) &&
+            (avgMoveH < deltaTouchDistance)) {
+            this._state = GH_PINCH;
+        } else {
+            this._state = GH_TWODRAG;
+        }
+
+        this._pushEvent('gesturestart');
+        this._pushEvent('gesturemove');
+    }
+
+    _pushEvent(type) {
+        let detail = { type: this._stateToGesture(this._state) };
+
+        // For most gesture events the current (average) position is the
+        // most useful
+        let avg = this._getPosition();
+        let pos = avg.last;
+
+        // However we have a slight distance to detect gestures, so for the
+        // first gesture event we want to use the first positions we saw
+        if (type === 'gesturestart') {
+            pos = avg.first;
+        }
+
+        // For these gestures, we always want the event coordinates
+        // to be where the gesture began, not the current touch location.
+        switch (this._state) {
+            case GH_TWODRAG:
+            case GH_PINCH:
+                pos = avg.first;
+                break;
+        }
+
+        detail['clientX'] = pos.x;
+        detail['clientY'] = pos.y;
+
+        // FIXME: other coordinates?
+
+        // Some gestures also have a magnitude
+        if (this._state === GH_PINCH) {
+            let distance = this._getAverageDistance();
+            if (type === 'gesturestart') {
+                detail['magnitudeX'] = distance.first.x;
+                detail['magnitudeY'] = distance.first.y;
+            } else {
+                detail['magnitudeX'] = distance.last.x;
+                detail['magnitudeY'] = distance.last.y;
+            }
+        } else if (this._state === GH_TWODRAG) {
+            if (type === 'gesturestart') {
+                detail['magnitudeX'] = 0.0;
+                detail['magnitudeY'] = 0.0;
+            } else {
+                let movement = this._getAverageMovement();
+                detail['magnitudeX'] = movement.x;
+                detail['magnitudeY'] = movement.y;
+            }
+        }
+
+        let gev = new CustomEvent(type, { detail: detail });
+        this._target.dispatchEvent(gev);
+    }
+
+    _stateToGesture(state) {
+        switch (state) {
+            case GH_ONETAP:
+                return 'onetap';
+            case GH_TWOTAP:
+                return 'twotap';
+            case GH_THREETAP:
+                return 'threetap';
+            case GH_DRAG:
+                return 'drag';
+            case GH_LONGPRESS:
+                return 'longpress';
+            case GH_TWODRAG:
+                return 'twodrag';
+            case GH_PINCH:
+                return 'pinch';
+        }
+
+        throw new Error("Unknown gesture state: " + state);
+    }
+
+    _getPosition() {
+        if (this._tracked.length === 0) {
+            throw new Error("Failed to get gesture position, no tracked touches");
+        }
+
+        let size = this._tracked.length;
+        let fx = 0, fy = 0, lx = 0, ly = 0;
+
+        for (let i = 0; i < this._tracked.length; i++) {
+            fx += this._tracked[i].firstX;
+            fy += this._tracked[i].firstY;
+            lx += this._tracked[i].lastX;
+            ly += this._tracked[i].lastY;
+        }
+
+        return { first: { x: fx / size,
+                          y: fy / size },
+                 last: { x: lx / size,
+                         y: ly / size } };
+    }
+
+    _getAverageMovement() {
+        if (this._tracked.length === 0) {
+            throw new Error("Failed to get gesture movement, no tracked touches");
+        }
+
+        let totalH, totalV;
+        totalH = totalV = 0;
+        let size = this._tracked.length;
+
+        for (let i = 0; i < this._tracked.length; i++) {
+            totalH += this._tracked[i].lastX - this._tracked[i].firstX;
+            totalV += this._tracked[i].lastY - this._tracked[i].firstY;
+        }
+
+        return { x: totalH / size,
+                 y: totalV / size };
+    }
+
+    _getAverageDistance() {
+        if (this._tracked.length === 0) {
+            throw new Error("Failed to get gesture distance, no tracked touches");
+        }
+
+        // Distance between the first and last tracked touches
+
+        let first = this._tracked[0];
+        let last = this._tracked[this._tracked.length - 1];
+
+        let fdx = Math.abs(last.firstX - first.firstX);
+        let fdy = Math.abs(last.firstY - first.firstY);
+
+        let ldx = Math.abs(last.lastX - first.lastX);
+        let ldy = Math.abs(last.lastY - first.lastY);
+
+        return { first: { x: fdx, y: fdy },
+                 last: { x: ldx, y: ldy } };
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/input/keyboard.js
@@ -0,0 +1,283 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 or any later version (see LICENSE.txt)
+ */
+
+import * as Log from '../util/logging.js';
+import { stopEvent } from '../util/events.js';
+import * as KeyboardUtil from "./util.js";
+import KeyTable from "./keysym.js";
+import * as browser from "../util/browser.js";
+
+//
+// Keyboard event handler
+//
+
+export default class Keyboard {
+    constructor(target) {
+        this._target = target || null;
+
+        this._keyDownList = {};         // List of depressed keys
+                                        // (even if they are happy)
+        this._altGrArmed = false;       // Windows AltGr detection
+
+        // keep these here so we can refer to them later
+        this._eventHandlers = {
+            'keyup': this._handleKeyUp.bind(this),
+            'keydown': this._handleKeyDown.bind(this),
+            'blur': this._allKeysUp.bind(this),
+        };
+
+        // ===== EVENT HANDLERS =====
+
+        this.onkeyevent = () => {}; // Handler for key press/release
+    }
+
+    // ===== PRIVATE METHODS =====
+
+    _sendKeyEvent(keysym, code, down) {
+        if (down) {
+            this._keyDownList[code] = keysym;
+        } else {
+            // Do we really think this key is down?
+            if (!(code in this._keyDownList)) {
+                return;
+            }
+            delete this._keyDownList[code];
+        }
+
+        Log.Debug("onkeyevent " + (down ? "down" : "up") +
+                  ", keysym: " + keysym, ", code: " + code);
+        this.onkeyevent(keysym, code, down);
+    }
+
+    _getKeyCode(e) {
+        const code = KeyboardUtil.getKeycode(e);
+        if (code !== 'Unidentified') {
+            return code;
+        }
+
+        // Unstable, but we don't have anything else to go on
+        if (e.keyCode) {
+            // 229 is used for composition events
+            if (e.keyCode !== 229) {
+                return 'Platform' + e.keyCode;
+            }
+        }
+
+        // A precursor to the final DOM3 standard. Unfortunately it
+        // is not layout independent, so it is as bad as using keyCode
+        if (e.keyIdentifier) {
+            // Non-character key?
+            if (e.keyIdentifier.substr(0, 2) !== 'U+') {
+                return e.keyIdentifier;
+            }
+
+            const codepoint = parseInt(e.keyIdentifier.substr(2), 16);
+            const char = String.fromCharCode(codepoint).toUpperCase();
+
+            return 'Platform' + char.charCodeAt();
+        }
+
+        return 'Unidentified';
+    }
+
+    _handleKeyDown(e) {
+        const code = this._getKeyCode(e);
+        let keysym = KeyboardUtil.getKeysym(e);
+
+        // Windows doesn't have a proper AltGr, but handles it using
+        // fake Ctrl+Alt. However the remote end might not be Windows,
+        // so we need to merge those in to a single AltGr event. We
+        // detect this case by seeing the two key events directly after
+        // each other with a very short time between them (<50ms).
+        if (this._altGrArmed) {
+            this._altGrArmed = false;
+            clearTimeout(this._altGrTimeout);
+
+            if ((code === "AltRight") &&
+                ((e.timeStamp - this._altGrCtrlTime) < 50)) {
+                // FIXME: We fail to detect this if either Ctrl key is
+                //        first manually pressed as Windows then no
+                //        longer sends the fake Ctrl down event. It
+                //        does however happily send real Ctrl events
+                //        even when AltGr is already down. Some
+                //        browsers detect this for us though and set the
+                //        key to "AltGraph".
+                keysym = KeyTable.XK_ISO_Level3_Shift;
+            } else {
+                this._sendKeyEvent(KeyTable.XK_Control_L, "ControlLeft", true);
+            }
+        }
+
+        // We cannot handle keys we cannot track, but we also need
+        // to deal with virtual keyboards which omit key info
+        if (code === 'Unidentified') {
+            if (keysym) {
+                // If it's a virtual keyboard then it should be
+                // sufficient to just send press and release right
+                // after each other
+                this._sendKeyEvent(keysym, code, true);
+                this._sendKeyEvent(keysym, code, false);
+            }
+
+            stopEvent(e);
+            return;
+        }
+
+        // Alt behaves more like AltGraph on macOS, so shuffle the
+        // keys around a bit to make things more sane for the remote
+        // server. This method is used by RealVNC and TigerVNC (and
+        // possibly others).
+        if (browser.isMac() || browser.isIOS()) {
+            switch (keysym) {
+                case KeyTable.XK_Super_L:
+                    keysym = KeyTable.XK_Alt_L;
+                    break;
+                case KeyTable.XK_Super_R:
+                    keysym = KeyTable.XK_Super_L;
+                    break;
+                case KeyTable.XK_Alt_L:
+                    keysym = KeyTable.XK_Mode_switch;
+                    break;
+                case KeyTable.XK_Alt_R:
+                    keysym = KeyTable.XK_ISO_Level3_Shift;
+                    break;
+            }
+        }
+
+        // Is this key already pressed? If so, then we must use the
+        // same keysym or we'll confuse the server
+        if (code in this._keyDownList) {
+            keysym = this._keyDownList[code];
+        }
+
+        // macOS doesn't send proper key releases if a key is pressed
+        // while meta is held down
+        if ((browser.isMac() || browser.isIOS()) &&
+            (e.metaKey && code !== 'MetaLeft' && code !== 'MetaRight')) {
+            this._sendKeyEvent(keysym, code, true);
+            this._sendKeyEvent(keysym, code, false);
+            stopEvent(e);
+            return;
+        }
+
+        // macOS doesn't send proper key events for modifiers, only
+        // state change events. That gets extra confusing for CapsLock
+        // which toggles on each press, but not on release. So pretend
+        // it was a quick press and release of the button.
+        if ((browser.isMac() || browser.isIOS()) && (code === 'CapsLock')) {
+            this._sendKeyEvent(KeyTable.XK_Caps_Lock, 'CapsLock', true);
+            this._sendKeyEvent(KeyTable.XK_Caps_Lock, 'CapsLock', false);
+            stopEvent(e);
+            return;
+        }
+
+        // Windows doesn't send proper key releases for a bunch of
+        // Japanese IM keys so we have to fake the release right away
+        const jpBadKeys = [ KeyTable.XK_Zenkaku_Hankaku,
+                            KeyTable.XK_Eisu_toggle,
+                            KeyTable.XK_Katakana,
+                            KeyTable.XK_Hiragana,
+                            KeyTable.XK_Romaji ];
+        if (browser.isWindows() && jpBadKeys.includes(keysym)) {
+            this._sendKeyEvent(keysym, code, true);
+            this._sendKeyEvent(keysym, code, false);
+            stopEvent(e);
+            return;
+        }
+
+        stopEvent(e);
+
+        // Possible start of AltGr sequence? (see above)
+        if ((code === "ControlLeft") && browser.isWindows() &&
+            !("ControlLeft" in this._keyDownList)) {
+            this._altGrArmed = true;
+            this._altGrTimeout = setTimeout(this._handleAltGrTimeout.bind(this), 100);
+            this._altGrCtrlTime = e.timeStamp;
+            return;
+        }
+
+        this._sendKeyEvent(keysym, code, true);
+    }
+
+    _handleKeyUp(e) {
+        stopEvent(e);
+
+        const code = this._getKeyCode(e);
+
+        // We can't get a release in the middle of an AltGr sequence, so
+        // abort that detection
+        if (this._altGrArmed) {
+            this._altGrArmed = false;
+            clearTimeout(this._altGrTimeout);
+            this._sendKeyEvent(KeyTable.XK_Control_L, "ControlLeft", true);
+        }
+
+        // See comment in _handleKeyDown()
+        if ((browser.isMac() || browser.isIOS()) && (code === 'CapsLock')) {
+            this._sendKeyEvent(KeyTable.XK_Caps_Lock, 'CapsLock', true);
+            this._sendKeyEvent(KeyTable.XK_Caps_Lock, 'CapsLock', false);
+            return;
+        }
+
+        this._sendKeyEvent(this._keyDownList[code], code, false);
+
+        // Windows has a rather nasty bug where it won't send key
+        // release events for a Shift button if the other Shift is still
+        // pressed
+        if (browser.isWindows() && ((code === 'ShiftLeft') ||
+                                    (code === 'ShiftRight'))) {
+            if ('ShiftRight' in this._keyDownList) {
+                this._sendKeyEvent(this._keyDownList['ShiftRight'],
+                                   'ShiftRight', false);
+            }
+            if ('ShiftLeft' in this._keyDownList) {
+                this._sendKeyEvent(this._keyDownList['ShiftLeft'],
+                                   'ShiftLeft', false);
+            }
+        }
+    }
+
+    _handleAltGrTimeout() {
+        this._altGrArmed = false;
+        clearTimeout(this._altGrTimeout);
+        this._sendKeyEvent(KeyTable.XK_Control_L, "ControlLeft", true);
+    }
+
+    _allKeysUp() {
+        Log.Debug(">> Keyboard.allKeysUp");
+        for (let code in this._keyDownList) {
+            this._sendKeyEvent(this._keyDownList[code], code, false);
+        }
+        Log.Debug("<< Keyboard.allKeysUp");
+    }
+
+    // ===== PUBLIC METHODS =====
+
+    grab() {
+        //Log.Debug(">> Keyboard.grab");
+
+        this._target.addEventListener('keydown', this._eventHandlers.keydown);
+        this._target.addEventListener('keyup', this._eventHandlers.keyup);
+
+        // Release (key up) if window loses focus
+        window.addEventListener('blur', this._eventHandlers.blur);
+
+        //Log.Debug("<< Keyboard.grab");
+    }
+
+    ungrab() {
+        //Log.Debug(">> Keyboard.ungrab");
+
+        this._target.removeEventListener('keydown', this._eventHandlers.keydown);
+        this._target.removeEventListener('keyup', this._eventHandlers.keyup);
+        window.removeEventListener('blur', this._eventHandlers.blur);
+
+        // Release (key up) all keys that are in a down state
+        this._allKeysUp();
+
+        //Log.Debug(">> Keyboard.ungrab");
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/input/keysym.js
@@ -0,0 +1,616 @@
+/* eslint-disable key-spacing */
+
+export default {
+    XK_VoidSymbol:                  0xffffff, /* Void symbol */
+
+    XK_BackSpace:                   0xff08, /* Back space, back char */
+    XK_Tab:                         0xff09,
+    XK_Linefeed:                    0xff0a, /* Linefeed, LF */
+    XK_Clear:                       0xff0b,
+    XK_Return:                      0xff0d, /* Return, enter */
+    XK_Pause:                       0xff13, /* Pause, hold */
+    XK_Scroll_Lock:                 0xff14,
+    XK_Sys_Req:                     0xff15,
+    XK_Escape:                      0xff1b,
+    XK_Delete:                      0xffff, /* Delete, rubout */
+
+    /* International & multi-key character composition */
+
+    XK_Multi_key:                   0xff20, /* Multi-key character compose */
+    XK_Codeinput:                   0xff37,
+    XK_SingleCandidate:             0xff3c,
+    XK_MultipleCandidate:           0xff3d,
+    XK_PreviousCandidate:           0xff3e,
+
+    /* Japanese keyboard support */
+
+    XK_Kanji:                       0xff21, /* Kanji, Kanji convert */
+    XK_Muhenkan:                    0xff22, /* Cancel Conversion */
+    XK_Henkan_Mode:                 0xff23, /* Start/Stop Conversion */
+    XK_Henkan:                      0xff23, /* Alias for Henkan_Mode */
+    XK_Romaji:                      0xff24, /* to Romaji */
+    XK_Hiragana:                    0xff25, /* to Hiragana */
+    XK_Katakana:                    0xff26, /* to Katakana */
+    XK_Hiragana_Katakana:           0xff27, /* Hiragana/Katakana toggle */
+    XK_Zenkaku:                     0xff28, /* to Zenkaku */
+    XK_Hankaku:                     0xff29, /* to Hankaku */
+    XK_Zenkaku_Hankaku:             0xff2a, /* Zenkaku/Hankaku toggle */
+    XK_Touroku:                     0xff2b, /* Add to Dictionary */
+    XK_Massyo:                      0xff2c, /* Delete from Dictionary */
+    XK_Kana_Lock:                   0xff2d, /* Kana Lock */
+    XK_Kana_Shift:                  0xff2e, /* Kana Shift */
+    XK_Eisu_Shift:                  0xff2f, /* Alphanumeric Shift */
+    XK_Eisu_toggle:                 0xff30, /* Alphanumeric toggle */
+    XK_Kanji_Bangou:                0xff37, /* Codeinput */
+    XK_Zen_Koho:                    0xff3d, /* Multiple/All Candidate(s) */
+    XK_Mae_Koho:                    0xff3e, /* Previous Candidate */
+
+    /* Cursor control & motion */
+
+    XK_Home:                        0xff50,
+    XK_Left:                        0xff51, /* Move left, left arrow */
+    XK_Up:                          0xff52, /* Move up, up arrow */
+    XK_Right:                       0xff53, /* Move right, right arrow */
+    XK_Down:                        0xff54, /* Move down, down arrow */
+    XK_Prior:                       0xff55, /* Prior, previous */
+    XK_Page_Up:                     0xff55,
+    XK_Next:                        0xff56, /* Next */
+    XK_Page_Down:                   0xff56,
+    XK_End:                         0xff57, /* EOL */
+    XK_Begin:                       0xff58, /* BOL */
+
+
+    /* Misc functions */
+
+    XK_Select:                      0xff60, /* Select, mark */
+    XK_Print:                       0xff61,
+    XK_Execute:                     0xff62, /* Execute, run, do */
+    XK_Insert:                      0xff63, /* Insert, insert here */
+    XK_Undo:                        0xff65,
+    XK_Redo:                        0xff66, /* Redo, again */
+    XK_Menu:                        0xff67,
+    XK_Find:                        0xff68, /* Find, search */
+    XK_Cancel:                      0xff69, /* Cancel, stop, abort, exit */
+    XK_Help:                        0xff6a, /* Help */
+    XK_Break:                       0xff6b,
+    XK_Mode_switch:                 0xff7e, /* Character set switch */
+    XK_script_switch:               0xff7e, /* Alias for mode_switch */
+    XK_Num_Lock:                    0xff7f,
+
+    /* Keypad functions, keypad numbers cleverly chosen to map to ASCII */
+
+    XK_KP_Space:                    0xff80, /* Space */
+    XK_KP_Tab:                      0xff89,
+    XK_KP_Enter:                    0xff8d, /* Enter */
+    XK_KP_F1:                       0xff91, /* PF1, KP_A, ... */
+    XK_KP_F2:                       0xff92,
+    XK_KP_F3:                       0xff93,
+    XK_KP_F4:                       0xff94,
+    XK_KP_Home:                     0xff95,
+    XK_KP_Left:                     0xff96,
+    XK_KP_Up:                       0xff97,
+    XK_KP_Right:                    0xff98,
+    XK_KP_Down:                     0xff99,
+    XK_KP_Prior:                    0xff9a,
+    XK_KP_Page_Up:                  0xff9a,
+    XK_KP_Next:                     0xff9b,
+    XK_KP_Page_Down:                0xff9b,
+    XK_KP_End:                      0xff9c,
+    XK_KP_Begin:                    0xff9d,
+    XK_KP_Insert:                   0xff9e,
+    XK_KP_Delete:                   0xff9f,
+    XK_KP_Equal:                    0xffbd, /* Equals */
+    XK_KP_Multiply:                 0xffaa,
+    XK_KP_Add:                      0xffab,
+    XK_KP_Separator:                0xffac, /* Separator, often comma */
+    XK_KP_Subtract:                 0xffad,
+    XK_KP_Decimal:                  0xffae,
+    XK_KP_Divide:                   0xffaf,
+
+    XK_KP_0:                        0xffb0,
+    XK_KP_1:                        0xffb1,
+    XK_KP_2:                        0xffb2,
+    XK_KP_3:                        0xffb3,
+    XK_KP_4:                        0xffb4,
+    XK_KP_5:                        0xffb5,
+    XK_KP_6:                        0xffb6,
+    XK_KP_7:                        0xffb7,
+    XK_KP_8:                        0xffb8,
+    XK_KP_9:                        0xffb9,
+
+    /*
+     * Auxiliary functions; note the duplicate definitions for left and right
+     * function keys;  Sun keyboards and a few other manufacturers have such
+     * function key groups on the left and/or right sides of the keyboard.
+     * We've not found a keyboard with more than 35 function keys total.
+     */
+
+    XK_F1:                          0xffbe,
+    XK_F2:                          0xffbf,
+    XK_F3:                          0xffc0,
+    XK_F4:                          0xffc1,
+    XK_F5:                          0xffc2,
+    XK_F6:                          0xffc3,
+    XK_F7:                          0xffc4,
+    XK_F8:                          0xffc5,
+    XK_F9:                          0xffc6,
+    XK_F10:                         0xffc7,
+    XK_F11:                         0xffc8,
+    XK_L1:                          0xffc8,
+    XK_F12:                         0xffc9,
+    XK_L2:                          0xffc9,
+    XK_F13:                         0xffca,
+    XK_L3:                          0xffca,
+    XK_F14:                         0xffcb,
+    XK_L4:                          0xffcb,
+    XK_F15:                         0xffcc,
+    XK_L5:                          0xffcc,
+    XK_F16:                         0xffcd,
+    XK_L6:                          0xffcd,
+    XK_F17:                         0xffce,
+    XK_L7:                          0xffce,
+    XK_F18:                         0xffcf,
+    XK_L8:                          0xffcf,
+    XK_F19:                         0xffd0,
+    XK_L9:                          0xffd0,
+    XK_F20:                         0xffd1,
+    XK_L10:                         0xffd1,
+    XK_F21:                         0xffd2,
+    XK_R1:                          0xffd2,
+    XK_F22:                         0xffd3,
+    XK_R2:                          0xffd3,
+    XK_F23:                         0xffd4,
+    XK_R3:                          0xffd4,
+    XK_F24:                         0xffd5,
+    XK_R4:                          0xffd5,
+    XK_F25:                         0xffd6,
+    XK_R5:                          0xffd6,
+    XK_F26:                         0xffd7,
+    XK_R6:                          0xffd7,
+    XK_F27:                         0xffd8,
+    XK_R7:                          0xffd8,
+    XK_F28:                         0xffd9,
+    XK_R8:                          0xffd9,
+    XK_F29:                         0xffda,
+    XK_R9:                          0xffda,
+    XK_F30:                         0xffdb,
+    XK_R10:                         0xffdb,
+    XK_F31:                         0xffdc,
+    XK_R11:                         0xffdc,
+    XK_F32:                         0xffdd,
+    XK_R12:                         0xffdd,
+    XK_F33:                         0xffde,
+    XK_R13:                         0xffde,
+    XK_F34:                         0xffdf,
+    XK_R14:                         0xffdf,
+    XK_F35:                         0xffe0,
+    XK_R15:                         0xffe0,
+
+    /* Modifiers */
+
+    XK_Shift_L:                     0xffe1, /* Left shift */
+    XK_Shift_R:                     0xffe2, /* Right shift */
+    XK_Control_L:                   0xffe3, /* Left control */
+    XK_Control_R:                   0xffe4, /* Right control */
+    XK_Caps_Lock:                   0xffe5, /* Caps lock */
+    XK_Shift_Lock:                  0xffe6, /* Shift lock */
+
+    XK_Meta_L:                      0xffe7, /* Left meta */
+    XK_Meta_R:                      0xffe8, /* Right meta */
+    XK_Alt_L:                       0xffe9, /* Left alt */
+    XK_Alt_R:                       0xffea, /* Right alt */
+    XK_Super_L:                     0xffeb, /* Left super */
+    XK_Super_R:                     0xffec, /* Right super */
+    XK_Hyper_L:                     0xffed, /* Left hyper */
+    XK_Hyper_R:                     0xffee, /* Right hyper */
+
+    /*
+     * Keyboard (XKB) Extension function and modifier keys
+     * (from Appendix C of "The X Keyboard Extension: Protocol Specification")
+     * Byte 3 = 0xfe
+     */
+
+    XK_ISO_Level3_Shift:            0xfe03, /* AltGr */
+    XK_ISO_Next_Group:              0xfe08,
+    XK_ISO_Prev_Group:              0xfe0a,
+    XK_ISO_First_Group:             0xfe0c,
+    XK_ISO_Last_Group:              0xfe0e,
+
+    /*
+     * Latin 1
+     * (ISO/IEC 8859-1: Unicode U+0020..U+00FF)
+     * Byte 3: 0
+     */
+
+    XK_space:                       0x0020, /* U+0020 SPACE */
+    XK_exclam:                      0x0021, /* U+0021 EXCLAMATION MARK */
+    XK_quotedbl:                    0x0022, /* U+0022 QUOTATION MARK */
+    XK_numbersign:                  0x0023, /* U+0023 NUMBER SIGN */
+    XK_dollar:                      0x0024, /* U+0024 DOLLAR SIGN */
+    XK_percent:                     0x0025, /* U+0025 PERCENT SIGN */
+    XK_ampersand:                   0x0026, /* U+0026 AMPERSAND */
+    XK_apostrophe:                  0x0027, /* U+0027 APOSTROPHE */
+    XK_quoteright:                  0x0027, /* deprecated */
+    XK_parenleft:                   0x0028, /* U+0028 LEFT PARENTHESIS */
+    XK_parenright:                  0x0029, /* U+0029 RIGHT PARENTHESIS */
+    XK_asterisk:                    0x002a, /* U+002A ASTERISK */
+    XK_plus:                        0x002b, /* U+002B PLUS SIGN */
+    XK_comma:                       0x002c, /* U+002C COMMA */
+    XK_minus:                       0x002d, /* U+002D HYPHEN-MINUS */
+    XK_period:                      0x002e, /* U+002E FULL STOP */
+    XK_slash:                       0x002f, /* U+002F SOLIDUS */
+    XK_0:                           0x0030, /* U+0030 DIGIT ZERO */
+    XK_1:                           0x0031, /* U+0031 DIGIT ONE */
+    XK_2:                           0x0032, /* U+0032 DIGIT TWO */
+    XK_3:                           0x0033, /* U+0033 DIGIT THREE */
+    XK_4:                           0x0034, /* U+0034 DIGIT FOUR */
+    XK_5:                           0x0035, /* U+0035 DIGIT FIVE */
+    XK_6:                           0x0036, /* U+0036 DIGIT SIX */
+    XK_7:                           0x0037, /* U+0037 DIGIT SEVEN */
+    XK_8:                           0x0038, /* U+0038 DIGIT EIGHT */
+    XK_9:                           0x0039, /* U+0039 DIGIT NINE */
+    XK_colon:                       0x003a, /* U+003A COLON */
+    XK_semicolon:                   0x003b, /* U+003B SEMICOLON */
+    XK_less:                        0x003c, /* U+003C LESS-THAN SIGN */
+    XK_equal:                       0x003d, /* U+003D EQUALS SIGN */
+    XK_greater:                     0x003e, /* U+003E GREATER-THAN SIGN */
+    XK_question:                    0x003f, /* U+003F QUESTION MARK */
+    XK_at:                          0x0040, /* U+0040 COMMERCIAL AT */
+    XK_A:                           0x0041, /* U+0041 LATIN CAPITAL LETTER A */
+    XK_B:                           0x0042, /* U+0042 LATIN CAPITAL LETTER B */
+    XK_C:                           0x0043, /* U+0043 LATIN CAPITAL LETTER C */
+    XK_D:                           0x0044, /* U+0044 LATIN CAPITAL LETTER D */
+    XK_E:                           0x0045, /* U+0045 LATIN CAPITAL LETTER E */
+    XK_F:                           0x0046, /* U+0046 LATIN CAPITAL LETTER F */
+    XK_G:                           0x0047, /* U+0047 LATIN CAPITAL LETTER G */
+    XK_H:                           0x0048, /* U+0048 LATIN CAPITAL LETTER H */
+    XK_I:                           0x0049, /* U+0049 LATIN CAPITAL LETTER I */
+    XK_J:                           0x004a, /* U+004A LATIN CAPITAL LETTER J */
+    XK_K:                           0x004b, /* U+004B LATIN CAPITAL LETTER K */
+    XK_L:                           0x004c, /* U+004C LATIN CAPITAL LETTER L */
+    XK_M:                           0x004d, /* U+004D LATIN CAPITAL LETTER M */
+    XK_N:                           0x004e, /* U+004E LATIN CAPITAL LETTER N */
+    XK_O:                           0x004f, /* U+004F LATIN CAPITAL LETTER O */
+    XK_P:                           0x0050, /* U+0050 LATIN CAPITAL LETTER P */
+    XK_Q:                           0x0051, /* U+0051 LATIN CAPITAL LETTER Q */
+    XK_R:                           0x0052, /* U+0052 LATIN CAPITAL LETTER R */
+    XK_S:                           0x0053, /* U+0053 LATIN CAPITAL LETTER S */
+    XK_T:                           0x0054, /* U+0054 LATIN CAPITAL LETTER T */
+    XK_U:                           0x0055, /* U+0055 LATIN CAPITAL LETTER U */
+    XK_V:                           0x0056, /* U+0056 LATIN CAPITAL LETTER V */
+    XK_W:                           0x0057, /* U+0057 LATIN CAPITAL LETTER W */
+    XK_X:                           0x0058, /* U+0058 LATIN CAPITAL LETTER X */
+    XK_Y:                           0x0059, /* U+0059 LATIN CAPITAL LETTER Y */
+    XK_Z:                           0x005a, /* U+005A LATIN CAPITAL LETTER Z */
+    XK_bracketleft:                 0x005b, /* U+005B LEFT SQUARE BRACKET */
+    XK_backslash:                   0x005c, /* U+005C REVERSE SOLIDUS */
+    XK_bracketright:                0x005d, /* U+005D RIGHT SQUARE BRACKET */
+    XK_asciicircum:                 0x005e, /* U+005E CIRCUMFLEX ACCENT */
+    XK_underscore:                  0x005f, /* U+005F LOW LINE */
+    XK_grave:                       0x0060, /* U+0060 GRAVE ACCENT */
+    XK_quoteleft:                   0x0060, /* deprecated */
+    XK_a:                           0x0061, /* U+0061 LATIN SMALL LETTER A */
+    XK_b:                           0x0062, /* U+0062 LATIN SMALL LETTER B */
+    XK_c:                           0x0063, /* U+0063 LATIN SMALL LETTER C */
+    XK_d:                           0x0064, /* U+0064 LATIN SMALL LETTER D */
+    XK_e:                           0x0065, /* U+0065 LATIN SMALL LETTER E */
+    XK_f:                           0x0066, /* U+0066 LATIN SMALL LETTER F */
+    XK_g:                           0x0067, /* U+0067 LATIN SMALL LETTER G */
+    XK_h:                           0x0068, /* U+0068 LATIN SMALL LETTER H */
+    XK_i:                           0x0069, /* U+0069 LATIN SMALL LETTER I */
+    XK_j:                           0x006a, /* U+006A LATIN SMALL LETTER J */
+    XK_k:                           0x006b, /* U+006B LATIN SMALL LETTER K */
+    XK_l:                           0x006c, /* U+006C LATIN SMALL LETTER L */
+    XK_m:                           0x006d, /* U+006D LATIN SMALL LETTER M */
+    XK_n:                           0x006e, /* U+006E LATIN SMALL LETTER N */
+    XK_o:                           0x006f, /* U+006F LATIN SMALL LETTER O */
+    XK_p:                           0x0070, /* U+0070 LATIN SMALL LETTER P */
+    XK_q:                           0x0071, /* U+0071 LATIN SMALL LETTER Q */
+    XK_r:                           0x0072, /* U+0072 LATIN SMALL LETTER R */
+    XK_s:                           0x0073, /* U+0073 LATIN SMALL LETTER S */
+    XK_t:                           0x0074, /* U+0074 LATIN SMALL LETTER T */
+    XK_u:                           0x0075, /* U+0075 LATIN SMALL LETTER U */
+    XK_v:                           0x0076, /* U+0076 LATIN SMALL LETTER V */
+    XK_w:                           0x0077, /* U+0077 LATIN SMALL LETTER W */
+    XK_x:                           0x0078, /* U+0078 LATIN SMALL LETTER X */
+    XK_y:                           0x0079, /* U+0079 LATIN SMALL LETTER Y */
+    XK_z:                           0x007a, /* U+007A LATIN SMALL LETTER Z */
+    XK_braceleft:                   0x007b, /* U+007B LEFT CURLY BRACKET */
+    XK_bar:                         0x007c, /* U+007C VERTICAL LINE */
+    XK_braceright:                  0x007d, /* U+007D RIGHT CURLY BRACKET */
+    XK_asciitilde:                  0x007e, /* U+007E TILDE */
+
+    XK_nobreakspace:                0x00a0, /* U+00A0 NO-BREAK SPACE */
+    XK_exclamdown:                  0x00a1, /* U+00A1 INVERTED EXCLAMATION MARK */
+    XK_cent:                        0x00a2, /* U+00A2 CENT SIGN */
+    XK_sterling:                    0x00a3, /* U+00A3 POUND SIGN */
+    XK_currency:                    0x00a4, /* U+00A4 CURRENCY SIGN */
+    XK_yen:                         0x00a5, /* U+00A5 YEN SIGN */
+    XK_brokenbar:                   0x00a6, /* U+00A6 BROKEN BAR */
+    XK_section:                     0x00a7, /* U+00A7 SECTION SIGN */
+    XK_diaeresis:                   0x00a8, /* U+00A8 DIAERESIS */
+    XK_copyright:                   0x00a9, /* U+00A9 COPYRIGHT SIGN */
+    XK_ordfeminine:                 0x00aa, /* U+00AA FEMININE ORDINAL INDICATOR */
+    XK_guillemotleft:               0x00ab, /* U+00AB LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */
+    XK_notsign:                     0x00ac, /* U+00AC NOT SIGN */
+    XK_hyphen:                      0x00ad, /* U+00AD SOFT HYPHEN */
+    XK_registered:                  0x00ae, /* U+00AE REGISTERED SIGN */
+    XK_macron:                      0x00af, /* U+00AF MACRON */
+    XK_degree:                      0x00b0, /* U+00B0 DEGREE SIGN */
+    XK_plusminus:                   0x00b1, /* U+00B1 PLUS-MINUS SIGN */
+    XK_twosuperior:                 0x00b2, /* U+00B2 SUPERSCRIPT TWO */
+    XK_threesuperior:               0x00b3, /* U+00B3 SUPERSCRIPT THREE */
+    XK_acute:                       0x00b4, /* U+00B4 ACUTE ACCENT */
+    XK_mu:                          0x00b5, /* U+00B5 MICRO SIGN */
+    XK_paragraph:                   0x00b6, /* U+00B6 PILCROW SIGN */
+    XK_periodcentered:              0x00b7, /* U+00B7 MIDDLE DOT */
+    XK_cedilla:                     0x00b8, /* U+00B8 CEDILLA */
+    XK_onesuperior:                 0x00b9, /* U+00B9 SUPERSCRIPT ONE */
+    XK_masculine:                   0x00ba, /* U+00BA MASCULINE ORDINAL INDICATOR */
+    XK_guillemotright:              0x00bb, /* U+00BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */
+    XK_onequarter:                  0x00bc, /* U+00BC VULGAR FRACTION ONE QUARTER */
+    XK_onehalf:                     0x00bd, /* U+00BD VULGAR FRACTION ONE HALF */
+    XK_threequarters:               0x00be, /* U+00BE VULGAR FRACTION THREE QUARTERS */
+    XK_questiondown:                0x00bf, /* U+00BF INVERTED QUESTION MARK */
+    XK_Agrave:                      0x00c0, /* U+00C0 LATIN CAPITAL LETTER A WITH GRAVE */
+    XK_Aacute:                      0x00c1, /* U+00C1 LATIN CAPITAL LETTER A WITH ACUTE */
+    XK_Acircumflex:                 0x00c2, /* U+00C2 LATIN CAPITAL LETTER A WITH CIRCUMFLEX */
+    XK_Atilde:                      0x00c3, /* U+00C3 LATIN CAPITAL LETTER A WITH TILDE */
+    XK_Adiaeresis:                  0x00c4, /* U+00C4 LATIN CAPITAL LETTER A WITH DIAERESIS */
+    XK_Aring:                       0x00c5, /* U+00C5 LATIN CAPITAL LETTER A WITH RING ABOVE */
+    XK_AE:                          0x00c6, /* U+00C6 LATIN CAPITAL LETTER AE */
+    XK_Ccedilla:                    0x00c7, /* U+00C7 LATIN CAPITAL LETTER C WITH CEDILLA */
+    XK_Egrave:                      0x00c8, /* U+00C8 LATIN CAPITAL LETTER E WITH GRAVE */
+    XK_Eacute:                      0x00c9, /* U+00C9 LATIN CAPITAL LETTER E WITH ACUTE */
+    XK_Ecircumflex:                 0x00ca, /* U+00CA LATIN CAPITAL LETTER E WITH CIRCUMFLEX */
+    XK_Ediaeresis:                  0x00cb, /* U+00CB LATIN CAPITAL LETTER E WITH DIAERESIS */
+    XK_Igrave:                      0x00cc, /* U+00CC LATIN CAPITAL LETTER I WITH GRAVE */
+    XK_Iacute:                      0x00cd, /* U+00CD LATIN CAPITAL LETTER I WITH ACUTE */
+    XK_Icircumflex:                 0x00ce, /* U+00CE LATIN CAPITAL LETTER I WITH CIRCUMFLEX */
+    XK_Idiaeresis:                  0x00cf, /* U+00CF LATIN CAPITAL LETTER I WITH DIAERESIS */
+    XK_ETH:                         0x00d0, /* U+00D0 LATIN CAPITAL LETTER ETH */
+    XK_Eth:                         0x00d0, /* deprecated */
+    XK_Ntilde:                      0x00d1, /* U+00D1 LATIN CAPITAL LETTER N WITH TILDE */
+    XK_Ograve:                      0x00d2, /* U+00D2 LATIN CAPITAL LETTER O WITH GRAVE */
+    XK_Oacute:                      0x00d3, /* U+00D3 LATIN CAPITAL LETTER O WITH ACUTE */
+    XK_Ocircumflex:                 0x00d4, /* U+00D4 LATIN CAPITAL LETTER O WITH CIRCUMFLEX */
+    XK_Otilde:                      0x00d5, /* U+00D5 LATIN CAPITAL LETTER O WITH TILDE */
+    XK_Odiaeresis:                  0x00d6, /* U+00D6 LATIN CAPITAL LETTER O WITH DIAERESIS */
+    XK_multiply:                    0x00d7, /* U+00D7 MULTIPLICATION SIGN */
+    XK_Oslash:                      0x00d8, /* U+00D8 LATIN CAPITAL LETTER O WITH STROKE */
+    XK_Ooblique:                    0x00d8, /* U+00D8 LATIN CAPITAL LETTER O WITH STROKE */
+    XK_Ugrave:                      0x00d9, /* U+00D9 LATIN CAPITAL LETTER U WITH GRAVE */
+    XK_Uacute:                      0x00da, /* U+00DA LATIN CAPITAL LETTER U WITH ACUTE */
+    XK_Ucircumflex:                 0x00db, /* U+00DB LATIN CAPITAL LETTER U WITH CIRCUMFLEX */
+    XK_Udiaeresis:                  0x00dc, /* U+00DC LATIN CAPITAL LETTER U WITH DIAERESIS */
+    XK_Yacute:                      0x00dd, /* U+00DD LATIN CAPITAL LETTER Y WITH ACUTE */
+    XK_THORN:                       0x00de, /* U+00DE LATIN CAPITAL LETTER THORN */
+    XK_Thorn:                       0x00de, /* deprecated */
+    XK_ssharp:                      0x00df, /* U+00DF LATIN SMALL LETTER SHARP S */
+    XK_agrave:                      0x00e0, /* U+00E0 LATIN SMALL LETTER A WITH GRAVE */
+    XK_aacute:                      0x00e1, /* U+00E1 LATIN SMALL LETTER A WITH ACUTE */
+    XK_acircumflex:                 0x00e2, /* U+00E2 LATIN SMALL LETTER A WITH CIRCUMFLEX */
+    XK_atilde:                      0x00e3, /* U+00E3 LATIN SMALL LETTER A WITH TILDE */
+    XK_adiaeresis:                  0x00e4, /* U+00E4 LATIN SMALL LETTER A WITH DIAERESIS */
+    XK_aring:                       0x00e5, /* U+00E5 LATIN SMALL LETTER A WITH RING ABOVE */
+    XK_ae:                          0x00e6, /* U+00E6 LATIN SMALL LETTER AE */
+    XK_ccedilla:                    0x00e7, /* U+00E7 LATIN SMALL LETTER C WITH CEDILLA */
+    XK_egrave:                      0x00e8, /* U+00E8 LATIN SMALL LETTER E WITH GRAVE */
+    XK_eacute:                      0x00e9, /* U+00E9 LATIN SMALL LETTER E WITH ACUTE */
+    XK_ecircumflex:                 0x00ea, /* U+00EA LATIN SMALL LETTER E WITH CIRCUMFLEX */
+    XK_ediaeresis:                  0x00eb, /* U+00EB LATIN SMALL LETTER E WITH DIAERESIS */
+    XK_igrave:                      0x00ec, /* U+00EC LATIN SMALL LETTER I WITH GRAVE */
+    XK_iacute:                      0x00ed, /* U+00ED LATIN SMALL LETTER I WITH ACUTE */
+    XK_icircumflex:                 0x00ee, /* U+00EE LATIN SMALL LETTER I WITH CIRCUMFLEX */
+    XK_idiaeresis:                  0x00ef, /* U+00EF LATIN SMALL LETTER I WITH DIAERESIS */
+    XK_eth:                         0x00f0, /* U+00F0 LATIN SMALL LETTER ETH */
+    XK_ntilde:                      0x00f1, /* U+00F1 LATIN SMALL LETTER N WITH TILDE */
+    XK_ograve:                      0x00f2, /* U+00F2 LATIN SMALL LETTER O WITH GRAVE */
+    XK_oacute:                      0x00f3, /* U+00F3 LATIN SMALL LETTER O WITH ACUTE */
+    XK_ocircumflex:                 0x00f4, /* U+00F4 LATIN SMALL LETTER O WITH CIRCUMFLEX */
+    XK_otilde:                      0x00f5, /* U+00F5 LATIN SMALL LETTER O WITH TILDE */
+    XK_odiaeresis:                  0x00f6, /* U+00F6 LATIN SMALL LETTER O WITH DIAERESIS */
+    XK_division:                    0x00f7, /* U+00F7 DIVISION SIGN */
+    XK_oslash:                      0x00f8, /* U+00F8 LATIN SMALL LETTER O WITH STROKE */
+    XK_ooblique:                    0x00f8, /* U+00F8 LATIN SMALL LETTER O WITH STROKE */
+    XK_ugrave:                      0x00f9, /* U+00F9 LATIN SMALL LETTER U WITH GRAVE */
+    XK_uacute:                      0x00fa, /* U+00FA LATIN SMALL LETTER U WITH ACUTE */
+    XK_ucircumflex:                 0x00fb, /* U+00FB LATIN SMALL LETTER U WITH CIRCUMFLEX */
+    XK_udiaeresis:                  0x00fc, /* U+00FC LATIN SMALL LETTER U WITH DIAERESIS */
+    XK_yacute:                      0x00fd, /* U+00FD LATIN SMALL LETTER Y WITH ACUTE */
+    XK_thorn:                       0x00fe, /* U+00FE LATIN SMALL LETTER THORN */
+    XK_ydiaeresis:                  0x00ff, /* U+00FF LATIN SMALL LETTER Y WITH DIAERESIS */
+
+    /*
+     * Korean
+     * Byte 3 = 0x0e
+     */
+
+    XK_Hangul:                      0xff31, /* Hangul start/stop(toggle) */
+    XK_Hangul_Hanja:                0xff34, /* Start Hangul->Hanja Conversion */
+    XK_Hangul_Jeonja:               0xff38, /* Jeonja mode */
+
+    /*
+     * XFree86 vendor specific keysyms.
+     *
+     * The XFree86 keysym range is 0x10080001 - 0x1008FFFF.
+     */
+
+    XF86XK_ModeLock:                0x1008FF01,
+    XF86XK_MonBrightnessUp:         0x1008FF02,
+    XF86XK_MonBrightnessDown:       0x1008FF03,
+    XF86XK_KbdLightOnOff:           0x1008FF04,
+    XF86XK_KbdBrightnessUp:         0x1008FF05,
+    XF86XK_KbdBrightnessDown:       0x1008FF06,
+    XF86XK_Standby:                 0x1008FF10,
+    XF86XK_AudioLowerVolume:        0x1008FF11,
+    XF86XK_AudioMute:               0x1008FF12,
+    XF86XK_AudioRaiseVolume:        0x1008FF13,
+    XF86XK_AudioPlay:               0x1008FF14,
+    XF86XK_AudioStop:               0x1008FF15,
+    XF86XK_AudioPrev:               0x1008FF16,
+    XF86XK_AudioNext:               0x1008FF17,
+    XF86XK_HomePage:                0x1008FF18,
+    XF86XK_Mail:                    0x1008FF19,
+    XF86XK_Start:                   0x1008FF1A,
+    XF86XK_Search:                  0x1008FF1B,
+    XF86XK_AudioRecord:             0x1008FF1C,
+    XF86XK_Calculator:              0x1008FF1D,
+    XF86XK_Memo:                    0x1008FF1E,
+    XF86XK_ToDoList:                0x1008FF1F,
+    XF86XK_Calendar:                0x1008FF20,
+    XF86XK_PowerDown:               0x1008FF21,
+    XF86XK_ContrastAdjust:          0x1008FF22,
+    XF86XK_RockerUp:                0x1008FF23,
+    XF86XK_RockerDown:              0x1008FF24,
+    XF86XK_RockerEnter:             0x1008FF25,
+    XF86XK_Back:                    0x1008FF26,
+    XF86XK_Forward:                 0x1008FF27,
+    XF86XK_Stop:                    0x1008FF28,
+    XF86XK_Refresh:                 0x1008FF29,
+    XF86XK_PowerOff:                0x1008FF2A,
+    XF86XK_WakeUp:                  0x1008FF2B,
+    XF86XK_Eject:                   0x1008FF2C,
+    XF86XK_ScreenSaver:             0x1008FF2D,
+    XF86XK_WWW:                     0x1008FF2E,
+    XF86XK_Sleep:                   0x1008FF2F,
+    XF86XK_Favorites:               0x1008FF30,
+    XF86XK_AudioPause:              0x1008FF31,
+    XF86XK_AudioMedia:              0x1008FF32,
+    XF86XK_MyComputer:              0x1008FF33,
+    XF86XK_VendorHome:              0x1008FF34,
+    XF86XK_LightBulb:               0x1008FF35,
+    XF86XK_Shop:                    0x1008FF36,
+    XF86XK_History:                 0x1008FF37,
+    XF86XK_OpenURL:                 0x1008FF38,
+    XF86XK_AddFavorite:             0x1008FF39,
+    XF86XK_HotLinks:                0x1008FF3A,
+    XF86XK_BrightnessAdjust:        0x1008FF3B,
+    XF86XK_Finance:                 0x1008FF3C,
+    XF86XK_Community:               0x1008FF3D,
+    XF86XK_AudioRewind:             0x1008FF3E,
+    XF86XK_BackForward:             0x1008FF3F,
+    XF86XK_Launch0:                 0x1008FF40,
+    XF86XK_Launch1:                 0x1008FF41,
+    XF86XK_Launch2:                 0x1008FF42,
+    XF86XK_Launch3:                 0x1008FF43,
+    XF86XK_Launch4:                 0x1008FF44,
+    XF86XK_Launch5:                 0x1008FF45,
+    XF86XK_Launch6:                 0x1008FF46,
+    XF86XK_Launch7:                 0x1008FF47,
+    XF86XK_Launch8:                 0x1008FF48,
+    XF86XK_Launch9:                 0x1008FF49,
+    XF86XK_LaunchA:                 0x1008FF4A,
+    XF86XK_LaunchB:                 0x1008FF4B,
+    XF86XK_LaunchC:                 0x1008FF4C,
+    XF86XK_LaunchD:                 0x1008FF4D,
+    XF86XK_LaunchE:                 0x1008FF4E,
+    XF86XK_LaunchF:                 0x1008FF4F,
+    XF86XK_ApplicationLeft:         0x1008FF50,
+    XF86XK_ApplicationRight:        0x1008FF51,
+    XF86XK_Book:                    0x1008FF52,
+    XF86XK_CD:                      0x1008FF53,
+    XF86XK_Calculater:              0x1008FF54,
+    XF86XK_Clear:                   0x1008FF55,
+    XF86XK_Close:                   0x1008FF56,
+    XF86XK_Copy:                    0x1008FF57,
+    XF86XK_Cut:                     0x1008FF58,
+    XF86XK_Display:                 0x1008FF59,
+    XF86XK_DOS:                     0x1008FF5A,
+    XF86XK_Documents:               0x1008FF5B,
+    XF86XK_Excel:                   0x1008FF5C,
+    XF86XK_Explorer:                0x1008FF5D,
+    XF86XK_Game:                    0x1008FF5E,
+    XF86XK_Go:                      0x1008FF5F,
+    XF86XK_iTouch:                  0x1008FF60,
+    XF86XK_LogOff:                  0x1008FF61,
+    XF86XK_Market:                  0x1008FF62,
+    XF86XK_Meeting:                 0x1008FF63,
+    XF86XK_MenuKB:                  0x1008FF65,
+    XF86XK_MenuPB:                  0x1008FF66,
+    XF86XK_MySites:                 0x1008FF67,
+    XF86XK_New:                     0x1008FF68,
+    XF86XK_News:                    0x1008FF69,
+    XF86XK_OfficeHome:              0x1008FF6A,
+    XF86XK_Open:                    0x1008FF6B,
+    XF86XK_Option:                  0x1008FF6C,
+    XF86XK_Paste:                   0x1008FF6D,
+    XF86XK_Phone:                   0x1008FF6E,
+    XF86XK_Q:                       0x1008FF70,
+    XF86XK_Reply:                   0x1008FF72,
+    XF86XK_Reload:                  0x1008FF73,
+    XF86XK_RotateWindows:           0x1008FF74,
+    XF86XK_RotationPB:              0x1008FF75,
+    XF86XK_RotationKB:              0x1008FF76,
+    XF86XK_Save:                    0x1008FF77,
+    XF86XK_ScrollUp:                0x1008FF78,
+    XF86XK_ScrollDown:              0x1008FF79,
+    XF86XK_ScrollClick:             0x1008FF7A,
+    XF86XK_Send:                    0x1008FF7B,
+    XF86XK_Spell:                   0x1008FF7C,
+    XF86XK_SplitScreen:             0x1008FF7D,
+    XF86XK_Support:                 0x1008FF7E,
+    XF86XK_TaskPane:                0x1008FF7F,
+    XF86XK_Terminal:                0x1008FF80,
+    XF86XK_Tools:                   0x1008FF81,
+    XF86XK_Travel:                  0x1008FF82,
+    XF86XK_UserPB:                  0x1008FF84,
+    XF86XK_User1KB:                 0x1008FF85,
+    XF86XK_User2KB:                 0x1008FF86,
+    XF86XK_Video:                   0x1008FF87,
+    XF86XK_WheelButton:             0x1008FF88,
+    XF86XK_Word:                    0x1008FF89,
+    XF86XK_Xfer:                    0x1008FF8A,
+    XF86XK_ZoomIn:                  0x1008FF8B,
+    XF86XK_ZoomOut:                 0x1008FF8C,
+    XF86XK_Away:                    0x1008FF8D,
+    XF86XK_Messenger:               0x1008FF8E,
+    XF86XK_WebCam:                  0x1008FF8F,
+    XF86XK_MailForward:             0x1008FF90,
+    XF86XK_Pictures:                0x1008FF91,
+    XF86XK_Music:                   0x1008FF92,
+    XF86XK_Battery:                 0x1008FF93,
+    XF86XK_Bluetooth:               0x1008FF94,
+    XF86XK_WLAN:                    0x1008FF95,
+    XF86XK_UWB:                     0x1008FF96,
+    XF86XK_AudioForward:            0x1008FF97,
+    XF86XK_AudioRepeat:             0x1008FF98,
+    XF86XK_AudioRandomPlay:         0x1008FF99,
+    XF86XK_Subtitle:                0x1008FF9A,
+    XF86XK_AudioCycleTrack:         0x1008FF9B,
+    XF86XK_CycleAngle:              0x1008FF9C,
+    XF86XK_FrameBack:               0x1008FF9D,
+    XF86XK_FrameForward:            0x1008FF9E,
+    XF86XK_Time:                    0x1008FF9F,
+    XF86XK_Select:                  0x1008FFA0,
+    XF86XK_View:                    0x1008FFA1,
+    XF86XK_TopMenu:                 0x1008FFA2,
+    XF86XK_Red:                     0x1008FFA3,
+    XF86XK_Green:                   0x1008FFA4,
+    XF86XK_Yellow:                  0x1008FFA5,
+    XF86XK_Blue:                    0x1008FFA6,
+    XF86XK_Suspend:                 0x1008FFA7,
+    XF86XK_Hibernate:               0x1008FFA8,
+    XF86XK_TouchpadToggle:          0x1008FFA9,
+    XF86XK_TouchpadOn:              0x1008FFB0,
+    XF86XK_TouchpadOff:             0x1008FFB1,
+    XF86XK_AudioMicMute:            0x1008FFB2,
+    XF86XK_Switch_VT_1:             0x1008FE01,
+    XF86XK_Switch_VT_2:             0x1008FE02,
+    XF86XK_Switch_VT_3:             0x1008FE03,
+    XF86XK_Switch_VT_4:             0x1008FE04,
+    XF86XK_Switch_VT_5:             0x1008FE05,
+    XF86XK_Switch_VT_6:             0x1008FE06,
+    XF86XK_Switch_VT_7:             0x1008FE07,
+    XF86XK_Switch_VT_8:             0x1008FE08,
+    XF86XK_Switch_VT_9:             0x1008FE09,
+    XF86XK_Switch_VT_10:            0x1008FE0A,
+    XF86XK_Switch_VT_11:            0x1008FE0B,
+    XF86XK_Switch_VT_12:            0x1008FE0C,
+    XF86XK_Ungrab:                  0x1008FE20,
+    XF86XK_ClearGrab:               0x1008FE21,
+    XF86XK_Next_VMode:              0x1008FE22,
+    XF86XK_Prev_VMode:              0x1008FE23,
+    XF86XK_LogWindowTree:           0x1008FE24,
+    XF86XK_LogGrabInfo:             0x1008FE25,
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/input/keysymdef.js
@@ -0,0 +1,688 @@
+/*
+ * Mapping from Unicode codepoints to X11/RFB keysyms
+ *
+ * This file was automatically generated from keysymdef.h
+ * DO NOT EDIT!
+ */
+
+/* Functions at the bottom */
+
+const codepoints = {
+    0x0100: 0x03c0, // XK_Amacron
+    0x0101: 0x03e0, // XK_amacron
+    0x0102: 0x01c3, // XK_Abreve
+    0x0103: 0x01e3, // XK_abreve
+    0x0104: 0x01a1, // XK_Aogonek
+    0x0105: 0x01b1, // XK_aogonek
+    0x0106: 0x01c6, // XK_Cacute
+    0x0107: 0x01e6, // XK_cacute
+    0x0108: 0x02c6, // XK_Ccircumflex
+    0x0109: 0x02e6, // XK_ccircumflex
+    0x010a: 0x02c5, // XK_Cabovedot
+    0x010b: 0x02e5, // XK_cabovedot
+    0x010c: 0x01c8, // XK_Ccaron
+    0x010d: 0x01e8, // XK_ccaron
+    0x010e: 0x01cf, // XK_Dcaron
+    0x010f: 0x01ef, // XK_dcaron
+    0x0110: 0x01d0, // XK_Dstroke
+    0x0111: 0x01f0, // XK_dstroke
+    0x0112: 0x03aa, // XK_Emacron
+    0x0113: 0x03ba, // XK_emacron
+    0x0116: 0x03cc, // XK_Eabovedot
+    0x0117: 0x03ec, // XK_eabovedot
+    0x0118: 0x01ca, // XK_Eogonek
+    0x0119: 0x01ea, // XK_eogonek
+    0x011a: 0x01cc, // XK_Ecaron
+    0x011b: 0x01ec, // XK_ecaron
+    0x011c: 0x02d8, // XK_Gcircumflex
+    0x011d: 0x02f8, // XK_gcircumflex
+    0x011e: 0x02ab, // XK_Gbreve
+    0x011f: 0x02bb, // XK_gbreve
+    0x0120: 0x02d5, // XK_Gabovedot
+    0x0121: 0x02f5, // XK_gabovedot
+    0x0122: 0x03ab, // XK_Gcedilla
+    0x0123: 0x03bb, // XK_gcedilla
+    0x0124: 0x02a6, // XK_Hcircumflex
+    0x0125: 0x02b6, // XK_hcircumflex
+    0x0126: 0x02a1, // XK_Hstroke
+    0x0127: 0x02b1, // XK_hstroke
+    0x0128: 0x03a5, // XK_Itilde
+    0x0129: 0x03b5, // XK_itilde
+    0x012a: 0x03cf, // XK_Imacron
+    0x012b: 0x03ef, // XK_imacron
+    0x012e: 0x03c7, // XK_Iogonek
+    0x012f: 0x03e7, // XK_iogonek
+    0x0130: 0x02a9, // XK_Iabovedot
+    0x0131: 0x02b9, // XK_idotless
+    0x0134: 0x02ac, // XK_Jcircumflex
+    0x0135: 0x02bc, // XK_jcircumflex
+    0x0136: 0x03d3, // XK_Kcedilla
+    0x0137: 0x03f3, // XK_kcedilla
+    0x0138: 0x03a2, // XK_kra
+    0x0139: 0x01c5, // XK_Lacute
+    0x013a: 0x01e5, // XK_lacute
+    0x013b: 0x03a6, // XK_Lcedilla
+    0x013c: 0x03b6, // XK_lcedilla
+    0x013d: 0x01a5, // XK_Lcaron
+    0x013e: 0x01b5, // XK_lcaron
+    0x0141: 0x01a3, // XK_Lstroke
+    0x0142: 0x01b3, // XK_lstroke
+    0x0143: 0x01d1, // XK_Nacute
+    0x0144: 0x01f1, // XK_nacute
+    0x0145: 0x03d1, // XK_Ncedilla
+    0x0146: 0x03f1, // XK_ncedilla
+    0x0147: 0x01d2, // XK_Ncaron
+    0x0148: 0x01f2, // XK_ncaron
+    0x014a: 0x03bd, // XK_ENG
+    0x014b: 0x03bf, // XK_eng
+    0x014c: 0x03d2, // XK_Omacron
+    0x014d: 0x03f2, // XK_omacron
+    0x0150: 0x01d5, // XK_Odoubleacute
+    0x0151: 0x01f5, // XK_odoubleacute
+    0x0152: 0x13bc, // XK_OE
+    0x0153: 0x13bd, // XK_oe
+    0x0154: 0x01c0, // XK_Racute
+    0x0155: 0x01e0, // XK_racute
+    0x0156: 0x03a3, // XK_Rcedilla
+    0x0157: 0x03b3, // XK_rcedilla
+    0x0158: 0x01d8, // XK_Rcaron
+    0x0159: 0x01f8, // XK_rcaron
+    0x015a: 0x01a6, // XK_Sacute
+    0x015b: 0x01b6, // XK_sacute
+    0x015c: 0x02de, // XK_Scircumflex
+    0x015d: 0x02fe, // XK_scircumflex
+    0x015e: 0x01aa, // XK_Scedilla
+    0x015f: 0x01ba, // XK_scedilla
+    0x0160: 0x01a9, // XK_Scaron
+    0x0161: 0x01b9, // XK_scaron
+    0x0162: 0x01de, // XK_Tcedilla
+    0x0163: 0x01fe, // XK_tcedilla
+    0x0164: 0x01ab, // XK_Tcaron
+    0x0165: 0x01bb, // XK_tcaron
+    0x0166: 0x03ac, // XK_Tslash
+    0x0167: 0x03bc, // XK_tslash
+    0x0168: 0x03dd, // XK_Utilde
+    0x0169: 0x03fd, // XK_utilde
+    0x016a: 0x03de, // XK_Umacron
+    0x016b: 0x03fe, // XK_umacron
+    0x016c: 0x02dd, // XK_Ubreve
+    0x016d: 0x02fd, // XK_ubreve
+    0x016e: 0x01d9, // XK_Uring
+    0x016f: 0x01f9, // XK_uring
+    0x0170: 0x01db, // XK_Udoubleacute
+    0x0171: 0x01fb, // XK_udoubleacute
+    0x0172: 0x03d9, // XK_Uogonek
+    0x0173: 0x03f9, // XK_uogonek
+    0x0178: 0x13be, // XK_Ydiaeresis
+    0x0179: 0x01ac, // XK_Zacute
+    0x017a: 0x01bc, // XK_zacute
+    0x017b: 0x01af, // XK_Zabovedot
+    0x017c: 0x01bf, // XK_zabovedot
+    0x017d: 0x01ae, // XK_Zcaron
+    0x017e: 0x01be, // XK_zcaron
+    0x0192: 0x08f6, // XK_function
+    0x01d2: 0x10001d1, // XK_Ocaron
+    0x02c7: 0x01b7, // XK_caron
+    0x02d8: 0x01a2, // XK_breve
+    0x02d9: 0x01ff, // XK_abovedot
+    0x02db: 0x01b2, // XK_ogonek
+    0x02dd: 0x01bd, // XK_doubleacute
+    0x0385: 0x07ae, // XK_Greek_accentdieresis
+    0x0386: 0x07a1, // XK_Greek_ALPHAaccent
+    0x0388: 0x07a2, // XK_Greek_EPSILONaccent
+    0x0389: 0x07a3, // XK_Greek_ETAaccent
+    0x038a: 0x07a4, // XK_Greek_IOTAaccent
+    0x038c: 0x07a7, // XK_Greek_OMICRONaccent
+    0x038e: 0x07a8, // XK_Greek_UPSILONaccent
+    0x038f: 0x07ab, // XK_Greek_OMEGAaccent
+    0x0390: 0x07b6, // XK_Greek_iotaaccentdieresis
+    0x0391: 0x07c1, // XK_Greek_ALPHA
+    0x0392: 0x07c2, // XK_Greek_BETA
+    0x0393: 0x07c3, // XK_Greek_GAMMA
+    0x0394: 0x07c4, // XK_Greek_DELTA
+    0x0395: 0x07c5, // XK_Greek_EPSILON
+    0x0396: 0x07c6, // XK_Greek_ZETA
+    0x0397: 0x07c7, // XK_Greek_ETA
+    0x0398: 0x07c8, // XK_Greek_THETA
+    0x0399: 0x07c9, // XK_Greek_IOTA
+    0x039a: 0x07ca, // XK_Greek_KAPPA
+    0x039b: 0x07cb, // XK_Greek_LAMDA
+    0x039c: 0x07cc, // XK_Greek_MU
+    0x039d: 0x07cd, // XK_Greek_NU
+    0x039e: 0x07ce, // XK_Greek_XI
+    0x039f: 0x07cf, // XK_Greek_OMICRON
+    0x03a0: 0x07d0, // XK_Greek_PI
+    0x03a1: 0x07d1, // XK_Greek_RHO
+    0x03a3: 0x07d2, // XK_Greek_SIGMA
+    0x03a4: 0x07d4, // XK_Greek_TAU
+    0x03a5: 0x07d5, // XK_Greek_UPSILON
+    0x03a6: 0x07d6, // XK_Greek_PHI
+    0x03a7: 0x07d7, // XK_Greek_CHI
+    0x03a8: 0x07d8, // XK_Greek_PSI
+    0x03a9: 0x07d9, // XK_Greek_OMEGA
+    0x03aa: 0x07a5, // XK_Greek_IOTAdieresis
+    0x03ab: 0x07a9, // XK_Greek_UPSILONdieresis
+    0x03ac: 0x07b1, // XK_Greek_alphaaccent
+    0x03ad: 0x07b2, // XK_Greek_epsilonaccent
+    0x03ae: 0x07b3, // XK_Greek_etaaccent
+    0x03af: 0x07b4, // XK_Greek_iotaaccent
+    0x03b0: 0x07ba, // XK_Greek_upsilonaccentdieresis
+    0x03b1: 0x07e1, // XK_Greek_alpha
+    0x03b2: 0x07e2, // XK_Greek_beta
+    0x03b3: 0x07e3, // XK_Greek_gamma
+    0x03b4: 0x07e4, // XK_Greek_delta
+    0x03b5: 0x07e5, // XK_Greek_epsilon
+    0x03b6: 0x07e6, // XK_Greek_zeta
+    0x03b7: 0x07e7, // XK_Greek_eta
+    0x03b8: 0x07e8, // XK_Greek_theta
+    0x03b9: 0x07e9, // XK_Greek_iota
+    0x03ba: 0x07ea, // XK_Greek_kappa
+    0x03bb: 0x07eb, // XK_Greek_lamda
+    0x03bc: 0x07ec, // XK_Greek_mu
+    0x03bd: 0x07ed, // XK_Greek_nu
+    0x03be: 0x07ee, // XK_Greek_xi
+    0x03bf: 0x07ef, // XK_Greek_omicron
+    0x03c0: 0x07f0, // XK_Greek_pi
+    0x03c1: 0x07f1, // XK_Greek_rho
+    0x03c2: 0x07f3, // XK_Greek_finalsmallsigma
+    0x03c3: 0x07f2, // XK_Greek_sigma
+    0x03c4: 0x07f4, // XK_Greek_tau
+    0x03c5: 0x07f5, // XK_Greek_upsilon
+    0x03c6: 0x07f6, // XK_Greek_phi
+    0x03c7: 0x07f7, // XK_Greek_chi
+    0x03c8: 0x07f8, // XK_Greek_psi
+    0x03c9: 0x07f9, // XK_Greek_omega
+    0x03ca: 0x07b5, // XK_Greek_iotadieresis
+    0x03cb: 0x07b9, // XK_Greek_upsilondieresis
+    0x03cc: 0x07b7, // XK_Greek_omicronaccent
+    0x03cd: 0x07b8, // XK_Greek_upsilonaccent
+    0x03ce: 0x07bb, // XK_Greek_omegaaccent
+    0x0401: 0x06b3, // XK_Cyrillic_IO
+    0x0402: 0x06b1, // XK_Serbian_DJE
+    0x0403: 0x06b2, // XK_Macedonia_GJE
+    0x0404: 0x06b4, // XK_Ukrainian_IE
+    0x0405: 0x06b5, // XK_Macedonia_DSE
+    0x0406: 0x06b6, // XK_Ukrainian_I
+    0x0407: 0x06b7, // XK_Ukrainian_YI
+    0x0408: 0x06b8, // XK_Cyrillic_JE
+    0x0409: 0x06b9, // XK_Cyrillic_LJE
+    0x040a: 0x06ba, // XK_Cyrillic_NJE
+    0x040b: 0x06bb, // XK_Serbian_TSHE
+    0x040c: 0x06bc, // XK_Macedonia_KJE
+    0x040e: 0x06be, // XK_Byelorussian_SHORTU
+    0x040f: 0x06bf, // XK_Cyrillic_DZHE
+    0x0410: 0x06e1, // XK_Cyrillic_A
+    0x0411: 0x06e2, // XK_Cyrillic_BE
+    0x0412: 0x06f7, // XK_Cyrillic_VE
+    0x0413: 0x06e7, // XK_Cyrillic_GHE
+    0x0414: 0x06e4, // XK_Cyrillic_DE
+    0x0415: 0x06e5, // XK_Cyrillic_IE
+    0x0416: 0x06f6, // XK_Cyrillic_ZHE
+    0x0417: 0x06fa, // XK_Cyrillic_ZE
+    0x0418: 0x06e9, // XK_Cyrillic_I
+    0x0419: 0x06ea, // XK_Cyrillic_SHORTI
+    0x041a: 0x06eb, // XK_Cyrillic_KA
+    0x041b: 0x06ec, // XK_Cyrillic_EL
+    0x041c: 0x06ed, // XK_Cyrillic_EM
+    0x041d: 0x06ee, // XK_Cyrillic_EN
+    0x041e: 0x06ef, // XK_Cyrillic_O
+    0x041f: 0x06f0, // XK_Cyrillic_PE
+    0x0420: 0x06f2, // XK_Cyrillic_ER
+    0x0421: 0x06f3, // XK_Cyrillic_ES
+    0x0422: 0x06f4, // XK_Cyrillic_TE
+    0x0423: 0x06f5, // XK_Cyrillic_U
+    0x0424: 0x06e6, // XK_Cyrillic_EF
+    0x0425: 0x06e8, // XK_Cyrillic_HA
+    0x0426: 0x06e3, // XK_Cyrillic_TSE
+    0x0427: 0x06fe, // XK_Cyrillic_CHE
+    0x0428: 0x06fb, // XK_Cyrillic_SHA
+    0x0429: 0x06fd, // XK_Cyrillic_SHCHA
+    0x042a: 0x06ff, // XK_Cyrillic_HARDSIGN
+    0x042b: 0x06f9, // XK_Cyrillic_YERU
+    0x042c: 0x06f8, // XK_Cyrillic_SOFTSIGN
+    0x042d: 0x06fc, // XK_Cyrillic_E
+    0x042e: 0x06e0, // XK_Cyrillic_YU
+    0x042f: 0x06f1, // XK_Cyrillic_YA
+    0x0430: 0x06c1, // XK_Cyrillic_a
+    0x0431: 0x06c2, // XK_Cyrillic_be
+    0x0432: 0x06d7, // XK_Cyrillic_ve
+    0x0433: 0x06c7, // XK_Cyrillic_ghe
+    0x0434: 0x06c4, // XK_Cyrillic_de
+    0x0435: 0x06c5, // XK_Cyrillic_ie
+    0x0436: 0x06d6, // XK_Cyrillic_zhe
+    0x0437: 0x06da, // XK_Cyrillic_ze
+    0x0438: 0x06c9, // XK_Cyrillic_i
+    0x0439: 0x06ca, // XK_Cyrillic_shorti
+    0x043a: 0x06cb, // XK_Cyrillic_ka
+    0x043b: 0x06cc, // XK_Cyrillic_el
+    0x043c: 0x06cd, // XK_Cyrillic_em
+    0x043d: 0x06ce, // XK_Cyrillic_en
+    0x043e: 0x06cf, // XK_Cyrillic_o
+    0x043f: 0x06d0, // XK_Cyrillic_pe
+    0x0440: 0x06d2, // XK_Cyrillic_er
+    0x0441: 0x06d3, // XK_Cyrillic_es
+    0x0442: 0x06d4, // XK_Cyrillic_te
+    0x0443: 0x06d5, // XK_Cyrillic_u
+    0x0444: 0x06c6, // XK_Cyrillic_ef
+    0x0445: 0x06c8, // XK_Cyrillic_ha
+    0x0446: 0x06c3, // XK_Cyrillic_tse
+    0x0447: 0x06de, // XK_Cyrillic_che
+    0x0448: 0x06db, // XK_Cyrillic_sha
+    0x0449: 0x06dd, // XK_Cyrillic_shcha
+    0x044a: 0x06df, // XK_Cyrillic_hardsign
+    0x044b: 0x06d9, // XK_Cyrillic_yeru
+    0x044c: 0x06d8, // XK_Cyrillic_softsign
+    0x044d: 0x06dc, // XK_Cyrillic_e
+    0x044e: 0x06c0, // XK_Cyrillic_yu
+    0x044f: 0x06d1, // XK_Cyrillic_ya
+    0x0451: 0x06a3, // XK_Cyrillic_io
+    0x0452: 0x06a1, // XK_Serbian_dje
+    0x0453: 0x06a2, // XK_Macedonia_gje
+    0x0454: 0x06a4, // XK_Ukrainian_ie
+    0x0455: 0x06a5, // XK_Macedonia_dse
+    0x0456: 0x06a6, // XK_Ukrainian_i
+    0x0457: 0x06a7, // XK_Ukrainian_yi
+    0x0458: 0x06a8, // XK_Cyrillic_je
+    0x0459: 0x06a9, // XK_Cyrillic_lje
+    0x045a: 0x06aa, // XK_Cyrillic_nje
+    0x045b: 0x06ab, // XK_Serbian_tshe
+    0x045c: 0x06ac, // XK_Macedonia_kje
+    0x045e: 0x06ae, // XK_Byelorussian_shortu
+    0x045f: 0x06af, // XK_Cyrillic_dzhe
+    0x0490: 0x06bd, // XK_Ukrainian_GHE_WITH_UPTURN
+    0x0491: 0x06ad, // XK_Ukrainian_ghe_with_upturn
+    0x05d0: 0x0ce0, // XK_hebrew_aleph
+    0x05d1: 0x0ce1, // XK_hebrew_bet
+    0x05d2: 0x0ce2, // XK_hebrew_gimel
+    0x05d3: 0x0ce3, // XK_hebrew_dalet
+    0x05d4: 0x0ce4, // XK_hebrew_he
+    0x05d5: 0x0ce5, // XK_hebrew_waw
+    0x05d6: 0x0ce6, // XK_hebrew_zain
+    0x05d7: 0x0ce7, // XK_hebrew_chet
+    0x05d8: 0x0ce8, // XK_hebrew_tet
+    0x05d9: 0x0ce9, // XK_hebrew_yod
+    0x05da: 0x0cea, // XK_hebrew_finalkaph
+    0x05db: 0x0ceb, // XK_hebrew_kaph
+    0x05dc: 0x0cec, // XK_hebrew_lamed
+    0x05dd: 0x0ced, // XK_hebrew_finalmem
+    0x05de: 0x0cee, // XK_hebrew_mem
+    0x05df: 0x0cef, // XK_hebrew_finalnun
+    0x05e0: 0x0cf0, // XK_hebrew_nun
+    0x05e1: 0x0cf1, // XK_hebrew_samech
+    0x05e2: 0x0cf2, // XK_hebrew_ayin
+    0x05e3: 0x0cf3, // XK_hebrew_finalpe
+    0x05e4: 0x0cf4, // XK_hebrew_pe
+    0x05e5: 0x0cf5, // XK_hebrew_finalzade
+    0x05e6: 0x0cf6, // XK_hebrew_zade
+    0x05e7: 0x0cf7, // XK_hebrew_qoph
+    0x05e8: 0x0cf8, // XK_hebrew_resh
+    0x05e9: 0x0cf9, // XK_hebrew_shin
+    0x05ea: 0x0cfa, // XK_hebrew_taw
+    0x060c: 0x05ac, // XK_Arabic_comma
+    0x061b: 0x05bb, // XK_Arabic_semicolon
+    0x061f: 0x05bf, // XK_Arabic_question_mark
+    0x0621: 0x05c1, // XK_Arabic_hamza
+    0x0622: 0x05c2, // XK_Arabic_maddaonalef
+    0x0623: 0x05c3, // XK_Arabic_hamzaonalef
+    0x0624: 0x05c4, // XK_Arabic_hamzaonwaw
+    0x0625: 0x05c5, // XK_Arabic_hamzaunderalef
+    0x0626: 0x05c6, // XK_Arabic_hamzaonyeh
+    0x0627: 0x05c7, // XK_Arabic_alef
+    0x0628: 0x05c8, // XK_Arabic_beh
+    0x0629: 0x05c9, // XK_Arabic_tehmarbuta
+    0x062a: 0x05ca, // XK_Arabic_teh
+    0x062b: 0x05cb, // XK_Arabic_theh
+    0x062c: 0x05cc, // XK_Arabic_jeem
+    0x062d: 0x05cd, // XK_Arabic_hah
+    0x062e: 0x05ce, // XK_Arabic_khah
+    0x062f: 0x05cf, // XK_Arabic_dal
+    0x0630: 0x05d0, // XK_Arabic_thal
+    0x0631: 0x05d1, // XK_Arabic_ra
+    0x0632: 0x05d2, // XK_Arabic_zain
+    0x0633: 0x05d3, // XK_Arabic_seen
+    0x0634: 0x05d4, // XK_Arabic_sheen
+    0x0635: 0x05d5, // XK_Arabic_sad
+    0x0636: 0x05d6, // XK_Arabic_dad
+    0x0637: 0x05d7, // XK_Arabic_tah
+    0x0638: 0x05d8, // XK_Arabic_zah
+    0x0639: 0x05d9, // XK_Arabic_ain
+    0x063a: 0x05da, // XK_Arabic_ghain
+    0x0640: 0x05e0, // XK_Arabic_tatweel
+    0x0641: 0x05e1, // XK_Arabic_feh
+    0x0642: 0x05e2, // XK_Arabic_qaf
+    0x0643: 0x05e3, // XK_Arabic_kaf
+    0x0644: 0x05e4, // XK_Arabic_lam
+    0x0645: 0x05e5, // XK_Arabic_meem
+    0x0646: 0x05e6, // XK_Arabic_noon
+    0x0647: 0x05e7, // XK_Arabic_ha
+    0x0648: 0x05e8, // XK_Arabic_waw
+    0x0649: 0x05e9, // XK_Arabic_alefmaksura
+    0x064a: 0x05ea, // XK_Arabic_yeh
+    0x064b: 0x05eb, // XK_Arabic_fathatan
+    0x064c: 0x05ec, // XK_Arabic_dammatan
+    0x064d: 0x05ed, // XK_Arabic_kasratan
+    0x064e: 0x05ee, // XK_Arabic_fatha
+    0x064f: 0x05ef, // XK_Arabic_damma
+    0x0650: 0x05f0, // XK_Arabic_kasra
+    0x0651: 0x05f1, // XK_Arabic_shadda
+    0x0652: 0x05f2, // XK_Arabic_sukun
+    0x0e01: 0x0da1, // XK_Thai_kokai
+    0x0e02: 0x0da2, // XK_Thai_khokhai
+    0x0e03: 0x0da3, // XK_Thai_khokhuat
+    0x0e04: 0x0da4, // XK_Thai_khokhwai
+    0x0e05: 0x0da5, // XK_Thai_khokhon
+    0x0e06: 0x0da6, // XK_Thai_khorakhang
+    0x0e07: 0x0da7, // XK_Thai_ngongu
+    0x0e08: 0x0da8, // XK_Thai_chochan
+    0x0e09: 0x0da9, // XK_Thai_choching
+    0x0e0a: 0x0daa, // XK_Thai_chochang
+    0x0e0b: 0x0dab, // XK_Thai_soso
+    0x0e0c: 0x0dac, // XK_Thai_chochoe
+    0x0e0d: 0x0dad, // XK_Thai_yoying
+    0x0e0e: 0x0dae, // XK_Thai_dochada
+    0x0e0f: 0x0daf, // XK_Thai_topatak
+    0x0e10: 0x0db0, // XK_Thai_thothan
+    0x0e11: 0x0db1, // XK_Thai_thonangmontho
+    0x0e12: 0x0db2, // XK_Thai_thophuthao
+    0x0e13: 0x0db3, // XK_Thai_nonen
+    0x0e14: 0x0db4, // XK_Thai_dodek
+    0x0e15: 0x0db5, // XK_Thai_totao
+    0x0e16: 0x0db6, // XK_Thai_thothung
+    0x0e17: 0x0db7, // XK_Thai_thothahan
+    0x0e18: 0x0db8, // XK_Thai_thothong
+    0x0e19: 0x0db9, // XK_Thai_nonu
+    0x0e1a: 0x0dba, // XK_Thai_bobaimai
+    0x0e1b: 0x0dbb, // XK_Thai_popla
+    0x0e1c: 0x0dbc, // XK_Thai_phophung
+    0x0e1d: 0x0dbd, // XK_Thai_fofa
+    0x0e1e: 0x0dbe, // XK_Thai_phophan
+    0x0e1f: 0x0dbf, // XK_Thai_fofan
+    0x0e20: 0x0dc0, // XK_Thai_phosamphao
+    0x0e21: 0x0dc1, // XK_Thai_moma
+    0x0e22: 0x0dc2, // XK_Thai_yoyak
+    0x0e23: 0x0dc3, // XK_Thai_rorua
+    0x0e24: 0x0dc4, // XK_Thai_ru
+    0x0e25: 0x0dc5, // XK_Thai_loling
+    0x0e26: 0x0dc6, // XK_Thai_lu
+    0x0e27: 0x0dc7, // XK_Thai_wowaen
+    0x0e28: 0x0dc8, // XK_Thai_sosala
+    0x0e29: 0x0dc9, // XK_Thai_sorusi
+    0x0e2a: 0x0dca, // XK_Thai_sosua
+    0x0e2b: 0x0dcb, // XK_Thai_hohip
+    0x0e2c: 0x0dcc, // XK_Thai_lochula
+    0x0e2d: 0x0dcd, // XK_Thai_oang
+    0x0e2e: 0x0dce, // XK_Thai_honokhuk
+    0x0e2f: 0x0dcf, // XK_Thai_paiyannoi
+    0x0e30: 0x0dd0, // XK_Thai_saraa
+    0x0e31: 0x0dd1, // XK_Thai_maihanakat
+    0x0e32: 0x0dd2, // XK_Thai_saraaa
+    0x0e33: 0x0dd3, // XK_Thai_saraam
+    0x0e34: 0x0dd4, // XK_Thai_sarai
+    0x0e35: 0x0dd5, // XK_Thai_saraii
+    0x0e36: 0x0dd6, // XK_Thai_saraue
+    0x0e37: 0x0dd7, // XK_Thai_sarauee
+    0x0e38: 0x0dd8, // XK_Thai_sarau
+    0x0e39: 0x0dd9, // XK_Thai_sarauu
+    0x0e3a: 0x0dda, // XK_Thai_phinthu
+    0x0e3f: 0x0ddf, // XK_Thai_baht
+    0x0e40: 0x0de0, // XK_Thai_sarae
+    0x0e41: 0x0de1, // XK_Thai_saraae
+    0x0e42: 0x0de2, // XK_Thai_sarao
+    0x0e43: 0x0de3, // XK_Thai_saraaimaimuan
+    0x0e44: 0x0de4, // XK_Thai_saraaimaimalai
+    0x0e45: 0x0de5, // XK_Thai_lakkhangyao
+    0x0e46: 0x0de6, // XK_Thai_maiyamok
+    0x0e47: 0x0de7, // XK_Thai_maitaikhu
+    0x0e48: 0x0de8, // XK_Thai_maiek
+    0x0e49: 0x0de9, // XK_Thai_maitho
+    0x0e4a: 0x0dea, // XK_Thai_maitri
+    0x0e4b: 0x0deb, // XK_Thai_maichattawa
+    0x0e4c: 0x0dec, // XK_Thai_thanthakhat
+    0x0e4d: 0x0ded, // XK_Thai_nikhahit
+    0x0e50: 0x0df0, // XK_Thai_leksun
+    0x0e51: 0x0df1, // XK_Thai_leknung
+    0x0e52: 0x0df2, // XK_Thai_leksong
+    0x0e53: 0x0df3, // XK_Thai_leksam
+    0x0e54: 0x0df4, // XK_Thai_leksi
+    0x0e55: 0x0df5, // XK_Thai_lekha
+    0x0e56: 0x0df6, // XK_Thai_lekhok
+    0x0e57: 0x0df7, // XK_Thai_lekchet
+    0x0e58: 0x0df8, // XK_Thai_lekpaet
+    0x0e59: 0x0df9, // XK_Thai_lekkao
+    0x2002: 0x0aa2, // XK_enspace
+    0x2003: 0x0aa1, // XK_emspace
+    0x2004: 0x0aa3, // XK_em3space
+    0x2005: 0x0aa4, // XK_em4space
+    0x2007: 0x0aa5, // XK_digitspace
+    0x2008: 0x0aa6, // XK_punctspace
+    0x2009: 0x0aa7, // XK_thinspace
+    0x200a: 0x0aa8, // XK_hairspace
+    0x2012: 0x0abb, // XK_figdash
+    0x2013: 0x0aaa, // XK_endash
+    0x2014: 0x0aa9, // XK_emdash
+    0x2015: 0x07af, // XK_Greek_horizbar
+    0x2017: 0x0cdf, // XK_hebrew_doublelowline
+    0x2018: 0x0ad0, // XK_leftsinglequotemark
+    0x2019: 0x0ad1, // XK_rightsinglequotemark
+    0x201a: 0x0afd, // XK_singlelowquotemark
+    0x201c: 0x0ad2, // XK_leftdoublequotemark
+    0x201d: 0x0ad3, // XK_rightdoublequotemark
+    0x201e: 0x0afe, // XK_doublelowquotemark
+    0x2020: 0x0af1, // XK_dagger
+    0x2021: 0x0af2, // XK_doubledagger
+    0x2022: 0x0ae6, // XK_enfilledcircbullet
+    0x2025: 0x0aaf, // XK_doubbaselinedot
+    0x2026: 0x0aae, // XK_ellipsis
+    0x2030: 0x0ad5, // XK_permille
+    0x2032: 0x0ad6, // XK_minutes
+    0x2033: 0x0ad7, // XK_seconds
+    0x2038: 0x0afc, // XK_caret
+    0x203e: 0x047e, // XK_overline
+    0x20a9: 0x0eff, // XK_Korean_Won
+    0x20ac: 0x20ac, // XK_EuroSign
+    0x2105: 0x0ab8, // XK_careof
+    0x2116: 0x06b0, // XK_numerosign
+    0x2117: 0x0afb, // XK_phonographcopyright
+    0x211e: 0x0ad4, // XK_prescription
+    0x2122: 0x0ac9, // XK_trademark
+    0x2153: 0x0ab0, // XK_onethird
+    0x2154: 0x0ab1, // XK_twothirds
+    0x2155: 0x0ab2, // XK_onefifth
+    0x2156: 0x0ab3, // XK_twofifths
+    0x2157: 0x0ab4, // XK_threefifths
+    0x2158: 0x0ab5, // XK_fourfifths
+    0x2159: 0x0ab6, // XK_onesixth
+    0x215a: 0x0ab7, // XK_fivesixths
+    0x215b: 0x0ac3, // XK_oneeighth
+    0x215c: 0x0ac4, // XK_threeeighths
+    0x215d: 0x0ac5, // XK_fiveeighths
+    0x215e: 0x0ac6, // XK_seveneighths
+    0x2190: 0x08fb, // XK_leftarrow
+    0x2191: 0x08fc, // XK_uparrow
+    0x2192: 0x08fd, // XK_rightarrow
+    0x2193: 0x08fe, // XK_downarrow
+    0x21d2: 0x08ce, // XK_implies
+    0x21d4: 0x08cd, // XK_ifonlyif
+    0x2202: 0x08ef, // XK_partialderivative
+    0x2207: 0x08c5, // XK_nabla
+    0x2218: 0x0bca, // XK_jot
+    0x221a: 0x08d6, // XK_radical
+    0x221d: 0x08c1, // XK_variation
+    0x221e: 0x08c2, // XK_infinity
+    0x2227: 0x08de, // XK_logicaland
+    0x2228: 0x08df, // XK_logicalor
+    0x2229: 0x08dc, // XK_intersection
+    0x222a: 0x08dd, // XK_union
+    0x222b: 0x08bf, // XK_integral
+    0x2234: 0x08c0, // XK_therefore
+    0x223c: 0x08c8, // XK_approximate
+    0x2243: 0x08c9, // XK_similarequal
+    0x2245: 0x1002248, // XK_approxeq
+    0x2260: 0x08bd, // XK_notequal
+    0x2261: 0x08cf, // XK_identical
+    0x2264: 0x08bc, // XK_lessthanequal
+    0x2265: 0x08be, // XK_greaterthanequal
+    0x2282: 0x08da, // XK_includedin
+    0x2283: 0x08db, // XK_includes
+    0x22a2: 0x0bfc, // XK_righttack
+    0x22a3: 0x0bdc, // XK_lefttack
+    0x22a4: 0x0bc2, // XK_downtack
+    0x22a5: 0x0bce, // XK_uptack
+    0x2308: 0x0bd3, // XK_upstile
+    0x230a: 0x0bc4, // XK_downstile
+    0x2315: 0x0afa, // XK_telephonerecorder
+    0x2320: 0x08a4, // XK_topintegral
+    0x2321: 0x08a5, // XK_botintegral
+    0x2395: 0x0bcc, // XK_quad
+    0x239b: 0x08ab, // XK_topleftparens
+    0x239d: 0x08ac, // XK_botleftparens
+    0x239e: 0x08ad, // XK_toprightparens
+    0x23a0: 0x08ae, // XK_botrightparens
+    0x23a1: 0x08a7, // XK_topleftsqbracket
+    0x23a3: 0x08a8, // XK_botleftsqbracket
+    0x23a4: 0x08a9, // XK_toprightsqbracket
+    0x23a6: 0x08aa, // XK_botrightsqbracket
+    0x23a8: 0x08af, // XK_leftmiddlecurlybrace
+    0x23ac: 0x08b0, // XK_rightmiddlecurlybrace
+    0x23b7: 0x08a1, // XK_leftradical
+    0x23ba: 0x09ef, // XK_horizlinescan1
+    0x23bb: 0x09f0, // XK_horizlinescan3
+    0x23bc: 0x09f2, // XK_horizlinescan7
+    0x23bd: 0x09f3, // XK_horizlinescan9
+    0x2409: 0x09e2, // XK_ht
+    0x240a: 0x09e5, // XK_lf
+    0x240b: 0x09e9, // XK_vt
+    0x240c: 0x09e3, // XK_ff
+    0x240d: 0x09e4, // XK_cr
+    0x2423: 0x0aac, // XK_signifblank
+    0x2424: 0x09e8, // XK_nl
+    0x2500: 0x08a3, // XK_horizconnector
+    0x2502: 0x08a6, // XK_vertconnector
+    0x250c: 0x08a2, // XK_topleftradical
+    0x2510: 0x09eb, // XK_uprightcorner
+    0x2514: 0x09ed, // XK_lowleftcorner
+    0x2518: 0x09ea, // XK_lowrightcorner
+    0x251c: 0x09f4, // XK_leftt
+    0x2524: 0x09f5, // XK_rightt
+    0x252c: 0x09f7, // XK_topt
+    0x2534: 0x09f6, // XK_bott
+    0x253c: 0x09ee, // XK_crossinglines
+    0x2592: 0x09e1, // XK_checkerboard
+    0x25aa: 0x0ae7, // XK_enfilledsqbullet
+    0x25ab: 0x0ae1, // XK_enopensquarebullet
+    0x25ac: 0x0adb, // XK_filledrectbullet
+    0x25ad: 0x0ae2, // XK_openrectbullet
+    0x25ae: 0x0adf, // XK_emfilledrect
+    0x25af: 0x0acf, // XK_emopenrectangle
+    0x25b2: 0x0ae8, // XK_filledtribulletup
+    0x25b3: 0x0ae3, // XK_opentribulletup
+    0x25b6: 0x0add, // XK_filledrighttribullet
+    0x25b7: 0x0acd, // XK_rightopentriangle
+    0x25bc: 0x0ae9, // XK_filledtribulletdown
+    0x25bd: 0x0ae4, // XK_opentribulletdown
+    0x25c0: 0x0adc, // XK_filledlefttribullet
+    0x25c1: 0x0acc, // XK_leftopentriangle
+    0x25c6: 0x09e0, // XK_soliddiamond
+    0x25cb: 0x0ace, // XK_emopencircle
+    0x25cf: 0x0ade, // XK_emfilledcircle
+    0x25e6: 0x0ae0, // XK_enopencircbullet
+    0x2606: 0x0ae5, // XK_openstar
+    0x260e: 0x0af9, // XK_telephone
+    0x2613: 0x0aca, // XK_signaturemark
+    0x261c: 0x0aea, // XK_leftpointer
+    0x261e: 0x0aeb, // XK_rightpointer
+    0x2640: 0x0af8, // XK_femalesymbol
+    0x2642: 0x0af7, // XK_malesymbol
+    0x2663: 0x0aec, // XK_club
+    0x2665: 0x0aee, // XK_heart
+    0x2666: 0x0aed, // XK_diamond
+    0x266d: 0x0af6, // XK_musicalflat
+    0x266f: 0x0af5, // XK_musicalsharp
+    0x2713: 0x0af3, // XK_checkmark
+    0x2717: 0x0af4, // XK_ballotcross
+    0x271d: 0x0ad9, // XK_latincross
+    0x2720: 0x0af0, // XK_maltesecross
+    0x27e8: 0x0abc, // XK_leftanglebracket
+    0x27e9: 0x0abe, // XK_rightanglebracket
+    0x3001: 0x04a4, // XK_kana_comma
+    0x3002: 0x04a1, // XK_kana_fullstop
+    0x300c: 0x04a2, // XK_kana_openingbracket
+    0x300d: 0x04a3, // XK_kana_closingbracket
+    0x309b: 0x04de, // XK_voicedsound
+    0x309c: 0x04df, // XK_semivoicedsound
+    0x30a1: 0x04a7, // XK_kana_a
+    0x30a2: 0x04b1, // XK_kana_A
+    0x30a3: 0x04a8, // XK_kana_i
+    0x30a4: 0x04b2, // XK_kana_I
+    0x30a5: 0x04a9, // XK_kana_u
+    0x30a6: 0x04b3, // XK_kana_U
+    0x30a7: 0x04aa, // XK_kana_e
+    0x30a8: 0x04b4, // XK_kana_E
+    0x30a9: 0x04ab, // XK_kana_o
+    0x30aa: 0x04b5, // XK_kana_O
+    0x30ab: 0x04b6, // XK_kana_KA
+    0x30ad: 0x04b7, // XK_kana_KI
+    0x30af: 0x04b8, // XK_kana_KU
+    0x30b1: 0x04b9, // XK_kana_KE
+    0x30b3: 0x04ba, // XK_kana_KO
+    0x30b5: 0x04bb, // XK_kana_SA
+    0x30b7: 0x04bc, // XK_kana_SHI
+    0x30b9: 0x04bd, // XK_kana_SU
+    0x30bb: 0x04be, // XK_kana_SE
+    0x30bd: 0x04bf, // XK_kana_SO
+    0x30bf: 0x04c0, // XK_kana_TA
+    0x30c1: 0x04c1, // XK_kana_CHI
+    0x30c3: 0x04af, // XK_kana_tsu
+    0x30c4: 0x04c2, // XK_kana_TSU
+    0x30c6: 0x04c3, // XK_kana_TE
+    0x30c8: 0x04c4, // XK_kana_TO
+    0x30ca: 0x04c5, // XK_kana_NA
+    0x30cb: 0x04c6, // XK_kana_NI
+    0x30cc: 0x04c7, // XK_kana_NU
+    0x30cd: 0x04c8, // XK_kana_NE
+    0x30ce: 0x04c9, // XK_kana_NO
+    0x30cf: 0x04ca, // XK_kana_HA
+    0x30d2: 0x04cb, // XK_kana_HI
+    0x30d5: 0x04cc, // XK_kana_FU
+    0x30d8: 0x04cd, // XK_kana_HE
+    0x30db: 0x04ce, // XK_kana_HO
+    0x30de: 0x04cf, // XK_kana_MA
+    0x30df: 0x04d0, // XK_kana_MI
+    0x30e0: 0x04d1, // XK_kana_MU
+    0x30e1: 0x04d2, // XK_kana_ME
+    0x30e2: 0x04d3, // XK_kana_MO
+    0x30e3: 0x04ac, // XK_kana_ya
+    0x30e4: 0x04d4, // XK_kana_YA
+    0x30e5: 0x04ad, // XK_kana_yu
+    0x30e6: 0x04d5, // XK_kana_YU
+    0x30e7: 0x04ae, // XK_kana_yo
+    0x30e8: 0x04d6, // XK_kana_YO
+    0x30e9: 0x04d7, // XK_kana_RA
+    0x30ea: 0x04d8, // XK_kana_RI
+    0x30eb: 0x04d9, // XK_kana_RU
+    0x30ec: 0x04da, // XK_kana_RE
+    0x30ed: 0x04db, // XK_kana_RO
+    0x30ef: 0x04dc, // XK_kana_WA
+    0x30f2: 0x04a6, // XK_kana_WO
+    0x30f3: 0x04dd, // XK_kana_N
+    0x30fb: 0x04a5, // XK_kana_conjunctive
+    0x30fc: 0x04b0, // XK_prolongedsound
+};
+
+export default {
+    lookup(u) {
+        // Latin-1 is one-to-one mapping
+        if ((u >= 0x20) && (u <= 0xff)) {
+            return u;
+        }
+
+        // Lookup table (fairly random)
+        const keysym = codepoints[u];
+        if (keysym !== undefined) {
+            return keysym;
+        }
+
+        // General mapping as final fallback
+        return 0x01000000 | u;
+    },
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/input/util.js
@@ -0,0 +1,191 @@
+import KeyTable from "./keysym.js";
+import keysyms from "./keysymdef.js";
+import vkeys from "./vkeys.js";
+import fixedkeys from "./fixedkeys.js";
+import DOMKeyTable from "./domkeytable.js";
+import * as browser from "../util/browser.js";
+
+// Get 'KeyboardEvent.code', handling legacy browsers
+export function getKeycode(evt) {
+    // Are we getting proper key identifiers?
+    // (unfortunately Firefox and Chrome are crappy here and gives
+    // us an empty string on some platforms, rather than leaving it
+    // undefined)
+    if (evt.code) {
+        // Mozilla isn't fully in sync with the spec yet
+        switch (evt.code) {
+            case 'OSLeft': return 'MetaLeft';
+            case 'OSRight': return 'MetaRight';
+        }
+
+        return evt.code;
+    }
+
+    // The de-facto standard is to use Windows Virtual-Key codes
+    // in the 'keyCode' field for non-printable characters
+    if (evt.keyCode in vkeys) {
+        let code = vkeys[evt.keyCode];
+
+        // macOS has messed up this code for some reason
+        if (browser.isMac() && (code === 'ContextMenu')) {
+            code = 'MetaRight';
+        }
+
+        // The keyCode doesn't distinguish between left and right
+        // for the standard modifiers
+        if (evt.location === 2) {
+            switch (code) {
+                case 'ShiftLeft': return 'ShiftRight';
+                case 'ControlLeft': return 'ControlRight';
+                case 'AltLeft': return 'AltRight';
+            }
+        }
+
+        // Nor a bunch of the numpad keys
+        if (evt.location === 3) {
+            switch (code) {
+                case 'Delete': return 'NumpadDecimal';
+                case 'Insert': return 'Numpad0';
+                case 'End': return 'Numpad1';
+                case 'ArrowDown': return 'Numpad2';
+                case 'PageDown': return 'Numpad3';
+                case 'ArrowLeft': return 'Numpad4';
+                case 'ArrowRight': return 'Numpad6';
+                case 'Home': return 'Numpad7';
+                case 'ArrowUp': return 'Numpad8';
+                case 'PageUp': return 'Numpad9';
+                case 'Enter': return 'NumpadEnter';
+            }
+        }
+
+        return code;
+    }
+
+    return 'Unidentified';
+}
+
+// Get 'KeyboardEvent.key', handling legacy browsers
+export function getKey(evt) {
+    // Are we getting a proper key value?
+    if (evt.key !== undefined) {
+        // Mozilla isn't fully in sync with the spec yet
+        switch (evt.key) {
+            case 'OS': return 'Meta';
+            case 'LaunchMyComputer': return 'LaunchApplication1';
+            case 'LaunchCalculator': return 'LaunchApplication2';
+        }
+
+        // iOS leaks some OS names
+        switch (evt.key) {
+            case 'UIKeyInputUpArrow': return 'ArrowUp';
+            case 'UIKeyInputDownArrow': return 'ArrowDown';
+            case 'UIKeyInputLeftArrow': return 'ArrowLeft';
+            case 'UIKeyInputRightArrow': return 'ArrowRight';
+            case 'UIKeyInputEscape': return 'Escape';
+        }
+
+        // Broken behaviour in Chrome
+        if ((evt.key === '\x00') && (evt.code === 'NumpadDecimal')) {
+            return 'Delete';
+        }
+
+        return evt.key;
+    }
+
+    // Try to deduce it based on the physical key
+    const code = getKeycode(evt);
+    if (code in fixedkeys) {
+        return fixedkeys[code];
+    }
+
+    // If that failed, then see if we have a printable character
+    if (evt.charCode) {
+        return String.fromCharCode(evt.charCode);
+    }
+
+    // At this point we have nothing left to go on
+    return 'Unidentified';
+}
+
+// Get the most reliable keysym value we can get from a key event
+export function getKeysym(evt) {
+    const key = getKey(evt);
+
+    if (key === 'Unidentified') {
+        return null;
+    }
+
+    // First look up special keys
+    if (key in DOMKeyTable) {
+        let location = evt.location;
+
+        // Safari screws up location for the right cmd key
+        if ((key === 'Meta') && (location === 0)) {
+            location = 2;
+        }
+
+        // And for Clear
+        if ((key === 'Clear') && (location === 3)) {
+            let code = getKeycode(evt);
+            if (code === 'NumLock') {
+                location = 0;
+            }
+        }
+
+        if ((location === undefined) || (location > 3)) {
+            location = 0;
+        }
+
+        // The original Meta key now gets confused with the Windows key
+        // https://bugs.chromium.org/p/chromium/issues/detail?id=1020141
+        // https://bugzilla.mozilla.org/show_bug.cgi?id=1232918
+        if (key === 'Meta') {
+            let code = getKeycode(evt);
+            if (code === 'AltLeft') {
+                return KeyTable.XK_Meta_L;
+            } else if (code === 'AltRight') {
+                return KeyTable.XK_Meta_R;
+            }
+        }
+
+        // macOS has Clear instead of NumLock, but the remote system is
+        // probably not macOS, so lying here is probably best...
+        if (key === 'Clear') {
+            let code = getKeycode(evt);
+            if (code === 'NumLock') {
+                return KeyTable.XK_Num_Lock;
+            }
+        }
+
+        // Windows sends alternating symbols for some keys when using a
+        // Japanese layout. We have no way of synchronising with the IM
+        // running on the remote system, so we send some combined keysym
+        // instead and hope for the best.
+        if (browser.isWindows()) {
+            switch (key) {
+                case 'Zenkaku':
+                case 'Hankaku':
+                    return KeyTable.XK_Zenkaku_Hankaku;
+                case 'Romaji':
+                case 'KanaMode':
+                    return KeyTable.XK_Romaji;
+            }
+        }
+
+        return DOMKeyTable[key][location];
+    }
+
+    // Now we need to look at the Unicode symbol instead
+
+    // Special key? (FIXME: Should have been caught earlier)
+    if (key.length !== 1) {
+        return null;
+    }
+
+    const codepoint = key.charCodeAt();
+    if (codepoint) {
+        return keysyms.lookup(codepoint);
+    }
+
+    return null;
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/input/vkeys.js
@@ -0,0 +1,116 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2018 The noVNC Authors
+ * Licensed under MPL 2.0 or any later version (see LICENSE.txt)
+ */
+
+/*
+ * Mapping between Microsoft® Windows® Virtual-Key codes and
+ * HTML key codes.
+ */
+
+export default {
+    0x08: 'Backspace',
+    0x09: 'Tab',
+    0x0a: 'NumpadClear',
+    0x0d: 'Enter',
+    0x10: 'ShiftLeft',
+    0x11: 'ControlLeft',
+    0x12: 'AltLeft',
+    0x13: 'Pause',
+    0x14: 'CapsLock',
+    0x15: 'Lang1',
+    0x19: 'Lang2',
+    0x1b: 'Escape',
+    0x1c: 'Convert',
+    0x1d: 'NonConvert',
+    0x20: 'Space',
+    0x21: 'PageUp',
+    0x22: 'PageDown',
+    0x23: 'End',
+    0x24: 'Home',
+    0x25: 'ArrowLeft',
+    0x26: 'ArrowUp',
+    0x27: 'ArrowRight',
+    0x28: 'ArrowDown',
+    0x29: 'Select',
+    0x2c: 'PrintScreen',
+    0x2d: 'Insert',
+    0x2e: 'Delete',
+    0x2f: 'Help',
+    0x30: 'Digit0',
+    0x31: 'Digit1',
+    0x32: 'Digit2',
+    0x33: 'Digit3',
+    0x34: 'Digit4',
+    0x35: 'Digit5',
+    0x36: 'Digit6',
+    0x37: 'Digit7',
+    0x38: 'Digit8',
+    0x39: 'Digit9',
+    0x5b: 'MetaLeft',
+    0x5c: 'MetaRight',
+    0x5d: 'ContextMenu',
+    0x5f: 'Sleep',
+    0x60: 'Numpad0',
+    0x61: 'Numpad1',
+    0x62: 'Numpad2',
+    0x63: 'Numpad3',
+    0x64: 'Numpad4',
+    0x65: 'Numpad5',
+    0x66: 'Numpad6',
+    0x67: 'Numpad7',
+    0x68: 'Numpad8',
+    0x69: 'Numpad9',
+    0x6a: 'NumpadMultiply',
+    0x6b: 'NumpadAdd',
+    0x6c: 'NumpadDecimal',
+    0x6d: 'NumpadSubtract',
+    0x6e: 'NumpadDecimal', // Duplicate, because buggy on Windows
+    0x6f: 'NumpadDivide',
+    0x70: 'F1',
+    0x71: 'F2',
+    0x72: 'F3',
+    0x73: 'F4',
+    0x74: 'F5',
+    0x75: 'F6',
+    0x76: 'F7',
+    0x77: 'F8',
+    0x78: 'F9',
+    0x79: 'F10',
+    0x7a: 'F11',
+    0x7b: 'F12',
+    0x7c: 'F13',
+    0x7d: 'F14',
+    0x7e: 'F15',
+    0x7f: 'F16',
+    0x80: 'F17',
+    0x81: 'F18',
+    0x82: 'F19',
+    0x83: 'F20',
+    0x84: 'F21',
+    0x85: 'F22',
+    0x86: 'F23',
+    0x87: 'F24',
+    0x90: 'NumLock',
+    0x91: 'ScrollLock',
+    0xa6: 'BrowserBack',
+    0xa7: 'BrowserForward',
+    0xa8: 'BrowserRefresh',
+    0xa9: 'BrowserStop',
+    0xaa: 'BrowserSearch',
+    0xab: 'BrowserFavorites',
+    0xac: 'BrowserHome',
+    0xad: 'AudioVolumeMute',
+    0xae: 'AudioVolumeDown',
+    0xaf: 'AudioVolumeUp',
+    0xb0: 'MediaTrackNext',
+    0xb1: 'MediaTrackPrevious',
+    0xb2: 'MediaStop',
+    0xb3: 'MediaPlayPause',
+    0xb4: 'LaunchMail',
+    0xb5: 'MediaSelect',
+    0xb6: 'LaunchApp1',
+    0xb7: 'LaunchApp2',
+    0xe1: 'AltRight', // Only when it is AltGraph
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/input/xtscancodes.js
@@ -0,0 +1,173 @@
+/*
+ * This file is auto-generated from keymaps.csv
+ * Database checksum sha256(76d68c10e97d37fe2ea459e210125ae41796253fb217e900bf2983ade13a7920)
+ * To re-generate, run:
+ *   keymap-gen code-map --lang=js keymaps.csv html atset1
+*/
+export default {
+  "Again": 0xe005, /* html:Again (Again) -> linux:129 (KEY_AGAIN) -> atset1:57349 */
+  "AltLeft": 0x38, /* html:AltLeft (AltLeft) -> linux:56 (KEY_LEFTALT) -> atset1:56 */
+  "AltRight": 0xe038, /* html:AltRight (AltRight) -> linux:100 (KEY_RIGHTALT) -> atset1:57400 */
+  "ArrowDown": 0xe050, /* html:ArrowDown (ArrowDown) -> linux:108 (KEY_DOWN) -> atset1:57424 */
+  "ArrowLeft": 0xe04b, /* html:ArrowLeft (ArrowLeft) -> linux:105 (KEY_LEFT) -> atset1:57419 */
+  "ArrowRight": 0xe04d, /* html:ArrowRight (ArrowRight) -> linux:106 (KEY_RIGHT) -> atset1:57421 */
+  "ArrowUp": 0xe048, /* html:ArrowUp (ArrowUp) -> linux:103 (KEY_UP) -> atset1:57416 */
+  "AudioVolumeDown": 0xe02e, /* html:AudioVolumeDown (AudioVolumeDown) -> linux:114 (KEY_VOLUMEDOWN) -> atset1:57390 */
+  "AudioVolumeMute": 0xe020, /* html:AudioVolumeMute (AudioVolumeMute) -> linux:113 (KEY_MUTE) -> atset1:57376 */
+  "AudioVolumeUp": 0xe030, /* html:AudioVolumeUp (AudioVolumeUp) -> linux:115 (KEY_VOLUMEUP) -> atset1:57392 */
+  "Backquote": 0x29, /* html:Backquote (Backquote) -> linux:41 (KEY_GRAVE) -> atset1:41 */
+  "Backslash": 0x2b, /* html:Backslash (Backslash) -> linux:43 (KEY_BACKSLASH) -> atset1:43 */
+  "Backspace": 0xe, /* html:Backspace (Backspace) -> linux:14 (KEY_BACKSPACE) -> atset1:14 */
+  "BracketLeft": 0x1a, /* html:BracketLeft (BracketLeft) -> linux:26 (KEY_LEFTBRACE) -> atset1:26 */
+  "BracketRight": 0x1b, /* html:BracketRight (BracketRight) -> linux:27 (KEY_RIGHTBRACE) -> atset1:27 */
+  "BrowserBack": 0xe06a, /* html:BrowserBack (BrowserBack) -> linux:158 (KEY_BACK) -> atset1:57450 */
+  "BrowserFavorites": 0xe066, /* html:BrowserFavorites (BrowserFavorites) -> linux:156 (KEY_BOOKMARKS) -> atset1:57446 */
+  "BrowserForward": 0xe069, /* html:BrowserForward (BrowserForward) -> linux:159 (KEY_FORWARD) -> atset1:57449 */
+  "BrowserHome": 0xe032, /* html:BrowserHome (BrowserHome) -> linux:172 (KEY_HOMEPAGE) -> atset1:57394 */
+  "BrowserRefresh": 0xe067, /* html:BrowserRefresh (BrowserRefresh) -> linux:173 (KEY_REFRESH) -> atset1:57447 */
+  "BrowserSearch": 0xe065, /* html:BrowserSearch (BrowserSearch) -> linux:217 (KEY_SEARCH) -> atset1:57445 */
+  "BrowserStop": 0xe068, /* html:BrowserStop (BrowserStop) -> linux:128 (KEY_STOP) -> atset1:57448 */
+  "CapsLock": 0x3a, /* html:CapsLock (CapsLock) -> linux:58 (KEY_CAPSLOCK) -> atset1:58 */
+  "Comma": 0x33, /* html:Comma (Comma) -> linux:51 (KEY_COMMA) -> atset1:51 */
+  "ContextMenu": 0xe05d, /* html:ContextMenu (ContextMenu) -> linux:127 (KEY_COMPOSE) -> atset1:57437 */
+  "ControlLeft": 0x1d, /* html:ControlLeft (ControlLeft) -> linux:29 (KEY_LEFTCTRL) -> atset1:29 */
+  "ControlRight": 0xe01d, /* html:ControlRight (ControlRight) -> linux:97 (KEY_RIGHTCTRL) -> atset1:57373 */
+  "Convert": 0x79, /* html:Convert (Convert) -> linux:92 (KEY_HENKAN) -> atset1:121 */
+  "Copy": 0xe078, /* html:Copy (Copy) -> linux:133 (KEY_COPY) -> atset1:57464 */
+  "Cut": 0xe03c, /* html:Cut (Cut) -> linux:137 (KEY_CUT) -> atset1:57404 */
+  "Delete": 0xe053, /* html:Delete (Delete) -> linux:111 (KEY_DELETE) -> atset1:57427 */
+  "Digit0": 0xb, /* html:Digit0 (Digit0) -> linux:11 (KEY_0) -> atset1:11 */
+  "Digit1": 0x2, /* html:Digit1 (Digit1) -> linux:2 (KEY_1) -> atset1:2 */
+  "Digit2": 0x3, /* html:Digit2 (Digit2) -> linux:3 (KEY_2) -> atset1:3 */
+  "Digit3": 0x4, /* html:Digit3 (Digit3) -> linux:4 (KEY_3) -> atset1:4 */
+  "Digit4": 0x5, /* html:Digit4 (Digit4) -> linux:5 (KEY_4) -> atset1:5 */
+  "Digit5": 0x6, /* html:Digit5 (Digit5) -> linux:6 (KEY_5) -> atset1:6 */
+  "Digit6": 0x7, /* html:Digit6 (Digit6) -> linux:7 (KEY_6) -> atset1:7 */
+  "Digit7": 0x8, /* html:Digit7 (Digit7) -> linux:8 (KEY_7) -> atset1:8 */
+  "Digit8": 0x9, /* html:Digit8 (Digit8) -> linux:9 (KEY_8) -> atset1:9 */
+  "Digit9": 0xa, /* html:Digit9 (Digit9) -> linux:10 (KEY_9) -> atset1:10 */
+  "Eject": 0xe07d, /* html:Eject (Eject) -> linux:162 (KEY_EJECTCLOSECD) -> atset1:57469 */
+  "End": 0xe04f, /* html:End (End) -> linux:107 (KEY_END) -> atset1:57423 */
+  "Enter": 0x1c, /* html:Enter (Enter) -> linux:28 (KEY_ENTER) -> atset1:28 */
+  "Equal": 0xd, /* html:Equal (Equal) -> linux:13 (KEY_EQUAL) -> atset1:13 */
+  "Escape": 0x1, /* html:Escape (Escape) -> linux:1 (KEY_ESC) -> atset1:1 */
+  "F1": 0x3b, /* html:F1 (F1) -> linux:59 (KEY_F1) -> atset1:59 */
+  "F10": 0x44, /* html:F10 (F10) -> linux:68 (KEY_F10) -> atset1:68 */
+  "F11": 0x57, /* html:F11 (F11) -> linux:87 (KEY_F11) -> atset1:87 */
+  "F12": 0x58, /* html:F12 (F12) -> linux:88 (KEY_F12) -> atset1:88 */
+  "F13": 0x5d, /* html:F13 (F13) -> linux:183 (KEY_F13) -> atset1:93 */
+  "F14": 0x5e, /* html:F14 (F14) -> linux:184 (KEY_F14) -> atset1:94 */
+  "F15": 0x5f, /* html:F15 (F15) -> linux:185 (KEY_F15) -> atset1:95 */
+  "F16": 0x55, /* html:F16 (F16) -> linux:186 (KEY_F16) -> atset1:85 */
+  "F17": 0xe003, /* html:F17 (F17) -> linux:187 (KEY_F17) -> atset1:57347 */
+  "F18": 0xe077, /* html:F18 (F18) -> linux:188 (KEY_F18) -> atset1:57463 */
+  "F19": 0xe004, /* html:F19 (F19) -> linux:189 (KEY_F19) -> atset1:57348 */
+  "F2": 0x3c, /* html:F2 (F2) -> linux:60 (KEY_F2) -> atset1:60 */
+  "F20": 0x5a, /* html:F20 (F20) -> linux:190 (KEY_F20) -> atset1:90 */
+  "F21": 0x74, /* html:F21 (F21) -> linux:191 (KEY_F21) -> atset1:116 */
+  "F22": 0xe079, /* html:F22 (F22) -> linux:192 (KEY_F22) -> atset1:57465 */
+  "F23": 0x6d, /* html:F23 (F23) -> linux:193 (KEY_F23) -> atset1:109 */
+  "F24": 0x6f, /* html:F24 (F24) -> linux:194 (KEY_F24) -> atset1:111 */
+  "F3": 0x3d, /* html:F3 (F3) -> linux:61 (KEY_F3) -> atset1:61 */
+  "F4": 0x3e, /* html:F4 (F4) -> linux:62 (KEY_F4) -> atset1:62 */
+  "F5": 0x3f, /* html:F5 (F5) -> linux:63 (KEY_F5) -> atset1:63 */
+  "F6": 0x40, /* html:F6 (F6) -> linux:64 (KEY_F6) -> atset1:64 */
+  "F7": 0x41, /* html:F7 (F7) -> linux:65 (KEY_F7) -> atset1:65 */
+  "F8": 0x42, /* html:F8 (F8) -> linux:66 (KEY_F8) -> atset1:66 */
+  "F9": 0x43, /* html:F9 (F9) -> linux:67 (KEY_F9) -> atset1:67 */
+  "Find": 0xe041, /* html:Find (Find) -> linux:136 (KEY_FIND) -> atset1:57409 */
+  "Help": 0xe075, /* html:Help (Help) -> linux:138 (KEY_HELP) -> atset1:57461 */
+  "Hiragana": 0x77, /* html:Hiragana (Lang4) -> linux:91 (KEY_HIRAGANA) -> atset1:119 */
+  "Home": 0xe047, /* html:Home (Home) -> linux:102 (KEY_HOME) -> atset1:57415 */
+  "Insert": 0xe052, /* html:Insert (Insert) -> linux:110 (KEY_INSERT) -> atset1:57426 */
+  "IntlBackslash": 0x56, /* html:IntlBackslash (IntlBackslash) -> linux:86 (KEY_102ND) -> atset1:86 */
+  "IntlRo": 0x73, /* html:IntlRo (IntlRo) -> linux:89 (KEY_RO) -> atset1:115 */
+  "IntlYen": 0x7d, /* html:IntlYen (IntlYen) -> linux:124 (KEY_YEN) -> atset1:125 */
+  "KanaMode": 0x70, /* html:KanaMode (KanaMode) -> linux:93 (KEY_KATAKANAHIRAGANA) -> atset1:112 */
+  "Katakana": 0x78, /* html:Katakana (Lang3) -> linux:90 (KEY_KATAKANA) -> atset1:120 */
+  "KeyA": 0x1e, /* html:KeyA (KeyA) -> linux:30 (KEY_A) -> atset1:30 */
+  "KeyB": 0x30, /* html:KeyB (KeyB) -> linux:48 (KEY_B) -> atset1:48 */
+  "KeyC": 0x2e, /* html:KeyC (KeyC) -> linux:46 (KEY_C) -> atset1:46 */
+  "KeyD": 0x20, /* html:KeyD (KeyD) -> linux:32 (KEY_D) -> atset1:32 */
+  "KeyE": 0x12, /* html:KeyE (KeyE) -> linux:18 (KEY_E) -> atset1:18 */
+  "KeyF": 0x21, /* html:KeyF (KeyF) -> linux:33 (KEY_F) -> atset1:33 */
+  "KeyG": 0x22, /* html:KeyG (KeyG) -> linux:34 (KEY_G) -> atset1:34 */
+  "KeyH": 0x23, /* html:KeyH (KeyH) -> linux:35 (KEY_H) -> atset1:35 */
+  "KeyI": 0x17, /* html:KeyI (KeyI) -> linux:23 (KEY_I) -> atset1:23 */
+  "KeyJ": 0x24, /* html:KeyJ (KeyJ) -> linux:36 (KEY_J) -> atset1:36 */
+  "KeyK": 0x25, /* html:KeyK (KeyK) -> linux:37 (KEY_K) -> atset1:37 */
+  "KeyL": 0x26, /* html:KeyL (KeyL) -> linux:38 (KEY_L) -> atset1:38 */
+  "KeyM": 0x32, /* html:KeyM (KeyM) -> linux:50 (KEY_M) -> atset1:50 */
+  "KeyN": 0x31, /* html:KeyN (KeyN) -> linux:49 (KEY_N) -> atset1:49 */
+  "KeyO": 0x18, /* html:KeyO (KeyO) -> linux:24 (KEY_O) -> atset1:24 */
+  "KeyP": 0x19, /* html:KeyP (KeyP) -> linux:25 (KEY_P) -> atset1:25 */
+  "KeyQ": 0x10, /* html:KeyQ (KeyQ) -> linux:16 (KEY_Q) -> atset1:16 */
+  "KeyR": 0x13, /* html:KeyR (KeyR) -> linux:19 (KEY_R) -> atset1:19 */
+  "KeyS": 0x1f, /* html:KeyS (KeyS) -> linux:31 (KEY_S) -> atset1:31 */
+  "KeyT": 0x14, /* html:KeyT (KeyT) -> linux:20 (KEY_T) -> atset1:20 */
+  "KeyU": 0x16, /* html:KeyU (KeyU) -> linux:22 (KEY_U) -> atset1:22 */
+  "KeyV": 0x2f, /* html:KeyV (KeyV) -> linux:47 (KEY_V) -> atset1:47 */
+  "KeyW": 0x11, /* html:KeyW (KeyW) -> linux:17 (KEY_W) -> atset1:17 */
+  "KeyX": 0x2d, /* html:KeyX (KeyX) -> linux:45 (KEY_X) -> atset1:45 */
+  "KeyY": 0x15, /* html:KeyY (KeyY) -> linux:21 (KEY_Y) -> atset1:21 */
+  "KeyZ": 0x2c, /* html:KeyZ (KeyZ) -> linux:44 (KEY_Z) -> atset1:44 */
+  "Lang1": 0x72, /* html:Lang1 (Lang1) -> linux:122 (KEY_HANGEUL) -> atset1:114 */
+  "Lang2": 0x71, /* html:Lang2 (Lang2) -> linux:123 (KEY_HANJA) -> atset1:113 */
+  "Lang3": 0x78, /* html:Lang3 (Lang3) -> linux:90 (KEY_KATAKANA) -> atset1:120 */
+  "Lang4": 0x77, /* html:Lang4 (Lang4) -> linux:91 (KEY_HIRAGANA) -> atset1:119 */
+  "Lang5": 0x76, /* html:Lang5 (Lang5) -> linux:85 (KEY_ZENKAKUHANKAKU) -> atset1:118 */
+  "LaunchApp1": 0xe06b, /* html:LaunchApp1 (LaunchApp1) -> linux:157 (KEY_COMPUTER) -> atset1:57451 */
+  "LaunchApp2": 0xe021, /* html:LaunchApp2 (LaunchApp2) -> linux:140 (KEY_CALC) -> atset1:57377 */
+  "LaunchMail": 0xe06c, /* html:LaunchMail (LaunchMail) -> linux:155 (KEY_MAIL) -> atset1:57452 */
+  "MediaPlayPause": 0xe022, /* html:MediaPlayPause (MediaPlayPause) -> linux:164 (KEY_PLAYPAUSE) -> atset1:57378 */
+  "MediaSelect": 0xe06d, /* html:MediaSelect (MediaSelect) -> linux:226 (KEY_MEDIA) -> atset1:57453 */
+  "MediaStop": 0xe024, /* html:MediaStop (MediaStop) -> linux:166 (KEY_STOPCD) -> atset1:57380 */
+  "MediaTrackNext": 0xe019, /* html:MediaTrackNext (MediaTrackNext) -> linux:163 (KEY_NEXTSONG) -> atset1:57369 */
+  "MediaTrackPrevious": 0xe010, /* html:MediaTrackPrevious (MediaTrackPrevious) -> linux:165 (KEY_PREVIOUSSONG) -> atset1:57360 */
+  "MetaLeft": 0xe05b, /* html:MetaLeft (MetaLeft) -> linux:125 (KEY_LEFTMETA) -> atset1:57435 */
+  "MetaRight": 0xe05c, /* html:MetaRight (MetaRight) -> linux:126 (KEY_RIGHTMETA) -> atset1:57436 */
+  "Minus": 0xc, /* html:Minus (Minus) -> linux:12 (KEY_MINUS) -> atset1:12 */
+  "NonConvert": 0x7b, /* html:NonConvert (NonConvert) -> linux:94 (KEY_MUHENKAN) -> atset1:123 */
+  "NumLock": 0x45, /* html:NumLock (NumLock) -> linux:69 (KEY_NUMLOCK) -> atset1:69 */
+  "Numpad0": 0x52, /* html:Numpad0 (Numpad0) -> linux:82 (KEY_KP0) -> atset1:82 */
+  "Numpad1": 0x4f, /* html:Numpad1 (Numpad1) -> linux:79 (KEY_KP1) -> atset1:79 */
+  "Numpad2": 0x50, /* html:Numpad2 (Numpad2) -> linux:80 (KEY_KP2) -> atset1:80 */
+  "Numpad3": 0x51, /* html:Numpad3 (Numpad3) -> linux:81 (KEY_KP3) -> atset1:81 */
+  "Numpad4": 0x4b, /* html:Numpad4 (Numpad4) -> linux:75 (KEY_KP4) -> atset1:75 */
+  "Numpad5": 0x4c, /* html:Numpad5 (Numpad5) -> linux:76 (KEY_KP5) -> atset1:76 */
+  "Numpad6": 0x4d, /* html:Numpad6 (Numpad6) -> linux:77 (KEY_KP6) -> atset1:77 */
+  "Numpad7": 0x47, /* html:Numpad7 (Numpad7) -> linux:71 (KEY_KP7) -> atset1:71 */
+  "Numpad8": 0x48, /* html:Numpad8 (Numpad8) -> linux:72 (KEY_KP8) -> atset1:72 */
+  "Numpad9": 0x49, /* html:Numpad9 (Numpad9) -> linux:73 (KEY_KP9) -> atset1:73 */
+  "NumpadAdd": 0x4e, /* html:NumpadAdd (NumpadAdd) -> linux:78 (KEY_KPPLUS) -> atset1:78 */
+  "NumpadComma": 0x7e, /* html:NumpadComma (NumpadComma) -> linux:121 (KEY_KPCOMMA) -> atset1:126 */
+  "NumpadDecimal": 0x53, /* html:NumpadDecimal (NumpadDecimal) -> linux:83 (KEY_KPDOT) -> atset1:83 */
+  "NumpadDivide": 0xe035, /* html:NumpadDivide (NumpadDivide) -> linux:98 (KEY_KPSLASH) -> atset1:57397 */
+  "NumpadEnter": 0xe01c, /* html:NumpadEnter (NumpadEnter) -> linux:96 (KEY_KPENTER) -> atset1:57372 */
+  "NumpadEqual": 0x59, /* html:NumpadEqual (NumpadEqual) -> linux:117 (KEY_KPEQUAL) -> atset1:89 */
+  "NumpadMultiply": 0x37, /* html:NumpadMultiply (NumpadMultiply) -> linux:55 (KEY_KPASTERISK) -> atset1:55 */
+  "NumpadParenLeft": 0xe076, /* html:NumpadParenLeft (NumpadParenLeft) -> linux:179 (KEY_KPLEFTPAREN) -> atset1:57462 */
+  "NumpadParenRight": 0xe07b, /* html:NumpadParenRight (NumpadParenRight) -> linux:180 (KEY_KPRIGHTPAREN) -> atset1:57467 */
+  "NumpadSubtract": 0x4a, /* html:NumpadSubtract (NumpadSubtract) -> linux:74 (KEY_KPMINUS) -> atset1:74 */
+  "Open": 0x64, /* html:Open (Open) -> linux:134 (KEY_OPEN) -> atset1:100 */
+  "PageDown": 0xe051, /* html:PageDown (PageDown) -> linux:109 (KEY_PAGEDOWN) -> atset1:57425 */
+  "PageUp": 0xe049, /* html:PageUp (PageUp) -> linux:104 (KEY_PAGEUP) -> atset1:57417 */
+  "Paste": 0x65, /* html:Paste (Paste) -> linux:135 (KEY_PASTE) -> atset1:101 */
+  "Pause": 0xe046, /* html:Pause (Pause) -> linux:119 (KEY_PAUSE) -> atset1:57414 */
+  "Period": 0x34, /* html:Period (Period) -> linux:52 (KEY_DOT) -> atset1:52 */
+  "Power": 0xe05e, /* html:Power (Power) -> linux:116 (KEY_POWER) -> atset1:57438 */
+  "PrintScreen": 0x54, /* html:PrintScreen (PrintScreen) -> linux:99 (KEY_SYSRQ) -> atset1:84 */
+  "Props": 0xe006, /* html:Props (Props) -> linux:130 (KEY_PROPS) -> atset1:57350 */
+  "Quote": 0x28, /* html:Quote (Quote) -> linux:40 (KEY_APOSTROPHE) -> atset1:40 */
+  "ScrollLock": 0x46, /* html:ScrollLock (ScrollLock) -> linux:70 (KEY_SCROLLLOCK) -> atset1:70 */
+  "Semicolon": 0x27, /* html:Semicolon (Semicolon) -> linux:39 (KEY_SEMICOLON) -> atset1:39 */
+  "ShiftLeft": 0x2a, /* html:ShiftLeft (ShiftLeft) -> linux:42 (KEY_LEFTSHIFT) -> atset1:42 */
+  "ShiftRight": 0x36, /* html:ShiftRight (ShiftRight) -> linux:54 (KEY_RIGHTSHIFT) -> atset1:54 */
+  "Slash": 0x35, /* html:Slash (Slash) -> linux:53 (KEY_SLASH) -> atset1:53 */
+  "Sleep": 0xe05f, /* html:Sleep (Sleep) -> linux:142 (KEY_SLEEP) -> atset1:57439 */
+  "Space": 0x39, /* html:Space (Space) -> linux:57 (KEY_SPACE) -> atset1:57 */
+  "Suspend": 0xe025, /* html:Suspend (Suspend) -> linux:205 (KEY_SUSPEND) -> atset1:57381 */
+  "Tab": 0xf, /* html:Tab (Tab) -> linux:15 (KEY_TAB) -> atset1:15 */
+  "Undo": 0xe007, /* html:Undo (Undo) -> linux:131 (KEY_UNDO) -> atset1:57351 */
+  "WakeUp": 0xe063, /* html:WakeUp (WakeUp) -> linux:143 (KEY_WAKEUP) -> atset1:57443 */
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/ra2.js
@@ -0,0 +1,567 @@
+import Base64 from './base64.js';
+import { encodeUTF8 } from './util/strings.js';
+import EventTargetMixin from './util/eventtarget.js';
+
+export class AESEAXCipher {
+    constructor() {
+        this._rawKey = null;
+        this._ctrKey = null;
+        this._cbcKey = null;
+        this._zeroBlock = new Uint8Array(16);
+        this._prefixBlock0 = this._zeroBlock;
+        this._prefixBlock1 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);
+        this._prefixBlock2 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2]);
+    }
+
+    async _encryptBlock(block) {
+        const encrypted = await window.crypto.subtle.encrypt({
+            name: "AES-CBC",
+            iv: this._zeroBlock,
+        }, this._cbcKey, block);
+        return new Uint8Array(encrypted).slice(0, 16);
+    }
+
+    async _initCMAC() {
+        const k1 = await this._encryptBlock(this._zeroBlock);
+        const k2 = new Uint8Array(16);
+        const v = k1[0] >>> 6;
+        for (let i = 0; i < 15; i++) {
+            k2[i] = (k1[i + 1] >> 6) | (k1[i] << 2);
+            k1[i] = (k1[i + 1] >> 7) | (k1[i] << 1);
+        }
+        const lut = [0x0, 0x87, 0x0e, 0x89];
+        k2[14] ^= v >>> 1;
+        k2[15] = (k1[15] << 2) ^ lut[v];
+        k1[15] = (k1[15] << 1) ^ lut[v >> 1];
+        this._k1 = k1;
+        this._k2 = k2;
+    }
+
+    async _encryptCTR(data, counter) {
+        const encrypted = await window.crypto.subtle.encrypt({
+            "name": "AES-CTR",
+            counter: counter,
+            length: 128
+        }, this._ctrKey, data);
+        return new Uint8Array(encrypted);
+    }
+
+    async _decryptCTR(data, counter) {
+        const decrypted = await window.crypto.subtle.decrypt({
+            "name": "AES-CTR",
+            counter: counter,
+            length: 128
+        }, this._ctrKey, data);
+        return new Uint8Array(decrypted);
+    }
+
+    async _computeCMAC(data, prefixBlock) {
+        if (prefixBlock.length !== 16) {
+            return null;
+        }
+        const n = Math.floor(data.length / 16);
+        const m = Math.ceil(data.length / 16);
+        const r = data.length - n * 16;
+        const cbcData = new Uint8Array((m + 1) * 16);
+        cbcData.set(prefixBlock);
+        cbcData.set(data, 16);
+        if (r === 0) {
+            for (let i = 0; i < 16; i++) {
+                cbcData[n * 16 + i] ^= this._k1[i];
+            }
+        } else {
+            cbcData[(n + 1) * 16 + r] = 0x80;
+            for (let i = 0; i < 16; i++) {
+                cbcData[(n + 1) * 16 + i] ^= this._k2[i];
+            }
+        }
+        let cbcEncrypted = await window.crypto.subtle.encrypt({
+            name: "AES-CBC",
+            iv: this._zeroBlock,
+        }, this._cbcKey, cbcData);
+
+        cbcEncrypted = new Uint8Array(cbcEncrypted);
+        const mac = cbcEncrypted.slice(cbcEncrypted.length - 32, cbcEncrypted.length - 16);
+        return mac;
+    }
+
+    async setKey(key) {
+        this._rawKey = key;
+        this._ctrKey = await window.crypto.subtle.importKey(
+            "raw", key, {"name": "AES-CTR"}, false, ["encrypt", "decrypt"]);
+        this._cbcKey = await window.crypto.subtle.importKey(
+            "raw", key, {"name": "AES-CBC"}, false, ["encrypt", "decrypt"]);
+        await this._initCMAC();
+    }
+
+    async encrypt(message, associatedData, nonce) {
+        const nCMAC = await this._computeCMAC(nonce, this._prefixBlock0);
+        const encrypted = await this._encryptCTR(message, nCMAC);
+        const adCMAC = await this._computeCMAC(associatedData, this._prefixBlock1);
+        const mac = await this._computeCMAC(encrypted, this._prefixBlock2);
+        for (let i = 0; i < 16; i++) {
+            mac[i] ^= nCMAC[i] ^ adCMAC[i];
+        }
+        const res = new Uint8Array(16 + encrypted.length);
+        res.set(encrypted);
+        res.set(mac, encrypted.length);
+        return res;
+    }
+
+    async decrypt(encrypted, associatedData, nonce, mac) {
+        const nCMAC = await this._computeCMAC(nonce, this._prefixBlock0);
+        const adCMAC = await this._computeCMAC(associatedData, this._prefixBlock1);
+        const computedMac = await this._computeCMAC(encrypted, this._prefixBlock2);
+        for (let i = 0; i < 16; i++) {
+            computedMac[i] ^= nCMAC[i] ^ adCMAC[i];
+        }
+        if (computedMac.length !== mac.length) {
+            return null;
+        }
+        for (let i = 0; i < mac.length; i++) {
+            if (computedMac[i] !== mac[i]) {
+                return null;
+            }
+        }
+        const res = await this._decryptCTR(encrypted, nCMAC);
+        return res;
+    }
+}
+
+export class RA2Cipher {
+    constructor() {
+        this._cipher = new AESEAXCipher();
+        this._counter = new Uint8Array(16);
+    }
+
+    async setKey(key) {
+        await this._cipher.setKey(key);
+    }
+
+    async makeMessage(message) {
+        const ad = new Uint8Array([(message.length & 0xff00) >>> 8, message.length & 0xff]);
+        const encrypted = await this._cipher.encrypt(message, ad, this._counter);
+        for (let i = 0; i < 16 && this._counter[i]++ === 255; i++);
+        const res = new Uint8Array(message.length + 2 + 16);
+        res.set(ad);
+        res.set(encrypted, 2);
+        return res;
+    }
+
+    async receiveMessage(length, encrypted, mac) {
+        const ad = new Uint8Array([(length & 0xff00) >>> 8, length & 0xff]);
+        const res = await this._cipher.decrypt(encrypted, ad, this._counter, mac);
+        for (let i = 0; i < 16 && this._counter[i]++ === 255; i++);
+        return res;
+    }
+}
+
+export class RSACipher {
+    constructor(keyLength) {
+        this._key = null;
+        this._keyLength = keyLength;
+        this._keyBytes = Math.ceil(keyLength / 8);
+        this._n = null;
+        this._e = null;
+        this._d = null;
+        this._nBigInt = null;
+        this._eBigInt = null;
+        this._dBigInt = null;
+    }
+
+    _base64urlDecode(data) {
+        data = data.replace(/-/g, "+").replace(/_/g, "/");
+        data = data.padEnd(Math.ceil(data.length / 4) * 4, "=");
+        return Base64.decode(data);
+    }
+
+    _u8ArrayToBigInt(arr) {
+        let hex = '0x';
+        for (let i = 0; i < arr.length; i++) {
+            hex += arr[i].toString(16).padStart(2, '0');
+        }
+        return BigInt(hex);
+    }
+
+    _padArray(arr, length) {
+        const res = new Uint8Array(length);
+        res.set(arr, length - arr.length);
+        return res;
+    }
+
+    _bigIntToU8Array(bigint, padLength=0) {
+        let hex = bigint.toString(16);
+        if (padLength === 0) {
+            padLength = Math.ceil(hex.length / 2) * 2;
+        }
+        hex = hex.padStart(padLength * 2, '0');
+        const length = hex.length / 2;
+        const arr = new Uint8Array(length);
+        for (let i = 0; i < length; i++) {
+            arr[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
+        }
+        return arr;
+    }
+
+    _modPow(b, e, m) {
+        if (m === 1n) {
+            return 0;
+        }
+        let r = 1n;
+        b = b % m;
+        while (e > 0) {
+            if (e % 2n === 1n) {
+                r = (r * b) % m;
+            }
+            e = e / 2n;
+            b = (b * b) % m;
+        }
+        return r;
+    }
+
+    async generateKey() {
+        this._key = await window.crypto.subtle.generateKey(
+            {
+                name: "RSA-OAEP",
+                modulusLength: this._keyLength,
+                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
+                hash: {name: "SHA-256"},
+            },
+            true, ["encrypt", "decrypt"]);
+        const privateKey = await window.crypto.subtle.exportKey("jwk", this._key.privateKey);
+        this._n = this._padArray(this._base64urlDecode(privateKey.n), this._keyBytes);
+        this._nBigInt = this._u8ArrayToBigInt(this._n);
+        this._e = this._padArray(this._base64urlDecode(privateKey.e), this._keyBytes);
+        this._eBigInt = this._u8ArrayToBigInt(this._e);
+        this._d = this._padArray(this._base64urlDecode(privateKey.d), this._keyBytes);
+        this._dBigInt = this._u8ArrayToBigInt(this._d);
+    }
+
+    setPublicKey(n, e) {
+        if (n.length !== this._keyBytes || e.length !== this._keyBytes) {
+            return;
+        }
+        this._n = new Uint8Array(this._keyBytes);
+        this._e = new Uint8Array(this._keyBytes);
+        this._n.set(n);
+        this._e.set(e);
+        this._nBigInt = this._u8ArrayToBigInt(this._n);
+        this._eBigInt = this._u8ArrayToBigInt(this._e);
+    }
+
+    encrypt(message) {
+        if (message.length > this._keyBytes - 11) {
+            return null;
+        }
+        const ps = new Uint8Array(this._keyBytes - message.length - 3);
+        window.crypto.getRandomValues(ps);
+        for (let i = 0; i < ps.length; i++) {
+            ps[i] = Math.floor(ps[i] * 254 / 255 + 1);
+        }
+        const em = new Uint8Array(this._keyBytes);
+        em[1] = 0x02;
+        em.set(ps, 2);
+        em.set(message, ps.length + 3);
+        const emBigInt = this._u8ArrayToBigInt(em);
+        const c = this._modPow(emBigInt, this._eBigInt, this._nBigInt);
+        return this._bigIntToU8Array(c, this._keyBytes);
+    }
+
+    decrypt(message) {
+        if (message.length !== this._keyBytes) {
+            return null;
+        }
+        const msgBigInt = this._u8ArrayToBigInt(message);
+        const emBigInt = this._modPow(msgBigInt, this._dBigInt, this._nBigInt);
+        const em = this._bigIntToU8Array(emBigInt, this._keyBytes);
+        if (em[0] !== 0x00 || em[1] !== 0x02) {
+            return null;
+        }
+        let i = 2;
+        for (; i < em.length; i++) {
+            if (em[i] === 0x00) {
+                break;
+            }
+        }
+        if (i === em.length) {
+            return null;
+        }
+        return em.slice(i + 1, em.length);
+    }
+
+    get keyLength() {
+        return this._keyLength;
+    }
+
+    get n() {
+        return this._n;
+    }
+
+    get e() {
+        return this._e;
+    }
+
+    get d() {
+        return this._d;
+    }
+}
+
+export default class RSAAESAuthenticationState extends EventTargetMixin {
+    constructor(sock, getCredentials) {
+        super();
+        this._hasStarted = false;
+        this._checkSock = null;
+        this._checkCredentials = null;
+        this._approveServerResolve = null;
+        this._sockReject = null;
+        this._credentialsReject = null;
+        this._approveServerReject = null;
+        this._sock = sock;
+        this._getCredentials = getCredentials;
+    }
+
+    _waitSockAsync(len) {
+        return new Promise((resolve, reject) => {
+            const hasData = () => !this._sock.rQwait('RA2', len);
+            if (hasData()) {
+                resolve();
+            } else {
+                this._checkSock = () => {
+                    if (hasData()) {
+                        resolve();
+                        this._checkSock = null;
+                        this._sockReject = null;
+                    }
+                };
+                this._sockReject = reject;
+            }
+        });
+    }
+
+    _waitApproveKeyAsync() {
+        return new Promise((resolve, reject) => {
+            this._approveServerResolve = resolve;
+            this._approveServerReject = reject;
+        });
+    }
+
+    _waitCredentialsAsync(subtype) {
+        const hasCredentials = () => {
+            if (subtype === 1 && this._getCredentials().username !== undefined &&
+                this._getCredentials().password !== undefined) {
+                return true;
+            } else if (subtype === 2 && this._getCredentials().password !== undefined) {
+                return true;
+            }
+            return false;
+        };
+        return new Promise((resolve, reject) => {
+            if (hasCredentials()) {
+                resolve();
+            } else {
+                this._checkCredentials = () => {
+                    if (hasCredentials()) {
+                        resolve();
+                        this._checkCredentials = null;
+                        this._credentialsReject = null;
+                    }
+                };
+                this._credentialsReject = reject;
+            }
+        });
+    }
+
+    checkInternalEvents() {
+        if (this._checkSock !== null) {
+            this._checkSock();
+        }
+        if (this._checkCredentials !== null) {
+            this._checkCredentials();
+        }
+    }
+
+    approveServer() {
+        if (this._approveServerResolve !== null) {
+            this._approveServerResolve();
+            this._approveServerResolve = null;
+        }
+    }
+
+    disconnect() {
+        if (this._sockReject !== null) {
+            this._sockReject(new Error("disconnect normally"));
+            this._sockReject = null;
+        }
+        if (this._credentialsReject !== null) {
+            this._credentialsReject(new Error("disconnect normally"));
+            this._credentialsReject = null;
+        }
+        if (this._approveServerReject !== null) {
+            this._approveServerReject(new Error("disconnect normally"));
+            this._approveServerReject = null;
+        }
+    }
+
+    async negotiateRA2neAuthAsync() {
+        this._hasStarted = true;
+        // 1: Receive server public key
+        await this._waitSockAsync(4);
+        const serverKeyLengthBuffer = this._sock.rQslice(0, 4);
+        const serverKeyLength = this._sock.rQshift32();
+        if (serverKeyLength < 1024) {
+            throw new Error("RA2: server public key is too short: " + serverKeyLength);
+        } else if (serverKeyLength > 8192) {
+            throw new Error("RA2: server public key is too long: " + serverKeyLength);
+        }
+        const serverKeyBytes = Math.ceil(serverKeyLength / 8);
+        await this._waitSockAsync(serverKeyBytes * 2);
+        const serverN = this._sock.rQshiftBytes(serverKeyBytes);
+        const serverE = this._sock.rQshiftBytes(serverKeyBytes);
+        const serverRSACipher = new RSACipher(serverKeyLength);
+        serverRSACipher.setPublicKey(serverN, serverE);
+        const serverPublickey = new Uint8Array(4 + serverKeyBytes * 2);
+        serverPublickey.set(serverKeyLengthBuffer);
+        serverPublickey.set(serverN, 4);
+        serverPublickey.set(serverE, 4 + serverKeyBytes);
+
+        // verify server public key
+        this.dispatchEvent(new CustomEvent("serververification", {
+            detail: { type: "RSA", publickey: serverPublickey }
+        }));
+        await this._waitApproveKeyAsync();
+
+        // 2: Send client public key
+        const clientKeyLength = 2048;
+        const clientKeyBytes = Math.ceil(clientKeyLength / 8);
+        const clientRSACipher = new RSACipher(clientKeyLength);
+        await clientRSACipher.generateKey();
+        const clientN = clientRSACipher.n;
+        const clientE = clientRSACipher.e;
+        const clientPublicKey = new Uint8Array(4 + clientKeyBytes * 2);
+        clientPublicKey[0] = (clientKeyLength & 0xff000000) >>> 24;
+        clientPublicKey[1] = (clientKeyLength & 0xff0000) >>> 16;
+        clientPublicKey[2] = (clientKeyLength & 0xff00) >>> 8;
+        clientPublicKey[3] = clientKeyLength & 0xff;
+        clientPublicKey.set(clientN, 4);
+        clientPublicKey.set(clientE, 4 + clientKeyBytes);
+        this._sock.send(clientPublicKey);
+
+        // 3: Send client random
+        const clientRandom = new Uint8Array(16);
+        window.crypto.getRandomValues(clientRandom);
+        const clientEncryptedRandom = serverRSACipher.encrypt(clientRandom);
+        const clientRandomMessage = new Uint8Array(2 + serverKeyBytes);
+        clientRandomMessage[0] = (serverKeyBytes & 0xff00) >>> 8;
+        clientRandomMessage[1] = serverKeyBytes & 0xff;
+        clientRandomMessage.set(clientEncryptedRandom, 2);
+        this._sock.send(clientRandomMessage);
+
+        // 4: Receive server random
+        await this._waitSockAsync(2);
+        if (this._sock.rQshift16() !== clientKeyBytes) {
+            throw new Error("RA2: wrong encrypted message length");
+        }
+        const serverEncryptedRandom = this._sock.rQshiftBytes(clientKeyBytes);
+        const serverRandom = clientRSACipher.decrypt(serverEncryptedRandom);
+        if (serverRandom === null || serverRandom.length !== 16) {
+            throw new Error("RA2: corrupted server encrypted random");
+        }
+
+        // 5: Compute session keys and set ciphers
+        let clientSessionKey = new Uint8Array(32);
+        let serverSessionKey = new Uint8Array(32);
+        clientSessionKey.set(serverRandom);
+        clientSessionKey.set(clientRandom, 16);
+        serverSessionKey.set(clientRandom);
+        serverSessionKey.set(serverRandom, 16);
+        clientSessionKey = await window.crypto.subtle.digest("SHA-1", clientSessionKey);
+        clientSessionKey = new Uint8Array(clientSessionKey).slice(0, 16);
+        serverSessionKey = await window.crypto.subtle.digest("SHA-1", serverSessionKey);
+        serverSessionKey = new Uint8Array(serverSessionKey).slice(0, 16);
+        const clientCipher = new RA2Cipher();
+        await clientCipher.setKey(clientSessionKey);
+        const serverCipher = new RA2Cipher();
+        await serverCipher.setKey(serverSessionKey);
+
+        // 6: Compute and exchange hashes
+        let serverHash = new Uint8Array(8 + serverKeyBytes * 2 + clientKeyBytes * 2);
+        let clientHash = new Uint8Array(8 + serverKeyBytes * 2 + clientKeyBytes * 2);
+        serverHash.set(serverPublickey);
+        serverHash.set(clientPublicKey, 4 + serverKeyBytes * 2);
+        clientHash.set(clientPublicKey);
+        clientHash.set(serverPublickey, 4 + clientKeyBytes * 2);
+        serverHash = await window.crypto.subtle.digest("SHA-1", serverHash);
+        clientHash = await window.crypto.subtle.digest("SHA-1", clientHash);
+        serverHash = new Uint8Array(serverHash);
+        clientHash = new Uint8Array(clientHash);
+        this._sock.send(await clientCipher.makeMessage(clientHash));
+        await this._waitSockAsync(2 + 20 + 16);
+        if (this._sock.rQshift16() !== 20) {
+            throw new Error("RA2: wrong server hash");
+        }
+        const serverHashReceived = await serverCipher.receiveMessage(
+            20, this._sock.rQshiftBytes(20), this._sock.rQshiftBytes(16));
+        if (serverHashReceived === null) {
+            throw new Error("RA2: failed to authenticate the message");
+        }
+        for (let i = 0; i < 20; i++) {
+            if (serverHashReceived[i] !== serverHash[i]) {
+                throw new Error("RA2: wrong server hash");
+            }
+        }
+
+        // 7: Receive subtype
+        await this._waitSockAsync(2 + 1 + 16);
+        if (this._sock.rQshift16() !== 1) {
+            throw new Error("RA2: wrong subtype");
+        }
+        let subtype = (await serverCipher.receiveMessage(
+            1, this._sock.rQshiftBytes(1), this._sock.rQshiftBytes(16)));
+        if (subtype === null) {
+            throw new Error("RA2: failed to authenticate the message");
+        }
+        subtype = subtype[0];
+        if (subtype === 1) {
+            if (this._getCredentials().username === undefined ||
+                this._getCredentials().password === undefined) {
+                this.dispatchEvent(new CustomEvent(
+                    "credentialsrequired",
+                    { detail: { types: ["username", "password"] } }));
+            }
+        } else if (subtype === 2) {
+            if (this._getCredentials().password === undefined) {
+                this.dispatchEvent(new CustomEvent(
+                    "credentialsrequired",
+                    { detail: { types: ["password"] } }));
+            }
+        } else {
+            throw new Error("RA2: wrong subtype");
+        }
+        await this._waitCredentialsAsync(subtype);
+        let username;
+        if (subtype === 1) {
+            username = encodeUTF8(this._getCredentials().username).slice(0, 255);
+        } else {
+            username = "";
+        }
+        const password = encodeUTF8(this._getCredentials().password).slice(0, 255);
+        const credentials = new Uint8Array(username.length + password.length + 2);
+        credentials[0] = username.length;
+        credentials[username.length + 1] = password.length;
+        for (let i = 0; i < username.length; i++) {
+            credentials[i + 1] = username.charCodeAt(i);
+        }
+        for (let i = 0; i < password.length; i++) {
+            credentials[username.length + 2 + i] = password.charCodeAt(i);
+        }
+        this._sock.send(await clientCipher.makeMessage(credentials));
+    }
+
+    get hasStarted() {
+        return this._hasStarted;
+    }
+
+    set hasStarted(s) {
+        this._hasStarted = s;
+    }
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/rfb.js
@@ -0,0 +1,3280 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2020 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ *
+ */
+
+import { toUnsigned32bit, toSigned32bit } from './util/int.js';
+import * as Log from './util/logging.js';
+import { encodeUTF8, decodeUTF8 } from './util/strings.js';
+import { dragThreshold } from './util/browser.js';
+import { clientToElement } from './util/element.js';
+import { setCapture } from './util/events.js';
+import EventTargetMixin from './util/eventtarget.js';
+import Display from "./display.js";
+import Inflator from "./inflator.js";
+import Deflator from "./deflator.js";
+import Keyboard from "./input/keyboard.js";
+import GestureHandler from "./input/gesturehandler.js";
+import Cursor from "./util/cursor.js";
+import Websock from "./websock.js";
+import DES from "./des.js";
+import KeyTable from "./input/keysym.js";
+import XtScancode from "./input/xtscancodes.js";
+import { encodings } from "./encodings.js";
+import RSAAESAuthenticationState from "./ra2.js";
+import { MD5 } from "./util/md5.js";
+
+import RawDecoder from "./decoders/raw.js";
+import CopyRectDecoder from "./decoders/copyrect.js";
+import RREDecoder from "./decoders/rre.js";
+import HextileDecoder from "./decoders/hextile.js";
+import TightDecoder from "./decoders/tight.js";
+import TightPNGDecoder from "./decoders/tightpng.js";
+import ZRLEDecoder from "./decoders/zrle.js";
+import JPEGDecoder from "./decoders/jpeg.js";
+
+// How many seconds to wait for a disconnect to finish
+const DISCONNECT_TIMEOUT = 3;
+const DEFAULT_BACKGROUND = 'rgb(40, 40, 40)';
+
+// Minimum wait (ms) between two mouse moves
+const MOUSE_MOVE_DELAY = 17;
+
+// Wheel thresholds
+const WHEEL_STEP = 50; // Pixels needed for one step
+const WHEEL_LINE_HEIGHT = 19; // Assumed pixels for one line step
+
+// Gesture thresholds
+const GESTURE_ZOOMSENS = 75;
+const GESTURE_SCRLSENS = 50;
+const DOUBLE_TAP_TIMEOUT = 1000;
+const DOUBLE_TAP_THRESHOLD = 50;
+
+// Security types
+const securityTypeNone              = 1;
+const securityTypeVNCAuth           = 2;
+const securityTypeRA2ne             = 6;
+const securityTypeTight             = 16;
+const securityTypeVeNCrypt          = 19;
+const securityTypeXVP               = 22;
+const securityTypeARD               = 30;
+
+// Special Tight security types
+const securityTypeUnixLogon         = 129;
+
+// VeNCrypt security types
+const securityTypePlain             = 256;
+
+// Extended clipboard pseudo-encoding formats
+const extendedClipboardFormatText   = 1;
+/*eslint-disable no-unused-vars */
+const extendedClipboardFormatRtf    = 1 << 1;
+const extendedClipboardFormatHtml   = 1 << 2;
+const extendedClipboardFormatDib    = 1 << 3;
+const extendedClipboardFormatFiles  = 1 << 4;
+/*eslint-enable */
+
+// Extended clipboard pseudo-encoding actions
+const extendedClipboardActionCaps    = 1 << 24;
+const extendedClipboardActionRequest = 1 << 25;
+const extendedClipboardActionPeek    = 1 << 26;
+const extendedClipboardActionNotify  = 1 << 27;
+const extendedClipboardActionProvide = 1 << 28;
+
+export default class RFB extends EventTargetMixin {
+    constructor(target, urlOrChannel, options) {
+        if (!target) {
+            throw new Error("Must specify target");
+        }
+        if (!urlOrChannel) {
+            throw new Error("Must specify URL, WebSocket or RTCDataChannel");
+        }
+
+        // We rely on modern APIs which might not be available in an
+        // insecure context
+        if (!window.isSecureContext) {
+            Log.Error("noVNC requires a secure context (TLS). Expect crashes!");
+        }
+
+        super();
+
+        this._target = target;
+
+        if (typeof urlOrChannel === "string") {
+            this._url = urlOrChannel;
+        } else {
+            this._url = null;
+            this._rawChannel = urlOrChannel;
+        }
+
+        // Connection details
+        options = options || {};
+        this._rfbCredentials = options.credentials || {};
+        this._shared = 'shared' in options ? !!options.shared : true;
+        this._repeaterID = options.repeaterID || '';
+        this._wsProtocols = options.wsProtocols || [];
+
+        // Internal state
+        this._rfbConnectionState = '';
+        this._rfbInitState = '';
+        this._rfbAuthScheme = -1;
+        this._rfbCleanDisconnect = true;
+        this._rfbRSAAESAuthenticationState = null;
+
+        // Server capabilities
+        this._rfbVersion = 0;
+        this._rfbMaxVersion = 3.8;
+        this._rfbTightVNC = false;
+        this._rfbVeNCryptState = 0;
+        this._rfbXvpVer = 0;
+
+        this._fbWidth = 0;
+        this._fbHeight = 0;
+
+        this._fbName = "";
+
+        this._capabilities = { power: false };
+
+        this._supportsFence = false;
+
+        this._supportsContinuousUpdates = false;
+        this._enabledContinuousUpdates = false;
+
+        this._supportsSetDesktopSize = false;
+        this._screenID = 0;
+        this._screenFlags = 0;
+
+        this._qemuExtKeyEventSupported = false;
+
+        this._clipboardText = null;
+        this._clipboardServerCapabilitiesActions = {};
+        this._clipboardServerCapabilitiesFormats = {};
+
+        // Internal objects
+        this._sock = null;              // Websock object
+        this._display = null;           // Display object
+        this._flushing = false;         // Display flushing state
+        this._keyboard = null;          // Keyboard input handler object
+        this._gestures = null;          // Gesture input handler object
+        this._resizeObserver = null;    // Resize observer object
+
+        // Timers
+        this._disconnTimer = null;      // disconnection timer
+        this._resizeTimeout = null;     // resize rate limiting
+        this._mouseMoveTimer = null;
+
+        // Decoder states
+        this._decoders = {};
+
+        this._FBU = {
+            rects: 0,
+            x: 0,
+            y: 0,
+            width: 0,
+            height: 0,
+            encoding: null,
+        };
+
+        // Mouse state
+        this._mousePos = {};
+        this._mouseButtonMask = 0;
+        this._mouseLastMoveTime = 0;
+        this._viewportDragging = false;
+        this._viewportDragPos = {};
+        this._viewportHasMoved = false;
+        this._accumulatedWheelDeltaX = 0;
+        this._accumulatedWheelDeltaY = 0;
+
+        // Gesture state
+        this._gestureLastTapTime = null;
+        this._gestureFirstDoubleTapEv = null;
+        this._gestureLastMagnitudeX = 0;
+        this._gestureLastMagnitudeY = 0;
+
+        // Bound event handlers
+        this._eventHandlers = {
+            focusCanvas: this._focusCanvas.bind(this),
+            handleResize: this._handleResize.bind(this),
+            handleMouse: this._handleMouse.bind(this),
+            handleWheel: this._handleWheel.bind(this),
+            handleGesture: this._handleGesture.bind(this),
+            handleRSAAESCredentialsRequired: this._handleRSAAESCredentialsRequired.bind(this),
+            handleRSAAESServerVerification: this._handleRSAAESServerVerification.bind(this),
+        };
+
+        // main setup
+        Log.Debug(">> RFB.constructor");
+
+        // Create DOM elements
+        this._screen = document.createElement('div');
+        this._screen.style.display = 'flex';
+        this._screen.style.width = '100%';
+        this._screen.style.height = '100%';
+        this._screen.style.overflow = 'auto';
+        this._screen.style.background = DEFAULT_BACKGROUND;
+        this._canvas = document.createElement('canvas');
+        this._canvas.style.margin = 'auto';
+        // Some browsers add an outline on focus
+        this._canvas.style.outline = 'none';
+        this._canvas.width = 0;
+        this._canvas.height = 0;
+        this._canvas.tabIndex = -1;
+        this._screen.appendChild(this._canvas);
+
+        // Cursor
+        this._cursor = new Cursor();
+
+        // XXX: TightVNC 2.8.11 sends no cursor at all until Windows changes
+        // it. Result: no cursor at all until a window border or an edit field
+        // is hit blindly. But there are also VNC servers that draw the cursor
+        // in the framebuffer and don't send the empty local cursor. There is
+        // no way to satisfy both sides.
+        //
+        // The spec is unclear on this "initial cursor" issue. Many other
+        // viewers (TigerVNC, RealVNC, Remmina) display an arrow as the
+        // initial cursor instead.
+        this._cursorImage = RFB.cursors.none;
+
+        // populate decoder array with objects
+        this._decoders[encodings.encodingRaw] = new RawDecoder();
+        this._decoders[encodings.encodingCopyRect] = new CopyRectDecoder();
+        this._decoders[encodings.encodingRRE] = new RREDecoder();
+        this._decoders[encodings.encodingHextile] = new HextileDecoder();
+        this._decoders[encodings.encodingTight] = new TightDecoder();
+        this._decoders[encodings.encodingTightPNG] = new TightPNGDecoder();
+        this._decoders[encodings.encodingZRLE] = new ZRLEDecoder();
+        this._decoders[encodings.encodingJPEG] = new JPEGDecoder();
+
+        // NB: nothing that needs explicit teardown should be done
+        // before this point, since this can throw an exception
+        try {
+            this._display = new Display(this._canvas);
+        } catch (exc) {
+            Log.Error("Display exception: " + exc);
+            throw exc;
+        }
+        this._display.onflush = this._onFlush.bind(this);
+
+        this._keyboard = new Keyboard(this._canvas);
+        this._keyboard.onkeyevent = this._handleKeyEvent.bind(this);
+
+        this._gestures = new GestureHandler();
+
+        this._sock = new Websock();
+        this._sock.on('open', this._socketOpen.bind(this));
+        this._sock.on('close', this._socketClose.bind(this));
+        this._sock.on('message', this._handleMessage.bind(this));
+        this._sock.on('error', this._socketError.bind(this));
+
+        this._expectedClientWidth = null;
+        this._expectedClientHeight = null;
+        this._resizeObserver = new ResizeObserver(this._eventHandlers.handleResize);
+
+        // All prepared, kick off the connection
+        this._updateConnectionState('connecting');
+
+        Log.Debug("<< RFB.constructor");
+
+        // ===== PROPERTIES =====
+
+        this.dragViewport = false;
+        this.focusOnClick = true;
+
+        this._viewOnly = false;
+        this._clipViewport = false;
+        this._scaleViewport = false;
+        this._resizeSession = false;
+
+        this._showDotCursor = false;
+        if (options.showDotCursor !== undefined) {
+            Log.Warn("Specifying showDotCursor as a RFB constructor argument is deprecated");
+            this._showDotCursor = options.showDotCursor;
+        }
+
+        this._qualityLevel = 6;
+        this._compressionLevel = 2;
+    }
+
+    // ===== PROPERTIES =====
+
+    get viewOnly() { return this._viewOnly; }
+    set viewOnly(viewOnly) {
+        this._viewOnly = viewOnly;
+
+        if (this._rfbConnectionState === "connecting" ||
+            this._rfbConnectionState === "connected") {
+            if (viewOnly) {
+                this._keyboard.ungrab();
+            } else {
+                this._keyboard.grab();
+            }
+        }
+    }
+
+    get capabilities() { return this._capabilities; }
+
+    get touchButton() { return 0; }
+    set touchButton(button) { Log.Warn("Using old API!"); }
+
+    get clipViewport() { return this._clipViewport; }
+    set clipViewport(viewport) {
+        this._clipViewport = viewport;
+        this._updateClip();
+    }
+
+    get scaleViewport() { return this._scaleViewport; }
+    set scaleViewport(scale) {
+        this._scaleViewport = scale;
+        // Scaling trumps clipping, so we may need to adjust
+        // clipping when enabling or disabling scaling
+        if (scale && this._clipViewport) {
+            this._updateClip();
+        }
+        this._updateScale();
+        if (!scale && this._clipViewport) {
+            this._updateClip();
+        }
+    }
+
+    get resizeSession() { return this._resizeSession; }
+    set resizeSession(resize) {
+        this._resizeSession = resize;
+        if (resize) {
+            this._requestRemoteResize();
+        }
+    }
+
+    get showDotCursor() { return this._showDotCursor; }
+    set showDotCursor(show) {
+        this._showDotCursor = show;
+        this._refreshCursor();
+    }
+
+    get background() { return this._screen.style.background; }
+    set background(cssValue) { this._screen.style.background = cssValue; }
+
+    get qualityLevel() {
+        return this._qualityLevel;
+    }
+    set qualityLevel(qualityLevel) {
+        if (!Number.isInteger(qualityLevel) || qualityLevel < 0 || qualityLevel > 9) {
+            Log.Error("qualityLevel must be an integer between 0 and 9");
+            return;
+        }
+
+        if (this._qualityLevel === qualityLevel) {
+            return;
+        }
+
+        this._qualityLevel = qualityLevel;
+
+        if (this._rfbConnectionState === 'connected') {
+            this._sendEncodings();
+        }
+    }
+
+    get compressionLevel() {
+        return this._compressionLevel;
+    }
+    set compressionLevel(compressionLevel) {
+        if (!Number.isInteger(compressionLevel) || compressionLevel < 0 || compressionLevel > 9) {
+            Log.Error("compressionLevel must be an integer between 0 and 9");
+            return;
+        }
+
+        if (this._compressionLevel === compressionLevel) {
+            return;
+        }
+
+        this._compressionLevel = compressionLevel;
+
+        if (this._rfbConnectionState === 'connected') {
+            this._sendEncodings();
+        }
+    }
+
+    // ===== PUBLIC METHODS =====
+
+    disconnect() {
+        this._updateConnectionState('disconnecting');
+        this._sock.off('error');
+        this._sock.off('message');
+        this._sock.off('open');
+        if (this._rfbRSAAESAuthenticationState !== null) {
+            this._rfbRSAAESAuthenticationState.disconnect();
+        }
+    }
+
+    approveServer() {
+        if (this._rfbRSAAESAuthenticationState !== null) {
+            this._rfbRSAAESAuthenticationState.approveServer();
+        }
+    }
+
+    sendCredentials(creds) {
+        this._rfbCredentials = creds;
+        this._resumeAuthentication();
+    }
+
+    sendCtrlAltDel() {
+        if (this._rfbConnectionState !== 'connected' || this._viewOnly) { return; }
+        Log.Info("Sending Ctrl-Alt-Del");
+
+        this.sendKey(KeyTable.XK_Control_L, "ControlLeft", true);
+        this.sendKey(KeyTable.XK_Alt_L, "AltLeft", true);
+        this.sendKey(KeyTable.XK_Delete, "Delete", true);
+        this.sendKey(KeyTable.XK_Delete, "Delete", false);
+        this.sendKey(KeyTable.XK_Alt_L, "AltLeft", false);
+        this.sendKey(KeyTable.XK_Control_L, "ControlLeft", false);
+    }
+
+    machineShutdown() {
+        this._xvpOp(1, 2);
+    }
+
+    machineReboot() {
+        this._xvpOp(1, 3);
+    }
+
+    machineReset() {
+        this._xvpOp(1, 4);
+    }
+
+    // Send a key press. If 'down' is not specified then send a down key
+    // followed by an up key.
+    sendKey(keysym, code, down) {
+        if (this._rfbConnectionState !== 'connected' || this._viewOnly) { return; }
+
+        if (down === undefined) {
+            this.sendKey(keysym, code, true);
+            this.sendKey(keysym, code, false);
+            return;
+        }
+
+        const scancode = XtScancode[code];
+
+        if (this._qemuExtKeyEventSupported && scancode) {
+            // 0 is NoSymbol
+            keysym = keysym || 0;
+
+            Log.Info("Sending key (" + (down ? "down" : "up") + "): keysym " + keysym + ", scancode " + scancode);
+
+            RFB.messages.QEMUExtendedKeyEvent(this._sock, keysym, down, scancode);
+        } else {
+            if (!keysym) {
+                return;
+            }
+            Log.Info("Sending keysym (" + (down ? "down" : "up") + "): " + keysym);
+            RFB.messages.keyEvent(this._sock, keysym, down ? 1 : 0);
+        }
+    }
+
+    focus(options) {
+        this._canvas.focus(options);
+    }
+
+    blur() {
+        this._canvas.blur();
+    }
+
+    clipboardPasteFrom(text) {
+        if (this._rfbConnectionState !== 'connected' || this._viewOnly) { return; }
+
+        if (this._clipboardServerCapabilitiesFormats[extendedClipboardFormatText] &&
+            this._clipboardServerCapabilitiesActions[extendedClipboardActionNotify]) {
+
+            this._clipboardText = text;
+            RFB.messages.extendedClipboardNotify(this._sock, [extendedClipboardFormatText]);
+        } else {
+            let data = new Uint8Array(text.length);
+            for (let i = 0; i < text.length; i++) {
+                // FIXME: text can have values outside of Latin1/Uint8
+                data[i] = text.charCodeAt(i);
+            }
+
+            RFB.messages.clientCutText(this._sock, data);
+        }
+    }
+
+    getImageData() {
+        return this._display.getImageData();
+    }
+
+    toDataURL(type, encoderOptions) {
+        return this._display.toDataURL(type, encoderOptions);
+    }
+
+    toBlob(callback, type, quality) {
+        return this._display.toBlob(callback, type, quality);
+    }
+
+    // ===== PRIVATE METHODS =====
+
+    _connect() {
+        Log.Debug(">> RFB.connect");
+
+        if (this._url) {
+            Log.Info(`connecting to ${this._url}`);
+            this._sock.open(this._url, this._wsProtocols);
+        } else {
+            Log.Info(`attaching ${this._rawChannel} to Websock`);
+            this._sock.attach(this._rawChannel);
+
+            if (this._sock.readyState === 'closed') {
+                throw Error("Cannot use already closed WebSocket/RTCDataChannel");
+            }
+
+            if (this._sock.readyState === 'open') {
+                // FIXME: _socketOpen() can in theory call _fail(), which
+                //        isn't allowed this early, but I'm not sure that can
+                //        happen without a bug messing up our state variables
+                this._socketOpen();
+            }
+        }
+
+        // Make our elements part of the page
+        this._target.appendChild(this._screen);
+
+        this._gestures.attach(this._canvas);
+
+        this._cursor.attach(this._canvas);
+        this._refreshCursor();
+
+        // Monitor size changes of the screen element
+        this._resizeObserver.observe(this._screen);
+
+        // Always grab focus on some kind of click event
+        this._canvas.addEventListener("mousedown", this._eventHandlers.focusCanvas);
+        this._canvas.addEventListener("touchstart", this._eventHandlers.focusCanvas);
+
+        // Mouse events
+        this._canvas.addEventListener('mousedown', this._eventHandlers.handleMouse);
+        this._canvas.addEventListener('mouseup', this._eventHandlers.handleMouse);
+        this._canvas.addEventListener('mousemove', this._eventHandlers.handleMouse);
+        // Prevent middle-click pasting (see handler for why we bind to document)
+        this._canvas.addEventListener('click', this._eventHandlers.handleMouse);
+        // preventDefault() on mousedown doesn't stop this event for some
+        // reason so we have to explicitly block it
+        this._canvas.addEventListener('contextmenu', this._eventHandlers.handleMouse);
+
+        // Wheel events
+        this._canvas.addEventListener("wheel", this._eventHandlers.handleWheel);
+
+        // Gesture events
+        this._canvas.addEventListener("gesturestart", this._eventHandlers.handleGesture);
+        this._canvas.addEventListener("gesturemove", this._eventHandlers.handleGesture);
+        this._canvas.addEventListener("gestureend", this._eventHandlers.handleGesture);
+
+        Log.Debug("<< RFB.connect");
+    }
+
+    _disconnect() {
+        Log.Debug(">> RFB.disconnect");
+        this._cursor.detach();
+        this._canvas.removeEventListener("gesturestart", this._eventHandlers.handleGesture);
+        this._canvas.removeEventListener("gesturemove", this._eventHandlers.handleGesture);
+        this._canvas.removeEventListener("gestureend", this._eventHandlers.handleGesture);
+        this._canvas.removeEventListener("wheel", this._eventHandlers.handleWheel);
+        this._canvas.removeEventListener('mousedown', this._eventHandlers.handleMouse);
+        this._canvas.removeEventListener('mouseup', this._eventHandlers.handleMouse);
+        this._canvas.removeEventListener('mousemove', this._eventHandlers.handleMouse);
+        this._canvas.removeEventListener('click', this._eventHandlers.handleMouse);
+        this._canvas.removeEventListener('contextmenu', this._eventHandlers.handleMouse);
+        this._canvas.removeEventListener("mousedown", this._eventHandlers.focusCanvas);
+        this._canvas.removeEventListener("touchstart", this._eventHandlers.focusCanvas);
+        this._resizeObserver.disconnect();
+        this._keyboard.ungrab();
+        this._gestures.detach();
+        this._sock.close();
+        try {
+            this._target.removeChild(this._screen);
+        } catch (e) {
+            if (e.name === 'NotFoundError') {
+                // Some cases where the initial connection fails
+                // can disconnect before the _screen is created
+            } else {
+                throw e;
+            }
+        }
+        clearTimeout(this._resizeTimeout);
+        clearTimeout(this._mouseMoveTimer);
+        Log.Debug("<< RFB.disconnect");
+    }
+
+    _socketOpen() {
+        if ((this._rfbConnectionState === 'connecting') &&
+            (this._rfbInitState === '')) {
+            this._rfbInitState = 'ProtocolVersion';
+            Log.Debug("Starting VNC handshake");
+        } else {
+            this._fail("Unexpected server connection while " +
+                       this._rfbConnectionState);
+        }
+    }
+
+    _socketClose(e) {
+        Log.Debug("WebSocket on-close event");
+        let msg = "";
+        if (e.code) {
+            msg = "(code: " + e.code;
+            if (e.reason) {
+                msg += ", reason: " + e.reason;
+            }
+            msg += ")";
+        }
+        switch (this._rfbConnectionState) {
+            case 'connecting':
+                this._fail("Connection closed " + msg);
+                break;
+            case 'connected':
+                // Handle disconnects that were initiated server-side
+                this._updateConnectionState('disconnecting');
+                this._updateConnectionState('disconnected');
+                break;
+            case 'disconnecting':
+                // Normal disconnection path
+                this._updateConnectionState('disconnected');
+                break;
+            case 'disconnected':
+                this._fail("Unexpected server disconnect " +
+                           "when already disconnected " + msg);
+                break;
+            default:
+                this._fail("Unexpected server disconnect before connecting " +
+                           msg);
+                break;
+        }
+        this._sock.off('close');
+        // Delete reference to raw channel to allow cleanup.
+        this._rawChannel = null;
+    }
+
+    _socketError(e) {
+        Log.Warn("WebSocket on-error event");
+    }
+
+    _focusCanvas(event) {
+        if (!this.focusOnClick) {
+            return;
+        }
+
+        this.focus({ preventScroll: true });
+    }
+
+    _setDesktopName(name) {
+        this._fbName = name;
+        this.dispatchEvent(new CustomEvent(
+            "desktopname",
+            { detail: { name: this._fbName } }));
+    }
+
+    _saveExpectedClientSize() {
+        this._expectedClientWidth = this._screen.clientWidth;
+        this._expectedClientHeight = this._screen.clientHeight;
+    }
+
+    _currentClientSize() {
+        return [this._screen.clientWidth, this._screen.clientHeight];
+    }
+
+    _clientHasExpectedSize() {
+        const [currentWidth, currentHeight] = this._currentClientSize();
+        return currentWidth == this._expectedClientWidth &&
+            currentHeight == this._expectedClientHeight;
+    }
+
+    _handleResize() {
+        // Don't change anything if the client size is already as expected
+        if (this._clientHasExpectedSize()) {
+            return;
+        }
+        // If the window resized then our screen element might have
+        // as well. Update the viewport dimensions.
+        window.requestAnimationFrame(() => {
+            this._updateClip();
+            this._updateScale();
+        });
+
+        if (this._resizeSession) {
+            // Request changing the resolution of the remote display to
+            // the size of the local browser viewport.
+
+            // In order to not send multiple requests before the browser-resize
+            // is finished we wait 0.5 seconds before sending the request.
+            clearTimeout(this._resizeTimeout);
+            this._resizeTimeout = setTimeout(this._requestRemoteResize.bind(this), 500);
+        }
+    }
+
+    // Update state of clipping in Display object, and make sure the
+    // configured viewport matches the current screen size
+    _updateClip() {
+        const curClip = this._display.clipViewport;
+        let newClip = this._clipViewport;
+
+        if (this._scaleViewport) {
+            // Disable viewport clipping if we are scaling
+            newClip = false;
+        }
+
+        if (curClip !== newClip) {
+            this._display.clipViewport = newClip;
+        }
+
+        if (newClip) {
+            // When clipping is enabled, the screen is limited to
+            // the size of the container.
+            const size = this._screenSize();
+            this._display.viewportChangeSize(size.w, size.h);
+            this._fixScrollbars();
+        }
+
+        // When changing clipping we might show or hide scrollbars.
+        // This causes the expected client dimensions to change.
+        if (curClip !== newClip) {
+            this._saveExpectedClientSize();
+        }
+    }
+
+    _updateScale() {
+        if (!this._scaleViewport) {
+            this._display.scale = 1.0;
+        } else {
+            const size = this._screenSize();
+            this._display.autoscale(size.w, size.h);
+        }
+        this._fixScrollbars();
+    }
+
+    // Requests a change of remote desktop size. This message is an extension
+    // and may only be sent if we have received an ExtendedDesktopSize message
+    _requestRemoteResize() {
+        clearTimeout(this._resizeTimeout);
+        this._resizeTimeout = null;
+
+        if (!this._resizeSession || this._viewOnly ||
+            !this._supportsSetDesktopSize) {
+            return;
+        }
+
+        const size = this._screenSize();
+
+        RFB.messages.setDesktopSize(this._sock,
+                                    Math.floor(size.w), Math.floor(size.h),
+                                    this._screenID, this._screenFlags);
+
+        Log.Debug('Requested new desktop size: ' +
+                   size.w + 'x' + size.h);
+    }
+
+    // Gets the the size of the available screen
+    _screenSize() {
+        let r = this._screen.getBoundingClientRect();
+        return { w: r.width, h: r.height };
+    }
+
+    _fixScrollbars() {
+        // This is a hack because Safari on macOS screws up the calculation
+        // for when scrollbars are needed. We get scrollbars when making the
+        // browser smaller, despite remote resize being enabled. So to fix it
+        // we temporarily toggle them off and on.
+        const orig = this._screen.style.overflow;
+        this._screen.style.overflow = 'hidden';
+        // Force Safari to recalculate the layout by asking for
+        // an element's dimensions
+        this._screen.getBoundingClientRect();
+        this._screen.style.overflow = orig;
+    }
+
+    /*
+     * Connection states:
+     *   connecting
+     *   connected
+     *   disconnecting
+     *   disconnected - permanent state
+     */
+    _updateConnectionState(state) {
+        const oldstate = this._rfbConnectionState;
+
+        if (state === oldstate) {
+            Log.Debug("Already in state '" + state + "', ignoring");
+            return;
+        }
+
+        // The 'disconnected' state is permanent for each RFB object
+        if (oldstate === 'disconnected') {
+            Log.Error("Tried changing state of a disconnected RFB object");
+            return;
+        }
+
+        // Ensure proper transitions before doing anything
+        switch (state) {
+            case 'connected':
+                if (oldstate !== 'connecting') {
+                    Log.Error("Bad transition to connected state, " +
+                               "previous connection state: " + oldstate);
+                    return;
+                }
+                break;
+
+            case 'disconnected':
+                if (oldstate !== 'disconnecting') {
+                    Log.Error("Bad transition to disconnected state, " +
+                               "previous connection state: " + oldstate);
+                    return;
+                }
+                break;
+
+            case 'connecting':
+                if (oldstate !== '') {
+                    Log.Error("Bad transition to connecting state, " +
+                               "previous connection state: " + oldstate);
+                    return;
+                }
+                break;
+
+            case 'disconnecting':
+                if (oldstate !== 'connected' && oldstate !== 'connecting') {
+                    Log.Error("Bad transition to disconnecting state, " +
+                               "previous connection state: " + oldstate);
+                    return;
+                }
+                break;
+
+            default:
+                Log.Error("Unknown connection state: " + state);
+                return;
+        }
+
+        // State change actions
+
+        this._rfbConnectionState = state;
+
+        Log.Debug("New state '" + state + "', was '" + oldstate + "'.");
+
+        if (this._disconnTimer && state !== 'disconnecting') {
+            Log.Debug("Clearing disconnect timer");
+            clearTimeout(this._disconnTimer);
+            this._disconnTimer = null;
+
+            // make sure we don't get a double event
+            this._sock.off('close');
+        }
+
+        switch (state) {
+            case 'connecting':
+                this._connect();
+                break;
+
+            case 'connected':
+                this.dispatchEvent(new CustomEvent("connect", { detail: {} }));
+                break;
+
+            case 'disconnecting':
+                this._disconnect();
+
+                this._disconnTimer = setTimeout(() => {
+                    Log.Error("Disconnection timed out.");
+                    this._updateConnectionState('disconnected');
+                }, DISCONNECT_TIMEOUT * 1000);
+                break;
+
+            case 'disconnected':
+                this.dispatchEvent(new CustomEvent(
+                    "disconnect", { detail:
+                                    { clean: this._rfbCleanDisconnect } }));
+                break;
+        }
+    }
+
+    /* Print errors and disconnect
+     *
+     * The parameter 'details' is used for information that
+     * should be logged but not sent to the user interface.
+     */
+    _fail(details) {
+        switch (this._rfbConnectionState) {
+            case 'disconnecting':
+                Log.Error("Failed when disconnecting: " + details);
+                break;
+            case 'connected':
+                Log.Error("Failed while connected: " + details);
+                break;
+            case 'connecting':
+                Log.Error("Failed when connecting: " + details);
+                break;
+            default:
+                Log.Error("RFB failure: " + details);
+                break;
+        }
+        this._rfbCleanDisconnect = false; //This is sent to the UI
+
+        // Transition to disconnected without waiting for socket to close
+        this._updateConnectionState('disconnecting');
+        this._updateConnectionState('disconnected');
+
+        return false;
+    }
+
+    _setCapability(cap, val) {
+        this._capabilities[cap] = val;
+        this.dispatchEvent(new CustomEvent("capabilities",
+                                           { detail: { capabilities: this._capabilities } }));
+    }
+
+    _handleMessage() {
+        if (this._sock.rQlen === 0) {
+            Log.Warn("handleMessage called on an empty receive queue");
+            return;
+        }
+
+        switch (this._rfbConnectionState) {
+            case 'disconnected':
+                Log.Error("Got data while disconnected");
+                break;
+            case 'connected':
+                while (true) {
+                    if (this._flushing) {
+                        break;
+                    }
+                    if (!this._normalMsg()) {
+                        break;
+                    }
+                    if (this._sock.rQlen === 0) {
+                        break;
+                    }
+                }
+                break;
+            case 'connecting':
+                while (this._rfbConnectionState === 'connecting') {
+                    if (!this._initMsg()) {
+                        break;
+                    }
+                }
+                break;
+            default:
+                Log.Error("Got data while in an invalid state");
+                break;
+        }
+    }
+
+    _handleKeyEvent(keysym, code, down) {
+        this.sendKey(keysym, code, down);
+    }
+
+    _handleMouse(ev) {
+        /*
+         * We don't check connection status or viewOnly here as the
+         * mouse events might be used to control the viewport
+         */
+
+        if (ev.type === 'click') {
+            /*
+             * Note: This is only needed for the 'click' event as it fails
+             *       to fire properly for the target element so we have
+             *       to listen on the document element instead.
+             */
+            if (ev.target !== this._canvas) {
+                return;
+            }
+        }
+
+        // FIXME: if we're in view-only and not dragging,
+        //        should we stop events?
+        ev.stopPropagation();
+        ev.preventDefault();
+
+        if ((ev.type === 'click') || (ev.type === 'contextmenu')) {
+            return;
+        }
+
+        let pos = clientToElement(ev.clientX, ev.clientY,
+                                  this._canvas);
+
+        switch (ev.type) {
+            case 'mousedown':
+                setCapture(this._canvas);
+                this._handleMouseButton(pos.x, pos.y,
+                                        true, 1 << ev.button);
+                break;
+            case 'mouseup':
+                this._handleMouseButton(pos.x, pos.y,
+                                        false, 1 << ev.button);
+                break;
+            case 'mousemove':
+                this._handleMouseMove(pos.x, pos.y);
+                break;
+        }
+    }
+
+    _handleMouseButton(x, y, down, bmask) {
+        if (this.dragViewport) {
+            if (down && !this._viewportDragging) {
+                this._viewportDragging = true;
+                this._viewportDragPos = {'x': x, 'y': y};
+                this._viewportHasMoved = false;
+
+                // Skip sending mouse events
+                return;
+            } else {
+                this._viewportDragging = false;
+
+                // If we actually performed a drag then we are done
+                // here and should not send any mouse events
+                if (this._viewportHasMoved) {
+                    return;
+                }
+
+                // Otherwise we treat this as a mouse click event.
+                // Send the button down event here, as the button up
+                // event is sent at the end of this function.
+                this._sendMouse(x, y, bmask);
+            }
+        }
+
+        // Flush waiting move event first
+        if (this._mouseMoveTimer !== null) {
+            clearTimeout(this._mouseMoveTimer);
+            this._mouseMoveTimer = null;
+            this._sendMouse(x, y, this._mouseButtonMask);
+        }
+
+        if (down) {
+            this._mouseButtonMask |= bmask;
+        } else {
+            this._mouseButtonMask &= ~bmask;
+        }
+
+        this._sendMouse(x, y, this._mouseButtonMask);
+    }
+
+    _handleMouseMove(x, y) {
+        if (this._viewportDragging) {
+            const deltaX = this._viewportDragPos.x - x;
+            const deltaY = this._viewportDragPos.y - y;
+
+            if (this._viewportHasMoved || (Math.abs(deltaX) > dragThreshold ||
+                                           Math.abs(deltaY) > dragThreshold)) {
+                this._viewportHasMoved = true;
+
+                this._viewportDragPos = {'x': x, 'y': y};
+                this._display.viewportChangePos(deltaX, deltaY);
+            }
+
+            // Skip sending mouse events
+            return;
+        }
+
+        this._mousePos = { 'x': x, 'y': y };
+
+        // Limit many mouse move events to one every MOUSE_MOVE_DELAY ms
+        if (this._mouseMoveTimer == null) {
+
+            const timeSinceLastMove = Date.now() - this._mouseLastMoveTime;
+            if (timeSinceLastMove > MOUSE_MOVE_DELAY) {
+                this._sendMouse(x, y, this._mouseButtonMask);
+                this._mouseLastMoveTime = Date.now();
+            } else {
+                // Too soon since the latest move, wait the remaining time
+                this._mouseMoveTimer = setTimeout(() => {
+                    this._handleDelayedMouseMove();
+                }, MOUSE_MOVE_DELAY - timeSinceLastMove);
+            }
+        }
+    }
+
+    _handleDelayedMouseMove() {
+        this._mouseMoveTimer = null;
+        this._sendMouse(this._mousePos.x, this._mousePos.y,
+                        this._mouseButtonMask);
+        this._mouseLastMoveTime = Date.now();
+    }
+
+    _sendMouse(x, y, mask) {
+        if (this._rfbConnectionState !== 'connected') { return; }
+        if (this._viewOnly) { return; } // View only, skip mouse events
+
+        RFB.messages.pointerEvent(this._sock, this._display.absX(x),
+                                  this._display.absY(y), mask);
+    }
+
+    _handleWheel(ev) {
+        if (this._rfbConnectionState !== 'connected') { return; }
+        if (this._viewOnly) { return; } // View only, skip mouse events
+
+        ev.stopPropagation();
+        ev.preventDefault();
+
+        let pos = clientToElement(ev.clientX, ev.clientY,
+                                  this._canvas);
+
+        let dX = ev.deltaX;
+        let dY = ev.deltaY;
+
+        // Pixel units unless it's non-zero.
+        // Note that if deltamode is line or page won't matter since we aren't
+        // sending the mouse wheel delta to the server anyway.
+        // The difference between pixel and line can be important however since
+        // we have a threshold that can be smaller than the line height.
+        if (ev.deltaMode !== 0) {
+            dX *= WHEEL_LINE_HEIGHT;
+            dY *= WHEEL_LINE_HEIGHT;
+        }
+
+        // Mouse wheel events are sent in steps over VNC. This means that the VNC
+        // protocol can't handle a wheel event with specific distance or speed.
+        // Therefor, if we get a lot of small mouse wheel events we combine them.
+        this._accumulatedWheelDeltaX += dX;
+        this._accumulatedWheelDeltaY += dY;
+
+        // Generate a mouse wheel step event when the accumulated delta
+        // for one of the axes is large enough.
+        if (Math.abs(this._accumulatedWheelDeltaX) >= WHEEL_STEP) {
+            if (this._accumulatedWheelDeltaX < 0) {
+                this._handleMouseButton(pos.x, pos.y, true, 1 << 5);
+                this._handleMouseButton(pos.x, pos.y, false, 1 << 5);
+            } else if (this._accumulatedWheelDeltaX > 0) {
+                this._handleMouseButton(pos.x, pos.y, true, 1 << 6);
+                this._handleMouseButton(pos.x, pos.y, false, 1 << 6);
+            }
+
+            this._accumulatedWheelDeltaX = 0;
+        }
+        if (Math.abs(this._accumulatedWheelDeltaY) >= WHEEL_STEP) {
+            if (this._accumulatedWheelDeltaY < 0) {
+                this._handleMouseButton(pos.x, pos.y, true, 1 << 3);
+                this._handleMouseButton(pos.x, pos.y, false, 1 << 3);
+            } else if (this._accumulatedWheelDeltaY > 0) {
+                this._handleMouseButton(pos.x, pos.y, true, 1 << 4);
+                this._handleMouseButton(pos.x, pos.y, false, 1 << 4);
+            }
+
+            this._accumulatedWheelDeltaY = 0;
+        }
+    }
+
+    _fakeMouseMove(ev, elementX, elementY) {
+        this._handleMouseMove(elementX, elementY);
+        this._cursor.move(ev.detail.clientX, ev.detail.clientY);
+    }
+
+    _handleTapEvent(ev, bmask) {
+        let pos = clientToElement(ev.detail.clientX, ev.detail.clientY,
+                                  this._canvas);
+
+        // If the user quickly taps multiple times we assume they meant to
+        // hit the same spot, so slightly adjust coordinates
+
+        if ((this._gestureLastTapTime !== null) &&
+            ((Date.now() - this._gestureLastTapTime) < DOUBLE_TAP_TIMEOUT) &&
+            (this._gestureFirstDoubleTapEv.detail.type === ev.detail.type)) {
+            let dx = this._gestureFirstDoubleTapEv.detail.clientX - ev.detail.clientX;
+            let dy = this._gestureFirstDoubleTapEv.detail.clientY - ev.detail.clientY;
+            let distance = Math.hypot(dx, dy);
+
+            if (distance < DOUBLE_TAP_THRESHOLD) {
+                pos = clientToElement(this._gestureFirstDoubleTapEv.detail.clientX,
+                                      this._gestureFirstDoubleTapEv.detail.clientY,
+                                      this._canvas);
+            } else {
+                this._gestureFirstDoubleTapEv = ev;
+            }
+        } else {
+            this._gestureFirstDoubleTapEv = ev;
+        }
+        this._gestureLastTapTime = Date.now();
+
+        this._fakeMouseMove(this._gestureFirstDoubleTapEv, pos.x, pos.y);
+        this._handleMouseButton(pos.x, pos.y, true, bmask);
+        this._handleMouseButton(pos.x, pos.y, false, bmask);
+    }
+
+    _handleGesture(ev) {
+        let magnitude;
+
+        let pos = clientToElement(ev.detail.clientX, ev.detail.clientY,
+                                  this._canvas);
+        switch (ev.type) {
+            case 'gesturestart':
+                switch (ev.detail.type) {
+                    case 'onetap':
+                        this._handleTapEvent(ev, 0x1);
+                        break;
+                    case 'twotap':
+                        this._handleTapEvent(ev, 0x4);
+                        break;
+                    case 'threetap':
+                        this._handleTapEvent(ev, 0x2);
+                        break;
+                    case 'drag':
+                        this._fakeMouseMove(ev, pos.x, pos.y);
+                        this._handleMouseButton(pos.x, pos.y, true, 0x1);
+                        break;
+                    case 'longpress':
+                        this._fakeMouseMove(ev, pos.x, pos.y);
+                        this._handleMouseButton(pos.x, pos.y, true, 0x4);
+                        break;
+
+                    case 'twodrag':
+                        this._gestureLastMagnitudeX = ev.detail.magnitudeX;
+                        this._gestureLastMagnitudeY = ev.detail.magnitudeY;
+                        this._fakeMouseMove(ev, pos.x, pos.y);
+                        break;
+                    case 'pinch':
+                        this._gestureLastMagnitudeX = Math.hypot(ev.detail.magnitudeX,
+                                                                 ev.detail.magnitudeY);
+                        this._fakeMouseMove(ev, pos.x, pos.y);
+                        break;
+                }
+                break;
+
+            case 'gesturemove':
+                switch (ev.detail.type) {
+                    case 'onetap':
+                    case 'twotap':
+                    case 'threetap':
+                        break;
+                    case 'drag':
+                    case 'longpress':
+                        this._fakeMouseMove(ev, pos.x, pos.y);
+                        break;
+                    case 'twodrag':
+                        // Always scroll in the same position.
+                        // We don't know if the mouse was moved so we need to move it
+                        // every update.
+                        this._fakeMouseMove(ev, pos.x, pos.y);
+                        while ((ev.detail.magnitudeY - this._gestureLastMagnitudeY) > GESTURE_SCRLSENS) {
+                            this._handleMouseButton(pos.x, pos.y, true, 0x8);
+                            this._handleMouseButton(pos.x, pos.y, false, 0x8);
+                            this._gestureLastMagnitudeY += GESTURE_SCRLSENS;
+                        }
+                        while ((ev.detail.magnitudeY - this._gestureLastMagnitudeY) < -GESTURE_SCRLSENS) {
+                            this._handleMouseButton(pos.x, pos.y, true, 0x10);
+                            this._handleMouseButton(pos.x, pos.y, false, 0x10);
+                            this._gestureLastMagnitudeY -= GESTURE_SCRLSENS;
+                        }
+                        while ((ev.detail.magnitudeX - this._gestureLastMagnitudeX) > GESTURE_SCRLSENS) {
+                            this._handleMouseButton(pos.x, pos.y, true, 0x20);
+                            this._handleMouseButton(pos.x, pos.y, false, 0x20);
+                            this._gestureLastMagnitudeX += GESTURE_SCRLSENS;
+                        }
+                        while ((ev.detail.magnitudeX - this._gestureLastMagnitudeX) < -GESTURE_SCRLSENS) {
+                            this._handleMouseButton(pos.x, pos.y, true, 0x40);
+                            this._handleMouseButton(pos.x, pos.y, false, 0x40);
+                            this._gestureLastMagnitudeX -= GESTURE_SCRLSENS;
+                        }
+                        break;
+                    case 'pinch':
+                        // Always scroll in the same position.
+                        // We don't know if the mouse was moved so we need to move it
+                        // every update.
+                        this._fakeMouseMove(ev, pos.x, pos.y);
+                        magnitude = Math.hypot(ev.detail.magnitudeX, ev.detail.magnitudeY);
+                        if (Math.abs(magnitude - this._gestureLastMagnitudeX) > GESTURE_ZOOMSENS) {
+                            this._handleKeyEvent(KeyTable.XK_Control_L, "ControlLeft", true);
+                            while ((magnitude - this._gestureLastMagnitudeX) > GESTURE_ZOOMSENS) {
+                                this._handleMouseButton(pos.x, pos.y, true, 0x8);
+                                this._handleMouseButton(pos.x, pos.y, false, 0x8);
+                                this._gestureLastMagnitudeX += GESTURE_ZOOMSENS;
+                            }
+                            while ((magnitude -  this._gestureLastMagnitudeX) < -GESTURE_ZOOMSENS) {
+                                this._handleMouseButton(pos.x, pos.y, true, 0x10);
+                                this._handleMouseButton(pos.x, pos.y, false, 0x10);
+                                this._gestureLastMagnitudeX -= GESTURE_ZOOMSENS;
+                            }
+                        }
+                        this._handleKeyEvent(KeyTable.XK_Control_L, "ControlLeft", false);
+                        break;
+                }
+                break;
+
+            case 'gestureend':
+                switch (ev.detail.type) {
+                    case 'onetap':
+                    case 'twotap':
+                    case 'threetap':
+                    case 'pinch':
+                    case 'twodrag':
+                        break;
+                    case 'drag':
+                        this._fakeMouseMove(ev, pos.x, pos.y);
+                        this._handleMouseButton(pos.x, pos.y, false, 0x1);
+                        break;
+                    case 'longpress':
+                        this._fakeMouseMove(ev, pos.x, pos.y);
+                        this._handleMouseButton(pos.x, pos.y, false, 0x4);
+                        break;
+                }
+                break;
+        }
+    }
+
+    // Message Handlers
+
+    _negotiateProtocolVersion() {
+        if (this._sock.rQwait("version", 12)) {
+            return false;
+        }
+
+        const sversion = this._sock.rQshiftStr(12).substr(4, 7);
+        Log.Info("Server ProtocolVersion: " + sversion);
+        let isRepeater = 0;
+        switch (sversion) {
+            case "000.000":  // UltraVNC repeater
+                isRepeater = 1;
+                break;
+            case "003.003":
+            case "003.006":  // UltraVNC
+                this._rfbVersion = 3.3;
+                break;
+            case "003.007":
+                this._rfbVersion = 3.7;
+                break;
+            case "003.008":
+            case "003.889":  // Apple Remote Desktop
+            case "004.000":  // Intel AMT KVM
+            case "004.001":  // RealVNC 4.6
+            case "005.000":  // RealVNC 5.3
+                this._rfbVersion = 3.8;
+                break;
+            default:
+                return this._fail("Invalid server version " + sversion);
+        }
+
+        if (isRepeater) {
+            let repeaterID = "ID:" + this._repeaterID;
+            while (repeaterID.length < 250) {
+                repeaterID += "\0";
+            }
+            this._sock.sendString(repeaterID);
+            return true;
+        }
+
+        if (this._rfbVersion > this._rfbMaxVersion) {
+            this._rfbVersion = this._rfbMaxVersion;
+        }
+
+        const cversion = "00" + parseInt(this._rfbVersion, 10) +
+                       ".00" + ((this._rfbVersion * 10) % 10);
+        this._sock.sendString("RFB " + cversion + "\n");
+        Log.Debug('Sent ProtocolVersion: ' + cversion);
+
+        this._rfbInitState = 'Security';
+    }
+
+    _isSupportedSecurityType(type) {
+        const clientTypes = [
+            securityTypeNone,
+            securityTypeVNCAuth,
+            securityTypeRA2ne,
+            securityTypeTight,
+            securityTypeVeNCrypt,
+            securityTypeXVP,
+            securityTypeARD,
+            securityTypePlain,
+        ];
+
+        return clientTypes.includes(type);
+    }
+
+    _negotiateSecurity() {
+        if (this._rfbVersion >= 3.7) {
+            // Server sends supported list, client decides
+            const numTypes = this._sock.rQshift8();
+            if (this._sock.rQwait("security type", numTypes, 1)) { return false; }
+
+            if (numTypes === 0) {
+                this._rfbInitState = "SecurityReason";
+                this._securityContext = "no security types";
+                this._securityStatus = 1;
+                return true;
+            }
+
+            const types = this._sock.rQshiftBytes(numTypes);
+            Log.Debug("Server security types: " + types);
+
+            // Look for a matching security type in the order that the
+            // server prefers
+            this._rfbAuthScheme = -1;
+            for (let type of types) {
+                if (this._isSupportedSecurityType(type)) {
+                    this._rfbAuthScheme = type;
+                    break;
+                }
+            }
+
+            if (this._rfbAuthScheme === -1) {
+                return this._fail("Unsupported security types (types: " + types + ")");
+            }
+
+            this._sock.send([this._rfbAuthScheme]);
+        } else {
+            // Server decides
+            if (this._sock.rQwait("security scheme", 4)) { return false; }
+            this._rfbAuthScheme = this._sock.rQshift32();
+
+            if (this._rfbAuthScheme == 0) {
+                this._rfbInitState = "SecurityReason";
+                this._securityContext = "authentication scheme";
+                this._securityStatus = 1;
+                return true;
+            }
+        }
+
+        this._rfbInitState = 'Authentication';
+        Log.Debug('Authenticating using scheme: ' + this._rfbAuthScheme);
+
+        return true;
+    }
+
+    _handleSecurityReason() {
+        if (this._sock.rQwait("reason length", 4)) {
+            return false;
+        }
+        const strlen = this._sock.rQshift32();
+        let reason = "";
+
+        if (strlen > 0) {
+            if (this._sock.rQwait("reason", strlen, 4)) { return false; }
+            reason = this._sock.rQshiftStr(strlen);
+        }
+
+        if (reason !== "") {
+            this.dispatchEvent(new CustomEvent(
+                "securityfailure",
+                { detail: { status: this._securityStatus,
+                            reason: reason } }));
+
+            return this._fail("Security negotiation failed on " +
+                              this._securityContext +
+                              " (reason: " + reason + ")");
+        } else {
+            this.dispatchEvent(new CustomEvent(
+                "securityfailure",
+                { detail: { status: this._securityStatus } }));
+
+            return this._fail("Security negotiation failed on " +
+                              this._securityContext);
+        }
+    }
+
+    // authentication
+    _negotiateXvpAuth() {
+        if (this._rfbCredentials.username === undefined ||
+            this._rfbCredentials.password === undefined ||
+            this._rfbCredentials.target === undefined) {
+            this.dispatchEvent(new CustomEvent(
+                "credentialsrequired",
+                { detail: { types: ["username", "password", "target"] } }));
+            return false;
+        }
+
+        const xvpAuthStr = String.fromCharCode(this._rfbCredentials.username.length) +
+                           String.fromCharCode(this._rfbCredentials.target.length) +
+                           this._rfbCredentials.username +
+                           this._rfbCredentials.target;
+        this._sock.sendString(xvpAuthStr);
+        this._rfbAuthScheme = securityTypeVNCAuth;
+        return this._negotiateAuthentication();
+    }
+
+    // VeNCrypt authentication, currently only supports version 0.2 and only Plain subtype
+    _negotiateVeNCryptAuth() {
+
+        // waiting for VeNCrypt version
+        if (this._rfbVeNCryptState == 0) {
+            if (this._sock.rQwait("vencrypt version", 2)) { return false; }
+
+            const major = this._sock.rQshift8();
+            const minor = this._sock.rQshift8();
+
+            if (!(major == 0 && minor == 2)) {
+                return this._fail("Unsupported VeNCrypt version " + major + "." + minor);
+            }
+
+            this._sock.send([0, 2]);
+            this._rfbVeNCryptState = 1;
+        }
+
+        // waiting for ACK
+        if (this._rfbVeNCryptState == 1) {
+            if (this._sock.rQwait("vencrypt ack", 1)) { return false; }
+
+            const res = this._sock.rQshift8();
+
+            if (res != 0) {
+                return this._fail("VeNCrypt failure " + res);
+            }
+
+            this._rfbVeNCryptState = 2;
+        }
+        // must fall through here (i.e. no "else if"), beacause we may have already received
+        // the subtypes length and won't be called again
+
+        if (this._rfbVeNCryptState == 2) { // waiting for subtypes length
+            if (this._sock.rQwait("vencrypt subtypes length", 1)) { return false; }
+
+            const subtypesLength = this._sock.rQshift8();
+            if (subtypesLength < 1) {
+                return this._fail("VeNCrypt subtypes empty");
+            }
+
+            this._rfbVeNCryptSubtypesLength = subtypesLength;
+            this._rfbVeNCryptState = 3;
+        }
+
+        // waiting for subtypes list
+        if (this._rfbVeNCryptState == 3) {
+            if (this._sock.rQwait("vencrypt subtypes", 4 * this._rfbVeNCryptSubtypesLength)) { return false; }
+
+            const subtypes = [];
+            for (let i = 0; i < this._rfbVeNCryptSubtypesLength; i++) {
+                subtypes.push(this._sock.rQshift32());
+            }
+
+            // Look for a matching security type in the order that the
+            // server prefers
+            this._rfbAuthScheme = -1;
+            for (let type of subtypes) {
+                // Avoid getting in to a loop
+                if (type === securityTypeVeNCrypt) {
+                    continue;
+                }
+
+                if (this._isSupportedSecurityType(type)) {
+                    this._rfbAuthScheme = type;
+                    break;
+                }
+            }
+
+            if (this._rfbAuthScheme === -1) {
+                return this._fail("Unsupported security types (types: " + subtypes + ")");
+            }
+
+            this._sock.send([this._rfbAuthScheme >> 24,
+                             this._rfbAuthScheme >> 16,
+                             this._rfbAuthScheme >> 8,
+                             this._rfbAuthScheme]);
+
+            this._rfbVeNCryptState == 4;
+            return true;
+        }
+    }
+
+    _negotiatePlainAuth() {
+        if (this._rfbCredentials.username === undefined ||
+            this._rfbCredentials.password === undefined) {
+            this.dispatchEvent(new CustomEvent(
+                "credentialsrequired",
+                { detail: { types: ["username", "password"] } }));
+            return false;
+        }
+
+        const user = encodeUTF8(this._rfbCredentials.username);
+        const pass = encodeUTF8(this._rfbCredentials.password);
+
+        this._sock.send([
+            (user.length >> 24) & 0xFF,
+            (user.length >> 16) & 0xFF,
+            (user.length >> 8) & 0xFF,
+            user.length & 0xFF
+        ]);
+        this._sock.send([
+            (pass.length >> 24) & 0xFF,
+            (pass.length >> 16) & 0xFF,
+            (pass.length >> 8) & 0xFF,
+            pass.length & 0xFF
+        ]);
+        this._sock.sendString(user);
+        this._sock.sendString(pass);
+
+        this._rfbInitState = "SecurityResult";
+        return true;
+    }
+
+    _negotiateStdVNCAuth() {
+        if (this._sock.rQwait("auth challenge", 16)) { return false; }
+
+        if (this._rfbCredentials.password === undefined) {
+            this.dispatchEvent(new CustomEvent(
+                "credentialsrequired",
+                { detail: { types: ["password"] } }));
+            return false;
+        }
+
+        // TODO(directxman12): make genDES not require an Array
+        const challenge = Array.prototype.slice.call(this._sock.rQshiftBytes(16));
+        const response = RFB.genDES(this._rfbCredentials.password, challenge);
+        this._sock.send(response);
+        this._rfbInitState = "SecurityResult";
+        return true;
+    }
+
+    _negotiateARDAuth() {
+
+        if (this._rfbCredentials.username === undefined ||
+            this._rfbCredentials.password === undefined) {
+            this.dispatchEvent(new CustomEvent(
+                "credentialsrequired",
+                { detail: { types: ["username", "password"] } }));
+            return false;
+        }
+
+        if (this._rfbCredentials.ardPublicKey != undefined &&
+            this._rfbCredentials.ardCredentials != undefined) {
+            // if the async web crypto is done return the results
+            this._sock.send(this._rfbCredentials.ardCredentials);
+            this._sock.send(this._rfbCredentials.ardPublicKey);
+            this._rfbCredentials.ardCredentials = null;
+            this._rfbCredentials.ardPublicKey = null;
+            this._rfbInitState = "SecurityResult";
+            return true;
+        }
+
+        if (this._sock.rQwait("read ard", 4)) { return false; }
+
+        let generator = this._sock.rQshiftBytes(2);   // DH base generator value
+
+        let keyLength = this._sock.rQshift16();
+
+        if (this._sock.rQwait("read ard keylength", keyLength*2, 4)) { return false; }
+
+        // read the server values
+        let prime = this._sock.rQshiftBytes(keyLength);  // predetermined prime modulus
+        let serverPublicKey = this._sock.rQshiftBytes(keyLength); // other party's public key
+
+        let clientPrivateKey = window.crypto.getRandomValues(new Uint8Array(keyLength));
+        let padding = Array.from(window.crypto.getRandomValues(new Uint8Array(64)), byte => String.fromCharCode(65+byte%26)).join('');
+
+        this._negotiateARDAuthAsync(generator, keyLength, prime, serverPublicKey, clientPrivateKey, padding);
+
+        return false;
+    }
+
+    _modPow(base, exponent, modulus) {
+
+        let baseHex = "0x"+Array.from(base, byte => ('0' + (byte & 0xFF).toString(16)).slice(-2)).join('');
+        let exponentHex = "0x"+Array.from(exponent, byte => ('0' + (byte & 0xFF).toString(16)).slice(-2)).join('');
+        let modulusHex = "0x"+Array.from(modulus, byte => ('0' + (byte & 0xFF).toString(16)).slice(-2)).join('');
+
+        let b = BigInt(baseHex);
+        let e = BigInt(exponentHex);
+        let m = BigInt(modulusHex);
+        let r = 1n;
+        b = b % m;
+        while (e > 0) {
+            if (e % 2n === 1n) {
+                r = (r * b) % m;
+            }
+            e = e / 2n;
+            b = (b * b) % m;
+        }
+        let hexResult = r.toString(16);
+
+        while (hexResult.length/2<exponent.length || (hexResult.length%2 != 0)) {
+            hexResult = "0"+hexResult;
+        }
+
+        let bytesResult = [];
+        for (let c = 0; c < hexResult.length; c += 2) {
+            bytesResult.push(parseInt(hexResult.substr(c, 2), 16));
+        }
+        return bytesResult;
+    }
+
+    async _aesEcbEncrypt(string, key) {
+        // perform AES-ECB blocks
+        let keyString = Array.from(key, byte => String.fromCharCode(byte)).join('');
+        let aesKey = await window.crypto.subtle.importKey("raw", MD5(keyString), {name: "AES-CBC"}, false, ["encrypt"]);
+        let data = new Uint8Array(string.length);
+        for (let i = 0; i < string.length; ++i) {
+            data[i] = string.charCodeAt(i);
+        }
+        let encrypted = new Uint8Array(data.length);
+        for (let i=0;i<data.length;i+=16) {
+            let block = data.slice(i, i+16);
+            let encryptedBlock = await window.crypto.subtle.encrypt({name: "AES-CBC", iv: block},
+                                                                    aesKey, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
+            );
+            encrypted.set((new Uint8Array(encryptedBlock)).slice(0, 16), i);
+        }
+        return encrypted;
+    }
+
+    async _negotiateARDAuthAsync(generator, keyLength, prime, serverPublicKey, clientPrivateKey, padding) {
+        // calculate the DH keys
+        let clientPublicKey = this._modPow(generator, clientPrivateKey, prime);
+        let sharedKey = this._modPow(serverPublicKey, clientPrivateKey, prime);
+
+        let username = encodeUTF8(this._rfbCredentials.username).substring(0, 63);
+        let password = encodeUTF8(this._rfbCredentials.password).substring(0, 63);
+
+        let paddedUsername = username + '\0' + padding.substring(0, 63);
+        let paddedPassword = password + '\0' + padding.substring(0, 63);
+        let credentials = paddedUsername.substring(0, 64) + paddedPassword.substring(0, 64);
+
+        let encrypted = await this._aesEcbEncrypt(credentials, sharedKey);
+
+        this._rfbCredentials.ardCredentials = encrypted;
+        this._rfbCredentials.ardPublicKey = clientPublicKey;
+
+        this._resumeAuthentication();
+    }
+
+    _negotiateTightUnixAuth() {
+        if (this._rfbCredentials.username === undefined ||
+            this._rfbCredentials.password === undefined) {
+            this.dispatchEvent(new CustomEvent(
+                "credentialsrequired",
+                { detail: { types: ["username", "password"] } }));
+            return false;
+        }
+
+        this._sock.send([0, 0, 0, this._rfbCredentials.username.length]);
+        this._sock.send([0, 0, 0, this._rfbCredentials.password.length]);
+        this._sock.sendString(this._rfbCredentials.username);
+        this._sock.sendString(this._rfbCredentials.password);
+        this._rfbInitState = "SecurityResult";
+        return true;
+    }
+
+    _negotiateTightTunnels(numTunnels) {
+        const clientSupportedTunnelTypes = {
+            0: { vendor: 'TGHT', signature: 'NOTUNNEL' }
+        };
+        const serverSupportedTunnelTypes = {};
+        // receive tunnel capabilities
+        for (let i = 0; i < numTunnels; i++) {
+            const capCode = this._sock.rQshift32();
+            const capVendor = this._sock.rQshiftStr(4);
+            const capSignature = this._sock.rQshiftStr(8);
+            serverSupportedTunnelTypes[capCode] = { vendor: capVendor, signature: capSignature };
+        }
+
+        Log.Debug("Server Tight tunnel types: " + serverSupportedTunnelTypes);
+
+        // Siemens touch panels have a VNC server that supports NOTUNNEL,
+        // but forgets to advertise it. Try to detect such servers by
+        // looking for their custom tunnel type.
+        if (serverSupportedTunnelTypes[1] &&
+            (serverSupportedTunnelTypes[1].vendor === "SICR") &&
+            (serverSupportedTunnelTypes[1].signature === "SCHANNEL")) {
+            Log.Debug("Detected Siemens server. Assuming NOTUNNEL support.");
+            serverSupportedTunnelTypes[0] = { vendor: 'TGHT', signature: 'NOTUNNEL' };
+        }
+
+        // choose the notunnel type
+        if (serverSupportedTunnelTypes[0]) {
+            if (serverSupportedTunnelTypes[0].vendor != clientSupportedTunnelTypes[0].vendor ||
+                serverSupportedTunnelTypes[0].signature != clientSupportedTunnelTypes[0].signature) {
+                return this._fail("Client's tunnel type had the incorrect " +
+                                  "vendor or signature");
+            }
+            Log.Debug("Selected tunnel type: " + clientSupportedTunnelTypes[0]);
+            this._sock.send([0, 0, 0, 0]);  // use NOTUNNEL
+            return false; // wait until we receive the sub auth count to continue
+        } else {
+            return this._fail("Server wanted tunnels, but doesn't support " +
+                              "the notunnel type");
+        }
+    }
+
+    _negotiateTightAuth() {
+        if (!this._rfbTightVNC) {  // first pass, do the tunnel negotiation
+            if (this._sock.rQwait("num tunnels", 4)) { return false; }
+            const numTunnels = this._sock.rQshift32();
+            if (numTunnels > 0 && this._sock.rQwait("tunnel capabilities", 16 * numTunnels, 4)) { return false; }
+
+            this._rfbTightVNC = true;
+
+            if (numTunnels > 0) {
+                this._negotiateTightTunnels(numTunnels);
+                return false;  // wait until we receive the sub auth to continue
+            }
+        }
+
+        // second pass, do the sub-auth negotiation
+        if (this._sock.rQwait("sub auth count", 4)) { return false; }
+        const subAuthCount = this._sock.rQshift32();
+        if (subAuthCount === 0) {  // empty sub-auth list received means 'no auth' subtype selected
+            this._rfbInitState = 'SecurityResult';
+            return true;
+        }
+
+        if (this._sock.rQwait("sub auth capabilities", 16 * subAuthCount, 4)) { return false; }
+
+        const clientSupportedTypes = {
+            'STDVNOAUTH__': 1,
+            'STDVVNCAUTH_': 2,
+            'TGHTULGNAUTH': 129
+        };
+
+        const serverSupportedTypes = [];
+
+        for (let i = 0; i < subAuthCount; i++) {
+            this._sock.rQshift32(); // capNum
+            const capabilities = this._sock.rQshiftStr(12);
+            serverSupportedTypes.push(capabilities);
+        }
+
+        Log.Debug("Server Tight authentication types: " + serverSupportedTypes);
+
+        for (let authType in clientSupportedTypes) {
+            if (serverSupportedTypes.indexOf(authType) != -1) {
+                this._sock.send([0, 0, 0, clientSupportedTypes[authType]]);
+                Log.Debug("Selected authentication type: " + authType);
+
+                switch (authType) {
+                    case 'STDVNOAUTH__':  // no auth
+                        this._rfbInitState = 'SecurityResult';
+                        return true;
+                    case 'STDVVNCAUTH_':
+                        this._rfbAuthScheme = securityTypeVNCAuth;
+                        return true;
+                    case 'TGHTULGNAUTH':
+                        this._rfbAuthScheme = securityTypeUnixLogon;
+                        return true;
+                    default:
+                        return this._fail("Unsupported tiny auth scheme " +
+                                          "(scheme: " + authType + ")");
+                }
+            }
+        }
+
+        return this._fail("No supported sub-auth types!");
+    }
+
+    _handleRSAAESCredentialsRequired(event) {
+        this.dispatchEvent(event);
+    }
+
+    _handleRSAAESServerVerification(event) {
+        this.dispatchEvent(event);
+    }
+
+    _negotiateRA2neAuth() {
+        if (this._rfbRSAAESAuthenticationState === null) {
+            this._rfbRSAAESAuthenticationState = new RSAAESAuthenticationState(this._sock, () => this._rfbCredentials);
+            this._rfbRSAAESAuthenticationState.addEventListener(
+                "serververification", this._eventHandlers.handleRSAAESServerVerification);
+            this._rfbRSAAESAuthenticationState.addEventListener(
+                "credentialsrequired", this._eventHandlers.handleRSAAESCredentialsRequired);
+        }
+        this._rfbRSAAESAuthenticationState.checkInternalEvents();
+        if (!this._rfbRSAAESAuthenticationState.hasStarted) {
+            this._rfbRSAAESAuthenticationState.negotiateRA2neAuthAsync()
+                .catch((e) => {
+                    if (e.message !== "disconnect normally") {
+                        this._fail(e.message);
+                    }
+                }).then(() => {
+                    this.dispatchEvent(new CustomEvent('securityresult'));
+                    this._rfbInitState = "SecurityResult";
+                    return true;
+                }).finally(() => {
+                    this._rfbRSAAESAuthenticationState.removeEventListener(
+                        "serververification", this._eventHandlers.handleRSAAESServerVerification);
+                    this._rfbRSAAESAuthenticationState.removeEventListener(
+                        "credentialsrequired", this._eventHandlers.handleRSAAESCredentialsRequired);
+                    this._rfbRSAAESAuthenticationState = null;
+                });
+        }
+        return false;
+    }
+
+    _negotiateAuthentication() {
+        switch (this._rfbAuthScheme) {
+            case securityTypeNone:
+                this._rfbInitState = 'SecurityResult';
+                return true;
+
+            case securityTypeXVP:
+                return this._negotiateXvpAuth();
+
+            case securityTypeARD:
+                return this._negotiateARDAuth();
+
+            case securityTypeVNCAuth:
+                return this._negotiateStdVNCAuth();
+
+            case securityTypeTight:
+                return this._negotiateTightAuth();
+
+            case securityTypeVeNCrypt:
+                return this._negotiateVeNCryptAuth();
+
+            case securityTypePlain:
+                return this._negotiatePlainAuth();
+
+            case securityTypeUnixLogon:
+                return this._negotiateTightUnixAuth();
+
+            case securityTypeRA2ne:
+                return this._negotiateRA2neAuth();
+
+            default:
+                return this._fail("Unsupported auth scheme (scheme: " +
+                                  this._rfbAuthScheme + ")");
+        }
+    }
+
+    _handleSecurityResult() {
+        // There is no security choice, and hence no security result
+        // until RFB 3.7
+        if (this._rfbVersion < 3.7) {
+            this._rfbInitState = 'ClientInitialisation';
+            return true;
+        }
+
+        if (this._sock.rQwait('VNC auth response ', 4)) { return false; }
+
+        const status = this._sock.rQshift32();
+
+        if (status === 0) { // OK
+            this._rfbInitState = 'ClientInitialisation';
+            Log.Debug('Authentication OK');
+            return true;
+        } else {
+            if (this._rfbVersion >= 3.8) {
+                this._rfbInitState = "SecurityReason";
+                this._securityContext = "security result";
+                this._securityStatus = status;
+                return true;
+            } else {
+                this.dispatchEvent(new CustomEvent(
+                    "securityfailure",
+                    { detail: { status: status } }));
+
+                return this._fail("Security handshake failed");
+            }
+        }
+    }
+
+    _negotiateServerInit() {
+        if (this._sock.rQwait("server initialization", 24)) { return false; }
+
+        /* Screen size */
+        const width = this._sock.rQshift16();
+        const height = this._sock.rQshift16();
+
+        /* PIXEL_FORMAT */
+        const bpp         = this._sock.rQshift8();
+        const depth       = this._sock.rQshift8();
+        const bigEndian  = this._sock.rQshift8();
+        const trueColor  = this._sock.rQshift8();
+
+        const redMax     = this._sock.rQshift16();
+        const greenMax   = this._sock.rQshift16();
+        const blueMax    = this._sock.rQshift16();
+        const redShift   = this._sock.rQshift8();
+        const greenShift = this._sock.rQshift8();
+        const blueShift  = this._sock.rQshift8();
+        this._sock.rQskipBytes(3);  // padding
+
+        // NB(directxman12): we don't want to call any callbacks or print messages until
+        //                   *after* we're past the point where we could backtrack
+
+        /* Connection name/title */
+        const nameLength = this._sock.rQshift32();
+        if (this._sock.rQwait('server init name', nameLength, 24)) { return false; }
+        let name = this._sock.rQshiftStr(nameLength);
+        name = decodeUTF8(name, true);
+
+        if (this._rfbTightVNC) {
+            if (this._sock.rQwait('TightVNC extended server init header', 8, 24 + nameLength)) { return false; }
+            // In TightVNC mode, ServerInit message is extended
+            const numServerMessages = this._sock.rQshift16();
+            const numClientMessages = this._sock.rQshift16();
+            const numEncodings = this._sock.rQshift16();
+            this._sock.rQskipBytes(2);  // padding
+
+            const totalMessagesLength = (numServerMessages + numClientMessages + numEncodings) * 16;
+            if (this._sock.rQwait('TightVNC extended server init header', totalMessagesLength, 32 + nameLength)) { return false; }
+
+            // we don't actually do anything with the capability information that TIGHT sends,
+            // so we just skip the all of this.
+
+            // TIGHT server message capabilities
+            this._sock.rQskipBytes(16 * numServerMessages);
+
+            // TIGHT client message capabilities
+            this._sock.rQskipBytes(16 * numClientMessages);
+
+            // TIGHT encoding capabilities
+            this._sock.rQskipBytes(16 * numEncodings);
+        }
+
+        // NB(directxman12): these are down here so that we don't run them multiple times
+        //                   if we backtrack
+        Log.Info("Screen: " + width + "x" + height +
+                  ", bpp: " + bpp + ", depth: " + depth +
+                  ", bigEndian: " + bigEndian +
+                  ", trueColor: " + trueColor +
+                  ", redMax: " + redMax +
+                  ", greenMax: " + greenMax +
+                  ", blueMax: " + blueMax +
+                  ", redShift: " + redShift +
+                  ", greenShift: " + greenShift +
+                  ", blueShift: " + blueShift);
+
+        // we're past the point where we could backtrack, so it's safe to call this
+        this._setDesktopName(name);
+        this._resize(width, height);
+
+        if (!this._viewOnly) { this._keyboard.grab(); }
+
+        this._fbDepth = 24;
+
+        if (this._fbName === "Intel(r) AMT KVM") {
+            Log.Warn("Intel AMT KVM only supports 8/16 bit depths. Using low color mode.");
+            this._fbDepth = 8;
+        }
+
+        RFB.messages.pixelFormat(this._sock, this._fbDepth, true);
+        this._sendEncodings();
+        RFB.messages.fbUpdateRequest(this._sock, false, 0, 0, this._fbWidth, this._fbHeight);
+
+        this._updateConnectionState('connected');
+        return true;
+    }
+
+    _sendEncodings() {
+        const encs = [];
+
+        // In preference order
+        encs.push(encodings.encodingCopyRect);
+        // Only supported with full depth support
+        if (this._fbDepth == 24) {
+            encs.push(encodings.encodingTight);
+            encs.push(encodings.encodingTightPNG);
+            encs.push(encodings.encodingZRLE);
+            encs.push(encodings.encodingJPEG);
+            encs.push(encodings.encodingHextile);
+            encs.push(encodings.encodingRRE);
+        }
+        encs.push(encodings.encodingRaw);
+
+        // Psuedo-encoding settings
+        encs.push(encodings.pseudoEncodingQualityLevel0 + this._qualityLevel);
+        encs.push(encodings.pseudoEncodingCompressLevel0 + this._compressionLevel);
+
+        encs.push(encodings.pseudoEncodingDesktopSize);
+        encs.push(encodings.pseudoEncodingLastRect);
+        encs.push(encodings.pseudoEncodingQEMUExtendedKeyEvent);
+        encs.push(encodings.pseudoEncodingExtendedDesktopSize);
+        encs.push(encodings.pseudoEncodingXvp);
+        encs.push(encodings.pseudoEncodingFence);
+        encs.push(encodings.pseudoEncodingContinuousUpdates);
+        encs.push(encodings.pseudoEncodingDesktopName);
+        encs.push(encodings.pseudoEncodingExtendedClipboard);
+
+        if (this._fbDepth == 24) {
+            encs.push(encodings.pseudoEncodingVMwareCursor);
+            encs.push(encodings.pseudoEncodingCursor);
+        }
+
+        RFB.messages.clientEncodings(this._sock, encs);
+    }
+
+    /* RFB protocol initialization states:
+     *   ProtocolVersion
+     *   Security
+     *   Authentication
+     *   SecurityResult
+     *   ClientInitialization - not triggered by server message
+     *   ServerInitialization
+     */
+    _initMsg() {
+        switch (this._rfbInitState) {
+            case 'ProtocolVersion':
+                return this._negotiateProtocolVersion();
+
+            case 'Security':
+                return this._negotiateSecurity();
+
+            case 'Authentication':
+                return this._negotiateAuthentication();
+
+            case 'SecurityResult':
+                return this._handleSecurityResult();
+
+            case 'SecurityReason':
+                return this._handleSecurityReason();
+
+            case 'ClientInitialisation':
+                this._sock.send([this._shared ? 1 : 0]); // ClientInitialisation
+                this._rfbInitState = 'ServerInitialisation';
+                return true;
+
+            case 'ServerInitialisation':
+                return this._negotiateServerInit();
+
+            default:
+                return this._fail("Unknown init state (state: " +
+                                  this._rfbInitState + ")");
+        }
+    }
+
+    // Resume authentication handshake after it was paused for some
+    // reason, e.g. waiting for a password from the user
+    _resumeAuthentication() {
+        // We use setTimeout() so it's run in its own context, just like
+        // it originally did via the WebSocket's event handler
+        setTimeout(this._initMsg.bind(this), 0);
+    }
+
+    _handleSetColourMapMsg() {
+        Log.Debug("SetColorMapEntries");
+
+        return this._fail("Unexpected SetColorMapEntries message");
+    }
+
+    _handleServerCutText() {
+        Log.Debug("ServerCutText");
+
+        if (this._sock.rQwait("ServerCutText header", 7, 1)) { return false; }
+
+        this._sock.rQskipBytes(3);  // Padding
+
+        let length = this._sock.rQshift32();
+        length = toSigned32bit(length);
+
+        if (this._sock.rQwait("ServerCutText content", Math.abs(length), 8)) { return false; }
+
+        if (length >= 0) {
+            //Standard msg
+            const text = this._sock.rQshiftStr(length);
+            if (this._viewOnly) {
+                return true;
+            }
+
+            this.dispatchEvent(new CustomEvent(
+                "clipboard",
+                { detail: { text: text } }));
+
+        } else {
+            //Extended msg.
+            length = Math.abs(length);
+            const flags = this._sock.rQshift32();
+            let formats = flags & 0x0000FFFF;
+            let actions = flags & 0xFF000000;
+
+            let isCaps = (!!(actions & extendedClipboardActionCaps));
+            if (isCaps) {
+                this._clipboardServerCapabilitiesFormats = {};
+                this._clipboardServerCapabilitiesActions = {};
+
+                // Update our server capabilities for Formats
+                for (let i = 0; i <= 15; i++) {
+                    let index = 1 << i;
+
+                    // Check if format flag is set.
+                    if ((formats & index)) {
+                        this._clipboardServerCapabilitiesFormats[index] = true;
+                        // We don't send unsolicited clipboard, so we
+                        // ignore the size
+                        this._sock.rQshift32();
+                    }
+                }
+
+                // Update our server capabilities for Actions
+                for (let i = 24; i <= 31; i++) {
+                    let index = 1 << i;
+                    this._clipboardServerCapabilitiesActions[index] = !!(actions & index);
+                }
+
+                /*  Caps handling done, send caps with the clients
+                    capabilities set as a response */
+                let clientActions = [
+                    extendedClipboardActionCaps,
+                    extendedClipboardActionRequest,
+                    extendedClipboardActionPeek,
+                    extendedClipboardActionNotify,
+                    extendedClipboardActionProvide
+                ];
+                RFB.messages.extendedClipboardCaps(this._sock, clientActions, {extendedClipboardFormatText: 0});
+
+            } else if (actions === extendedClipboardActionRequest) {
+                if (this._viewOnly) {
+                    return true;
+                }
+
+                // Check if server has told us it can handle Provide and there is clipboard data to send.
+                if (this._clipboardText != null &&
+                    this._clipboardServerCapabilitiesActions[extendedClipboardActionProvide]) {
+
+                    if (formats & extendedClipboardFormatText) {
+                        RFB.messages.extendedClipboardProvide(this._sock, [extendedClipboardFormatText], [this._clipboardText]);
+                    }
+                }
+
+            } else if (actions === extendedClipboardActionPeek) {
+                if (this._viewOnly) {
+                    return true;
+                }
+
+                if (this._clipboardServerCapabilitiesActions[extendedClipboardActionNotify]) {
+
+                    if (this._clipboardText != null) {
+                        RFB.messages.extendedClipboardNotify(this._sock, [extendedClipboardFormatText]);
+                    } else {
+                        RFB.messages.extendedClipboardNotify(this._sock, []);
+                    }
+                }
+
+            } else if (actions === extendedClipboardActionNotify) {
+                if (this._viewOnly) {
+                    return true;
+                }
+
+                if (this._clipboardServerCapabilitiesActions[extendedClipboardActionRequest]) {
+
+                    if (formats & extendedClipboardFormatText) {
+                        RFB.messages.extendedClipboardRequest(this._sock, [extendedClipboardFormatText]);
+                    }
+                }
+
+            } else if (actions === extendedClipboardActionProvide) {
+                if (this._viewOnly) {
+                    return true;
+                }
+
+                if (!(formats & extendedClipboardFormatText)) {
+                    return true;
+                }
+                // Ignore what we had in our clipboard client side.
+                this._clipboardText = null;
+
+                // FIXME: Should probably verify that this data was actually requested
+                let zlibStream = this._sock.rQshiftBytes(length - 4);
+                let streamInflator = new Inflator();
+                let textData = null;
+
+                streamInflator.setInput(zlibStream);
+                for (let i = 0; i <= 15; i++) {
+                    let format = 1 << i;
+
+                    if (formats & format) {
+
+                        let size = 0x00;
+                        let sizeArray = streamInflator.inflate(4);
+
+                        size |= (sizeArray[0] << 24);
+                        size |= (sizeArray[1] << 16);
+                        size |= (sizeArray[2] << 8);
+                        size |= (sizeArray[3]);
+                        let chunk = streamInflator.inflate(size);
+
+                        if (format === extendedClipboardFormatText) {
+                            textData = chunk;
+                        }
+                    }
+                }
+                streamInflator.setInput(null);
+
+                if (textData !== null) {
+                    let tmpText = "";
+                    for (let i = 0; i < textData.length; i++) {
+                        tmpText += String.fromCharCode(textData[i]);
+                    }
+                    textData = tmpText;
+
+                    textData = decodeUTF8(textData);
+                    if ((textData.length > 0) && "\0" === textData.charAt(textData.length - 1)) {
+                        textData = textData.slice(0, -1);
+                    }
+
+                    textData = textData.replace("\r\n", "\n");
+
+                    this.dispatchEvent(new CustomEvent(
+                        "clipboard",
+                        { detail: { text: textData } }));
+                }
+            } else {
+                return this._fail("Unexpected action in extended clipboard message: " + actions);
+            }
+        }
+        return true;
+    }
+
+    _handleServerFenceMsg() {
+        if (this._sock.rQwait("ServerFence header", 8, 1)) { return false; }
+        this._sock.rQskipBytes(3); // Padding
+        let flags = this._sock.rQshift32();
+        let length = this._sock.rQshift8();
+
+        if (this._sock.rQwait("ServerFence payload", length, 9)) { return false; }
+
+        if (length > 64) {
+            Log.Warn("Bad payload length (" + length + ") in fence response");
+            length = 64;
+        }
+
+        const payload = this._sock.rQshiftStr(length);
+
+        this._supportsFence = true;
+
+        /*
+         * Fence flags
+         *
+         *  (1<<0)  - BlockBefore
+         *  (1<<1)  - BlockAfter
+         *  (1<<2)  - SyncNext
+         *  (1<<31) - Request
+         */
+
+        if (!(flags & (1<<31))) {
+            return this._fail("Unexpected fence response");
+        }
+
+        // Filter out unsupported flags
+        // FIXME: support syncNext
+        flags &= (1<<0) | (1<<1);
+
+        // BlockBefore and BlockAfter are automatically handled by
+        // the fact that we process each incoming message
+        // synchronuosly.
+        RFB.messages.clientFence(this._sock, flags, payload);
+
+        return true;
+    }
+
+    _handleXvpMsg() {
+        if (this._sock.rQwait("XVP version and message", 3, 1)) { return false; }
+        this._sock.rQskipBytes(1);  // Padding
+        const xvpVer = this._sock.rQshift8();
+        const xvpMsg = this._sock.rQshift8();
+
+        switch (xvpMsg) {
+            case 0:  // XVP_FAIL
+                Log.Error("XVP Operation Failed");
+                break;
+            case 1:  // XVP_INIT
+                this._rfbXvpVer = xvpVer;
+                Log.Info("XVP extensions enabled (version " + this._rfbXvpVer + ")");
+                this._setCapability("power", true);
+                break;
+            default:
+                this._fail("Illegal server XVP message (msg: " + xvpMsg + ")");
+                break;
+        }
+
+        return true;
+    }
+
+    _normalMsg() {
+        let msgType;
+        if (this._FBU.rects > 0) {
+            msgType = 0;
+        } else {
+            msgType = this._sock.rQshift8();
+        }
+
+        let first, ret;
+        switch (msgType) {
+            case 0:  // FramebufferUpdate
+                ret = this._framebufferUpdate();
+                if (ret && !this._enabledContinuousUpdates) {
+                    RFB.messages.fbUpdateRequest(this._sock, true, 0, 0,
+                                                 this._fbWidth, this._fbHeight);
+                }
+                return ret;
+
+            case 1:  // SetColorMapEntries
+                return this._handleSetColourMapMsg();
+
+            case 2:  // Bell
+                Log.Debug("Bell");
+                this.dispatchEvent(new CustomEvent(
+                    "bell",
+                    { detail: {} }));
+                return true;
+
+            case 3:  // ServerCutText
+                return this._handleServerCutText();
+
+            case 150: // EndOfContinuousUpdates
+                first = !this._supportsContinuousUpdates;
+                this._supportsContinuousUpdates = true;
+                this._enabledContinuousUpdates = false;
+                if (first) {
+                    this._enabledContinuousUpdates = true;
+                    this._updateContinuousUpdates();
+                    Log.Info("Enabling continuous updates.");
+                } else {
+                    // FIXME: We need to send a framebufferupdaterequest here
+                    // if we add support for turning off continuous updates
+                }
+                return true;
+
+            case 248: // ServerFence
+                return this._handleServerFenceMsg();
+
+            case 250:  // XVP
+                return this._handleXvpMsg();
+
+            default:
+                this._fail("Unexpected server message (type " + msgType + ")");
+                Log.Debug("sock.rQslice(0, 30): " + this._sock.rQslice(0, 30));
+                return true;
+        }
+    }
+
+    _onFlush() {
+        this._flushing = false;
+        // Resume processing
+        if (this._sock.rQlen > 0) {
+            this._handleMessage();
+        }
+    }
+
+    _framebufferUpdate() {
+        if (this._FBU.rects === 0) {
+            if (this._sock.rQwait("FBU header", 3, 1)) { return false; }
+            this._sock.rQskipBytes(1);  // Padding
+            this._FBU.rects = this._sock.rQshift16();
+
+            // Make sure the previous frame is fully rendered first
+            // to avoid building up an excessive queue
+            if (this._display.pending()) {
+                this._flushing = true;
+                this._display.flush();
+                return false;
+            }
+        }
+
+        while (this._FBU.rects > 0) {
+            if (this._FBU.encoding === null) {
+                if (this._sock.rQwait("rect header", 12)) { return false; }
+                /* New FramebufferUpdate */
+
+                const hdr = this._sock.rQshiftBytes(12);
+                this._FBU.x        = (hdr[0] << 8) + hdr[1];
+                this._FBU.y        = (hdr[2] << 8) + hdr[3];
+                this._FBU.width    = (hdr[4] << 8) + hdr[5];
+                this._FBU.height   = (hdr[6] << 8) + hdr[7];
+                this._FBU.encoding = parseInt((hdr[8] << 24) + (hdr[9] << 16) +
+                                              (hdr[10] << 8) + hdr[11], 10);
+            }
+
+            if (!this._handleRect()) {
+                return false;
+            }
+
+            this._FBU.rects--;
+            this._FBU.encoding = null;
+        }
+
+        this._display.flip();
+
+        return true;  // We finished this FBU
+    }
+
+    _handleRect() {
+        switch (this._FBU.encoding) {
+            case encodings.pseudoEncodingLastRect:
+                this._FBU.rects = 1; // Will be decreased when we return
+                return true;
+
+            case encodings.pseudoEncodingVMwareCursor:
+                return this._handleVMwareCursor();
+
+            case encodings.pseudoEncodingCursor:
+                return this._handleCursor();
+
+            case encodings.pseudoEncodingQEMUExtendedKeyEvent:
+                this._qemuExtKeyEventSupported = true;
+                return true;
+
+            case encodings.pseudoEncodingDesktopName:
+                return this._handleDesktopName();
+
+            case encodings.pseudoEncodingDesktopSize:
+                this._resize(this._FBU.width, this._FBU.height);
+                return true;
+
+            case encodings.pseudoEncodingExtendedDesktopSize:
+                return this._handleExtendedDesktopSize();
+
+            default:
+                return this._handleDataRect();
+        }
+    }
+
+    _handleVMwareCursor() {
+        const hotx = this._FBU.x;  // hotspot-x
+        const hoty = this._FBU.y;  // hotspot-y
+        const w = this._FBU.width;
+        const h = this._FBU.height;
+        if (this._sock.rQwait("VMware cursor encoding", 1)) {
+            return false;
+        }
+
+        const cursorType = this._sock.rQshift8();
+
+        this._sock.rQshift8(); //Padding
+
+        let rgba;
+        const bytesPerPixel = 4;
+
+        //Classic cursor
+        if (cursorType == 0) {
+            //Used to filter away unimportant bits.
+            //OR is used for correct conversion in js.
+            const PIXEL_MASK = 0xffffff00 | 0;
+            rgba = new Array(w * h * bytesPerPixel);
+
+            if (this._sock.rQwait("VMware cursor classic encoding",
+                                  (w * h * bytesPerPixel) * 2, 2)) {
+                return false;
+            }
+
+            let andMask = new Array(w * h);
+            for (let pixel = 0; pixel < (w * h); pixel++) {
+                andMask[pixel] = this._sock.rQshift32();
+            }
+
+            let xorMask = new Array(w * h);
+            for (let pixel = 0; pixel < (w * h); pixel++) {
+                xorMask[pixel] = this._sock.rQshift32();
+            }
+
+            for (let pixel = 0; pixel < (w * h); pixel++) {
+                if (andMask[pixel] == 0) {
+                    //Fully opaque pixel
+                    let bgr = xorMask[pixel];
+                    let r   = bgr >> 8  & 0xff;
+                    let g   = bgr >> 16 & 0xff;
+                    let b   = bgr >> 24 & 0xff;
+
+                    rgba[(pixel * bytesPerPixel)     ] = r;    //r
+                    rgba[(pixel * bytesPerPixel) + 1 ] = g;    //g
+                    rgba[(pixel * bytesPerPixel) + 2 ] = b;    //b
+                    rgba[(pixel * bytesPerPixel) + 3 ] = 0xff; //a
+
+                } else if ((andMask[pixel] & PIXEL_MASK) ==
+                           PIXEL_MASK) {
+                    //Only screen value matters, no mouse colouring
+                    if (xorMask[pixel] == 0) {
+                        //Transparent pixel
+                        rgba[(pixel * bytesPerPixel)     ] = 0x00;
+                        rgba[(pixel * bytesPerPixel) + 1 ] = 0x00;
+                        rgba[(pixel * bytesPerPixel) + 2 ] = 0x00;
+                        rgba[(pixel * bytesPerPixel) + 3 ] = 0x00;
+
+                    } else if ((xorMask[pixel] & PIXEL_MASK) ==
+                               PIXEL_MASK) {
+                        //Inverted pixel, not supported in browsers.
+                        //Fully opaque instead.
+                        rgba[(pixel * bytesPerPixel)     ] = 0x00;
+                        rgba[(pixel * bytesPerPixel) + 1 ] = 0x00;
+                        rgba[(pixel * bytesPerPixel) + 2 ] = 0x00;
+                        rgba[(pixel * bytesPerPixel) + 3 ] = 0xff;
+
+                    } else {
+                        //Unhandled xorMask
+                        rgba[(pixel * bytesPerPixel)     ] = 0x00;
+                        rgba[(pixel * bytesPerPixel) + 1 ] = 0x00;
+                        rgba[(pixel * bytesPerPixel) + 2 ] = 0x00;
+                        rgba[(pixel * bytesPerPixel) + 3 ] = 0xff;
+                    }
+
+                } else {
+                    //Unhandled andMask
+                    rgba[(pixel * bytesPerPixel)     ] = 0x00;
+                    rgba[(pixel * bytesPerPixel) + 1 ] = 0x00;
+                    rgba[(pixel * bytesPerPixel) + 2 ] = 0x00;
+                    rgba[(pixel * bytesPerPixel) + 3 ] = 0xff;
+                }
+            }
+
+        //Alpha cursor.
+        } else if (cursorType == 1) {
+            if (this._sock.rQwait("VMware cursor alpha encoding",
+                                  (w * h * 4), 2)) {
+                return false;
+            }
+
+            rgba = new Array(w * h * bytesPerPixel);
+
+            for (let pixel = 0; pixel < (w * h); pixel++) {
+                let data = this._sock.rQshift32();
+
+                rgba[(pixel * 4)     ] = data >> 24 & 0xff; //r
+                rgba[(pixel * 4) + 1 ] = data >> 16 & 0xff; //g
+                rgba[(pixel * 4) + 2 ] = data >> 8 & 0xff;  //b
+                rgba[(pixel * 4) + 3 ] = data & 0xff;       //a
+            }
+
+        } else {
+            Log.Warn("The given cursor type is not supported: "
+                      + cursorType + " given.");
+            return false;
+        }
+
+        this._updateCursor(rgba, hotx, hoty, w, h);
+
+        return true;
+    }
+
+    _handleCursor() {
+        const hotx = this._FBU.x;  // hotspot-x
+        const hoty = this._FBU.y;  // hotspot-y
+        const w = this._FBU.width;
+        const h = this._FBU.height;
+
+        const pixelslength = w * h * 4;
+        const masklength = Math.ceil(w / 8) * h;
+
+        let bytes = pixelslength + masklength;
+        if (this._sock.rQwait("cursor encoding", bytes)) {
+            return false;
+        }
+
+        // Decode from BGRX pixels + bit mask to RGBA
+        const pixels = this._sock.rQshiftBytes(pixelslength);
+        const mask = this._sock.rQshiftBytes(masklength);
+        let rgba = new Uint8Array(w * h * 4);
+
+        let pixIdx = 0;
+        for (let y = 0; y < h; y++) {
+            for (let x = 0; x < w; x++) {
+                let maskIdx = y * Math.ceil(w / 8) + Math.floor(x / 8);
+                let alpha = (mask[maskIdx] << (x % 8)) & 0x80 ? 255 : 0;
+                rgba[pixIdx    ] = pixels[pixIdx + 2];
+                rgba[pixIdx + 1] = pixels[pixIdx + 1];
+                rgba[pixIdx + 2] = pixels[pixIdx];
+                rgba[pixIdx + 3] = alpha;
+                pixIdx += 4;
+            }
+        }
+
+        this._updateCursor(rgba, hotx, hoty, w, h);
+
+        return true;
+    }
+
+    _handleDesktopName() {
+        if (this._sock.rQwait("DesktopName", 4)) {
+            return false;
+        }
+
+        let length = this._sock.rQshift32();
+
+        if (this._sock.rQwait("DesktopName", length, 4)) {
+            return false;
+        }
+
+        let name = this._sock.rQshiftStr(length);
+        name = decodeUTF8(name, true);
+
+        this._setDesktopName(name);
+
+        return true;
+    }
+
+    _handleExtendedDesktopSize() {
+        if (this._sock.rQwait("ExtendedDesktopSize", 4)) {
+            return false;
+        }
+
+        const numberOfScreens = this._sock.rQpeek8();
+
+        let bytes = 4 + (numberOfScreens * 16);
+        if (this._sock.rQwait("ExtendedDesktopSize", bytes)) {
+            return false;
+        }
+
+        const firstUpdate = !this._supportsSetDesktopSize;
+        this._supportsSetDesktopSize = true;
+
+        // Normally we only apply the current resize mode after a
+        // window resize event. However there is no such trigger on the
+        // initial connect. And we don't know if the server supports
+        // resizing until we've gotten here.
+        if (firstUpdate) {
+            this._requestRemoteResize();
+        }
+
+        this._sock.rQskipBytes(1);  // number-of-screens
+        this._sock.rQskipBytes(3);  // padding
+
+        for (let i = 0; i < numberOfScreens; i += 1) {
+            // Save the id and flags of the first screen
+            if (i === 0) {
+                this._screenID = this._sock.rQshiftBytes(4);    // id
+                this._sock.rQskipBytes(2);                       // x-position
+                this._sock.rQskipBytes(2);                       // y-position
+                this._sock.rQskipBytes(2);                       // width
+                this._sock.rQskipBytes(2);                       // height
+                this._screenFlags = this._sock.rQshiftBytes(4); // flags
+            } else {
+                this._sock.rQskipBytes(16);
+            }
+        }
+
+        /*
+         * The x-position indicates the reason for the change:
+         *
+         *  0 - server resized on its own
+         *  1 - this client requested the resize
+         *  2 - another client requested the resize
+         */
+
+        // We need to handle errors when we requested the resize.
+        if (this._FBU.x === 1 && this._FBU.y !== 0) {
+            let msg = "";
+            // The y-position indicates the status code from the server
+            switch (this._FBU.y) {
+                case 1:
+                    msg = "Resize is administratively prohibited";
+                    break;
+                case 2:
+                    msg = "Out of resources";
+                    break;
+                case 3:
+                    msg = "Invalid screen layout";
+                    break;
+                default:
+                    msg = "Unknown reason";
+                    break;
+            }
+            Log.Warn("Server did not accept the resize request: "
+                     + msg);
+        } else {
+            this._resize(this._FBU.width, this._FBU.height);
+        }
+
+        return true;
+    }
+
+    _handleDataRect() {
+        let decoder = this._decoders[this._FBU.encoding];
+        if (!decoder) {
+            this._fail("Unsupported encoding (encoding: " +
+                       this._FBU.encoding + ")");
+            return false;
+        }
+
+        try {
+            return decoder.decodeRect(this._FBU.x, this._FBU.y,
+                                      this._FBU.width, this._FBU.height,
+                                      this._sock, this._display,
+                                      this._fbDepth);
+        } catch (err) {
+            this._fail("Error decoding rect: " + err);
+            return false;
+        }
+    }
+
+    _updateContinuousUpdates() {
+        if (!this._enabledContinuousUpdates) { return; }
+
+        RFB.messages.enableContinuousUpdates(this._sock, true, 0, 0,
+                                             this._fbWidth, this._fbHeight);
+    }
+
+    _resize(width, height) {
+        this._fbWidth = width;
+        this._fbHeight = height;
+
+        this._display.resize(this._fbWidth, this._fbHeight);
+
+        // Adjust the visible viewport based on the new dimensions
+        this._updateClip();
+        this._updateScale();
+
+        this._updateContinuousUpdates();
+
+        // Keep this size until browser client size changes
+        this._saveExpectedClientSize();
+    }
+
+    _xvpOp(ver, op) {
+        if (this._rfbXvpVer < ver) { return; }
+        Log.Info("Sending XVP operation " + op + " (version " + ver + ")");
+        RFB.messages.xvpOp(this._sock, ver, op);
+    }
+
+    _updateCursor(rgba, hotx, hoty, w, h) {
+        this._cursorImage = {
+            rgbaPixels: rgba,
+            hotx: hotx, hoty: hoty, w: w, h: h,
+        };
+        this._refreshCursor();
+    }
+
+    _shouldShowDotCursor() {
+        // Called when this._cursorImage is updated
+        if (!this._showDotCursor) {
+            // User does not want to see the dot, so...
+            return false;
+        }
+
+        // The dot should not be shown if the cursor is already visible,
+        // i.e. contains at least one not-fully-transparent pixel.
+        // So iterate through all alpha bytes in rgba and stop at the
+        // first non-zero.
+        for (let i = 3; i < this._cursorImage.rgbaPixels.length; i += 4) {
+            if (this._cursorImage.rgbaPixels[i]) {
+                return false;
+            }
+        }
+
+        // At this point, we know that the cursor is fully transparent, and
+        // the user wants to see the dot instead of this.
+        return true;
+    }
+
+    _refreshCursor() {
+        if (this._rfbConnectionState !== "connecting" &&
+            this._rfbConnectionState !== "connected") {
+            return;
+        }
+        const image = this._shouldShowDotCursor() ? RFB.cursors.dot : this._cursorImage;
+        this._cursor.change(image.rgbaPixels,
+                            image.hotx, image.hoty,
+                            image.w, image.h
+        );
+    }
+
+    static genDES(password, challenge) {
+        const passwordChars = password.split('').map(c => c.charCodeAt(0));
+        return (new DES(passwordChars)).encrypt(challenge);
+    }
+}
+
+// Class Methods
+RFB.messages = {
+    keyEvent(sock, keysym, down) {
+        const buff = sock._sQ;
+        const offset = sock._sQlen;
+
+        buff[offset] = 4;  // msg-type
+        buff[offset + 1] = down;
+
+        buff[offset + 2] = 0;
+        buff[offset + 3] = 0;
+
+        buff[offset + 4] = (keysym >> 24);
+        buff[offset + 5] = (keysym >> 16);
+        buff[offset + 6] = (keysym >> 8);
+        buff[offset + 7] = keysym;
+
+        sock._sQlen += 8;
+        sock.flush();
+    },
+
+    QEMUExtendedKeyEvent(sock, keysym, down, keycode) {
+        function getRFBkeycode(xtScanCode) {
+            const upperByte = (keycode >> 8);
+            const lowerByte = (keycode & 0x00ff);
+            if (upperByte === 0xe0 && lowerByte < 0x7f) {
+                return lowerByte | 0x80;
+            }
+            return xtScanCode;
+        }
+
+        const buff = sock._sQ;
+        const offset = sock._sQlen;
+
+        buff[offset] = 255; // msg-type
+        buff[offset + 1] = 0; // sub msg-type
+
+        buff[offset + 2] = (down >> 8);
+        buff[offset + 3] = down;
+
+        buff[offset + 4] = (keysym >> 24);
+        buff[offset + 5] = (keysym >> 16);
+        buff[offset + 6] = (keysym >> 8);
+        buff[offset + 7] = keysym;
+
+        const RFBkeycode = getRFBkeycode(keycode);
+
+        buff[offset + 8] = (RFBkeycode >> 24);
+        buff[offset + 9] = (RFBkeycode >> 16);
+        buff[offset + 10] = (RFBkeycode >> 8);
+        buff[offset + 11] = RFBkeycode;
+
+        sock._sQlen += 12;
+        sock.flush();
+    },
+
+    pointerEvent(sock, x, y, mask) {
+        const buff = sock._sQ;
+        const offset = sock._sQlen;
+
+        buff[offset] = 5; // msg-type
+
+        buff[offset + 1] = mask;
+
+        buff[offset + 2] = x >> 8;
+        buff[offset + 3] = x;
+
+        buff[offset + 4] = y >> 8;
+        buff[offset + 5] = y;
+
+        sock._sQlen += 6;
+        sock.flush();
+    },
+
+    // Used to build Notify and Request data.
+    _buildExtendedClipboardFlags(actions, formats) {
+        let data = new Uint8Array(4);
+        let formatFlag = 0x00000000;
+        let actionFlag = 0x00000000;
+
+        for (let i = 0; i < actions.length; i++) {
+            actionFlag |= actions[i];
+        }
+
+        for (let i = 0; i < formats.length; i++) {
+            formatFlag |= formats[i];
+        }
+
+        data[0] = actionFlag >> 24; // Actions
+        data[1] = 0x00;             // Reserved
+        data[2] = 0x00;             // Reserved
+        data[3] = formatFlag;       // Formats
+
+        return data;
+    },
+
+    extendedClipboardProvide(sock, formats, inData) {
+        // Deflate incomming data and their sizes
+        let deflator = new Deflator();
+        let dataToDeflate = [];
+
+        for (let i = 0; i < formats.length; i++) {
+            // We only support the format Text at this time
+            if (formats[i] != extendedClipboardFormatText) {
+                throw new Error("Unsupported extended clipboard format for Provide message.");
+            }
+
+            // Change lone \r or \n into \r\n as defined in rfbproto
+            inData[i] = inData[i].replace(/\r\n|\r|\n/gm, "\r\n");
+
+            // Check if it already has \0
+            let text = encodeUTF8(inData[i] + "\0");
+
+            dataToDeflate.push( (text.length >> 24) & 0xFF,
+                                (text.length >> 16) & 0xFF,
+                                (text.length >>  8) & 0xFF,
+                                (text.length & 0xFF));
+
+            for (let j = 0; j < text.length; j++) {
+                dataToDeflate.push(text.charCodeAt(j));
+            }
+        }
+
+        let deflatedData = deflator.deflate(new Uint8Array(dataToDeflate));
+
+        // Build data  to send
+        let data = new Uint8Array(4 + deflatedData.length);
+        data.set(RFB.messages._buildExtendedClipboardFlags([extendedClipboardActionProvide],
+                                                           formats));
+        data.set(deflatedData, 4);
+
+        RFB.messages.clientCutText(sock, data, true);
+    },
+
+    extendedClipboardNotify(sock, formats) {
+        let flags = RFB.messages._buildExtendedClipboardFlags([extendedClipboardActionNotify],
+                                                              formats);
+        RFB.messages.clientCutText(sock, flags, true);
+    },
+
+    extendedClipboardRequest(sock, formats) {
+        let flags = RFB.messages._buildExtendedClipboardFlags([extendedClipboardActionRequest],
+                                                              formats);
+        RFB.messages.clientCutText(sock, flags, true);
+    },
+
+    extendedClipboardCaps(sock, actions, formats) {
+        let formatKeys = Object.keys(formats);
+        let data  = new Uint8Array(4 + (4 * formatKeys.length));
+
+        formatKeys.map(x => parseInt(x));
+        formatKeys.sort((a, b) =>  a - b);
+
+        data.set(RFB.messages._buildExtendedClipboardFlags(actions, []));
+
+        let loopOffset = 4;
+        for (let i = 0; i < formatKeys.length; i++) {
+            data[loopOffset]     = formats[formatKeys[i]] >> 24;
+            data[loopOffset + 1] = formats[formatKeys[i]] >> 16;
+            data[loopOffset + 2] = formats[formatKeys[i]] >> 8;
+            data[loopOffset + 3] = formats[formatKeys[i]] >> 0;
+
+            loopOffset += 4;
+            data[3] |= (1 << formatKeys[i]); // Update our format flags
+        }
+
+        RFB.messages.clientCutText(sock, data, true);
+    },
+
+    clientCutText(sock, data, extended = false) {
+        const buff = sock._sQ;
+        const offset = sock._sQlen;
+
+        buff[offset] = 6; // msg-type
+
+        buff[offset + 1] = 0; // padding
+        buff[offset + 2] = 0; // padding
+        buff[offset + 3] = 0; // padding
+
+        let length;
+        if (extended) {
+            length = toUnsigned32bit(-data.length);
+        } else {
+            length = data.length;
+        }
+
+        buff[offset + 4] = length >> 24;
+        buff[offset + 5] = length >> 16;
+        buff[offset + 6] = length >> 8;
+        buff[offset + 7] = length;
+
+        sock._sQlen += 8;
+
+        // We have to keep track of from where in the data we begin creating the
+        // buffer for the flush in the next iteration.
+        let dataOffset = 0;
+
+        let remaining = data.length;
+        while (remaining > 0) {
+
+            let flushSize = Math.min(remaining, (sock._sQbufferSize - sock._sQlen));
+            for (let i = 0; i < flushSize; i++) {
+                buff[sock._sQlen + i] = data[dataOffset + i];
+            }
+
+            sock._sQlen += flushSize;
+            sock.flush();
+
+            remaining -= flushSize;
+            dataOffset += flushSize;
+        }
+
+    },
+
+    setDesktopSize(sock, width, height, id, flags) {
+        const buff = sock._sQ;
+        const offset = sock._sQlen;
+
+        buff[offset] = 251;              // msg-type
+        buff[offset + 1] = 0;            // padding
+        buff[offset + 2] = width >> 8;   // width
+        buff[offset + 3] = width;
+        buff[offset + 4] = height >> 8;  // height
+        buff[offset + 5] = height;
+
+        buff[offset + 6] = 1;            // number-of-screens
+        buff[offset + 7] = 0;            // padding
+
+        // screen array
+        buff[offset + 8] = id >> 24;     // id
+        buff[offset + 9] = id >> 16;
+        buff[offset + 10] = id >> 8;
+        buff[offset + 11] = id;
+        buff[offset + 12] = 0;           // x-position
+        buff[offset + 13] = 0;
+        buff[offset + 14] = 0;           // y-position
+        buff[offset + 15] = 0;
+        buff[offset + 16] = width >> 8;  // width
+        buff[offset + 17] = width;
+        buff[offset + 18] = height >> 8; // height
+        buff[offset + 19] = height;
+        buff[offset + 20] = flags >> 24; // flags
+        buff[offset + 21] = flags >> 16;
+        buff[offset + 22] = flags >> 8;
+        buff[offset + 23] = flags;
+
+        sock._sQlen += 24;
+        sock.flush();
+    },
+
+    clientFence(sock, flags, payload) {
+        const buff = sock._sQ;
+        const offset = sock._sQlen;
+
+        buff[offset] = 248; // msg-type
+
+        buff[offset + 1] = 0; // padding
+        buff[offset + 2] = 0; // padding
+        buff[offset + 3] = 0; // padding
+
+        buff[offset + 4] = flags >> 24; // flags
+        buff[offset + 5] = flags >> 16;
+        buff[offset + 6] = flags >> 8;
+        buff[offset + 7] = flags;
+
+        const n = payload.length;
+
+        buff[offset + 8] = n; // length
+
+        for (let i = 0; i < n; i++) {
+            buff[offset + 9 + i] = payload.charCodeAt(i);
+        }
+
+        sock._sQlen += 9 + n;
+        sock.flush();
+    },
+
+    enableContinuousUpdates(sock, enable, x, y, width, height) {
+        const buff = sock._sQ;
+        const offset = sock._sQlen;
+
+        buff[offset] = 150;             // msg-type
+        buff[offset + 1] = enable;      // enable-flag
+
+        buff[offset + 2] = x >> 8;      // x
+        buff[offset + 3] = x;
+        buff[offset + 4] = y >> 8;      // y
+        buff[offset + 5] = y;
+        buff[offset + 6] = width >> 8;  // width
+        buff[offset + 7] = width;
+        buff[offset + 8] = height >> 8; // height
+        buff[offset + 9] = height;
+
+        sock._sQlen += 10;
+        sock.flush();
+    },
+
+    pixelFormat(sock, depth, trueColor) {
+        const buff = sock._sQ;
+        const offset = sock._sQlen;
+
+        let bpp;
+
+        if (depth > 16) {
+            bpp = 32;
+        } else if (depth > 8) {
+            bpp = 16;
+        } else {
+            bpp = 8;
+        }
+
+        const bits = Math.floor(depth/3);
+
+        buff[offset] = 0;  // msg-type
+
+        buff[offset + 1] = 0; // padding
+        buff[offset + 2] = 0; // padding
+        buff[offset + 3] = 0; // padding
+
+        buff[offset + 4] = bpp;                 // bits-per-pixel
+        buff[offset + 5] = depth;               // depth
+        buff[offset + 6] = 0;                   // little-endian
+        buff[offset + 7] = trueColor ? 1 : 0;  // true-color
+
+        buff[offset + 8] = 0;    // red-max
+        buff[offset + 9] = (1 << bits) - 1;  // red-max
+
+        buff[offset + 10] = 0;   // green-max
+        buff[offset + 11] = (1 << bits) - 1; // green-max
+
+        buff[offset + 12] = 0;   // blue-max
+        buff[offset + 13] = (1 << bits) - 1; // blue-max
+
+        buff[offset + 14] = bits * 0; // red-shift
+        buff[offset + 15] = bits * 1; // green-shift
+        buff[offset + 16] = bits * 2; // blue-shift
+
+        buff[offset + 17] = 0;   // padding
+        buff[offset + 18] = 0;   // padding
+        buff[offset + 19] = 0;   // padding
+
+        sock._sQlen += 20;
+        sock.flush();
+    },
+
+    clientEncodings(sock, encodings) {
+        const buff = sock._sQ;
+        const offset = sock._sQlen;
+
+        buff[offset] = 2; // msg-type
+        buff[offset + 1] = 0; // padding
+
+        buff[offset + 2] = encodings.length >> 8;
+        buff[offset + 3] = encodings.length;
+
+        let j = offset + 4;
+        for (let i = 0; i < encodings.length; i++) {
+            const enc = encodings[i];
+            buff[j] = enc >> 24;
+            buff[j + 1] = enc >> 16;
+            buff[j + 2] = enc >> 8;
+            buff[j + 3] = enc;
+
+            j += 4;
+        }
+
+        sock._sQlen += j - offset;
+        sock.flush();
+    },
+
+    fbUpdateRequest(sock, incremental, x, y, w, h) {
+        const buff = sock._sQ;
+        const offset = sock._sQlen;
+
+        if (typeof(x) === "undefined") { x = 0; }
+        if (typeof(y) === "undefined") { y = 0; }
+
+        buff[offset] = 3;  // msg-type
+        buff[offset + 1] = incremental ? 1 : 0;
+
+        buff[offset + 2] = (x >> 8) & 0xFF;
+        buff[offset + 3] = x & 0xFF;
+
+        buff[offset + 4] = (y >> 8) & 0xFF;
+        buff[offset + 5] = y & 0xFF;
+
+        buff[offset + 6] = (w >> 8) & 0xFF;
+        buff[offset + 7] = w & 0xFF;
+
+        buff[offset + 8] = (h >> 8) & 0xFF;
+        buff[offset + 9] = h & 0xFF;
+
+        sock._sQlen += 10;
+        sock.flush();
+    },
+
+    xvpOp(sock, ver, op) {
+        const buff = sock._sQ;
+        const offset = sock._sQlen;
+
+        buff[offset] = 250; // msg-type
+        buff[offset + 1] = 0; // padding
+
+        buff[offset + 2] = ver;
+        buff[offset + 3] = op;
+
+        sock._sQlen += 4;
+        sock.flush();
+    }
+};
+
+RFB.cursors = {
+    none: {
+        rgbaPixels: new Uint8Array(),
+        w: 0, h: 0,
+        hotx: 0, hoty: 0,
+    },
+
+    dot: {
+        /* eslint-disable indent */
+        rgbaPixels: new Uint8Array([
+            255, 255, 255, 255,   0,   0,   0, 255, 255, 255, 255, 255,
+              0,   0,   0, 255,   0,   0,   0,   0,   0,   0,  0,  255,
+            255, 255, 255, 255,   0,   0,   0, 255, 255, 255, 255, 255,
+        ]),
+        /* eslint-enable indent */
+        w: 3, h: 3,
+        hotx: 1, hoty: 1,
+    }
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/util/browser.js
@@ -0,0 +1,103 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ *
+ * Browser feature support detection
+ */
+
+import * as Log from './logging.js';
+
+// Touch detection
+export let isTouchDevice = ('ontouchstart' in document.documentElement) ||
+                                 // requried for Chrome debugger
+                                 (document.ontouchstart !== undefined) ||
+                                 // required for MS Surface
+                                 (navigator.maxTouchPoints > 0) ||
+                                 (navigator.msMaxTouchPoints > 0);
+window.addEventListener('touchstart', function onFirstTouch() {
+    isTouchDevice = true;
+    window.removeEventListener('touchstart', onFirstTouch, false);
+}, false);
+
+
+// The goal is to find a certain physical width, the devicePixelRatio
+// brings us a bit closer but is not optimal.
+export let dragThreshold = 10 * (window.devicePixelRatio || 1);
+
+let _supportsCursorURIs = false;
+
+try {
+    const target = document.createElement('canvas');
+    target.style.cursor = 'url("data:image/x-icon;base64,AAACAAEACAgAAAIAAgA4AQAAFgAAACgAAAAIAAAAEAAAAAEAIAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAAAAAAAAAAAAAAAA==") 2 2, default';
+
+    if (target.style.cursor.indexOf("url") === 0) {
+        Log.Info("Data URI scheme cursor supported");
+        _supportsCursorURIs = true;
+    } else {
+        Log.Warn("Data URI scheme cursor not supported");
+    }
+} catch (exc) {
+    Log.Error("Data URI scheme cursor test exception: " + exc);
+}
+
+export const supportsCursorURIs = _supportsCursorURIs;
+
+let _hasScrollbarGutter = true;
+try {
+    // Create invisible container
+    const container = document.createElement('div');
+    container.style.visibility = 'hidden';
+    container.style.overflow = 'scroll'; // forcing scrollbars
+    document.body.appendChild(container);
+
+    // Create a div and place it in the container
+    const child = document.createElement('div');
+    container.appendChild(child);
+
+    // Calculate the difference between the container's full width
+    // and the child's width - the difference is the scrollbars
+    const scrollbarWidth = (container.offsetWidth - child.offsetWidth);
+
+    // Clean up
+    container.parentNode.removeChild(container);
+
+    _hasScrollbarGutter = scrollbarWidth != 0;
+} catch (exc) {
+    Log.Error("Scrollbar test exception: " + exc);
+}
+export const hasScrollbarGutter = _hasScrollbarGutter;
+
+/*
+ * The functions for detection of platforms and browsers below are exported
+ * but the use of these should be minimized as much as possible.
+ *
+ * It's better to use feature detection than platform detection.
+ */
+
+export function isMac() {
+    return navigator && !!(/mac/i).exec(navigator.platform);
+}
+
+export function isWindows() {
+    return navigator && !!(/win/i).exec(navigator.platform);
+}
+
+export function isIOS() {
+    return navigator &&
+           (!!(/ipad/i).exec(navigator.platform) ||
+            !!(/iphone/i).exec(navigator.platform) ||
+            !!(/ipod/i).exec(navigator.platform));
+}
+
+export function isSafari() {
+    return navigator && (navigator.userAgent.indexOf('Safari') !== -1 &&
+                         navigator.userAgent.indexOf('Chrome') === -1);
+}
+
+export function isFirefox() {
+    return navigator && !!(/firefox/i).exec(navigator.userAgent);
+}
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/util/cursor.js
@@ -0,0 +1,243 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 or any later version (see LICENSE.txt)
+ */
+
+import { supportsCursorURIs, isTouchDevice } from './browser.js';
+
+const useFallback = !supportsCursorURIs || isTouchDevice;
+
+export default class Cursor {
+    constructor() {
+        this._target = null;
+
+        this._canvas = document.createElement('canvas');
+
+        if (useFallback) {
+            this._canvas.style.position = 'fixed';
+            this._canvas.style.zIndex = '65535';
+            this._canvas.style.pointerEvents = 'none';
+            // Can't use "display" because of Firefox bug #1445997
+            this._canvas.style.visibility = 'hidden';
+        }
+
+        this._position = { x: 0, y: 0 };
+        this._hotSpot = { x: 0, y: 0 };
+
+        this._eventHandlers = {
+            'mouseover': this._handleMouseOver.bind(this),
+            'mouseleave': this._handleMouseLeave.bind(this),
+            'mousemove': this._handleMouseMove.bind(this),
+            'mouseup': this._handleMouseUp.bind(this),
+        };
+    }
+
+    attach(target) {
+        if (this._target) {
+            this.detach();
+        }
+
+        this._target = target;
+
+        if (useFallback) {
+            document.body.appendChild(this._canvas);
+
+            const options = { capture: true, passive: true };
+            this._target.addEventListener('mouseover', this._eventHandlers.mouseover, options);
+            this._target.addEventListener('mouseleave', this._eventHandlers.mouseleave, options);
+            this._target.addEventListener('mousemove', this._eventHandlers.mousemove, options);
+            this._target.addEventListener('mouseup', this._eventHandlers.mouseup, options);
+        }
+
+        this.clear();
+    }
+
+    detach() {
+        if (!this._target) {
+            return;
+        }
+
+        if (useFallback) {
+            const options = { capture: true, passive: true };
+            this._target.removeEventListener('mouseover', this._eventHandlers.mouseover, options);
+            this._target.removeEventListener('mouseleave', this._eventHandlers.mouseleave, options);
+            this._target.removeEventListener('mousemove', this._eventHandlers.mousemove, options);
+            this._target.removeEventListener('mouseup', this._eventHandlers.mouseup, options);
+
+            document.body.removeChild(this._canvas);
+        }
+
+        this._target = null;
+    }
+
+    change(rgba, hotx, hoty, w, h) {
+        if ((w === 0) || (h === 0)) {
+            this.clear();
+            return;
+        }
+
+        this._position.x = this._position.x + this._hotSpot.x - hotx;
+        this._position.y = this._position.y + this._hotSpot.y - hoty;
+        this._hotSpot.x = hotx;
+        this._hotSpot.y = hoty;
+
+        let ctx = this._canvas.getContext('2d');
+
+        this._canvas.width = w;
+        this._canvas.height = h;
+
+        let img = new ImageData(new Uint8ClampedArray(rgba), w, h);
+        ctx.clearRect(0, 0, w, h);
+        ctx.putImageData(img, 0, 0);
+
+        if (useFallback) {
+            this._updatePosition();
+        } else {
+            let url = this._canvas.toDataURL();
+            this._target.style.cursor = 'url(' + url + ')' + hotx + ' ' + hoty + ', default';
+        }
+    }
+
+    clear() {
+        this._target.style.cursor = 'none';
+        this._canvas.width = 0;
+        this._canvas.height = 0;
+        this._position.x = this._position.x + this._hotSpot.x;
+        this._position.y = this._position.y + this._hotSpot.y;
+        this._hotSpot.x = 0;
+        this._hotSpot.y = 0;
+    }
+
+    // Mouse events might be emulated, this allows
+    // moving the cursor in such cases
+    move(clientX, clientY) {
+        if (!useFallback) {
+            return;
+        }
+        // clientX/clientY are relative the _visual viewport_,
+        // but our position is relative the _layout viewport_,
+        // so try to compensate when we can
+        if (window.visualViewport) {
+            this._position.x = clientX + window.visualViewport.offsetLeft;
+            this._position.y = clientY + window.visualViewport.offsetTop;
+        } else {
+            this._position.x = clientX;
+            this._position.y = clientY;
+        }
+        this._updatePosition();
+        let target = document.elementFromPoint(clientX, clientY);
+        this._updateVisibility(target);
+    }
+
+    _handleMouseOver(event) {
+        // This event could be because we're entering the target, or
+        // moving around amongst its sub elements. Let the move handler
+        // sort things out.
+        this._handleMouseMove(event);
+    }
+
+    _handleMouseLeave(event) {
+        // Check if we should show the cursor on the element we are leaving to
+        this._updateVisibility(event.relatedTarget);
+    }
+
+    _handleMouseMove(event) {
+        this._updateVisibility(event.target);
+
+        this._position.x = event.clientX - this._hotSpot.x;
+        this._position.y = event.clientY - this._hotSpot.y;
+
+        this._updatePosition();
+    }
+
+    _handleMouseUp(event) {
+        // We might get this event because of a drag operation that
+        // moved outside of the target. Check what's under the cursor
+        // now and adjust visibility based on that.
+        let target = document.elementFromPoint(event.clientX, event.clientY);
+        this._updateVisibility(target);
+
+        // Captures end with a mouseup but we can't know the event order of
+        // mouseup vs releaseCapture.
+        //
+        // In the cases when releaseCapture comes first, the code above is
+        // enough.
+        //
+        // In the cases when the mouseup comes first, we need wait for the
+        // browser to flush all events and then check again if the cursor
+        // should be visible.
+        if (this._captureIsActive()) {
+            window.setTimeout(() => {
+                // We might have detached at this point
+                if (!this._target) {
+                    return;
+                }
+                // Refresh the target from elementFromPoint since queued events
+                // might have altered the DOM
+                target = document.elementFromPoint(event.clientX,
+                                                   event.clientY);
+                this._updateVisibility(target);
+            }, 0);
+        }
+    }
+
+    _showCursor() {
+        if (this._canvas.style.visibility === 'hidden') {
+            this._canvas.style.visibility = '';
+        }
+    }
+
+    _hideCursor() {
+        if (this._canvas.style.visibility !== 'hidden') {
+            this._canvas.style.visibility = 'hidden';
+        }
+    }
+
+    // Should we currently display the cursor?
+    // (i.e. are we over the target, or a child of the target without a
+    // different cursor set)
+    _shouldShowCursor(target) {
+        if (!target) {
+            return false;
+        }
+        // Easy case
+        if (target === this._target) {
+            return true;
+        }
+        // Other part of the DOM?
+        if (!this._target.contains(target)) {
+            return false;
+        }
+        // Has the child its own cursor?
+        // FIXME: How can we tell that a sub element has an
+        //        explicit "cursor: none;"?
+        if (window.getComputedStyle(target).cursor !== 'none') {
+            return false;
+        }
+        return true;
+    }
+
+    _updateVisibility(target) {
+        // When the cursor target has capture we want to show the cursor.
+        // So, if a capture is active - look at the captured element instead.
+        if (this._captureIsActive()) {
+            target = document.captureElement;
+        }
+        if (this._shouldShowCursor(target)) {
+            this._showCursor();
+        } else {
+            this._hideCursor();
+        }
+    }
+
+    _updatePosition() {
+        this._canvas.style.left = this._position.x + "px";
+        this._canvas.style.top = this._position.y + "px";
+    }
+
+    _captureIsActive() {
+        return document.captureElement &&
+            document.documentElement.contains(document.captureElement);
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/util/element.js
@@ -0,0 +1,32 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2020 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+/*
+ * HTML element utility functions
+ */
+
+export function clientToElement(x, y, elem) {
+    const bounds = elem.getBoundingClientRect();
+    let pos = { x: 0, y: 0 };
+    // Clip to target bounds
+    if (x < bounds.left) {
+        pos.x = 0;
+    } else if (x >= bounds.right) {
+        pos.x = bounds.width - 1;
+    } else {
+        pos.x = x - bounds.left;
+    }
+    if (y < bounds.top) {
+        pos.y = 0;
+    } else if (y >= bounds.bottom) {
+        pos.y = bounds.height - 1;
+    } else {
+        pos.y = y - bounds.top;
+    }
+    return pos;
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/util/events.js
@@ -0,0 +1,138 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2018 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+/*
+ * Cross-browser event and position routines
+ */
+
+export function getPointerEvent(e) {
+    return e.changedTouches ? e.changedTouches[0] : e.touches ? e.touches[0] : e;
+}
+
+export function stopEvent(e) {
+    e.stopPropagation();
+    e.preventDefault();
+}
+
+// Emulate Element.setCapture() when not supported
+let _captureRecursion = false;
+let _elementForUnflushedEvents = null;
+document.captureElement = null;
+function _captureProxy(e) {
+    // Recursion protection as we'll see our own event
+    if (_captureRecursion) return;
+
+    // Clone the event as we cannot dispatch an already dispatched event
+    const newEv = new e.constructor(e.type, e);
+
+    _captureRecursion = true;
+    if (document.captureElement) {
+        document.captureElement.dispatchEvent(newEv);
+    } else {
+        _elementForUnflushedEvents.dispatchEvent(newEv);
+    }
+    _captureRecursion = false;
+
+    // Avoid double events
+    e.stopPropagation();
+
+    // Respect the wishes of the redirected event handlers
+    if (newEv.defaultPrevented) {
+        e.preventDefault();
+    }
+
+    // Implicitly release the capture on button release
+    if (e.type === "mouseup") {
+        releaseCapture();
+    }
+}
+
+// Follow cursor style of target element
+function _capturedElemChanged() {
+    const proxyElem = document.getElementById("noVNC_mouse_capture_elem");
+    proxyElem.style.cursor = window.getComputedStyle(document.captureElement).cursor;
+}
+
+const _captureObserver = new MutationObserver(_capturedElemChanged);
+
+export function setCapture(target) {
+    if (target.setCapture) {
+
+        target.setCapture();
+        document.captureElement = target;
+    } else {
+        // Release any existing capture in case this method is
+        // called multiple times without coordination
+        releaseCapture();
+
+        let proxyElem = document.getElementById("noVNC_mouse_capture_elem");
+
+        if (proxyElem === null) {
+            proxyElem = document.createElement("div");
+            proxyElem.id = "noVNC_mouse_capture_elem";
+            proxyElem.style.position = "fixed";
+            proxyElem.style.top = "0px";
+            proxyElem.style.left = "0px";
+            proxyElem.style.width = "100%";
+            proxyElem.style.height = "100%";
+            proxyElem.style.zIndex = 10000;
+            proxyElem.style.display = "none";
+            document.body.appendChild(proxyElem);
+
+            // This is to make sure callers don't get confused by having
+            // our blocking element as the target
+            proxyElem.addEventListener('contextmenu', _captureProxy);
+
+            proxyElem.addEventListener('mousemove', _captureProxy);
+            proxyElem.addEventListener('mouseup', _captureProxy);
+        }
+
+        document.captureElement = target;
+
+        // Track cursor and get initial cursor
+        _captureObserver.observe(target, {attributes: true});
+        _capturedElemChanged();
+
+        proxyElem.style.display = "";
+
+        // We listen to events on window in order to keep tracking if it
+        // happens to leave the viewport
+        window.addEventListener('mousemove', _captureProxy);
+        window.addEventListener('mouseup', _captureProxy);
+    }
+}
+
+export function releaseCapture() {
+    if (document.releaseCapture) {
+
+        document.releaseCapture();
+        document.captureElement = null;
+
+    } else {
+        if (!document.captureElement) {
+            return;
+        }
+
+        // There might be events already queued. The event proxy needs
+        // access to the captured element for these queued events.
+        // E.g. contextmenu (right-click) in Microsoft Edge
+        //
+        // Before removing the capturedElem pointer we save it to a
+        // temporary variable that the unflushed events can use.
+        _elementForUnflushedEvents = document.captureElement;
+        document.captureElement = null;
+
+        _captureObserver.disconnect();
+
+        const proxyElem = document.getElementById("noVNC_mouse_capture_elem");
+        proxyElem.style.display = "none";
+
+        window.removeEventListener('mousemove', _captureProxy);
+        window.removeEventListener('mouseup', _captureProxy);
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/util/eventtarget.js
@@ -0,0 +1,35 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+export default class EventTargetMixin {
+    constructor() {
+        this._listeners = new Map();
+    }
+
+    addEventListener(type, callback) {
+        if (!this._listeners.has(type)) {
+            this._listeners.set(type, new Set());
+        }
+        this._listeners.get(type).add(callback);
+    }
+
+    removeEventListener(type, callback) {
+        if (this._listeners.has(type)) {
+            this._listeners.get(type).delete(callback);
+        }
+    }
+
+    dispatchEvent(event) {
+        if (!this._listeners.has(event.type)) {
+            return true;
+        }
+        this._listeners.get(event.type)
+            .forEach(callback => callback.call(this, event));
+        return !event.defaultPrevented;
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/util/int.js
@@ -0,0 +1,15 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2020 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+export function toUnsigned32bit(toConvert) {
+    return toConvert >>> 0;
+}
+
+export function toSigned32bit(toConvert) {
+    return toConvert | 0;
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/util/logging.js
@@ -0,0 +1,56 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+/*
+ * Logging/debug routines
+ */
+
+let _logLevel = 'warn';
+
+let Debug = () => {};
+let Info = () => {};
+let Warn = () => {};
+let Error = () => {};
+
+export function initLogging(level) {
+    if (typeof level === 'undefined') {
+        level = _logLevel;
+    } else {
+        _logLevel = level;
+    }
+
+    Debug = Info = Warn = Error = () => {};
+
+    if (typeof window.console !== "undefined") {
+        /* eslint-disable no-console, no-fallthrough */
+        switch (level) {
+            case 'debug':
+                Debug = console.debug.bind(window.console);
+            case 'info':
+                Info  = console.info.bind(window.console);
+            case 'warn':
+                Warn  = console.warn.bind(window.console);
+            case 'error':
+                Error = console.error.bind(window.console);
+            case 'none':
+                break;
+            default:
+                throw new window.Error("invalid logging type '" + level + "'");
+        }
+        /* eslint-enable no-console, no-fallthrough */
+    }
+}
+
+export function getLogging() {
+    return _logLevel;
+}
+
+export { Debug, Info, Warn, Error };
+
+// Initialize logging level
+initLogging();
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/util/md5.js
@@ -0,0 +1,79 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2021 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+/*
+ * Performs MD5 hashing on a string of binary characters, returns an array of bytes
+ */
+
+export function MD5(d) {
+    let r = M(V(Y(X(d), 8 * d.length)));
+    return r;
+}
+
+function M(d) {
+    let f = new Uint8Array(d.length);
+    for (let i=0;i<d.length;i++) {
+        f[i] = d.charCodeAt(i);
+    }
+    return f;
+}
+
+function X(d) {
+    let r = Array(d.length >> 2);
+    for (let m = 0; m < r.length; m++) r[m] = 0;
+    for (let m = 0; m < 8 * d.length; m += 8) r[m >> 5] |= (255 & d.charCodeAt(m / 8)) << m % 32;
+    return r;
+}
+
+function V(d) {
+    let r = "";
+    for (let m = 0; m < 32 * d.length; m += 8) r += String.fromCharCode(d[m >> 5] >>> m % 32 & 255);
+    return r;
+}
+
+function Y(d, g) {
+    d[g >> 5] |= 128 << g % 32, d[14 + (g + 64 >>> 9 << 4)] = g;
+    let m = 1732584193, f = -271733879, r = -1732584194, i = 271733878;
+    for (let n = 0; n < d.length; n += 16) {
+        let h = m,
+            t = f,
+            g = r,
+            e = i;
+        f = ii(f = ii(f = ii(f = ii(f = hh(f = hh(f = hh(f = hh(f = gg(f = gg(f = gg(f = gg(f = ff(f = ff(f = ff(f = ff(f, r = ff(r, i = ff(i, m = ff(m, f, r, i, d[n + 0], 7, -680876936), f, r, d[n + 1], 12, -389564586), m, f, d[n + 2], 17, 606105819), i, m, d[n + 3], 22, -1044525330), r = ff(r, i = ff(i, m = ff(m, f, r, i, d[n + 4], 7, -176418897), f, r, d[n + 5], 12, 1200080426), m, f, d[n + 6], 17, -1473231341), i, m, d[n + 7], 22, -45705983), r = ff(r, i = ff(i, m = ff(m, f, r, i, d[n + 8], 7, 1770035416), f, r, d[n + 9], 12, -1958414417), m, f, d[n + 10], 17, -42063), i, m, d[n + 11], 22, -1990404162), r = ff(r, i = ff(i, m = ff(m, f, r, i, d[n + 12], 7, 1804603682), f, r, d[n + 13], 12, -40341101), m, f, d[n + 14], 17, -1502002290), i, m, d[n + 15], 22, 1236535329), r = gg(r, i = gg(i, m = gg(m, f, r, i, d[n + 1], 5, -165796510), f, r, d[n + 6], 9, -1069501632), m, f, d[n + 11], 14, 643717713), i, m, d[n + 0], 20, -373897302), r = gg(r, i = gg(i, m = gg(m, f, r, i, d[n + 5], 5, -701558691), f, r, d[n + 10], 9, 38016083), m, f, d[n + 15], 14, -660478335), i, m, d[n + 4], 20, -405537848), r = gg(r, i = gg(i, m = gg(m, f, r, i, d[n + 9], 5, 568446438), f, r, d[n + 14], 9, -1019803690), m, f, d[n + 3], 14, -187363961), i, m, d[n + 8], 20, 1163531501), r = gg(r, i = gg(i, m = gg(m, f, r, i, d[n + 13], 5, -1444681467), f, r, d[n + 2], 9, -51403784), m, f, d[n + 7], 14, 1735328473), i, m, d[n + 12], 20, -1926607734), r = hh(r, i = hh(i, m = hh(m, f, r, i, d[n + 5], 4, -378558), f, r, d[n + 8], 11, -2022574463), m, f, d[n + 11], 16, 1839030562), i, m, d[n + 14], 23, -35309556), r = hh(r, i = hh(i, m = hh(m, f, r, i, d[n + 1], 4, -1530992060), f, r, d[n + 4], 11, 1272893353), m, f, d[n + 7], 16, -155497632), i, m, d[n + 10], 23, -1094730640), r = hh(r, i = hh(i, m = hh(m, f, r, i, d[n + 13], 4, 681279174), f, r, d[n + 0], 11, -358537222), m, f, d[n + 3], 16, -722521979), i, m, d[n + 6], 23, 76029189), r = hh(r, i = hh(i, m = hh(m, f, r, i, d[n + 9], 4, -640364487), f, r, d[n + 12], 11, -421815835), m, f, d[n + 15], 16, 530742520), i, m, d[n + 2], 23, -995338651), r = ii(r, i = ii(i, m = ii(m, f, r, i, d[n + 0], 6, -198630844), f, r, d[n + 7], 10, 1126891415), m, f, d[n + 14], 15, -1416354905), i, m, d[n + 5], 21, -57434055), r = ii(r, i = ii(i, m = ii(m, f, r, i, d[n + 12], 6, 1700485571), f, r, d[n + 3], 10, -1894986606), m, f, d[n + 10], 15, -1051523), i, m, d[n + 1], 21, -2054922799), r = ii(r, i = ii(i, m = ii(m, f, r, i, d[n + 8], 6, 1873313359), f, r, d[n + 15], 10, -30611744), m, f, d[n + 6], 15, -1560198380), i, m, d[n + 13], 21, 1309151649), r = ii(r, i = ii(i, m = ii(m, f, r, i, d[n + 4], 6, -145523070), f, r, d[n + 11], 10, -1120210379), m, f, d[n + 2], 15, 718787259), i, m, d[n + 9], 21, -343485551), m = add(m, h), f = add(f, t), r = add(r, g), i = add(i, e);
+    }
+    return Array(m, f, r, i);
+}
+
+function cmn(d, g, m, f, r, i) {
+    return add(rol(add(add(g, d), add(f, i)), r), m);
+}
+
+function ff(d, g, m, f, r, i, n) {
+    return cmn(g & m | ~g & f, d, g, r, i, n);
+}
+
+function gg(d, g, m, f, r, i, n) {
+    return cmn(g & f | m & ~f, d, g, r, i, n);
+}
+
+function hh(d, g, m, f, r, i, n) {
+    return cmn(g ^ m ^ f, d, g, r, i, n);
+}
+
+function ii(d, g, m, f, r, i, n) {
+    return cmn(m ^ (g | ~f), d, g, r, i, n);
+}
+
+function add(d, g) {
+    let m = (65535 & d) + (65535 & g);
+    return (d >> 16) + (g >> 16) + (m >> 16) << 16 | 65535 & m;
+}
+
+function rol(d, g) {
+    return d << g | d >>> 32 - g;
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/util/strings.js
@@ -0,0 +1,28 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+// Decode from UTF-8
+export function decodeUTF8(utf8string, allowLatin1=false) {
+    try {
+        return decodeURIComponent(escape(utf8string));
+    } catch (e) {
+        if (e instanceof URIError) {
+            if (allowLatin1) {
+                // If we allow Latin1 we can ignore any decoding fails
+                // and in these cases return the original string
+                return utf8string;
+            }
+        }
+        throw e;
+    }
+}
+
+// Encode to UTF-8
+export function encodeUTF8(DOMString) {
+    return unescape(encodeURIComponent(DOMString));
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/core/websock.js
@@ -0,0 +1,353 @@
+/*
+ * Websock: high-performance buffering wrapper
+ * Copyright (C) 2019 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * Websock is similar to the standard WebSocket / RTCDataChannel object
+ * but with extra buffer handling.
+ *
+ * Websock has built-in receive queue buffering; the message event
+ * does not contain actual data but is simply a notification that
+ * there is new data available. Several rQ* methods are available to
+ * read binary data off of the receive queue.
+ */
+
+import * as Log from './util/logging.js';
+
+// this has performance issues in some versions Chromium, and
+// doesn't gain a tremendous amount of performance increase in Firefox
+// at the moment.  It may be valuable to turn it on in the future.
+const MAX_RQ_GROW_SIZE = 40 * 1024 * 1024;  // 40 MiB
+
+// Constants pulled from RTCDataChannelState enum
+// https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/readyState#RTCDataChannelState_enum
+const DataChannel = {
+    CONNECTING: "connecting",
+    OPEN: "open",
+    CLOSING: "closing",
+    CLOSED: "closed"
+};
+
+const ReadyStates = {
+    CONNECTING: [WebSocket.CONNECTING, DataChannel.CONNECTING],
+    OPEN: [WebSocket.OPEN, DataChannel.OPEN],
+    CLOSING: [WebSocket.CLOSING, DataChannel.CLOSING],
+    CLOSED: [WebSocket.CLOSED, DataChannel.CLOSED],
+};
+
+// Properties a raw channel must have, WebSocket and RTCDataChannel are two examples
+const rawChannelProps = [
+    "send",
+    "close",
+    "binaryType",
+    "onerror",
+    "onmessage",
+    "onopen",
+    "protocol",
+    "readyState",
+];
+
+export default class Websock {
+    constructor() {
+        this._websocket = null;  // WebSocket or RTCDataChannel object
+
+        this._rQi = 0;           // Receive queue index
+        this._rQlen = 0;         // Next write position in the receive queue
+        this._rQbufferSize = 1024 * 1024 * 4; // Receive queue buffer size (4 MiB)
+        // called in init: this._rQ = new Uint8Array(this._rQbufferSize);
+        this._rQ = null; // Receive queue
+
+        this._sQbufferSize = 1024 * 10;  // 10 KiB
+        // called in init: this._sQ = new Uint8Array(this._sQbufferSize);
+        this._sQlen = 0;
+        this._sQ = null;  // Send queue
+
+        this._eventHandlers = {
+            message: () => {},
+            open: () => {},
+            close: () => {},
+            error: () => {}
+        };
+    }
+
+    // Getters and Setters
+
+    get readyState() {
+        let subState;
+
+        if (this._websocket === null) {
+            return "unused";
+        }
+
+        subState = this._websocket.readyState;
+
+        if (ReadyStates.CONNECTING.includes(subState)) {
+            return "connecting";
+        } else if (ReadyStates.OPEN.includes(subState)) {
+            return "open";
+        } else if (ReadyStates.CLOSING.includes(subState)) {
+            return "closing";
+        } else if (ReadyStates.CLOSED.includes(subState)) {
+            return "closed";
+        }
+
+        return "unknown";
+    }
+
+    get sQ() {
+        return this._sQ;
+    }
+
+    get rQ() {
+        return this._rQ;
+    }
+
+    get rQi() {
+        return this._rQi;
+    }
+
+    set rQi(val) {
+        this._rQi = val;
+    }
+
+    // Receive Queue
+    get rQlen() {
+        return this._rQlen - this._rQi;
+    }
+
+    rQpeek8() {
+        return this._rQ[this._rQi];
+    }
+
+    rQskipBytes(bytes) {
+        this._rQi += bytes;
+    }
+
+    rQshift8() {
+        return this._rQshift(1);
+    }
+
+    rQshift16() {
+        return this._rQshift(2);
+    }
+
+    rQshift32() {
+        return this._rQshift(4);
+    }
+
+    // TODO(directxman12): test performance with these vs a DataView
+    _rQshift(bytes) {
+        let res = 0;
+        for (let byte = bytes - 1; byte >= 0; byte--) {
+            res += this._rQ[this._rQi++] << (byte * 8);
+        }
+        return res;
+    }
+
+    rQshiftStr(len) {
+        if (typeof(len) === 'undefined') { len = this.rQlen; }
+        let str = "";
+        // Handle large arrays in steps to avoid long strings on the stack
+        for (let i = 0; i < len; i += 4096) {
+            let part = this.rQshiftBytes(Math.min(4096, len - i));
+            str += String.fromCharCode.apply(null, part);
+        }
+        return str;
+    }
+
+    rQshiftBytes(len) {
+        if (typeof(len) === 'undefined') { len = this.rQlen; }
+        this._rQi += len;
+        return new Uint8Array(this._rQ.buffer, this._rQi - len, len);
+    }
+
+    rQshiftTo(target, len) {
+        if (len === undefined) { len = this.rQlen; }
+        // TODO: make this just use set with views when using a ArrayBuffer to store the rQ
+        target.set(new Uint8Array(this._rQ.buffer, this._rQi, len));
+        this._rQi += len;
+    }
+
+    rQslice(start, end = this.rQlen) {
+        return new Uint8Array(this._rQ.buffer, this._rQi + start, end - start);
+    }
+
+    // Check to see if we must wait for 'num' bytes (default to FBU.bytes)
+    // to be available in the receive queue. Return true if we need to
+    // wait (and possibly print a debug message), otherwise false.
+    rQwait(msg, num, goback) {
+        if (this.rQlen < num) {
+            if (goback) {
+                if (this._rQi < goback) {
+                    throw new Error("rQwait cannot backup " + goback + " bytes");
+                }
+                this._rQi -= goback;
+            }
+            return true; // true means need more data
+        }
+        return false;
+    }
+
+    // Send Queue
+
+    flush() {
+        if (this._sQlen > 0 && this.readyState === 'open') {
+            this._websocket.send(this._encodeMessage());
+            this._sQlen = 0;
+        }
+    }
+
+    send(arr) {
+        this._sQ.set(arr, this._sQlen);
+        this._sQlen += arr.length;
+        this.flush();
+    }
+
+    sendString(str) {
+        this.send(str.split('').map(chr => chr.charCodeAt(0)));
+    }
+
+    // Event Handlers
+    off(evt) {
+        this._eventHandlers[evt] = () => {};
+    }
+
+    on(evt, handler) {
+        this._eventHandlers[evt] = handler;
+    }
+
+    _allocateBuffers() {
+        this._rQ = new Uint8Array(this._rQbufferSize);
+        this._sQ = new Uint8Array(this._sQbufferSize);
+    }
+
+    init() {
+        this._allocateBuffers();
+        this._rQi = 0;
+        this._websocket = null;
+    }
+
+    open(uri, protocols) {
+        this.attach(new WebSocket(uri, protocols));
+    }
+
+    attach(rawChannel) {
+        this.init();
+
+        // Must get object and class methods to be compatible with the tests.
+        const channelProps = [...Object.keys(rawChannel), ...Object.getOwnPropertyNames(Object.getPrototypeOf(rawChannel))];
+        for (let i = 0; i < rawChannelProps.length; i++) {
+            const prop = rawChannelProps[i];
+            if (channelProps.indexOf(prop) < 0) {
+                throw new Error('Raw channel missing property: ' + prop);
+            }
+        }
+
+        this._websocket = rawChannel;
+        this._websocket.binaryType = "arraybuffer";
+        this._websocket.onmessage = this._recvMessage.bind(this);
+
+        this._websocket.onopen = () => {
+            Log.Debug('>> WebSock.onopen');
+            if (this._websocket.protocol) {
+                Log.Info("Server choose sub-protocol: " + this._websocket.protocol);
+            }
+
+            this._eventHandlers.open();
+            Log.Debug("<< WebSock.onopen");
+        };
+
+        this._websocket.onclose = (e) => {
+            Log.Debug(">> WebSock.onclose");
+            this._eventHandlers.close(e);
+            Log.Debug("<< WebSock.onclose");
+        };
+
+        this._websocket.onerror = (e) => {
+            Log.Debug(">> WebSock.onerror: " + e);
+            this._eventHandlers.error(e);
+            Log.Debug("<< WebSock.onerror: " + e);
+        };
+    }
+
+    close() {
+        if (this._websocket) {
+            if (this.readyState === 'connecting' ||
+                this.readyState === 'open') {
+                Log.Info("Closing WebSocket connection");
+                this._websocket.close();
+            }
+
+            this._websocket.onmessage = () => {};
+        }
+    }
+
+    // private methods
+    _encodeMessage() {
+        // Put in a binary arraybuffer
+        // according to the spec, you can send ArrayBufferViews with the send method
+        return new Uint8Array(this._sQ.buffer, 0, this._sQlen);
+    }
+
+    // We want to move all the unread data to the start of the queue,
+    // e.g. compacting.
+    // The function also expands the receive que if needed, and for
+    // performance reasons we combine these two actions to avoid
+    // unneccessary copying.
+    _expandCompactRQ(minFit) {
+        // if we're using less than 1/8th of the buffer even with the incoming bytes, compact in place
+        // instead of resizing
+        const requiredBufferSize =  (this._rQlen - this._rQi + minFit) * 8;
+        const resizeNeeded = this._rQbufferSize < requiredBufferSize;
+
+        if (resizeNeeded) {
+            // Make sure we always *at least* double the buffer size, and have at least space for 8x
+            // the current amount of data
+            this._rQbufferSize = Math.max(this._rQbufferSize * 2, requiredBufferSize);
+        }
+
+        // we don't want to grow unboundedly
+        if (this._rQbufferSize > MAX_RQ_GROW_SIZE) {
+            this._rQbufferSize = MAX_RQ_GROW_SIZE;
+            if (this._rQbufferSize - this.rQlen < minFit) {
+                throw new Error("Receive Queue buffer exceeded " + MAX_RQ_GROW_SIZE + " bytes, and the new message could not fit");
+            }
+        }
+
+        if (resizeNeeded) {
+            const oldRQbuffer = this._rQ.buffer;
+            this._rQ = new Uint8Array(this._rQbufferSize);
+            this._rQ.set(new Uint8Array(oldRQbuffer, this._rQi, this._rQlen - this._rQi));
+        } else {
+            this._rQ.copyWithin(0, this._rQi, this._rQlen);
+        }
+
+        this._rQlen = this._rQlen - this._rQi;
+        this._rQi = 0;
+    }
+
+    // push arraybuffer values onto the end of the receive que
+    _DecodeMessage(data) {
+        const u8 = new Uint8Array(data);
+        if (u8.length > this._rQbufferSize - this._rQlen) {
+            this._expandCompactRQ(u8.length);
+        }
+        this._rQ.set(u8, this._rQlen);
+        this._rQlen += u8.length;
+    }
+
+    _recvMessage(e) {
+        this._DecodeMessage(e.data);
+        if (this.rQlen > 0) {
+            this._eventHandlers.message();
+            if (this._rQlen == this._rQi) {
+                // All data has now been processed, this means we
+                // can reset the receive queue.
+                this._rQlen = 0;
+                this._rQi = 0;
+            }
+        } else {
+            Log.Debug("Ignoring empty message");
+        }
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/docs/API-internal.md
@@ -0,0 +1,89 @@
+# 1. Internal Modules
+
+The noVNC client is composed of several internal modules that handle
+rendering, input, networking, etc. Each of the modules is designed to
+be cross-browser and independent from each other.
+
+Note however that the API of these modules is not guaranteed to be
+stable, and this documentation is not maintained as well as the
+official external API.
+
+
+## 1.1 Module List
+
+* __Keyboard__ (core/input/keyboard.js): Keyboard input event handler with
+non-US keyboard support. Translates keyDown and keyUp events to X11
+keysym values.
+
+* __Display__ (core/display.js): Efficient 2D rendering abstraction
+layered on the HTML5 canvas element.
+
+* __Websock__ (core/websock.js): Websock client from websockify
+with transparent binary data support.
+[Websock API](https://github.com/novnc/websockify-js/wiki/websock.js) wiki page.
+
+
+## 1.2 Callbacks
+
+For the Mouse, Keyboard and Display objects the callback functions are
+assigned to configuration attributes, just as for the RFB object. The
+WebSock module has a method named 'on' that takes two parameters: the
+callback event name, and the callback function.
+
+## 2. Modules
+
+## 2.1 Keyboard Module
+
+### 2.1.1 Configuration Attributes
+
+None
+
+### 2.1.2 Methods
+
+| name   | parameters | description
+| ------ | ---------- | ------------
+| grab   | ()         | Begin capturing keyboard events
+| ungrab | ()         | Stop capturing keyboard events
+
+### 2.1.3 Callbacks
+
+| name       | parameters           | description
+| ---------- | -------------------- | ------------
+| onkeypress | (keysym, code, down) | Handler for key press/release
+
+
+## 2.2 Display Module
+
+### 2.2.1 Configuration Attributes
+
+| name         | type  | mode | default | description
+| ------------ | ----- | ---- | ------- | ------------
+| scale        | float | RW   | 1.0     | Display area scale factor 0.0 - 1.0
+| clipViewport | bool  | RW   | false   | Use viewport clipping
+| width        | int   | RO   |         | Display area width
+| height       | int   | RO   |         | Display area height
+
+### 2.2.2 Methods
+
+| name               | parameters                                              | description
+| ------------------ | ------------------------------------------------------- | ------------
+| viewportChangePos  | (deltaX, deltaY)                                        | Move the viewport relative to the current location
+| viewportChangeSize | (width, height)                                         | Change size of the viewport
+| absX               | (x)                                                     | Return X relative to the remote display
+| absY               | (y)                                                     | Return Y relative to the remote display
+| resize             | (width, height)                                         | Set width and height
+| flip               | (from_queue)                                            | Update the visible canvas with the contents of the rendering canvas
+| pending            | ()                                                      | Check if there are waiting items in the render queue
+| flush              | ()                                                      | Resume processing the render queue unless it's empty
+| fillRect           | (x, y, width, height, color, from_queue)                | Draw a filled in rectangle
+| copyImage          | (old_x, old_y, new_x, new_y, width, height, from_queue) | Copy a rectangular area
+| imageRect          | (x, y, width, height, mime, arr)                        | Draw a rectangle with an image
+| blitImage          | (x, y, width, height, arr, offset, from_queue)          | Blit pixels (of R,G,B,A) to the display
+| drawImage          | (img, x, y)                                             | Draw image and track damage
+| autoscale          | (containerWidth, containerHeight)                       | Scale the display
+
+### 2.2.3 Callbacks
+
+| name    | parameters | description
+| ------- | ---------- | ------------
+| onflush | ()         | A display flush has been requested and we are now ready to resume FBU processing
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/docs/API.md
@@ -0,0 +1,486 @@
+# noVNC API
+
+The interface of the noVNC client consists of a single RFB object that
+is instantiated once per connection.
+
+## RFB
+
+The `RFB` object represents a single connection to a VNC server. It
+communicates using a WebSocket that must provide a standard RFB
+protocol stream.
+
+### Constructor
+
+[`RFB()`](#rfb-1)
+  - Creates and returns a new `RFB` object.
+
+### Properties
+
+`viewOnly`
+  - Is a `boolean` indicating if any events (e.g. key presses or mouse
+    movement) should be prevented from being sent to the server.
+    Disabled by default.
+
+`focusOnClick`
+  - Is a `boolean` indicating if keyboard focus should automatically be
+    moved to the remote session when a `mousedown` or `touchstart`
+    event is received. Enabled by default.
+
+`clipViewport`
+  - Is a `boolean` indicating if the remote session should be clipped
+    to its container. When disabled scrollbars will be shown to handle
+    the resulting overflow. Disabled by default.
+
+`dragViewport`
+  - Is a `boolean` indicating if mouse events should control the
+    relative position of a clipped remote session. Only relevant if
+    `clipViewport` is enabled. Disabled by default.
+
+`scaleViewport`
+  - Is a `boolean` indicating if the remote session should be scaled
+    locally so it fits its container. When disabled it will be centered
+    if the remote session is smaller than its container, or handled
+    according to `clipViewport` if it is larger. Disabled by default.
+
+`resizeSession`
+  - Is a `boolean` indicating if a request to resize the remote session
+    should be sent whenever the container changes dimensions. Disabled
+    by default.
+
+`showDotCursor`
+  - Is a `boolean` indicating whether a dot cursor should be shown
+    instead of a zero-sized or fully-transparent cursor if the server
+    sets such invisible cursor. Disabled by default.
+
+`background`
+  - Is a valid CSS [background](https://developer.mozilla.org/en-US/docs/Web/CSS/background)
+    style value indicating which background style should be applied
+    to the element containing the remote session screen. The default value is `rgb(40, 40, 40)`
+    (solid gray color).
+
+`qualityLevel`
+  - Is an `int` in range `[0-9]` controlling the desired JPEG quality.
+    Value `0` implies low quality and `9` implies high quality.
+    Default value is `6`.
+
+`compressionLevel`
+  - Is an `int` in range `[0-9]` controlling the desired compression
+    level. Value `0` means no compression. Level 1 uses a minimum of CPU
+    resources and achieves weak compression ratios, while level 9 offers
+    best compression but is slow in terms of CPU consumption on the server
+    side. Use high levels with very slow network connections.
+    Default value is `2`.
+
+`capabilities` *Read only*
+  - Is an `Object` indicating which optional extensions are available
+    on the server. Some methods may only be called if the corresponding
+    capability is set. The following capabilities are defined:
+
+    | name     | type      | description
+    | -------- | --------- | -----------
+    | `power`  | `boolean` | Machine power control is available
+
+### Events
+
+[`connect`](#connect)
+  - The `connect` event is fired when the `RFB` object has completed
+    the connection and handshaking with the server.
+
+[`disconnect`](#disconnect)
+  - The `disconnect` event is fired when the `RFB` object disconnects.
+
+[`serververification`](#serververification)
+  - The `serververification` event is fired when the server identity
+    must be confirmed by the user.
+
+[`credentialsrequired`](#credentialsrequired)
+  - The `credentialsrequired` event is fired when more credentials must
+    be given to continue.
+
+[`securityfailure`](#securityfailure)
+  - The `securityfailure` event is fired when the security negotiation
+    with the server fails.
+
+[`clipboard`](#clipboard)
+  - The `clipboard` event is fired when clipboard data is received from
+    the server.
+
+[`bell`](#bell)
+  - The `bell` event is fired when a audible bell request is received
+    from the server.
+
+[`desktopname`](#desktopname)
+  - The `desktopname` event is fired when the remote desktop name
+    changes.
+
+[`capabilities`](#capabilities)
+  - The `capabilities` event is fired when `RFB.capabilities` is
+    updated.
+
+### Methods
+
+[`RFB.disconnect()`](#rfbdisconnect)
+  - Disconnect from the server.
+
+[`RFB.approveServer()`](#rfbapproveserver)
+  - Proceed connecting to the server. Should be called after the
+    [`serververification`](#serververification) event has fired and the
+    user has verified the identity of the server.
+
+[`RFB.sendCredentials()`](#rfbsendcredentials)
+  - Send credentials to server. Should be called after the
+    [`credentialsrequired`](#credentialsrequired) event has fired.
+
+[`RFB.sendKey()`](#rfbsendkey)
+  - Send a key event.
+
+[`RFB.sendCtrlAltDel()`](#rfbsendctrlaltdel)
+  - Send Ctrl-Alt-Del key sequence.
+
+[`RFB.focus()`](#rfbfocus)
+  - Move keyboard focus to the remote session.
+
+[`RFB.blur()`](#rfbblur)
+  - Remove keyboard focus from the remote session.
+
+[`RFB.machineShutdown()`](#rfbmachineshutdown)
+  - Request a shutdown of the remote machine.
+
+[`RFB.machineReboot()`](#rfbmachinereboot)
+  - Request a reboot of the remote machine.
+
+[`RFB.machineReset()`](#rfbmachinereset)
+  - Request a reset of the remote machine.
+
+[`RFB.clipboardPasteFrom()`](#rfbclipboardpastefrom)
+  - Send clipboard contents to server.
+
+[`RFB.getImageData()`](#rfbgetimagedata)
+  - Return the current content of the screen as an ImageData array.
+
+[`RFB.toDataURL()`](#rfbtodataurl)
+  - Return the current content of the screen as data-url encoded image file.
+
+[`RFB.toBlob()`](#rfbtoblob)
+  - Return the current content of the screen as Blob encoded image file.
+
+### Details
+
+#### RFB()
+
+The `RFB()` constructor returns a new `RFB` object and initiates a new
+connection to a specified VNC server.
+
+##### Syntax
+
+    let rfb = new RFB( target, url [, options] );
+
+###### Parameters
+
+**`target`**
+  - A block [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement)
+    that specifies where the `RFB` object should attach itself. The
+    existing contents of the `HTMLElement` will be untouched, but new
+    elements will be added during the lifetime of the `RFB` object.
+
+**`urlOrDataChannel`**
+  - A `DOMString` specifying the VNC server to connect to. This must be
+    a valid WebSocket URL. This can also be a `WebSocket` or `RTCDataChannel`.
+
+**`options`** *Optional*
+  - An `Object` specifying extra details about how the connection
+    should be made.
+
+    Possible options:
+
+    `shared`
+      - A `boolean` indicating if the remote server should be shared or
+        if any other connected clients should be disconnected. Enabled
+        by default.
+
+    `credentials`
+      - An `Object` specifying the credentials to provide to the server
+        when authenticating. The following credentials are possible:
+
+        | name         | type        | description
+        | ------------ | ----------- | -----------
+        | `"username"` | `DOMString` | The user that authenticates
+        | `"password"` | `DOMString` | Password for the user
+        | `"target"`   | `DOMString` | Target machine or session
+
+    `repeaterID`
+      - A `DOMString` specifying the ID to provide to any VNC repeater
+        encountered.
+
+    `wsProtocols`
+      - An `Array` of `DOMString`s specifying the sub-protocols to use
+        in the WebSocket connection. Empty by default.
+
+#### connect
+
+The `connect` event is fired after all the handshaking with the server
+is completed and the connection is fully established. After this event
+the `RFB` object is ready to recieve graphics updates and to send input.
+
+#### disconnect
+
+The `disconnect` event is fired when the connection has been
+terminated. The `detail` property is an `Object` that contains the
+property `clean`. `clean` is a `boolean` indicating if the termination
+was clean or not. In the event of an unexpected termination or an error
+`clean` will be set to false.
+
+#### serververification
+
+The `serververification` event is fired when the server provides
+information that allows the user to verify that it is the correct server
+and protect against a man-in-the-middle attack. The `detail` property is
+an `Object` containing the property `type` which is a `DOMString`
+specifying which type of information the server has provided. Other
+properties are also available, depending on the value of `type`:
+
+`"RSA"`
+ - The server identity is verified using just a RSA key. The property
+   `publickey` is a `Uint8Array` containing the public key in a unsigned
+   big endian representation.
+
+#### credentialsrequired
+
+The `credentialsrequired` event is fired when the server requests more
+credentials than were specified to [`RFB()`](#rfb-1). The `detail`
+property is an `Object` containing the property `types` which is an
+`Array` of `DOMString` listing the credentials that are required.
+
+#### securityfailure
+
+The `securityfailure` event is fired when the handshaking process with
+the server fails during the security negotiation step. The `detail`
+property is an `Object` containing the following properties:
+
+| Property | Type        | Description
+| -------- | ----------- | -----------
+| `status` | `long`      | The failure status code
+| `reason` | `DOMString` | The **optional** reason for the failure
+
+The property `status` corresponds to the
+[SecurityResult](https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#securityresult)
+status code in cases of failure. A status of zero will not be sent in
+this event since that indicates a successful security handshaking
+process. The optional property `reason` is provided by the server and
+thus the language of the string is not known. However most servers will
+probably send English strings. The server can choose to not send a
+reason and in these cases the `reason` property will be omitted.
+
+#### clipboard
+
+The `clipboard` event is fired when the server has sent clipboard data.
+The `detail` property is an `Object` containing the property `text`
+which is a `DOMString` with the clipboard data.
+
+#### bell
+
+The `bell` event is fired when the server has requested an audible
+bell.
+
+#### desktopname
+
+The `desktopname` event is fired when the name of the remote desktop
+changes. The `detail` property is an `Object` with the property `name`
+which is a `DOMString` specifying the new name.
+
+#### capabilities
+
+The `capabilities` event is fired whenever an entry is added or removed
+from `RFB.capabilities`. The `detail` property is an `Object` with the
+property `capabilities` containing the new value of `RFB.capabilities`.
+
+#### RFB.disconnect()
+
+The `RFB.disconnect()` method is used to disconnect from the currently
+connected server.
+
+##### Syntax
+
+    RFB.disconnect( );
+
+#### RFB.approveServer()
+
+The `RFB.approveServer()` method is used to signal that the user has
+verified the server identity provided in a `serververification` event
+and that the connection can continue.
+
+##### Syntax
+
+    RFB.approveServer( );
+
+#### RFB.sendCredentials()
+
+The `RFB.sendCredentials()` method is used to provide the missing
+credentials after a `credentialsrequired` event has been fired.
+
+##### Syntax
+
+    RFB.sendCredentials( credentials );
+
+###### Parameters
+
+**`credentials`**
+  - An `Object` specifying the credentials to provide to the server
+    when authenticating. See [`RFB()`](#rfb-1) for details.
+
+#### RFB.sendKey()
+
+The `RFB.sendKey()` method is used to send a key event to the server.
+
+##### Syntax
+
+    RFB.sendKey( keysym, code [, down] );
+
+###### Parameters
+
+**`keysym`**
+  - A `long` specifying the RFB keysym to send. Can be `0` if a valid
+    **`code`** is specified.
+
+**`code`**
+  - A `DOMString` specifying the physical key to send. Valid values are
+    those that can be specified to
+    [`KeyboardEvent.code`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code).
+    If the physical key cannot be determined then `null` shall be
+    specified.
+
+**`down`** *Optional*
+  - A `boolean` specifying if a press or a release event should be
+    sent. If omitted then both a press and release event are sent.
+
+#### RFB.sendCtrlAltDel()
+
+The `RFB.sendCtrlAltDel()` method is used to send the key sequence
+*left Control*, *left Alt*, *Delete*. This is a convenience wrapper
+around [`RFB.sendKey()`](#rfbsendkey).
+
+##### Syntax
+
+    RFB.sendCtrlAltDel( );
+
+#### RFB.focus()
+
+The `RFB.focus()` method sets the keyboard focus on the remote session.
+Keyboard events will be sent to the remote server after this point.
+
+##### Syntax
+
+    RFB.focus( [options] );
+
+###### Parameters
+
+**`options`** *Optional*
+  - A `object` providing options to control how the focus will be
+    performed. Please see [`HTMLElement.focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus)
+    for available options.
+
+#### RFB.blur()
+
+The `RFB.blur()` method remove keyboard focus on the remote session.
+Keyboard events will no longer be sent to the remote server after this
+point.
+
+##### Syntax
+
+    RFB.blur( );
+
+#### RFB.machineShutdown()
+
+The `RFB.machineShutdown()` method is used to request to shut down the
+remote machine. The capability `power` must be set for this method to
+have any effect.
+
+##### Syntax
+
+    RFB.machineShutdown( );
+
+#### RFB.machineReboot()
+
+The `RFB.machineReboot()` method is used to request a clean reboot of
+the remote machine. The capability `power` must be set for this method
+to have any effect.
+
+##### Syntax
+
+    RFB.machineReboot( );
+
+#### RFB.machineReset()
+
+The `RFB.machineReset()` method is used to request a forced reset of
+the remote machine. The capability `power` must be set for this method
+to have any effect.
+
+##### Syntax
+
+    RFB.machineReset( );
+
+#### RFB.clipboardPasteFrom()
+
+The `RFB.clipboardPasteFrom()` method is used to send clipboard data
+to the remote server.
+
+##### Syntax
+
+    RFB.clipboardPasteFrom( text );
+
+###### Parameters
+
+**`text`**
+  - A `DOMString` specifying the clipboard data to send.
+
+#### RFB.getImageData()
+
+The `RFB.getImageData()` method is used to return the current content of the
+screen encoded as [`ImageData`](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).
+
+##### Syntax
+
+  RFB.getImageData();
+
+#### RFB.toDataURL()
+
+The `RFB.toDataURL()` method is used to return the current content of the
+screen encoded as a data URL that could for example be put in the `src` attribute
+of an `img` tag.
+
+##### Syntax
+
+  RFB.toDataURL();
+  RFB.toDataURL(type);
+  RFB.toDataURL(type, encoderOptions);
+
+###### Parameters
+
+**`type`** *Optional*
+  - A string indicating the requested MIME type of the image
+
+**`encoderOptions`** *Optional*
+  - A number between 0 and 1 indicating the image quality.
+
+#### RFB.toBlob()
+
+The `RFB.toBlob()` method is used to return the current content of the
+screen encoded as [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).
+
+##### Syntax
+
+  RFB.toDataURL(callback);
+  RFB.toDataURL(callback, type);
+  RFB.toDataURL(callback, type, quality);
+
+###### Parameters
+
+**`callback`**
+  - A callback function which will receive the resulting [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob)
+    as the single argument
+
+**`type`** *Optional*
+  - A string indicating the requested MIME type of the image
+
+**`encoderOptions`** *Optional*
+  - A number between 0 and 1 indicating the image quality.
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/docs/EMBEDDING.md
@@ -0,0 +1,105 @@
+# Embedding and Deploying noVNC Application
+
+This document describes how to embed and deploy the noVNC application, which
+includes settings and a full user interface. If you are looking for
+documentation on how to use the core noVNC library in your own application,
+then please see our [library documentation](LIBRARY.md).
+
+## Files
+
+The noVNC application consists of the following files and directories:
+
+* `vnc.html` - The main page for the application and where users should go. It
+  is possible to rename this file.
+
+* `app/` - Support files for the application. Contains code, images, styles and
+  translations.
+
+* `core/` - The core noVNC library.
+
+* `vendor/` - Third party support libraries used by the application and the
+  core library.
+
+The most basic deployment consists of simply serving these files from a web
+server and setting up a WebSocket proxy to the VNC server.
+
+## Parameters
+
+The noVNC application can be controlled by including certain settings in the
+query string. Currently the following options are available:
+
+* `autoconnect` - Automatically connect as soon as the page has finished
+  loading.
+
+* `reconnect` - If noVNC should automatically reconnect if the connection is
+  dropped.
+
+* `reconnect_delay` - How long to wait in milliseconds before attempting to
+  reconnect.
+
+* `host` - The WebSocket host to connect to.
+
+* `port` - The WebSocket port to connect to.
+
+* `encrypt` - If TLS should be used for the WebSocket connection.
+
+* `path` - The WebSocket path to use.
+
+* `password` - The password sent to the server, if required.
+
+* `repeaterID` - The repeater ID to use if a VNC repeater is detected.
+
+* `shared` - If other VNC clients should be disconnected when noVNC connects.
+
+* `bell` - If the keyboard bell should be enabled or not.
+
+* `view_only` - If the remote session should be in non-interactive mode.
+
+* `view_clip` - If the remote session should be clipped or use scrollbars if
+  it cannot fit in the browser.
+
+* `resize` - How to resize the remote session if it is not the same size as
+  the browser window. Can be one of `off`, `scale` and `remote`.
+
+* `quality` - The session JPEG quality level. Can be `0` to `9`.
+
+* `compression` - The session compression level. Can be `0` to `9`.
+
+* `show_dot` - If a dot cursor should be shown when the remote server provides
+  no local cursor, or provides a fully-transparent (invisible) cursor.
+
+* `logging` - The console log level. Can be one of `error`, `warn`, `info` or
+  `debug`.
+
+## HTTP Serving Considerations
+### Browser Cache Issue
+
+If you serve noVNC files using a web server that provides an ETag header, and
+include any options in the query string, a nasty browser cache issue can bite
+you on upgrade, resulting in a red error box. The issue is caused by a mismatch
+between the new vnc.html (which is reloaded because the user has used it with
+new query string after the upgrade) and the old javascript files (that the
+browser reuses from its cache). To avoid this issue, the browser must be told
+to always revalidate cached files using conditional requests. The correct
+semantics are achieved via the (confusingly named) `Cache-Control: no-cache`
+header that needs to be provided in the web server responses.
+
+### Example Server Configurations
+
+Apache:
+
+```
+    # In the main configuration file
+    # (Debian/Ubuntu users: use "a2enmod headers" instead)
+    LoadModule headers_module modules/mod_headers.so
+
+    # In the <Directory> or <Location> block related to noVNC
+    Header set Cache-Control "no-cache"
+```
+
+Nginx:
+
+```
+    # In the location block related to noVNC
+    add_header Cache-Control no-cache;
+```
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/docs/LIBRARY.md
@@ -0,0 +1,31 @@
+# Using the noVNC JavaScript library
+
+This document describes how to make use of the noVNC JavaScript library for
+integration in your own VNC client application. If you wish to embed the more
+complete noVNC application with its included user interface then please see
+our [embedding documentation](EMBEDDING.md).
+
+## API
+
+The API of noVNC consists of a single object called `RFB`. The formal
+documentation for that object can be found in our [API documentation](API.md).
+
+## Example
+
+noVNC includes a small example application called `vnc_lite.html`. This does
+not make use of all the features of noVNC, but is a good start to see how to
+do things.
+
+## Conversion of Modules
+
+noVNC is written using ECMAScript 6 modules. This is not supported by older
+versions of Node.js. To use noVNC with those older versions of Node.js the
+library must first be converted.
+
+Fortunately noVNC includes a script to handle this conversion. Please follow
+the following steps:
+
+ 1. Install Node.js
+ 2. Run `npm install` in the noVNC directory
+
+The result of the conversion is available in the `lib/` directory.
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/docs/LICENSE.BSD-2-Clause
@@ -0,0 +1,22 @@
+Copyright (c) <year>, <copyright holder>
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/docs/LICENSE.BSD-3-Clause
@@ -0,0 +1,24 @@
+Copyright (c) <year>, <copyright holder>
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the <organization> nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/docs/LICENSE.MPL-2.0
@@ -0,0 +1,373 @@
+Mozilla Public License Version 2.0
+==================================
+
+1. Definitions
+--------------
+
+1.1. "Contributor"
+    means each individual or legal entity that creates, contributes to
+    the creation of, or owns Covered Software.
+
+1.2. "Contributor Version"
+    means the combination of the Contributions of others (if any) used
+    by a Contributor and that particular Contributor's Contribution.
+
+1.3. "Contribution"
+    means Covered Software of a particular Contributor.
+
+1.4. "Covered Software"
+    means Source Code Form to which the initial Contributor has attached
+    the notice in Exhibit A, the Executable Form of such Source Code
+    Form, and Modifications of such Source Code Form, in each case
+    including portions thereof.
+
+1.5. "Incompatible With Secondary Licenses"
+    means
+
+    (a) that the initial Contributor has attached the notice described
+        in Exhibit B to the Covered Software; or
+
+    (b) that the Covered Software was made available under the terms of
+        version 1.1 or earlier of the License, but not also under the
+        terms of a Secondary License.
+
+1.6. "Executable Form"
+    means any form of the work other than Source Code Form.
+
+1.7. "Larger Work"
+    means a work that combines Covered Software with other material, in 
+    a separate file or files, that is not Covered Software.
+
+1.8. "License"
+    means this document.
+
+1.9. "Licensable"
+    means having the right to grant, to the maximum extent possible,
+    whether at the time of the initial grant or subsequently, any and
+    all of the rights conveyed by this License.
+
+1.10. "Modifications"
+    means any of the following:
+
+    (a) any file in Source Code Form that results from an addition to,
+        deletion from, or modification of the contents of Covered
+        Software; or
+
+    (b) any new file in Source Code Form that contains any Covered
+        Software.
+
+1.11. "Patent Claims" of a Contributor
+    means any patent claim(s), including without limitation, method,
+    process, and apparatus claims, in any patent Licensable by such
+    Contributor that would be infringed, but for the grant of the
+    License, by the making, using, selling, offering for sale, having
+    made, import, or transfer of either its Contributions or its
+    Contributor Version.
+
+1.12. "Secondary License"
+    means either the GNU General Public License, Version 2.0, the GNU
+    Lesser General Public License, Version 2.1, the GNU Affero General
+    Public License, Version 3.0, or any later versions of those
+    licenses.
+
+1.13. "Source Code Form"
+    means the form of the work preferred for making modifications.
+
+1.14. "You" (or "Your")
+    means an individual or a legal entity exercising rights under this
+    License. For legal entities, "You" includes any entity that
+    controls, is controlled by, or is under common control with You. For
+    purposes of this definition, "control" means (a) the power, direct
+    or indirect, to cause the direction or management of such entity,
+    whether by contract or otherwise, or (b) ownership of more than
+    fifty percent (50%) of the outstanding shares or beneficial
+    ownership of such entity.
+
+2. License Grants and Conditions
+--------------------------------
+
+2.1. Grants
+
+Each Contributor hereby grants You a world-wide, royalty-free,
+non-exclusive license:
+
+(a) under intellectual property rights (other than patent or trademark)
+    Licensable by such Contributor to use, reproduce, make available,
+    modify, display, perform, distribute, and otherwise exploit its
+    Contributions, either on an unmodified basis, with Modifications, or
+    as part of a Larger Work; and
+
+(b) under Patent Claims of such Contributor to make, use, sell, offer
+    for sale, have made, import, and otherwise transfer either its
+    Contributions or its Contributor Version.
+
+2.2. Effective Date
+
+The licenses granted in Section 2.1 with respect to any Contribution
+become effective for each Contribution on the date the Contributor first
+distributes such Contribution.
+
+2.3. Limitations on Grant Scope
+
+The licenses granted in this Section 2 are the only rights granted under
+this License. No additional rights or licenses will be implied from the
+distribution or licensing of Covered Software under this License.
+Notwithstanding Section 2.1(b) above, no patent license is granted by a
+Contributor:
+
+(a) for any code that a Contributor has removed from Covered Software;
+    or
+
+(b) for infringements caused by: (i) Your and any other third party's
+    modifications of Covered Software, or (ii) the combination of its
+    Contributions with other software (except as part of its Contributor
+    Version); or
+
+(c) under Patent Claims infringed by Covered Software in the absence of
+    its Contributions.
+
+This License does not grant any rights in the trademarks, service marks,
+or logos of any Contributor (except as may be necessary to comply with
+the notice requirements in Section 3.4).
+
+2.4. Subsequent Licenses
+
+No Contributor makes additional grants as a result of Your choice to
+distribute the Covered Software under a subsequent version of this
+License (see Section 10.2) or under the terms of a Secondary License (if
+permitted under the terms of Section 3.3).
+
+2.5. Representation
+
+Each Contributor represents that the Contributor believes its
+Contributions are its original creation(s) or it has sufficient rights
+to grant the rights to its Contributions conveyed by this License.
+
+2.6. Fair Use
+
+This License is not intended to limit any rights You have under
+applicable copyright doctrines of fair use, fair dealing, or other
+equivalents.
+
+2.7. Conditions
+
+Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
+in Section 2.1.
+
+3. Responsibilities
+-------------------
+
+3.1. Distribution of Source Form
+
+All distribution of Covered Software in Source Code Form, including any
+Modifications that You create or to which You contribute, must be under
+the terms of this License. You must inform recipients that the Source
+Code Form of the Covered Software is governed by the terms of this
+License, and how they can obtain a copy of this License. You may not
+attempt to alter or restrict the recipients' rights in the Source Code
+Form.
+
+3.2. Distribution of Executable Form
+
+If You distribute Covered Software in Executable Form then:
+
+(a) such Covered Software must also be made available in Source Code
+    Form, as described in Section 3.1, and You must inform recipients of
+    the Executable Form how they can obtain a copy of such Source Code
+    Form by reasonable means in a timely manner, at a charge no more
+    than the cost of distribution to the recipient; and
+
+(b) You may distribute such Executable Form under the terms of this
+    License, or sublicense it under different terms, provided that the
+    license for the Executable Form does not attempt to limit or alter
+    the recipients' rights in the Source Code Form under this License.
+
+3.3. Distribution of a Larger Work
+
+You may create and distribute a Larger Work under terms of Your choice,
+provided that You also comply with the requirements of this License for
+the Covered Software. If the Larger Work is a combination of Covered
+Software with a work governed by one or more Secondary Licenses, and the
+Covered Software is not Incompatible With Secondary Licenses, this
+License permits You to additionally distribute such Covered Software
+under the terms of such Secondary License(s), so that the recipient of
+the Larger Work may, at their option, further distribute the Covered
+Software under the terms of either this License or such Secondary
+License(s).
+
+3.4. Notices
+
+You may not remove or alter the substance of any license notices
+(including copyright notices, patent notices, disclaimers of warranty,
+or limitations of liability) contained within the Source Code Form of
+the Covered Software, except that You may alter any license notices to
+the extent required to remedy known factual inaccuracies.
+
+3.5. Application of Additional Terms
+
+You may choose to offer, and to charge a fee for, warranty, support,
+indemnity or liability obligations to one or more recipients of Covered
+Software. However, You may do so only on Your own behalf, and not on
+behalf of any Contributor. You must make it absolutely clear that any
+such warranty, support, indemnity, or liability obligation is offered by
+You alone, and You hereby agree to indemnify every Contributor for any
+liability incurred by such Contributor as a result of warranty, support,
+indemnity or liability terms You offer. You may include additional
+disclaimers of warranty and limitations of liability specific to any
+jurisdiction.
+
+4. Inability to Comply Due to Statute or Regulation
+---------------------------------------------------
+
+If it is impossible for You to comply with any of the terms of this
+License with respect to some or all of the Covered Software due to
+statute, judicial order, or regulation then You must: (a) comply with
+the terms of this License to the maximum extent possible; and (b)
+describe the limitations and the code they affect. Such description must
+be placed in a text file included with all distributions of the Covered
+Software under this License. Except to the extent prohibited by statute
+or regulation, such description must be sufficiently detailed for a
+recipient of ordinary skill to be able to understand it.
+
+5. Termination
+--------------
+
+5.1. The rights granted under this License will terminate automatically
+if You fail to comply with any of its terms. However, if You become
+compliant, then the rights granted under this License from a particular
+Contributor are reinstated (a) provisionally, unless and until such
+Contributor explicitly and finally terminates Your grants, and (b) on an
+ongoing basis, if such Contributor fails to notify You of the
+non-compliance by some reasonable means prior to 60 days after You have
+come back into compliance. Moreover, Your grants from a particular
+Contributor are reinstated on an ongoing basis if such Contributor
+notifies You of the non-compliance by some reasonable means, this is the
+first time You have received notice of non-compliance with this License
+from such Contributor, and You become compliant prior to 30 days after
+Your receipt of the notice.
+
+5.2. If You initiate litigation against any entity by asserting a patent
+infringement claim (excluding declaratory judgment actions,
+counter-claims, and cross-claims) alleging that a Contributor Version
+directly or indirectly infringes any patent, then the rights granted to
+You by any and all Contributors for the Covered Software under Section
+2.1 of this License shall terminate.
+
+5.3. In the event of termination under Sections 5.1 or 5.2 above, all
+end user license agreements (excluding distributors and resellers) which
+have been validly granted by You or Your distributors under this License
+prior to termination shall survive termination.
+
+************************************************************************
+*                                                                      *
+*  6. Disclaimer of Warranty                                           *
+*  -------------------------                                           *
+*                                                                      *
+*  Covered Software is provided under this License on an "as is"       *
+*  basis, without warranty of any kind, either expressed, implied, or  *
+*  statutory, including, without limitation, warranties that the       *
+*  Covered Software is free of defects, merchantable, fit for a        *
+*  particular purpose or non-infringing. The entire risk as to the     *
+*  quality and performance of the Covered Software is with You.        *
+*  Should any Covered Software prove defective in any respect, You     *
+*  (not any Contributor) assume the cost of any necessary servicing,   *
+*  repair, or correction. This disclaimer of warranty constitutes an   *
+*  essential part of this License. No use of any Covered Software is   *
+*  authorized under this License except under this disclaimer.         *
+*                                                                      *
+************************************************************************
+
+************************************************************************
+*                                                                      *
+*  7. Limitation of Liability                                          *
+*  --------------------------                                          *
+*                                                                      *
+*  Under no circumstances and under no legal theory, whether tort      *
+*  (including negligence), contract, or otherwise, shall any           *
+*  Contributor, or anyone who distributes Covered Software as          *
+*  permitted above, be liable to You for any direct, indirect,         *
+*  special, incidental, or consequential damages of any character      *
+*  including, without limitation, damages for lost profits, loss of    *
+*  goodwill, work stoppage, computer failure or malfunction, or any    *
+*  and all other commercial damages or losses, even if such party      *
+*  shall have been informed of the possibility of such damages. This   *
+*  limitation of liability shall not apply to liability for death or   *
+*  personal injury resulting from such party's negligence to the       *
+*  extent applicable law prohibits such limitation. Some               *
+*  jurisdictions do not allow the exclusion or limitation of           *
+*  incidental or consequential damages, so this exclusion and          *
+*  limitation may not apply to You.                                    *
+*                                                                      *
+************************************************************************
+
+8. Litigation
+-------------
+
+Any litigation relating to this License may be brought only in the
+courts of a jurisdiction where the defendant maintains its principal
+place of business and such litigation shall be governed by laws of that
+jurisdiction, without reference to its conflict-of-law provisions.
+Nothing in this Section shall prevent a party's ability to bring
+cross-claims or counter-claims.
+
+9. Miscellaneous
+----------------
+
+This License represents the complete agreement concerning the subject
+matter hereof. If any provision of this License is held to be
+unenforceable, such provision shall be reformed only to the extent
+necessary to make it enforceable. Any law or regulation which provides
+that the language of a contract shall be construed against the drafter
+shall not be used to construe this License against a Contributor.
+
+10. Versions of the License
+---------------------------
+
+10.1. New Versions
+
+Mozilla Foundation is the license steward. Except as provided in Section
+10.3, no one other than the license steward has the right to modify or
+publish new versions of this License. Each version will be given a
+distinguishing version number.
+
+10.2. Effect of New Versions
+
+You may distribute the Covered Software under the terms of the version
+of the License under which You originally received the Covered Software,
+or under the terms of any subsequent version published by the license
+steward.
+
+10.3. Modified Versions
+
+If you create software not governed by this License, and you want to
+create a new license for such software, you may create and use a
+modified version of this License if you rename the license and remove
+any references to the name of the license steward (except to note that
+such modified license differs from this License).
+
+10.4. Distributing Source Code Form that is Incompatible With Secondary
+Licenses
+
+If You choose to distribute Source Code Form that is Incompatible With
+Secondary Licenses under the terms of this version of the License, the
+notice described in Exhibit B of this License must be attached.
+
+Exhibit A - Source Code Form License Notice
+-------------------------------------------
+
+  This Source Code Form is subject to the terms of the Mozilla Public
+  License, v. 2.0. If a copy of the MPL was not distributed with this
+  file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+If it is not possible or desirable to put the notice in a particular
+file, then You may include the notice in a location (such as a LICENSE
+file in a relevant directory) where a recipient would be likely to look
+for such a notice.
+
+You may add additional accurate notices of copyright ownership.
+
+Exhibit B - "Incompatible With Secondary Licenses" Notice
+---------------------------------------------------------
+
+  This Source Code Form is "Incompatible With Secondary Licenses", as
+  defined by the Mozilla Public License, v. 2.0.
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/docs/LICENSE.OFL-1.1
@@ -0,0 +1,91 @@
+This Font Software is licensed under the SIL Open Font License, Version 1.1.
+This license is copied below, and is also available with a FAQ at:
+http://scripts.sil.org/OFL
+
+
+-----------------------------------------------------------
+SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
+-----------------------------------------------------------
+
+PREAMBLE
+The goals of the Open Font License (OFL) are to stimulate worldwide
+development of collaborative font projects, to support the font creation
+efforts of academic and linguistic communities, and to provide a free and
+open framework in which fonts may be shared and improved in partnership
+with others.
+
+The OFL allows the licensed fonts to be used, studied, modified and
+redistributed freely as long as they are not sold by themselves. The
+fonts, including any derivative works, can be bundled, embedded, 
+redistributed and/or sold with any software provided that any reserved
+names are not used by derivative works. The fonts and derivatives,
+however, cannot be released under any other type of license. The
+requirement for fonts to remain under this license does not apply
+to any document created using the fonts or their derivatives.
+
+DEFINITIONS
+"Font Software" refers to the set of files released by the Copyright
+Holder(s) under this license and clearly marked as such. This may
+include source files, build scripts and documentation.
+
+"Reserved Font Name" refers to any names specified as such after the
+copyright statement(s).
+
+"Original Version" refers to the collection of Font Software components as
+distributed by the Copyright Holder(s).
+
+"Modified Version" refers to any derivative made by adding to, deleting,
+or substituting -- in part or in whole -- any of the components of the
+Original Version, by changing formats or by porting the Font Software to a
+new environment.
+
+"Author" refers to any designer, engineer, programmer, technical
+writer or other person who contributed to the Font Software.
+
+PERMISSION & CONDITIONS
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of the Font Software, to use, study, copy, merge, embed, modify,
+redistribute, and sell modified and unmodified copies of the Font
+Software, subject to the following conditions:
+
+1) Neither the Font Software nor any of its individual components,
+in Original or Modified Versions, may be sold by itself.
+
+2) Original or Modified Versions of the Font Software may be bundled,
+redistributed and/or sold with any software, provided that each copy
+contains the above copyright notice and this license. These can be
+included either as stand-alone text files, human-readable headers or
+in the appropriate machine-readable metadata fields within text or
+binary files as long as those fields can be easily viewed by the user.
+
+3) No Modified Version of the Font Software may use the Reserved Font
+Name(s) unless explicit written permission is granted by the corresponding
+Copyright Holder. This restriction only applies to the primary font name as
+presented to the users.
+
+4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
+Software shall not be used to promote, endorse or advertise any
+Modified Version, except to acknowledge the contribution(s) of the
+Copyright Holder(s) and the Author(s) or with their explicit written
+permission.
+
+5) The Font Software, modified or unmodified, in part or in whole,
+must be distributed entirely under this license, and must not be
+distributed under any other license. The requirement for fonts to
+remain under this license does not apply to any document created
+using the Font Software.
+
+TERMINATION
+This license becomes null and void if any of the above conditions are
+not met.
+
+DISCLAIMER
+THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
+COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
+DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
+OTHER DEALINGS IN THE FONT SOFTWARE.
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/docs/flash_policy.txt
@@ -0,0 +1,4 @@
+Manual setup:
+
+DATA="echo \'<cross-domain-policy><allow-access-from domain=\\\"*\\\" to-ports=\\\"*\\\" /></cross-domain-policy>\'"
+/usr/bin/socat -T 1 TCP-L:843,reuseaddr,fork,crlf SYSTEM:"$DATA"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/docs/links
@@ -0,0 +1,76 @@
+New tight PNG protocol:
+    http://wiki.qemu.org/VNC_Tight_PNG
+    http://xf.iksaif.net/blog/index.php?post/2010/06/14/QEMU:-Tight-PNG-and-some-profiling
+
+RFB protocol and extensions:
+    http://tigervnc.org/cgi-bin/rfbproto
+
+Canvas Browser Compatibility:
+    http://philip.html5.org/tests/canvas/suite/tests/results.html
+
+WebSockets API standard:
+    http://www.whatwg.org/specs/web-apps/current-work/complete.html#websocket
+    http://dev.w3.org/html5/websockets/
+    http://www.ietf.org/id/draft-ietf-hybi-thewebsocketprotocol-00.txt
+
+Browser Keyboard Events detailed:
+    http://unixpapa.com/js/key.html
+
+ActionScript (Flash) WebSocket implementation:
+    http://github.com/gimite/web-socket-js
+
+ActionScript (Flash) crypto/TLS library:
+    http://code.google.com/p/as3crypto
+    http://github.com/lyokato/as3crypto_patched
+
+TLS Protocol:
+    http://en.wikipedia.org/wiki/Transport_Layer_Security
+
+Generate self-signed certificate:
+    http://docs.python.org/dev/library/ssl.html#certificates
+
+Cursor appearance/style (for Cursor pseudo-encoding):
+    http://en.wikipedia.org/wiki/ICO_(file_format)
+    http://www.daubnet.com/en/file-format-cur
+    https://developer.mozilla.org/en/Using_URL_values_for_the_cursor_property
+    http://www.fileformat.info/format/bmp/egff.htm
+
+Icon/Cursor file format:
+    http://msdn.microsoft.com/en-us/library/ms997538
+    http://msdn.microsoft.com/en-us/library/aa921550.aspx
+    http://msdn.microsoft.com/en-us/library/aa930622.aspx
+
+
+RDP Protocol specification:
+    http://msdn.microsoft.com/en-us/library/cc240445(v=PROT.10).aspx
+
+
+Related projects:
+    
+    guacamole: http://guacamole.sourceforge.net/
+
+        - Web client, but Java servlet does pre-processing
+
+    jsvnc: http://code.google.com/p/jsvnc/
+
+        - No releases
+
+    webvnc: http://code.google.com/p/webvnc/
+
+        - Jetty web server gateway, no updates since April 2008.
+
+    RealVNC Java applet: http://www.realvnc.com/support/javavncviewer.html
+
+        - Java applet
+
+    Flashlight-VNC: http://www.wizhelp.com/flashlight-vnc/
+
+        - Adobe Flash implementation
+
+    FVNC: http://osflash.org/fvnc
+
+        - Adbove Flash implementation
+
+    CanVNC: http://canvnc.sourceforge.net/
+
+        - HTML client with REST to VNC python proxy. Mostly vapor.
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/docs/notes
@@ -0,0 +1,5 @@
+Rebuilding inflator.js
+
+- Download pako from npm
+- Install browserify using npm
+- browserify core/inflator.mod.js -o core/inflator.js -s Inflator
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/docs/novnc_proxy.1
@@ -0,0 +1,37 @@
+.TH novnc_proxy 1  "June 25, 2020" "version 1.2.0" "USER COMMANDS"
+
+.SH NAME
+novnc_proxy - noVNC proxy server
+.SH SYNOPSIS
+.B novnc_proxy [--listen PORT] [--vnc VNC_HOST:PORT] [--cert CERT] [--ssl-only]
+
+Starts the WebSockets proxy and a mini-webserver and
+provides a cut-and-paste URL to go to.
+
+    --listen PORT         Port for proxy/webserver to listen on
+                          Default: 6080
+    --vnc VNC_HOST:PORT   VNC server host:port proxy target
+                          Default: localhost:5900
+    --cert CERT           Path to combined cert/key file, or just
+                          the cert file if used with --key
+                          Default: self.pem
+    --key KEY             Path to key file, when not combined with cert
+    --web WEB             Path to web files (e.g. vnc.html)
+                          Default: ./
+    --ssl-only            Disable non-https connections.
+
+    --record FILE         Record traffic to FILE.session.js
+
+    --syslog SERVER       Can be local socket such as /dev/log, or a UDP host:port pair.
+
+    --heartbeat SEC       send a ping to the client every SEC seconds
+    --timeout SEC         after SEC seconds exit when not connected
+    --idle-timeout SEC    server exits after SEC seconds if there are no
+                          active connections
+
+.SH AUTHOR
+The noVNC Authors
+https://github.com/novnc/noVNC
+
+.SH SEE ALSO
+websockify(1), nova-novncproxy(1)
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/docs/rfb_notes
@@ -0,0 +1,147 @@
+5.1.1 ProtocolVersion: 12, 12 bytes
+
+    - Sent by server, max supported
+        12 ascii - "RFB 003.008\n"
+    - Response by client, version to use
+        12 ascii - "RFB 003.003\n"
+
+5.1.2 Authentication: >=4, [16, 4] bytes
+
+    - Sent by server
+        CARD32 - authentication-scheme
+                0 - connection failed
+                    CARD32 - length
+                    length - reason
+                1 - no authentication
+
+                2 - VNC authentication
+                    16 CARD8 - challenge (random bytes)
+
+    - Response by client (if VNC authentication)
+        16 CARD8 - client encrypts the challenge with DES, using user
+                   password as key, sends resulting 16 byte response
+
+    - Response by server (if VNC authentication) 
+        CARD32 - 0 - OK
+                 1 - failed
+                 2 - too-many
+
+5.1.3 ClientInitialisation: 1 byte
+    - Sent by client
+        CARD8 - shared-flag, 0 exclusive, non-zero shared
+
+5.1.4 ServerInitialisation: >=24 bytes
+    - Sent by server
+        CARD16 - framebuffer-width
+        CARD16 - framebuffer-height
+        16 byte PIXEL_FORMAT - server-pixel-format
+            CARD8 - bits-per-pixel
+            CARD8 - depth
+            CARD8 - big-endian-flag, non-zero is big endian
+            CARD8 - true-color-flag, non-zero then next 6 apply
+            CARD16 - red-max
+            CARD16 - green-max
+            CARD16 - blue-max
+            CARD8 - red-shift
+            CARD8 - green-shift
+            CARD8 - blue-shift
+            3 bytes - padding
+        CARD32 - name-length
+
+        CARD8[length] - name-string
+
+
+
+Client to Server Messages:
+
+5.2.1 SetPixelFormat: 20 bytes
+    CARD8: 0 - message-type
+    ...
+
+5.2.2 FixColourMapEntries: >=6 bytes
+    CARD8: 1 - message-type
+    ...
+
+5.2.3 SetEncodings: >=8 bytes
+    CARD8: 2 - message-type
+    CARD8    - padding
+    CARD16   - numer-of-encodings
+
+    CARD32   - encoding-type in preference order
+        0 - raw
+        1 - copy-rectangle
+        2 - RRE
+        4 - CoRRE
+        5 - hextile
+
+5.2.4 FramebufferUpdateRequest (10 bytes)
+    CARD8: 3 - message-type
+    CARD8    - incremental (0 for full-update, non-zero for incremental)
+    CARD16   - x-position
+    CARD16   - y-position
+    CARD16   - width
+    CARD16   - height
+
+
+5.2.5 KeyEvent: 8 bytes
+    CARD8: 4 - message-type
+    CARD8    - down-flag
+    2 bytes  - padding
+    CARD32   - key (X-Windows keysym values)
+
+5.2.6 PointerEvent: 6 bytes
+    CARD8: 5 - message-type
+    CARD8    - button-mask
+    CARD16   - x-position
+    CARD16   - y-position
+
+5.2.7 ClientCutText: >=9 bytes
+    CARD8: 6 - message-type
+    ...
+
+
+Server to Client Messages:
+
+5.3.1 FramebufferUpdate
+    CARD8: 0 - message-type
+    1 byte   - padding
+    CARD16   - number-of-rectangles
+
+    CARD16   - x-position
+    CARD16   - y-position
+    CARD16   - width
+    CARD16   - height
+    CARD16   - encoding-type:
+        0 - raw
+        1 - copy rectangle
+        2 - RRE
+        4 - CoRRE
+        5 - hextile
+
+        raw:
+            - width x height pixel values
+
+        copy rectangle: 
+            CARD16 - src-x-position
+            CARD16 - src-y-position
+
+        RRE:
+            CARD32  - N number-of-subrectangles
+            Nxd bytes - background-pixel-value (d bits-per-pixel)
+
+        ...
+
+5.3.2 SetColourMapEntries (no support)
+    CARD8: 1 - message-type
+    ...
+
+5.3.3 Bell
+    CARD8: 2 - message-type
+
+5.3.4 ServerCutText
+    CARD8: 3 - message-type
+
+
+
+
+    
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/images/Oltre 1000 immagini di campo verde - Scarica immagini gratuite su Unsplash.url	
@@ -0,0 +1,2 @@
+[InternetShortcut]
+URL=https://unsplash.com/pt-br/s/fotografias/campo-verde
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/base.css
@@ -0,0 +1,512 @@
+/*
+ * noVNC base CSS
+ * Copyright (C) 2012 Joel Martin
+ * Copyright (C) 2013 Samuel Mannehed for Cendio AB
+ * noVNC is licensed under the MPL 2.0 (see LICENSE.txt)
+ * This file is licensed under the 2-Clause BSD license (see LICENSE.txt).
+ */
+
+body {
+  margin:0;
+  padding:0;
+  font-family: Helvetica;
+  /*Background image with light grey curve.*/
+  background-color:#494949;
+  background-repeat:no-repeat;
+  background-position:right bottom;
+  height:100%;
+}
+
+html {
+  height:100%;
+}
+
+#noVNC_controls ul {
+  list-style: none;
+  margin: 0px;
+  padding: 0px;
+}
+#noVNC_controls li {
+  padding-bottom:8px;
+}
+
+#noVNC_host {
+  width:150px;
+}
+#noVNC_port {
+  width: 80px;
+}
+#noVNC_password {
+  width: 150px;
+}
+#noVNC_encrypt {
+}
+#noVNC_path {
+  width: 100px;
+}
+#noVNC_connect_button {
+  width: 110px;
+  float:right;
+}
+
+#noVNC_buttons {
+  white-space: nowrap;
+}
+
+#noVNC_view_drag_button {
+  display: none;
+}
+#sendCtrlAltDelButton {
+  display: none;
+}
+#noVNC_xvp_buttons {
+  display: none;
+}
+#noVNC_mobile_buttons {
+  display: none;
+}
+
+#noVNC_extra_keys {
+  display: inline;
+  list-style-type: none;
+  padding: 0px;
+  margin: 0px;
+  position: relative;
+}
+
+.noVNC-buttons-left {
+  float: left;
+  z-index: 1;
+  position: relative;
+}
+
+.noVNC-buttons-right {
+  float:right;
+  right: 0px;
+  z-index: 2;
+  position: absolute;
+}
+
+#noVNC_status {
+  font-size: 12px;
+  padding-top: 4px;
+  height:32px;
+  text-align: center;
+  font-weight: bold;
+  color: #fff;
+}
+
+#noVNC_settings_menu {
+  margin: 3px;
+  text-align: left;
+}
+#noVNC_settings_menu ul {
+  list-style: none;
+  margin: 0px;
+  padding: 0px;
+}
+
+#noVNC_apply {
+  float:right;
+}
+
+/* Do not set width/height for VNC_screen or VNC_canvas or incorrect
+ * scaling will occur. Canvas resizes to remote VNC settings */
+#noVNC_screen_pad {
+  margin: 0px;
+  padding: 0px;
+  height: 36px;
+}
+#noVNC_screen {
+  text-align: center;
+  display: table;
+  width:100%;
+  height:100%;
+  background-color:#313131;
+  border-bottom-right-radius: 800px 600px;
+  /*border-top-left-radius: 800px 600px;*/
+}
+
+#noVNC_container, #noVNC_canvas {
+  margin: 0px;
+  padding: 0px;
+}
+
+#noVNC_canvas {
+  left: 0px;
+}
+
+#VNC_clipboard_clear_button {
+  float:right;
+}
+#VNC_clipboard_text {
+  font-size: 11px;
+}
+
+#noVNC_clipboard_clear_button {
+  float:right;
+}
+
+/*Bubble contents divs*/
+#noVNC_settings {
+  display:none;
+  margin-top:73px;
+  right:20px;
+  position:fixed;
+}
+
+#noVNC_controls {
+  display:none;
+  margin-top:73px;
+  right:12px;
+  position:fixed;
+}
+#noVNC_controls.top:after  {
+  right:15px;
+}
+
+#noVNC_description {
+  display:none;
+  position:fixed;
+
+  margin-top:73px;
+  right:20px;
+  left:20px;
+  padding:15px;
+  color:#000;
+  background:#eee; /* default background for browsers without gradient support */
+
+  border:2px solid #E0E0E0;
+  -webkit-border-radius:10px;
+  -moz-border-radius:10px;
+  border-radius:10px;
+}
+
+#noVNC_popup_status_panel {
+  display:none;
+  position: fixed;
+  z-index: 1;
+
+  margin:15px;
+  margin-top:60px;
+  padding:15px;
+  width:auto;
+
+  text-align:center;
+  font-weight:bold;
+  word-wrap:break-word;
+  color:#fff;
+  background:rgba(0,0,0,0.65);
+
+  -webkit-border-radius:10px;
+  -moz-border-radius:10px;
+  border-radius:10px;
+}
+
+#noVNC_xvp {
+  display:none;
+  margin-top:73px;
+  right:30px;
+  position:fixed;
+}
+#noVNC_xvp.top:after {
+  right:125px;
+}
+
+#noVNC_clipboard {
+  display:none;
+  margin-top:73px;
+  right:30px;
+  position:fixed;
+}
+#noVNC_clipboard.top:after {
+  right:85px;
+}
+
+#keyboardinput {
+  width:1px;
+  height:1px;
+  background-color:#fff;
+  color:#fff;
+  border:0;
+  position: relative;
+  left: -40px;
+  z-index: -1;
+}
+
+/*
+ * Advanced Styling
+ */
+
+.noVNC_status_normal {
+  background: #b2bdcd; /* Old browsers */
+  background: -moz-linear-gradient(top, #b2bdcd 0%, #899cb3 49%, #7e93af 51%, #6e84a3 100%); /* FF3.6+ */
+  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#b2bdcd), color-stop(49%,#899cb3), color-stop(51%,#7e93af), color-stop(100%,#6e84a3)); /* Chrome,Safari4+ */
+  background: -webkit-linear-gradient(top, #b2bdcd 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* Chrome10+,Safari5.1+ */
+  background: -o-linear-gradient(top, #b2bdcd 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* Opera11.10+ */
+  background: -ms-linear-gradient(top, #b2bdcd 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* IE10+ */
+  background: linear-gradient(top, #b2bdcd 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* W3C */
+}
+.noVNC_status_error {
+  background: #f04040; /* Old browsers */
+  background: -moz-linear-gradient(top, #f04040 0%, #899cb3 49%, #7e93af 51%, #6e84a3 100%); /* FF3.6+ */
+  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f04040), color-stop(49%,#899cb3), color-stop(51%,#7e93af), color-stop(100%,#6e84a3)); /* Chrome,Safari4+ */
+  background: -webkit-linear-gradient(top, #f04040 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* Chrome10+,Safari5.1+ */
+  background: -o-linear-gradient(top, #f04040 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* Opera11.10+ */
+  background: -ms-linear-gradient(top, #f04040 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* IE10+ */
+  background: linear-gradient(top, #f04040 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* W3C */
+}
+.noVNC_status_warn {
+  background: #f0f040; /* Old browsers */
+  background: -moz-linear-gradient(top, #f0f040 0%, #899cb3 49%, #7e93af 51%, #6e84a3 100%); /* FF3.6+ */
+  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f0f040), color-stop(49%,#899cb3), color-stop(51%,#7e93af), color-stop(100%,#6e84a3)); /* Chrome,Safari4+ */
+  background: -webkit-linear-gradient(top, #f0f040 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* Chrome10+,Safari5.1+ */
+  background: -o-linear-gradient(top, #f0f040 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* Opera11.10+ */
+  background: -ms-linear-gradient(top, #f0f040 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* IE10+ */
+  background: linear-gradient(top, #f0f040 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* W3C */
+}
+
+/* Control bar */
+#noVNC-control-bar {
+  position:fixed;
+  
+  display:block;
+  height:36px;
+  left:0;
+  top:0;
+  width:100%;
+  z-index:200;
+}
+
+.noVNC_status_button {
+  padding: 4px 4px;
+  vertical-align: middle;
+  border:1px solid #869dbc;
+  -webkit-border-radius: 6px;
+  -moz-border-radius: 6px;
+  border-radius: 6px;
+  background: #b2bdcd; /* Old browsers */
+  background: -moz-linear-gradient(top, #b2bdcd 0%, #899cb3 49%, #7e93af 51%, #6e84a3 100%); /* FF3.6+ */
+  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#b2bdcd), color-stop(49%,#899cb3), color-stop(51%,#7e93af), color-stop(100%,#6e84a3)); /* Chrome,Safari4+ */
+  background: -webkit-linear-gradient(top, #b2bdcd 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* Chrome10+,Safari5.1+ */
+  background: -o-linear-gradient(top, #b2bdcd 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* Opera11.10+ */
+  background: -ms-linear-gradient(top, #b2bdcd 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* IE10+ */
+  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#b2bdcd', endColorstr='#6e84a3',GradientType=0 ); /* IE6-9 */
+  background: linear-gradient(top, #b2bdcd 0%,#899cb3 49%,#7e93af 51%,#6e84a3 100%); /* W3C */
+  /*box-shadow:inset 0.4px 0.4px 0.4px #000000;*/
+}
+
+.noVNC_status_button_selected {
+  padding: 4px 4px;
+  vertical-align: middle;
+  border:1px solid #4366a9;
+  -webkit-border-radius: 6px;
+  -moz-border-radius: 6px;
+  background: #779ced; /* Old browsers */
+  background: -moz-linear-gradient(top, #779ced 0%, #3970e0 49%, #2160dd 51%, #2463df 100%); /* FF3.6+ */
+  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#779ced), color-stop(49%,#3970e0), color-stop(51%,#2160dd), color-stop(100%,#2463df)); /* Chrome,Safari4+ */
+  background: -webkit-linear-gradient(top, #779ced 0%,#3970e0 49%,#2160dd 51%,#2463df 100%); /* Chrome10+,Safari5.1+ */
+  background: -o-linear-gradient(top, #779ced 0%,#3970e0 49%,#2160dd 51%,#2463df 100%); /* Opera11.10+ */
+  background: -ms-linear-gradient(top, #779ced 0%,#3970e0 49%,#2160dd 51%,#2463df 100%); /* IE10+ */
+  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#779ced', endColorstr='#2463df',GradientType=0 ); /* IE6-9 */
+  background: linear-gradient(top, #779ced 0%,#3970e0 49%,#2160dd 51%,#2463df 100%); /* W3C */
+ /*box-shadow:inset 0.4px 0.4px 0.4px #000000;*/
+}
+
+
+/*Settings Bubble*/
+.triangle-right {
+  position:relative;
+  padding:15px;
+  margin:1em 0 3em;
+  color:#fff;
+  background:#fff; /* default background for browsers without gradient support */
+  /* css3 */
+  /*background:-webkit-gradient(linear, 0 0, 0 100%, from(#2e88c4), to(#075698));
+  background:-moz-linear-gradient(#2e88c4, #075698);
+  background:-o-linear-gradient(#2e88c4, #075698);
+  background:linear-gradient(#2e88c4, #075698);*/
+  -webkit-border-radius:10px;
+  -moz-border-radius:10px;
+  border-radius:10px;
+  color:#000;
+  border:2px solid #E0E0E0;
+}
+
+.triangle-right.top:after {
+  border-color: transparent #E0E0E0;
+  border-width: 20px 20px 0 0;
+  bottom: auto;
+  left: auto;
+  right: 50px;
+  top: -20px;
+}
+
+.triangle-right:after {
+  content:"";
+  position:absolute;
+  bottom:-20px; /* value = - border-top-width - border-bottom-width */
+  left:50px; /* controls horizontal position */
+  border-width:20px 0 0 20px; /* vary these values to change the angle of the vertex */
+  border-style:solid;
+  border-color:#E0E0E0 transparent;
+  /* reduce the damage in FF3.0 */
+  display:block;
+  width:0;
+}
+
+.triangle-right.top:after {
+  top:-40px; /* value = - border-top-width - border-bottom-width */
+  right:50px; /* controls horizontal position */
+  bottom:auto;
+  left:auto;
+  border-width:40px 40px 0 0; /* vary these values to change the angle of the vertex */
+  border-color:transparent #E0E0E0;
+}
+
+/*Default noVNC logo.*/
+/* From: http://fonts.googleapis.com/css?family=Orbitron:700 */
+@font-face {
+  font-family: 'Orbitron';
+  font-style: normal;
+  font-weight: 700;
+  src: local('?'), url('Orbitron700.woff') format('woff'),
+                   url('Orbitron700.ttf') format('truetype');
+}
+
+#noVNC_logo {
+  margin-top: 170px;
+  margin-left: 10px;
+  color:yellow;
+  text-align:left;
+  font-family: 'Orbitron', 'OrbitronTTF', sans-serif;
+  line-height:90%;
+  text-shadow:
+       5px 5px 0 #000,
+      -1px -1px 0 #000,
+       1px -1px 0 #000,
+      -1px 1px 0 #000,
+       1px 1px 0 #000;
+}
+
+
+#noVNC_logo span{
+  color:green;
+}
+
+/* ----------------------------------------
+ * Media sizing
+ * ----------------------------------------
+ */
+
+
+.noVNC_status_button {
+  font-size: 12px;
+}
+
+#noVNC_clipboard_text {
+  width: 500px;
+}
+
+#noVNC_logo {
+  font-size: 180px;
+}
+
+.noVNC-buttons-left {
+  padding-left: 10px;
+}
+
+.noVNC-buttons-right {
+  padding-right: 10px;
+}
+
+#noVNC_status {
+  z-index: 0;
+  position: absolute;
+  width: 100%;
+  margin-left: 0px;
+}
+
+#showExtraKeysButton { display: none; }
+#toggleCtrlButton { display: inline; }
+#toggleAltButton {  display: inline; }
+#sendTabButton { display: inline; }
+#sendEscButton { display: inline; }
+
+/* left-align the status text on lower resolutions */
+@media screen and (max-width: 800px){
+  #noVNC_status {
+    z-index: 1;
+    position: relative;
+    width: auto;
+    float: left;
+    margin-left: 4px;
+  }
+}
+
+@media screen and (max-width: 640px){
+  #noVNC_clipboard_text {
+    width: 410px;
+  }
+  #noVNC_logo {
+    font-size: 150px;
+  }
+  .noVNC_status_button {
+    font-size: 10px;
+  }
+  .noVNC-buttons-left {
+    padding-left: 0px;
+  }
+  .noVNC-buttons-right {
+    padding-right: 0px;
+  }
+  /* collapse the extra keys on lower resolutions */
+  #showExtraKeysButton {
+    display: inline;
+  }
+  #toggleCtrlButton {
+    display: none;
+    position: absolute;
+    top: 30px;
+    left: 0px;
+  }
+  #toggleAltButton {
+    display: none;
+    position: absolute;
+    top: 65px;
+    left: 0px;
+  }
+  #sendTabButton {
+    display: none;
+    position: absolute;
+    top: 100px;
+    left: 0px;
+  }
+  #sendEscButton {
+    display: none;
+    position: absolute;
+    top: 135px;
+    left: 0px;
+  }
+}
+
+@media screen and (min-width: 321px) and (max-width: 480px) {
+  #noVNC_clipboard_text {
+    width: 250px;
+  }
+  #noVNC_logo {
+    font-size: 110px;
+  }
+}
+
+@media screen and (max-width: 320px) {
+  .noVNC_status_button {
+    font-size: 9px;
+  }
+  #noVNC_clipboard_text {
+    width: 220px;
+  }
+  #noVNC_logo {
+    font-size: 90px;
+  }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/base64.js
@@ -0,0 +1,113 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// From: http://hg.mozilla.org/mozilla-central/raw-file/ec10630b1a54/js/src/devtools/jint/sunspider/string-base64.js
+
+/*jslint white: false */
+/*global console */
+
+var Base64 = {
+    /* Convert data (an array of integers) to a Base64 string. */
+    toBase64Table : 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split(''),
+    base64Pad     : '=',
+
+    encode: function (data) {
+        "use strict";
+        var result = '';
+        var toBase64Table = Base64.toBase64Table;
+        var length = data.length;
+        var lengthpad = (length % 3);
+        // Convert every three bytes to 4 ascii characters.
+
+        for (var i = 0; i < (length - 2); i += 3) {
+            result += toBase64Table[data[i] >> 2];
+            result += toBase64Table[((data[i] & 0x03) << 4) + (data[i + 1] >> 4)];
+            result += toBase64Table[((data[i + 1] & 0x0f) << 2) + (data[i + 2] >> 6)];
+            result += toBase64Table[data[i + 2] & 0x3f];
+        }
+
+        // Convert the remaining 1 or 2 bytes, pad out to 4 characters.
+        var j = 0;
+        if (lengthpad === 2) {
+            j = length - lengthpad;
+            result += toBase64Table[data[j] >> 2];
+            result += toBase64Table[((data[j] & 0x03) << 4) + (data[j + 1] >> 4)];
+            result += toBase64Table[(data[j + 1] & 0x0f) << 2];
+            result += toBase64Table[64];
+        } else if (lengthpad === 1) {
+            j = length - lengthpad;
+            result += toBase64Table[data[j] >> 2];
+            result += toBase64Table[(data[j] & 0x03) << 4];
+            result += toBase64Table[64];
+            result += toBase64Table[64];
+        }
+
+        return result;
+    },
+
+    /* Convert Base64 data to a string */
+    /* jshint -W013 */
+    toBinaryTable : [
+        -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
+        -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
+        -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,62, -1,-1,-1,63,
+        52,53,54,55, 56,57,58,59, 60,61,-1,-1, -1, 0,-1,-1,
+        -1, 0, 1, 2,  3, 4, 5, 6,  7, 8, 9,10, 11,12,13,14,
+        15,16,17,18, 19,20,21,22, 23,24,25,-1, -1,-1,-1,-1,
+        -1,26,27,28, 29,30,31,32, 33,34,35,36, 37,38,39,40,
+        41,42,43,44, 45,46,47,48, 49,50,51,-1, -1,-1,-1,-1
+    ],
+    /* jshint +W013 */
+
+    decode: function (data, offset) {
+        "use strict";
+        offset = typeof(offset) !== 'undefined' ? offset : 0;
+        var toBinaryTable = Base64.toBinaryTable;
+        var base64Pad = Base64.base64Pad;
+        var result, result_length;
+        var leftbits = 0; // number of bits decoded, but yet to be appended
+        var leftdata = 0; // bits decoded, but yet to be appended
+        var data_length = data.indexOf('=') - offset;
+
+        if (data_length < 0) { data_length = data.length - offset; }
+
+        /* Every four characters is 3 resulting numbers */
+        result_length = (data_length >> 2) * 3 + Math.floor((data_length % 4) / 1.5);
+        result = new Array(result_length);
+
+        // Convert one by one.
+        for (var idx = 0, i = offset; i < data.length; i++) {
+            var c = toBinaryTable[data.charCodeAt(i) & 0x7f];
+            var padding = (data.charAt(i) === base64Pad);
+            // Skip illegal characters and whitespace
+            if (c === -1) {
+                console.error("Illegal character code " + data.charCodeAt(i) + " at position " + i);
+                continue;
+            }
+          
+            // Collect data into leftdata, update bitcount
+            leftdata = (leftdata << 6) | c;
+            leftbits += 6;
+
+            // If we have 8 or more bits, append 8 bits to the result
+            if (leftbits >= 8) {
+                leftbits -= 8;
+                // Append if not padding.
+                if (!padding) {
+                    result[idx++] = (leftdata >> leftbits) & 0xff;
+                }
+                leftdata &= (1 << leftbits) - 1;
+            }
+        }
+
+        // If there are any bits left, the base64 string was corrupted
+        if (leftbits) {
+            err = new Error('Corrupted base64 string');
+            err.name = 'Base64-Error';
+            throw err;
+        }
+
+        return result;
+    }
+}; /* End of Base64 namespace */
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/black.css
@@ -0,0 +1,71 @@
+/*
+ * noVNC black CSS
+ * Copyright (C) 2012 Joel Martin
+ * Copyright (C) 2013 Samuel Mannehed for Cendio AB
+ * noVNC is licensed under the MPL 2.0 (see LICENSE.txt)
+ * This file is licensed under the 2-Clause BSD license (see LICENSE.txt).
+ */
+
+#keyboardinput {
+  background-color:#000;
+}
+
+.noVNC_status_normal {
+  background: #4c4c4c; /* Old browsers */
+  background: -moz-linear-gradient(top, #4c4c4c 0%, #2c2c2c 50%, #000000 51%, #131313 100%); /* FF3.6+ */
+  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#4c4c4c), color-stop(50%,#2c2c2c), color-stop(51%,#000000), color-stop(100%,#131313)); /* Chrome,Safari4+ */
+  background: -webkit-linear-gradient(top, #4c4c4c 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* Chrome10+,Safari5.1+ */
+  background: -o-linear-gradient(top, #4c4c4c 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* Opera11.10+ */
+  background: -ms-linear-gradient(top, #4c4c4c 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* IE10+ */
+  background: linear-gradient(top, #4c4c4c 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* W3C */
+}
+.noVNC_status_error {
+  background: #f04040; /* Old browsers */
+  background: -moz-linear-gradient(top, #f04040 0%, #2c2c2c 50%, #000000 51%, #131313 100%); /* FF3.6+ */
+  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f04040), color-stop(50%,#2c2c2c), color-stop(51%,#000000), color-stop(100%,#131313)); /* Chrome,Safari4+ */
+  background: -webkit-linear-gradient(top, #f04040 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* Chrome10+,Safari5.1+ */
+  background: -o-linear-gradient(top, #f04040 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* Opera11.10+ */
+  background: -ms-linear-gradient(top, #f04040 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* IE10+ */
+  background: linear-gradient(top, #f04040 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* W3C */
+}
+.noVNC_status_warn {
+  background: #f0f040; /* Old browsers */
+  background: -moz-linear-gradient(top, #f0f040 0%, #2c2c2c 50%, #000000 51%, #131313 100%); /* FF3.6+ */
+  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f0f040), color-stop(50%,#2c2c2c), color-stop(51%,#000000), color-stop(100%,#131313)); /* Chrome,Safari4+ */
+  background: -webkit-linear-gradient(top, #f0f040 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* Chrome10+,Safari5.1+ */
+  background: -o-linear-gradient(top, #f0f040 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* Opera11.10+ */
+  background: -ms-linear-gradient(top, #f0f040 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* IE10+ */
+  background: linear-gradient(top, #f0f040 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* W3C */
+}
+
+.triangle-right {
+  border:2px solid #fff;
+  background:#000;
+  color:#fff;
+}
+
+.noVNC_status_button {
+  font-size: 12px;
+  vertical-align: middle;
+  border:1px solid #4c4c4c;
+
+  background: #4c4c4c; /* Old browsers */
+  background: -moz-linear-gradient(top, #4c4c4c 0%, #2c2c2c 50%, #000000 51%, #131313 100%); /* FF3.6+ */
+  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#4c4c4c), color-stop(50%,#2c2c2c), color-stop(51%,#000000), color-stop(100%,#131313)); /* Chrome,Safari4+ */
+  background: -webkit-linear-gradient(top, #4c4c4c 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* Chrome10+,Safari5.1+ */
+  background: -o-linear-gradient(top, #4c4c4c 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* Opera11.10+ */
+  background: -ms-linear-gradient(top, #4c4c4c 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* IE10+ */
+  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#4c4c4c', endColorstr='#131313',GradientType=0 ); /* IE6-9 */
+  background: linear-gradient(top, #4c4c4c 0%,#2c2c2c 50%,#000000 51%,#131313 100%); /* W3C */
+}
+
+.noVNC_status_button_selected {
+  background: #9dd53a; /* Old browsers */
+  background: -moz-linear-gradient(top, #9dd53a 0%, #a1d54f 50%, #80c217 51%, #7cbc0a 100%); /* FF3.6+ */
+  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#9dd53a), color-stop(50%,#a1d54f), color-stop(51%,#80c217), color-stop(100%,#7cbc0a)); /* Chrome,Safari4+ */
+  background: -webkit-linear-gradient(top, #9dd53a 0%,#a1d54f 50%,#80c217 51%,#7cbc0a 100%); /* Chrome10+,Safari5.1+ */
+  background: -o-linear-gradient(top, #9dd53a 0%,#a1d54f 50%,#80c217 51%,#7cbc0a 100%); /* Opera11.10+ */
+  background: -ms-linear-gradient(top, #9dd53a 0%,#a1d54f 50%,#80c217 51%,#7cbc0a 100%); /* IE10+ */
+  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#9dd53a', endColorstr='#7cbc0a',GradientType=0 ); /* IE6-9 */
+  background: linear-gradient(top, #9dd53a 0%,#a1d54f 50%,#80c217 51%,#7cbc0a 100%); /* W3C */
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/blue.css
@@ -0,0 +1,64 @@
+/*
+ * noVNC blue CSS
+ * Copyright (C) 2012 Joel Martin
+ * Copyright (C) 2013 Samuel Mannehed for Cendio AB
+ * noVNC is licensed under the MPL 2.0 (see LICENSE.txt)
+ * This file is licensed under the 2-Clause BSD license (see LICENSE.txt).
+ */
+
+.noVNC_status_normal {
+  background-color:#04073d;
+  background-image: -webkit-gradient(
+    linear,
+    left bottom,
+    left top,
+    color-stop(0.54, rgb(10,15,79)),
+    color-stop(0.5, rgb(4,7,61))
+  );
+  background-image: -moz-linear-gradient(
+    center bottom,
+    rgb(10,15,79) 54%,
+    rgb(4,7,61) 50%
+  );
+}
+.noVNC_status_error {
+  background-color:#f04040;
+  background-image: -webkit-gradient(
+    linear,
+    left bottom,
+    left top,
+    color-stop(0.54, rgb(240,64,64)),
+    color-stop(0.5, rgb(4,7,61))
+  );
+  background-image: -moz-linear-gradient(
+    center bottom,
+    rgb(4,7,61) 54%,
+    rgb(249,64,64) 50%
+  );
+}
+.noVNC_status_warn {
+  background-color:#f0f040;
+  background-image: -webkit-gradient(
+    linear,
+    left bottom,
+    left top,
+    color-stop(0.54, rgb(240,240,64)),
+    color-stop(0.5, rgb(4,7,61))
+  );
+  background-image: -moz-linear-gradient(
+    center bottom,
+    rgb(4,7,61) 54%,
+    rgb(240,240,64) 50%
+  );
+}
+
+.triangle-right {
+  border:2px solid #fff;
+  background:#04073d;
+  color:#fff;
+}
+
+#keyboardinput {
+  background-color:#04073d;
+}
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/chrome-app/tcp-client.js
@@ -0,0 +1,321 @@
+/*
+Copyright 2012 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+Author: Boris Smus (smus@chromium.org)
+*/
+
+(function(exports) {
+
+  // Define some local variables here.
+  var socket = chrome.socket || chrome.experimental.socket;
+  var dns = chrome.experimental.dns;
+
+  /**
+   * Creates an instance of the client
+   *
+   * @param {String} host The remote host to connect to
+   * @param {Number} port The port to connect to at the remote host
+   */
+  function TcpClient(host, port, pollInterval) {
+    this.host = host;
+    this.port = port;
+    this.pollInterval = pollInterval || 15;
+
+    // Callback functions.
+    this.callbacks = {
+      connect: null,    // Called when socket is connected.
+      disconnect: null, // Called when socket is disconnected.
+      recvBuffer: null, // Called (as ArrayBuffer) when client receives data from server.
+      recvString: null, // Called (as string) when client receives data from server.
+      sent: null        // Called when client sends data to server.
+    };
+
+    // Socket.
+    this.socketId = null;
+    this.isConnected = false;
+
+    log('initialized tcp client');
+  }
+
+  /**
+   * Connects to the TCP socket, and creates an open socket.
+   *
+   * @see http://developer.chrome.com/trunk/apps/socket.html#method-create
+   * @param {Function} callback The function to call on connection
+   */
+  TcpClient.prototype.connect = function(callback) {
+    // First resolve the hostname to an IP.
+    dns.resolve(this.host, function(result) {
+      this.addr = result.address;
+      socket.create('tcp', {}, this._onCreate.bind(this));
+
+      // Register connect callback.
+      this.callbacks.connect = callback;
+    }.bind(this));
+  };
+
+  /**
+   * Sends an arraybuffer/view down the wire to the remote side
+   *
+   * @see http://developer.chrome.com/trunk/apps/socket.html#method-write
+   * @param {String} msg The arraybuffer/view to send
+   * @param {Function} callback The function to call when the message has sent
+   */
+  TcpClient.prototype.sendBuffer = function(buf, callback) {
+    if (buf.buffer) {
+        buf = buf.buffer;
+    }
+
+    /*
+    // Debug
+    var bytes = [], u8 = new Uint8Array(buf);
+    for (var i = 0; i < u8.length; i++) {
+        bytes.push(u8[i]);
+    }
+    log("sending bytes: " + (bytes.join(',')));
+    */
+    
+    socket.write(this.socketId, buf, this._onWriteComplete.bind(this));
+
+    // Register sent callback.
+    this.callbacks.sent = callback;
+  };
+
+  /**
+   * Sends a string down the wire to the remote side
+   *
+   * @see http://developer.chrome.com/trunk/apps/socket.html#method-write
+   * @param {String} msg The string to send
+   * @param {Function} callback The function to call when the message has sent
+   */
+  TcpClient.prototype.sendString = function(msg, callback) {
+    /*
+    // Debug
+    log("sending string: " + msg);
+    */
+
+    this._stringToArrayBuffer(msg, function(arrayBuffer) {
+      socket.write(this.socketId, arrayBuffer, this._onWriteComplete.bind(this));
+    }.bind(this));
+
+    // Register sent callback.
+    this.callbacks.sent = callback;
+  };
+
+  /**
+   * Sets the callback for when a message is received
+   *
+   * @param {Function} callback The function to call when a message has arrived
+   * @param {String} type The callback argument type: "arraybuffer" or "string"
+   */
+  TcpClient.prototype.addResponseListener = function(callback, type) {
+    if (typeof type === "undefined") {
+        type = "arraybuffer";
+    }
+    // Register received callback.
+    if (type === "string") {
+      this.callbacks.recvString = callback;
+    } else {
+      this.callbacks.recvBuffer = callback;
+    }
+  };
+
+  /**
+   * Sets the callback for when the socket disconnects
+   *
+   * @param {Function} callback The function to call when the socket disconnects
+   * @param {String} type The callback argument type: "arraybuffer" or "string"
+   */
+  TcpClient.prototype.addDisconnectListener = function(callback) {
+    // Register disconnect callback.
+    this.callbacks.disconnect = callback;
+  };
+
+  /**
+   * Disconnects from the remote side
+   *
+   * @see http://developer.chrome.com/trunk/apps/socket.html#method-disconnect
+   */
+  TcpClient.prototype.disconnect = function() {
+    if (this.isConnected) {
+      this.isConnected = false;
+      socket.disconnect(this.socketId);
+      if (this.callbacks.disconnect) {
+        this.callbacks.disconnect();
+      }
+      log('socket disconnected');
+    }
+  };
+
+  /**
+   * The callback function used for when we attempt to have Chrome
+   * create a socket. If the socket is successfully created
+   * we go ahead and connect to the remote side.
+   *
+   * @private
+   * @see http://developer.chrome.com/trunk/apps/socket.html#method-connect
+   * @param {Object} createInfo The socket details
+   */
+  TcpClient.prototype._onCreate = function(createInfo) {
+    this.socketId = createInfo.socketId;
+    if (this.socketId > 0) {
+      socket.connect(this.socketId, this.addr, this.port, this._onConnectComplete.bind(this));
+    } else {
+      error('Unable to create socket');
+    }
+  };
+
+  /**
+   * The callback function used for when we attempt to have Chrome
+   * connect to the remote side. If a successful connection is
+   * made then polling starts to check for data to read
+   *
+   * @private
+   * @param {Number} resultCode Indicates whether the connection was successful
+   */
+  TcpClient.prototype._onConnectComplete = function(resultCode) {
+    // Start polling for reads.
+    this.isConnected = true;
+    setTimeout(this._periodicallyRead.bind(this), this.pollInterval);
+
+    if (this.callbacks.connect) {
+      log('connect complete');
+      this.callbacks.connect();
+    }
+    log('onConnectComplete');
+  };
+
+  /**
+   * Checks for new data to read from the socket
+   *
+   * @see http://developer.chrome.com/trunk/apps/socket.html#method-read
+   */
+  TcpClient.prototype._periodicallyRead = function() {
+    var that = this;
+    socket.getInfo(this.socketId, function (info) {
+      if (info.connected) {
+        setTimeout(that._periodicallyRead.bind(that), that.pollInterval);
+        socket.read(that.socketId, null, that._onDataRead.bind(that));
+      } else if (that.isConnected) {
+        log('socket disconnect detected');
+        that.disconnect();
+      }
+   });
+  };
+
+  /**
+   * Callback function for when data has been read from the socket.
+   * Converts the array buffer that is read in to a string
+   * and sends it on for further processing by passing it to
+   * the previously assigned callback function.
+   *
+   * @private
+   * @see TcpClient.prototype.addResponseListener
+   * @param {Object} readInfo The incoming message
+   */
+  TcpClient.prototype._onDataRead = function(readInfo) {
+    // Call received callback if there's data in the response.
+    if (readInfo.resultCode > 0) {
+      log('onDataRead');
+
+      /*
+      // Debug
+      var bytes = [], u8 = new Uint8Array(readInfo.data);
+      for (var i = 0; i < u8.length; i++) {
+          bytes.push(u8[i]);
+      }
+      log("received bytes: " + (bytes.join(',')));
+      */
+      
+      if (this.callbacks.recvBuffer) {
+        // Return raw ArrayBuffer directly.
+        this.callbacks.recvBuffer(readInfo.data);
+      }
+      if (this.callbacks.recvString) {
+        // Convert ArrayBuffer to string.
+        this._arrayBufferToString(readInfo.data, function(str) {
+          this.callbacks.recvString(str);
+        }.bind(this));
+      }
+
+      // Trigger another read right away
+      setTimeout(this._periodicallyRead.bind(this), 0);
+    }
+  };
+
+  /**
+   * Callback for when data has been successfully
+   * written to the socket.
+   *
+   * @private
+   * @param {Object} writeInfo The outgoing message
+   */
+  TcpClient.prototype._onWriteComplete = function(writeInfo) {
+    log('onWriteComplete');
+    // Call sent callback.
+    if (this.callbacks.sent) {
+      this.callbacks.sent(writeInfo);
+    }
+  };
+
+  /**
+   * Converts an array buffer to a string
+   *
+   * @private
+   * @param {ArrayBuffer} buf The buffer to convert
+   * @param {Function} callback The function to call when conversion is complete
+   */
+  TcpClient.prototype._arrayBufferToString = function(buf, callback) {
+    var bb = new Blob([new Uint8Array(buf)]);
+    var f = new FileReader();
+    f.onload = function(e) {
+      callback(e.target.result);
+    };
+    f.readAsText(bb);
+  };
+
+  /**
+   * Converts a string to an array buffer
+   *
+   * @private
+   * @param {String} str The string to convert
+   * @param {Function} callback The function to call when conversion is complete
+   */
+  TcpClient.prototype._stringToArrayBuffer = function(str, callback) {
+    var bb = new Blob([str]);
+    var f = new FileReader();
+    f.onload = function(e) {
+        callback(e.target.result);
+    };
+    f.readAsArrayBuffer(bb);
+  };
+
+  /**
+   * Wrapper function for logging
+   */
+  function log(msg) {
+    console.log(msg);
+  }
+
+  /**
+   * Wrapper function for error logging
+   */
+  function error(msg) {
+    console.error(msg);
+  }
+
+  exports.TcpClient = TcpClient;
+
+})(window);
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/des.js
@@ -0,0 +1,276 @@
+/*
+ * Ported from Flashlight VNC ActionScript implementation:
+ *     http://www.wizhelp.com/flashlight-vnc/
+ *
+ * Full attribution follows:
+ *
+ * -------------------------------------------------------------------------
+ *
+ * This DES class has been extracted from package Acme.Crypto for use in VNC.
+ * The unnecessary odd parity code has been removed.
+ *
+ * These changes are:
+ *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
+ *
+ * This software is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+
+ * DesCipher - the DES encryption method
+ *
+ * The meat of this code is by Dave Zimmerman <dzimm@widget.com>, and is:
+ *
+ * Copyright (c) 1996 Widget Workshop, Inc. All Rights Reserved.
+ *
+ * Permission to use, copy, modify, and distribute this software
+ * and its documentation for NON-COMMERCIAL or COMMERCIAL purposes and
+ * without fee is hereby granted, provided that this copyright notice is kept 
+ * intact. 
+ * 
+ * WIDGET WORKSHOP MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY
+ * OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+ * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+ * PARTICULAR PURPOSE, OR NON-INFRINGEMENT. WIDGET WORKSHOP SHALL NOT BE LIABLE
+ * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR
+ * DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
+ * 
+ * THIS SOFTWARE IS NOT DESIGNED OR INTENDED FOR USE OR RESALE AS ON-LINE
+ * CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE
+ * PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT
+ * NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE
+ * SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF THE
+ * SOFTWARE COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE
+ * PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH RISK ACTIVITIES").  WIDGET WORKSHOP
+ * SPECIFICALLY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR
+ * HIGH RISK ACTIVITIES.
+ *
+ *
+ * The rest is:
+ *
+ * Copyright (C) 1996 by Jef Poskanzer <jef@acme.com>.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Visit the ACME Labs Java page for up-to-date versions of this and other
+ * fine Java utilities: http://www.acme.com/java/
+ */
+
+/* jslint white: false */
+
+function DES(passwd) {
+    "use strict";
+
+    // Tables, permutations, S-boxes, etc.
+    // jshint -W013
+    var PC2 = [13,16,10,23, 0, 4, 2,27,14, 5,20, 9,22,18,11, 3,
+               25, 7,15, 6,26,19,12, 1,40,51,30,36,46,54,29,39,
+               50,44,32,47,43,48,38,55,33,52,45,41,49,35,28,31 ],
+        totrot = [ 1, 2, 4, 6, 8,10,12,14,15,17,19,21,23,25,27,28],
+        z = 0x0, a,b,c,d,e,f, SP1,SP2,SP3,SP4,SP5,SP6,SP7,SP8,
+        keys = [];
+
+    // jshint -W015
+    a=1<<16; b=1<<24; c=a|b; d=1<<2; e=1<<10; f=d|e;
+    SP1 = [c|e,z|z,a|z,c|f,c|d,a|f,z|d,a|z,z|e,c|e,c|f,z|e,b|f,c|d,b|z,z|d,
+           z|f,b|e,b|e,a|e,a|e,c|z,c|z,b|f,a|d,b|d,b|d,a|d,z|z,z|f,a|f,b|z,
+           a|z,c|f,z|d,c|z,c|e,b|z,b|z,z|e,c|d,a|z,a|e,b|d,z|e,z|d,b|f,a|f,
+           c|f,a|d,c|z,b|f,b|d,z|f,a|f,c|e,z|f,b|e,b|e,z|z,a|d,a|e,z|z,c|d];
+    a=1<<20; b=1<<31; c=a|b; d=1<<5; e=1<<15; f=d|e;
+    SP2 = [c|f,b|e,z|e,a|f,a|z,z|d,c|d,b|f,b|d,c|f,c|e,b|z,b|e,a|z,z|d,c|d,
+           a|e,a|d,b|f,z|z,b|z,z|e,a|f,c|z,a|d,b|d,z|z,a|e,z|f,c|e,c|z,z|f,
+           z|z,a|f,c|d,a|z,b|f,c|z,c|e,z|e,c|z,b|e,z|d,c|f,a|f,z|d,z|e,b|z,
+           z|f,c|e,a|z,b|d,a|d,b|f,b|d,a|d,a|e,z|z,b|e,z|f,b|z,c|d,c|f,a|e];
+    a=1<<17; b=1<<27; c=a|b; d=1<<3; e=1<<9; f=d|e;
+    SP3 = [z|f,c|e,z|z,c|d,b|e,z|z,a|f,b|e,a|d,b|d,b|d,a|z,c|f,a|d,c|z,z|f,
+           b|z,z|d,c|e,z|e,a|e,c|z,c|d,a|f,b|f,a|e,a|z,b|f,z|d,c|f,z|e,b|z,
+           c|e,b|z,a|d,z|f,a|z,c|e,b|e,z|z,z|e,a|d,c|f,b|e,b|d,z|e,z|z,c|d,
+           b|f,a|z,b|z,c|f,z|d,a|f,a|e,b|d,c|z,b|f,z|f,c|z,a|f,z|d,c|d,a|e];
+    a=1<<13; b=1<<23; c=a|b; d=1<<0; e=1<<7; f=d|e;
+    SP4 = [c|d,a|f,a|f,z|e,c|e,b|f,b|d,a|d,z|z,c|z,c|z,c|f,z|f,z|z,b|e,b|d,
+           z|d,a|z,b|z,c|d,z|e,b|z,a|d,a|e,b|f,z|d,a|e,b|e,a|z,c|e,c|f,z|f,
+           b|e,b|d,c|z,c|f,z|f,z|z,z|z,c|z,a|e,b|e,b|f,z|d,c|d,a|f,a|f,z|e,
+           c|f,z|f,z|d,a|z,b|d,a|d,c|e,b|f,a|d,a|e,b|z,c|d,z|e,b|z,a|z,c|e];
+    a=1<<25; b=1<<30; c=a|b; d=1<<8; e=1<<19; f=d|e;
+    SP5 = [z|d,a|f,a|e,c|d,z|e,z|d,b|z,a|e,b|f,z|e,a|d,b|f,c|d,c|e,z|f,b|z,
+           a|z,b|e,b|e,z|z,b|d,c|f,c|f,a|d,c|e,b|d,z|z,c|z,a|f,a|z,c|z,z|f,
+           z|e,c|d,z|d,a|z,b|z,a|e,c|d,b|f,a|d,b|z,c|e,a|f,b|f,z|d,a|z,c|e,
+           c|f,z|f,c|z,c|f,a|e,z|z,b|e,c|z,z|f,a|d,b|d,z|e,z|z,b|e,a|f,b|d];
+    a=1<<22; b=1<<29; c=a|b; d=1<<4; e=1<<14; f=d|e;
+    SP6 = [b|d,c|z,z|e,c|f,c|z,z|d,c|f,a|z,b|e,a|f,a|z,b|d,a|d,b|e,b|z,z|f,
+           z|z,a|d,b|f,z|e,a|e,b|f,z|d,c|d,c|d,z|z,a|f,c|e,z|f,a|e,c|e,b|z,
+           b|e,z|d,c|d,a|e,c|f,a|z,z|f,b|d,a|z,b|e,b|z,z|f,b|d,c|f,a|e,c|z,
+           a|f,c|e,z|z,c|d,z|d,z|e,c|z,a|f,z|e,a|d,b|f,z|z,c|e,b|z,a|d,b|f];
+    a=1<<21; b=1<<26; c=a|b; d=1<<1; e=1<<11; f=d|e;
+    SP7 = [a|z,c|d,b|f,z|z,z|e,b|f,a|f,c|e,c|f,a|z,z|z,b|d,z|d,b|z,c|d,z|f,
+           b|e,a|f,a|d,b|e,b|d,c|z,c|e,a|d,c|z,z|e,z|f,c|f,a|e,z|d,b|z,a|e,
+           b|z,a|e,a|z,b|f,b|f,c|d,c|d,z|d,a|d,b|z,b|e,a|z,c|e,z|f,a|f,c|e,
+           z|f,b|d,c|f,c|z,a|e,z|z,z|d,c|f,z|z,a|f,c|z,z|e,b|d,b|e,z|e,a|d];
+    a=1<<18; b=1<<28; c=a|b; d=1<<6; e=1<<12; f=d|e;
+    SP8 = [b|f,z|e,a|z,c|f,b|z,b|f,z|d,b|z,a|d,c|z,c|f,a|e,c|e,a|f,z|e,z|d,
+           c|z,b|d,b|e,z|f,a|e,a|d,c|d,c|e,z|f,z|z,z|z,c|d,b|d,b|e,a|f,a|z,
+           a|f,a|z,c|e,z|e,z|d,c|d,z|e,a|f,b|e,z|d,b|d,c|z,c|d,b|z,a|z,b|f,
+           z|z,c|f,a|d,b|d,c|z,b|e,b|f,z|z,c|f,a|e,a|e,z|f,z|f,a|d,b|z,c|e];
+    // jshint +W013,+W015
+
+    // Set the key.
+    function setKeys(keyBlock) {
+        var i, j, l, m, n, o, pc1m = [], pcr = [], kn = [],
+            raw0, raw1, rawi, KnLi;
+
+        for (j = 0, l = 56; j < 56; ++j, l -= 8) {
+            l += l < -5 ? 65 : l < -3 ? 31 : l < -1 ? 63 : l === 27 ? 35 : 0; // PC1
+            m = l & 0x7;
+            pc1m[j] = ((keyBlock[l >>> 3] & (1<<m)) !== 0) ? 1: 0;
+        }
+
+        for (i = 0; i < 16; ++i) {
+            m = i << 1;
+            n = m + 1;
+            kn[m] = kn[n] = 0;
+            for (o = 28; o < 59; o += 28) {
+                for (j = o - 28; j < o; ++j) {
+                    l = j + totrot[i];
+                    if (l < o) {
+                        pcr[j] = pc1m[l];
+                    } else {
+                        pcr[j] = pc1m[l - 28];
+                    }
+                }
+            }
+            for (j = 0; j < 24; ++j) {
+                if (pcr[PC2[j]] !== 0) {
+                    kn[m] |= 1 << (23 - j);
+                }
+                if (pcr[PC2[j + 24]] !== 0) {
+                    kn[n] |= 1 << (23 - j);
+                }
+            }
+        }
+
+        // cookey
+        for (i = 0, rawi = 0, KnLi = 0; i < 16; ++i) {
+            raw0 = kn[rawi++];
+            raw1 = kn[rawi++];
+            keys[KnLi] = (raw0 & 0x00fc0000) << 6;
+            keys[KnLi] |= (raw0 & 0x00000fc0) << 10;
+            keys[KnLi] |= (raw1 & 0x00fc0000) >>> 10;
+            keys[KnLi] |= (raw1 & 0x00000fc0) >>> 6;
+            ++KnLi;
+            keys[KnLi] = (raw0 & 0x0003f000) << 12;
+            keys[KnLi] |= (raw0 & 0x0000003f) << 16;
+            keys[KnLi] |= (raw1 & 0x0003f000) >>> 4;
+            keys[KnLi] |= (raw1 & 0x0000003f);
+            ++KnLi;
+        }
+    }
+
+    // Encrypt 8 bytes of text
+    function enc8(text) {
+        var i = 0, b = text.slice(), fval, keysi = 0,
+            l, r, x; // left, right, accumulator
+
+        // Squash 8 bytes to 2 ints
+        l = b[i++]<<24 | b[i++]<<16 | b[i++]<<8 | b[i++];
+        r = b[i++]<<24 | b[i++]<<16 | b[i++]<<8 | b[i++];
+
+        x = ((l >>> 4) ^ r) & 0x0f0f0f0f;
+        r ^= x;
+        l ^= (x << 4);
+        x = ((l >>> 16) ^ r) & 0x0000ffff;
+        r ^= x;
+        l ^= (x << 16);
+        x = ((r >>> 2) ^ l) & 0x33333333;
+        l ^= x;
+        r ^= (x << 2);
+        x = ((r >>> 8) ^ l) & 0x00ff00ff;
+        l ^= x;
+        r ^= (x << 8);
+        r = (r << 1) | ((r >>> 31) & 1);
+        x = (l ^ r) & 0xaaaaaaaa;
+        l ^= x;
+        r ^= x;
+        l = (l << 1) | ((l >>> 31) & 1);
+
+        for (i = 0; i < 8; ++i) {
+            x = (r << 28) | (r >>> 4);
+            x ^= keys[keysi++];
+            fval =  SP7[x & 0x3f];
+            fval |= SP5[(x >>> 8) & 0x3f];
+            fval |= SP3[(x >>> 16) & 0x3f];
+            fval |= SP1[(x >>> 24) & 0x3f];
+            x = r ^ keys[keysi++];
+            fval |= SP8[x & 0x3f];
+            fval |= SP6[(x >>> 8) & 0x3f];
+            fval |= SP4[(x >>> 16) & 0x3f];
+            fval |= SP2[(x >>> 24) & 0x3f];
+            l ^= fval;
+            x = (l << 28) | (l >>> 4);
+            x ^= keys[keysi++];
+            fval =  SP7[x & 0x3f];
+            fval |= SP5[(x >>> 8) & 0x3f];
+            fval |= SP3[(x >>> 16) & 0x3f];
+            fval |= SP1[(x >>> 24) & 0x3f];
+            x = l ^ keys[keysi++];
+            fval |= SP8[x & 0x0000003f];
+            fval |= SP6[(x >>> 8) & 0x3f];
+            fval |= SP4[(x >>> 16) & 0x3f];
+            fval |= SP2[(x >>> 24) & 0x3f];
+            r ^= fval;
+        }
+
+        r = (r << 31) | (r >>> 1);
+        x = (l ^ r) & 0xaaaaaaaa;
+        l ^= x;
+        r ^= x;
+        l = (l << 31) | (l >>> 1);
+        x = ((l >>> 8) ^ r) & 0x00ff00ff;
+        r ^= x;
+        l ^= (x << 8);
+        x = ((l >>> 2) ^ r) & 0x33333333;
+        r ^= x;
+        l ^= (x << 2);
+        x = ((r >>> 16) ^ l) & 0x0000ffff;
+        l ^= x;
+        r ^= (x << 16);
+        x = ((r >>> 4) ^ l) & 0x0f0f0f0f;
+        l ^= x;
+        r ^= (x << 4);
+
+        // Spread ints to bytes
+        x = [r, l];
+        for (i = 0; i < 8; i++) {
+            b[i] = (x[i>>>2] >>> (8 * (3 - (i % 4)))) % 256;
+            if (b[i] < 0) { b[i] += 256; } // unsigned
+        }
+        return b;
+    }
+
+    // Encrypt 16 bytes of text using passwd as key
+    function encrypt(t) {
+        return enc8(t.slice(0, 8)).concat(enc8(t.slice(8, 16)));
+    }
+
+    setKeys(passwd);             // Setup keys
+    return {'encrypt': encrypt}; // Public interface
+
+} // function DES
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/display.js
@@ -0,0 +1,746 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2012 Joel Martin
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+/*jslint browser: true, white: false */
+/*global Util, Base64, changeCursor */
+
+var Display;
+
+(function () {
+    "use strict";
+
+    Display = function (defaults) {
+        this._drawCtx = null;
+        this._c_forceCanvas = false;
+
+        this._renderQ = [];  // queue drawing actions for in-oder rendering
+
+        // the full frame buffer (logical canvas) size
+        this._fb_width = 0;
+        this._fb_height = 0;
+
+        // the visible "physical canvas" viewport
+        this._viewportLoc = { 'x': 0, 'y': 0, 'w': 0, 'h': 0 };
+        this._cleanRect = { 'x1': 0, 'y1': 0, 'x2': -1, 'y2': -1 };
+
+        this._prevDrawStyle = "";
+        this._tile = null;
+        this._tile16x16 = null;
+        this._tile_x = 0;
+        this._tile_y = 0;
+
+        Util.set_defaults(this, defaults, {
+            'true_color': true,
+            'colourMap': [],
+            'scale': 1.0,
+            'viewport': false,
+            'render_mode': ''
+        });
+
+        Util.Debug(">> Display.constructor");
+
+        if (!this._target) {
+            throw new Error("Target must be set");
+        }
+
+        if (typeof this._target === 'string') {
+            throw new Error('target must be a DOM element');
+        }
+
+        if (!this._target.getContext) {
+            throw new Error("no getContext method");
+        }
+
+        if (!this._drawCtx) {
+            this._drawCtx = this._target.getContext('2d');
+        }
+
+        Util.Debug("User Agent: " + navigator.userAgent);
+        if (Util.Engine.gecko) { Util.Debug("Browser: gecko " + Util.Engine.gecko); }
+        if (Util.Engine.webkit) { Util.Debug("Browser: webkit " + Util.Engine.webkit); }
+        if (Util.Engine.trident) { Util.Debug("Browser: trident " + Util.Engine.trident); }
+        if (Util.Engine.presto) { Util.Debug("Browser: presto " + Util.Engine.presto); }
+
+        this.clear();
+
+        // Check canvas features
+        if ('createImageData' in this._drawCtx) {
+            this._render_mode = 'canvas rendering';
+        } else {
+            throw new Error("Canvas does not support createImageData");
+        }
+
+        if (this._prefer_js === null) {
+            Util.Info("Prefering javascript operations");
+            this._prefer_js = true;
+        }
+
+        // Determine browser support for setting the cursor via data URI scheme
+        var curDat = [];
+        for (var i = 0; i < 8 * 8 * 4; i++) {
+            curDat.push(255);
+        }
+        try {
+            var curSave = this._target.style.cursor;
+            Display.changeCursor(this._target, curDat, curDat, 2, 2, 8, 8);
+            if (this._target.style.cursor) {
+                if (this._cursor_uri === null || this._cursor_uri === undefined) {
+                    this._cursor_uri = true;
+                }
+                Util.Info("Data URI scheme cursor supported");
+            } else {
+                if (this._cursor_uri === null || this._cursor_uri === undefined) {
+                    this._cursor_uri = false;
+                }
+                Util.Warn("Data URI scheme cursor not supported");
+            }
+            this._target.style.cursor = curSave;
+        } catch (exc) {
+            Util.Error("Data URI scheme cursor test exception: " + exc);
+            this._cursor_uri = false;
+        }
+
+        Util.Debug("<< Display.constructor");
+    };
+
+    Display.prototype = {
+        // Public methods
+        viewportChange: function (deltaX, deltaY, width, height) {
+            var vp = this._viewportLoc;
+            var cr = this._cleanRect;
+            var canvas = this._target;
+
+            if (!this._viewport) {
+                Util.Debug("Setting viewport to full display region");
+                deltaX = -vp.w;  // clamped later of out of bounds
+                deltaY = -vp.h;
+                width = this._fb_width;
+                height = this._fb_height;
+            }
+
+            if (typeof(deltaX) === "undefined") { deltaX = 0; }
+            if (typeof(deltaY) === "undefined") { deltaY = 0; }
+            if (typeof(width) === "undefined") { width = vp.w; }
+            if (typeof(height) === "undefined") { height = vp.h; }
+
+            // Size change
+            if (width > this._fb_width) { width = this._fb_width; }
+            if (height > this._fb_height) { height = this._fb_height; }
+
+            if (vp.w !== width || vp.h !== height) {
+                // Change width
+                if (width < vp.w &&  cr.x2 > vp.x + width - 1) {
+                    cr.x2 = vp.x + width - 1;
+                }
+                vp.w = width;
+
+                // Change height
+                if (height < vp.h &&  cr.y2 > vp.y + height - 1) {
+                    cr.y2 = vp.y + height - 1;
+                }
+                vp.h = height;
+
+                var saveImg = null;
+                if (vp.w > 0 && vp.h > 0 && canvas.width > 0 && canvas.height > 0) {
+                    var img_width = canvas.width < vp.w ? canvas.width : vp.w;
+                    var img_height = canvas.height < vp.h ? canvas.height : vp.h;
+                    saveImg = this._drawCtx.getImageData(0, 0, img_width, img_height);
+                }
+
+                canvas.width = vp.w;
+                canvas.height = vp.h;
+
+                if (saveImg) {
+                    this._drawCtx.putImageData(saveImg, 0, 0);
+                }
+            }
+
+            var vx2 = vp.x + vp.w - 1;
+            var vy2 = vp.y + vp.h - 1;
+
+            // Position change
+
+            if (deltaX < 0 && vp.x + deltaX < 0) {
+                deltaX = -vp.x;
+            }
+            if (vx2 + deltaX >= this._fb_width) {
+                deltaX -= vx2 + deltaX - this._fb_width + 1;
+            }
+
+            if (vp.y + deltaY < 0) {
+                deltaY = -vp.y;
+            }
+            if (vy2 + deltaY >= this._fb_height) {
+                deltaY -= (vy2 + deltaY - this._fb_height + 1);
+            }
+
+            if (deltaX === 0 && deltaY === 0) {
+                return;
+            }
+            Util.Debug("viewportChange deltaX: " + deltaX + ", deltaY: " + deltaY);
+
+            vp.x += deltaX;
+            vx2 += deltaX;
+            vp.y += deltaY;
+            vy2 += deltaY;
+
+            // Update the clean rectangle
+            if (vp.x > cr.x1) {
+                cr.x1 = vp.x;
+            }
+            if (vx2 < cr.x2) {
+                cr.x2 = vx2;
+            }
+            if (vp.y > cr.y1) {
+                cr.y1 = vp.y;
+            }
+            if (vy2 < cr.y2) {
+                cr.y2 = vy2;
+            }
+
+            var x1, w;
+            if (deltaX < 0) {
+                // Shift viewport left, redraw left section
+                x1 = 0;
+                w = -deltaX;
+            } else {
+                // Shift viewport right, redraw right section
+                x1 = vp.w - deltaX;
+                w = deltaX;
+            }
+
+            var y1, h;
+            if (deltaY < 0) {
+                // Shift viewport up, redraw top section
+                y1 = 0;
+                h = -deltaY;
+            } else {
+                // Shift viewport down, redraw bottom section
+                y1 = vp.h - deltaY;
+                h = deltaY;
+            }
+
+            // Copy the valid part of the viewport to the shifted location
+            var saveStyle = this._drawCtx.fillStyle;
+            this._drawCtx.fillStyle = "rgb(255,255,255)";
+            if (deltaX !== 0) {
+                this._drawCtx.drawImage(canvas, 0, 0, vp.w, vp.h, -deltaX, 0, vp.w, vp.h);
+                this._drawCtx.fillRect(x1, 0, w, vp.h);
+            }
+            if (deltaY !== 0) {
+                this._drawCtx.drawImage(canvas, 0, 0, vp.w, vp.h, 0, -deltaY, vp.w, vp.h);
+                this._drawCtx.fillRect(0, y1, vp.w, h);
+            }
+            this._drawCtx.fillStyle = saveStyle;
+        },
+
+        // Return a map of clean and dirty areas of the viewport and reset the
+        // tracking of clean and dirty areas
+        //
+        // Returns: { 'cleanBox': { 'x': x, 'y': y, 'w': w, 'h': h},
+        //            'dirtyBoxes': [{ 'x': x, 'y': y, 'w': w, 'h': h }, ...] }
+        getCleanDirtyReset: function () {
+            var vp = this._viewportLoc;
+            var cr = this._cleanRect;
+
+            var cleanBox = { 'x': cr.x1, 'y': cr.y1,
+                             'w': cr.x2 - cr.x1 + 1, 'h': cr.y2 - cr.y1 + 1 };
+
+            var dirtyBoxes = [];
+            if (cr.x1 >= cr.x2 || cr.y1 >= cr.y2) {
+                // Whole viewport is dirty
+                dirtyBoxes.push({ 'x': vp.x, 'y': vp.y, 'w': vp.w, 'h': vp.h });
+            } else {
+                // Redraw dirty regions
+                var vx2 = vp.x + vp.w - 1;
+                var vy2 = vp.y + vp.h - 1;
+
+                if (vp.x < cr.x1) {
+                    // left side dirty region
+                    dirtyBoxes.push({'x': vp.x, 'y': vp.y,
+                                     'w': cr.x1 - vp.x + 1, 'h': vp.h});
+                }
+                if (vx2 > cr.x2) {
+                    // right side dirty region
+                    dirtyBoxes.push({'x': cr.x2 + 1, 'y': vp.y,
+                                     'w': vx2 - cr.x2, 'h': vp.h});
+                }
+                if(vp.y < cr.y1) {
+                    // top/middle dirty region
+                    dirtyBoxes.push({'x': cr.x1, 'y': vp.y,
+                                     'w': cr.x2 - cr.x1 + 1, 'h': cr.y1 - vp.y});
+                }
+                if (vy2 > cr.y2) {
+                    // bottom/middle dirty region
+                    dirtyBoxes.push({'x': cr.x1, 'y': cr.y2 + 1,
+                                     'w': cr.x2 - cr.x1 + 1, 'h': vy2 - cr.y2});
+                }
+            }
+
+            this._cleanRect = {'x1': vp.x, 'y1': vp.y,
+                               'x2': vp.x + vp.w - 1, 'y2': vp.y + vp.h - 1};
+
+            return {'cleanBox': cleanBox, 'dirtyBoxes': dirtyBoxes};
+        },
+
+        absX: function (x) {
+            return x + this._viewportLoc.x;
+        },
+
+        absY: function (y) {
+            return y + this._viewportLoc.y;
+        },
+
+        resize: function (width, height) {
+            this._prevDrawStyle = "";
+
+            this._fb_width = width;
+            this._fb_height = height;
+
+            this._rescale(this._scale);
+
+            this.viewportChange();
+        },
+
+        clear: function () {
+            if (this._logo) {
+                this.resize(this._logo.width, this._logo.height);
+                this.blitStringImage(this._logo.data, 0, 0);
+            } else {
+                if (Util.Engine.trident === 6) {
+                    // NB(directxman12): there's a bug in IE10 where we can fail to actually
+                    //                   clear the canvas here because of the resize.
+                    //                   Clearing the current viewport first fixes the issue
+                    this._drawCtx.clearRect(0, 0, this._viewportLoc.w, this._viewportLoc.h);
+                }
+                this.resize(240, 20);
+                this._drawCtx.clearRect(0, 0, this._viewportLoc.w, this._viewportLoc.h);
+            }
+
+            this._renderQ = [];
+        },
+
+        fillRect: function (x, y, width, height, color) {
+            this._setFillColor(color);
+            this._drawCtx.fillRect(x - this._viewportLoc.x, y - this._viewportLoc.y, width, height);
+        },
+
+        copyImage: function (old_x, old_y, new_x, new_y, w, h) {
+            var x1 = old_x - this._viewportLoc.x;
+            var y1 = old_y - this._viewportLoc.y;
+            var x2 = new_x - this._viewportLoc.x;
+            var y2 = new_y - this._viewportLoc.y;
+
+            this._drawCtx.drawImage(this._target, x1, y1, w, h, x2, y2, w, h);
+        },
+
+        // start updating a tile
+        startTile: function (x, y, width, height, color) {
+            this._tile_x = x;
+            this._tile_y = y;
+            if (width === 16 && height === 16) {
+                this._tile = this._tile16x16;
+            } else {
+                this._tile = this._drawCtx.createImageData(width, height);
+            }
+
+            if (this._prefer_js) {
+                var bgr;
+                if (this._true_color) {
+                    bgr = color;
+                } else {
+                    bgr = this._colourMap[color[0]];
+                }
+                var red = bgr[2];
+                var green = bgr[1];
+                var blue = bgr[0];
+
+                var data = this._tile.data;
+                for (var i = 0; i < width * height * 4; i += 4) {
+                    data[i] = red;
+                    data[i + 1] = green;
+                    data[i + 2] = blue;
+                    data[i + 3] = 255;
+                }
+            } else {
+                this.fillRect(x, y, width, height, color);
+            }
+        },
+
+        // update sub-rectangle of the current tile
+        subTile: function (x, y, w, h, color) {
+            if (this._prefer_js) {
+                var bgr;
+                if (this._true_color) {
+                    bgr = color;
+                } else {
+                    bgr = this._colourMap[color[0]];
+                }
+                var red = bgr[2];
+                var green = bgr[1];
+                var blue = bgr[0];
+                var xend = x + w;
+                var yend = y + h;
+
+                var data = this._tile.data;
+                var width = this._tile.width;
+                for (var j = y; j < yend; j++) {
+                    for (var i = x; i < xend; i++) {
+                        var p = (i + (j * width)) * 4;
+                        data[p] = red;
+                        data[p + 1] = green;
+                        data[p + 2] = blue;
+                        data[p + 3] = 255;
+                    }
+                }
+            } else {
+                this.fillRect(this._tile_x + x, this._tile_y + y, w, h, color);
+            }
+        },
+
+        // draw the current tile to the screen
+        finishTile: function () {
+            if (this._prefer_js) {
+                this._drawCtx.putImageData(this._tile, this._tile_x - this._viewportLoc.x,
+                                           this._tile_y - this._viewportLoc.y);
+            }
+            // else: No-op -- already done by setSubTile
+        },
+
+        blitImage: function (x, y, width, height, arr, offset) {
+            if (this._true_color) {
+                this._bgrxImageData(x, y, this._viewportLoc.x, this._viewportLoc.y, width, height, arr, offset);
+            } else {
+                this._cmapImageData(x, y, this._viewportLoc.x, this._viewportLoc.y, width, height, arr, offset);
+            }
+        },
+
+        blitRgbImage: function (x, y , width, height, arr, offset) {
+            if (this._true_color) {
+                this._rgbImageData(x, y, this._viewportLoc.x, this._viewportLoc.y, width, height, arr, offset);
+            } else {
+                // probably wrong?
+                this._cmapImageData(x, y, this._viewportLoc.x, this._viewportLoc.y, width, height, arr, offset);
+            }
+        },
+
+        blitStringImage: function (str, x, y) {
+            var img = new Image();
+            img.onload = function () {
+                this._drawCtx.drawImage(img, x - this._viewportLoc.x, y - this._viewportLoc.y);
+            }.bind(this);
+            img.src = str;
+            return img; // for debugging purposes
+        },
+
+        // wrap ctx.drawImage but relative to viewport
+        drawImage: function (img, x, y) {
+            this._drawCtx.drawImage(img, x - this._viewportLoc.x, y - this._viewportLoc.y);
+        },
+
+        renderQ_push: function (action) {
+            this._renderQ.push(action);
+            if (this._renderQ.length === 1) {
+                // If this can be rendered immediately it will be, otherwise
+                // the scanner will start polling the queue (every
+                // requestAnimationFrame interval)
+                this._scan_renderQ();
+            }
+        },
+
+        changeCursor: function (pixels, mask, hotx, hoty, w, h) {
+            if (this._cursor_uri === false) {
+                Util.Warn("changeCursor called but no cursor data URI support");
+                return;
+            }
+
+            if (this._true_color) {
+                Display.changeCursor(this._target, pixels, mask, hotx, hoty, w, h);
+            } else {
+                Display.changeCursor(this._target, pixels, mask, hotx, hoty, w, h, this._colourMap);
+            }
+        },
+
+        defaultCursor: function () {
+            this._target.style.cursor = "default";
+        },
+
+        // Overridden getters/setters
+        get_context: function () {
+            return this._drawCtx;
+        },
+
+        set_scale: function (scale) {
+            this._rescale(scale);
+        },
+
+        set_width: function (w) {
+            this.resize(w, this._fb_height);
+        },
+        get_width: function () {
+            return this._fb_width;
+        },
+
+        set_height: function (h) {
+            this.resize(this._fb_width, h);
+        },
+        get_height: function () {
+            return this._fb_height;
+        },
+
+        // Private Methods
+        _rescale: function (factor) {
+            var canvas = this._target;
+            var properties = ['transform', 'WebkitTransform', 'MozTransform'];
+            var transform_prop;
+            while ((transform_prop = properties.shift())) {
+                if (typeof canvas.style[transform_prop] !== 'undefined') {
+                    break;
+                }
+            }
+
+            if (transform_prop === null) {
+                Util.Debug("No scaling support");
+                return;
+            }
+
+            if (typeof(factor) === "undefined") {
+                factor = this._scale;
+            } else if (factor > 1.0) {
+                factor = 1.0;
+            } else if (factor < 0.1) {
+                factor = 0.1;
+            }
+
+            if (this._scale === factor) {
+                return;
+            }
+
+            this._scale = factor;
+            var x = canvas.width - (canvas.width * factor);
+            var y = canvas.height - (canvas.height * factor);
+            canvas.style[transform_prop] = 'scale(' + this._scale + ') translate(-' + x + 'px, -' + y + 'px)';
+        },
+
+        _setFillColor: function (color) {
+            var bgr;
+            if (this._true_color) {
+                bgr = color;
+            } else {
+                bgr = this._colourMap[color[0]];
+            }
+
+            var newStyle = 'rgb(' + bgr[2] + ',' + bgr[1] + ',' + bgr[0] + ')';
+            if (newStyle !== this._prevDrawStyle) {
+                this._drawCtx.fillStyle = newStyle;
+                this._prevDrawStyle = newStyle;
+            }
+        },
+
+        _rgbImageData: function (x, y, vx, vy, width, height, arr, offset) {
+            var img = this._drawCtx.createImageData(width, height);
+            var data = img.data;
+            for (var i = 0, j = offset; i < width * height * 4; i += 4, j += 3) {
+                data[i]     = arr[j];
+                data[i + 1] = arr[j + 1];
+                data[i + 2] = arr[j + 2];
+                data[i + 3] = 255;  // Alpha
+            }
+            this._drawCtx.putImageData(img, x - vx, y - vy);
+        },
+
+        _bgrxImageData: function (x, y, vx, vy, width, height, arr, offset) {
+            var img = this._drawCtx.createImageData(width, height);
+            var data = img.data;
+            for (var i = 0, j = offset; i < width * height * 4; i += 4, j += 4) {
+                data[i]     = arr[j + 2];
+                data[i + 1] = arr[j + 1];
+                data[i + 2] = arr[j];
+                data[i + 3] = 255;  // Alpha
+            }
+            this._drawCtx.putImageData(img, x - vx, y - vy);
+        },
+
+        _cmapImageData: function (x, y, vx, vy, width, height, arr, offset) {
+            var img = this._drawCtx.createImageData(width, height);
+            var data = img.data;
+            var cmap = this._colourMap;
+            for (var i = 0, j = offset; i < width * height * 4; i += 4, j++) {
+                var bgr = cmap[arr[j]];
+                data[i]     = bgr[2];
+                data[i + 1] = bgr[1];
+                data[i + 2] = bgr[0];
+                data[i + 3] = 255;  // Alpha
+            }
+            this._drawCtx.putImageData(img, x - vx, y - vy);
+        },
+
+        _scan_renderQ: function () {
+            var ready = true;
+            while (ready && this._renderQ.length > 0) {
+                var a = this._renderQ[0];
+                switch (a.type) {
+                    case 'copy':
+                        this.copyImage(a.old_x, a.old_y, a.x, a.y, a.width, a.height);
+                        break;
+                    case 'fill':
+                        this.fillRect(a.x, a.y, a.width, a.height, a.color);
+                        break;
+                    case 'blit':
+                        this.blitImage(a.x, a.y, a.width, a.height, a.data, 0);
+                        break;
+                    case 'blitRgb':
+                        this.blitRgbImage(a.x, a.y, a.width, a.height, a.data, 0);
+                        break;
+                    case 'img':
+                        if (a.img.complete) {
+                            this.drawImage(a.img, a.x, a.y);
+                        } else {
+                            // We need to wait for this image to 'load'
+                            // to keep things in-order
+                            ready = false;
+                        }
+                        break;
+                }
+
+                if (ready) {
+                    this._renderQ.shift();
+                }
+            }
+
+            if (this._renderQ.length > 0) {
+                requestAnimFrame(this._scan_renderQ.bind(this));
+            }
+        },
+    };
+
+    Util.make_properties(Display, [
+        ['target', 'wo', 'dom'],       // Canvas element for rendering
+        ['context', 'ro', 'raw'],      // Canvas 2D context for rendering (read-only)
+        ['logo', 'rw', 'raw'],         // Logo to display when cleared: {"width": w, "height": h, "data": data}
+        ['true_color', 'rw', 'bool'],  // Use true-color pixel data
+        ['colourMap', 'rw', 'arr'],    // Colour map array (when not true-color)
+        ['scale', 'rw', 'float'],      // Display area scale factor 0.0 - 1.0
+        ['viewport', 'rw', 'bool'],    // Use a viewport set with viewportChange()
+        ['width', 'rw', 'int'],        // Display area width
+        ['height', 'rw', 'int'],       // Display area height
+
+        ['render_mode', 'ro', 'str'],  // Canvas rendering mode (read-only)
+
+        ['prefer_js', 'rw', 'str'],    // Prefer Javascript over canvas methods
+        ['cursor_uri', 'rw', 'raw']    // Can we render cursor using data URI
+    ]);
+
+    // Class Methods
+    Display.changeCursor = function (target, pixels, mask, hotx, hoty, w0, h0, cmap) {
+        var w = w0;
+        var h = h0;
+        if (h < w) {
+            h = w;  // increase h to make it square
+        } else {
+            w = h;  // increase w to make it square
+        }
+
+        var cur = [];
+
+        // Push multi-byte little-endian values
+        cur.push16le = function (num) {
+            this.push(num & 0xFF, (num >> 8) & 0xFF);
+        };
+        cur.push32le = function (num) {
+            this.push(num & 0xFF,
+                      (num >> 8) & 0xFF,
+                      (num >> 16) & 0xFF,
+                      (num >> 24) & 0xFF);
+        };
+
+        var IHDRsz = 40;
+        var RGBsz = w * h * 4;
+        var XORsz = Math.ceil((w * h) / 8.0);
+        var ANDsz = Math.ceil((w * h) / 8.0);
+
+        cur.push16le(0);        // 0: Reserved
+        cur.push16le(2);        // 2: .CUR type
+        cur.push16le(1);        // 4: Number of images, 1 for non-animated ico
+
+        // Cursor #1 header (ICONDIRENTRY)
+        cur.push(w);            // 6: width
+        cur.push(h);            // 7: height
+        cur.push(0);            // 8: colors, 0 -> true-color
+        cur.push(0);            // 9: reserved
+        cur.push16le(hotx);     // 10: hotspot x coordinate
+        cur.push16le(hoty);     // 12: hotspot y coordinate
+        cur.push32le(IHDRsz + RGBsz + XORsz + ANDsz);
+                                // 14: cursor data byte size
+        cur.push32le(22);       // 18: offset of cursor data in the file
+
+        // Cursor #1 InfoHeader (ICONIMAGE/BITMAPINFO)
+        cur.push32le(IHDRsz);   // 22: InfoHeader size
+        cur.push32le(w);        // 26: Cursor width
+        cur.push32le(h * 2);    // 30: XOR+AND height
+        cur.push16le(1);        // 34: number of planes
+        cur.push16le(32);       // 36: bits per pixel
+        cur.push32le(0);        // 38: Type of compression
+
+        cur.push32le(XORsz + ANDsz);
+                                // 42: Size of Image
+        cur.push32le(0);        // 46: reserved
+        cur.push32le(0);        // 50: reserved
+        cur.push32le(0);        // 54: reserved
+        cur.push32le(0);        // 58: reserved
+
+        // 62: color data (RGBQUAD icColors[])
+        var y, x;
+        for (y = h - 1; y >= 0; y--) {
+            for (x = 0; x < w; x++) {
+                if (x >= w0 || y >= h0) {
+                    cur.push(0);  // blue
+                    cur.push(0);  // green
+                    cur.push(0);  // red
+                    cur.push(0);  // alpha
+                } else {
+                    var idx = y * Math.ceil(w0 / 8) + Math.floor(x / 8);
+                    var alpha = (mask[idx] << (x % 8)) & 0x80 ? 255 : 0;
+                    if (cmap) {
+                        idx = (w0 * y) + x;
+                        var rgb = cmap[pixels[idx]];
+                        cur.push(rgb[2]);  // blue
+                        cur.push(rgb[1]);  // green
+                        cur.push(rgb[0]);  // red
+                        cur.push(alpha);   // alpha
+                    } else {
+                        idx = ((w0 * y) + x) * 4;
+                        cur.push(pixels[idx + 2]); // blue
+                        cur.push(pixels[idx + 1]); // green
+                        cur.push(pixels[idx]);     // red
+                        cur.push(alpha);           // alpha
+                    }
+                }
+            }
+        }
+
+        // XOR/bitmask data (BYTE icXOR[])
+        // (ignored, just needs to be the right size)
+        for (y = 0; y < h; y++) {
+            for (x = 0; x < Math.ceil(w / 8); x++) {
+                cur.push(0);
+            }
+        }
+
+        // AND/bitmask data (BYTE icAND[])
+        // (ignored, just needs to be the right size)
+        for (y = 0; y < h; y++) {
+            for (x = 0; x < Math.ceil(w / 8); x++) {
+                cur.push(0);
+            }
+        }
+
+        var url = 'data:image/x-icon;base64,' + Base64.encode(cur);
+        target.style.cursor = 'url(' + url + ')' + hotx + ' ' + hoty + ', default';
+    };
+})();
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/input.js
@@ -0,0 +1,388 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2012 Joel Martin
+ * Copyright (C) 2013 Samuel Mannehed for Cendio AB
+ * Licensed under MPL 2.0 or any later version (see LICENSE.txt)
+ */
+
+/*jslint browser: true, white: false */
+/*global window, Util */
+
+var Keyboard, Mouse;
+
+(function () {
+    "use strict";
+
+    //
+    // Keyboard event handler
+    //
+
+    Keyboard = function (defaults) {
+        this._keyDownList = [];         // List of depressed keys
+                                        // (even if they are happy)
+
+        Util.set_defaults(this, defaults, {
+            'target': document,
+            'focused': true
+        });
+
+        // create the keyboard handler
+        this._handler = new KeyEventDecoder(kbdUtil.ModifierSync(),
+            VerifyCharModifier( /* jshint newcap: false */
+                TrackKeyState(
+                    EscapeModifiers(this._handleRfbEvent.bind(this))
+                )
+            )
+        ); /* jshint newcap: true */
+
+        // keep these here so we can refer to them later
+        this._eventHandlers = {
+            'keyup': this._handleKeyUp.bind(this),
+            'keydown': this._handleKeyDown.bind(this),
+            'keypress': this._handleKeyPress.bind(this),
+            'blur': this._allKeysUp.bind(this)
+        };
+    };
+
+    Keyboard.prototype = {
+        // private methods
+
+        _handleRfbEvent: function (e) {
+            if (this._onKeyPress) {
+                Util.Debug("onKeyPress " + (e.type == 'keydown' ? "down" : "up") +
+                           ", keysym: " + e.keysym.keysym + "(" + e.keysym.keyname + ")");
+                this._onKeyPress(e.keysym.keysym, e.type == 'keydown');
+            }
+        },
+
+        _handleKeyDown: function (e) {
+            if (!this._focused) { return true; }
+
+            if (this._handler.keydown(e)) {
+                // Suppress bubbling/default actions
+                Util.stopEvent(e);
+                return false;
+            } else {
+                // Allow the event to bubble and become a keyPress event which
+                // will have the character code translated
+                return true;
+            }
+        },
+
+        _handleKeyPress: function (e) {
+            if (!this._focused) { return true; }
+
+            if (this._handler.keypress(e)) {
+                // Suppress bubbling/default actions
+                Util.stopEvent(e);
+                return false;
+            } else {
+                // Allow the event to bubble and become a keyPress event which
+                // will have the character code translated
+                return true;
+            }
+        },
+
+        _handleKeyUp: function (e) {
+            if (!this._focused) { return true; }
+
+            if (this._handler.keyup(e)) {
+                // Suppress bubbling/default actions
+                Util.stopEvent(e);
+                return false;
+            } else {
+                // Allow the event to bubble and become a keyPress event which
+                // will have the character code translated
+                return true;
+            }
+        },
+
+        _allKeysUp: function () {
+            Util.Debug(">> Keyboard.allKeysUp");
+            this._handler.releaseAll();
+            Util.Debug("<< Keyboard.allKeysUp");
+        },
+
+        // Public methods
+
+        grab: function () {
+            //Util.Debug(">> Keyboard.grab");
+            var c = this._target;
+
+            Util.addEvent(c, 'keydown', this._eventHandlers.keydown);
+            Util.addEvent(c, 'keyup', this._eventHandlers.keyup);
+            Util.addEvent(c, 'keypress', this._eventHandlers.keypress);
+
+            // Release (key up) if window loses focus
+            Util.addEvent(window, 'blur', this._eventHandlers.blur);
+
+            //Util.Debug("<< Keyboard.grab");
+        },
+
+        ungrab: function () {
+            //Util.Debug(">> Keyboard.ungrab");
+            var c = this._target;
+
+            Util.removeEvent(c, 'keydown', this._eventHandlers.keydown);
+            Util.removeEvent(c, 'keyup', this._eventHandlers.keyup);
+            Util.removeEvent(c, 'keypress', this._eventHandlers.keypress);
+            Util.removeEvent(window, 'blur', this._eventHandlers.blur);
+
+            // Release (key up) all keys that are in a down state
+            this._allKeysUp();
+
+            //Util.Debug(">> Keyboard.ungrab");
+        },
+
+        sync: function (e) {
+            this._handler.syncModifiers(e);
+        }
+    };
+
+    Util.make_properties(Keyboard, [
+        ['target',     'wo', 'dom'],  // DOM element that captures keyboard input
+        ['focused',    'rw', 'bool'], // Capture and send key events
+
+        ['onKeyPress', 'rw', 'func'] // Handler for key press/release
+    ]);
+
+    //
+    // Mouse event handler
+    //
+
+    Mouse = function (defaults) {
+        this._mouseCaptured  = false;
+
+        this._doubleClickTimer = null;
+        this._lastTouchPos = null;
+
+        // Configuration attributes
+        Util.set_defaults(this, defaults, {
+            'target': document,
+            'focused': true,
+            'scale': 1.0,
+            'touchButton': 1
+        });
+
+        this._eventHandlers = {
+            'mousedown': this._handleMouseDown.bind(this),
+            'mouseup': this._handleMouseUp.bind(this),
+            'mousemove': this._handleMouseMove.bind(this),
+            'mousewheel': this._handleMouseWheel.bind(this),
+            'mousedisable': this._handleMouseDisable.bind(this)
+        };
+    };
+
+    Mouse.prototype = {
+        // private methods
+        _captureMouse: function () {
+            // capturing the mouse ensures we get the mouseup event
+            if (this._target.setCapture) {
+                this._target.setCapture();
+            }
+
+            // some browsers give us mouseup events regardless,
+            // so if we never captured the mouse, we can disregard the event
+            this._mouseCaptured = true;
+        },
+
+        _releaseMouse: function () {
+            if (this._target.releaseCapture) {
+                this._target.releaseCapture();
+            }
+            this._mouseCaptured = false;
+        },
+
+        _resetDoubleClickTimer: function () {
+            this._doubleClickTimer = null;
+        },
+
+        _handleMouseButton: function (e, down) {
+            if (!this._focused) { return true; }
+
+            if (this._notify) {
+                this._notify(e);
+            }
+
+            var evt = (e ? e : window.event);
+            var pos = Util.getEventPosition(e, this._target, this._scale);
+
+            var bmask;
+            if (e.touches || e.changedTouches) {
+                // Touch device
+
+                // When two touches occur within 500 ms of each other and are
+                // closer than 20 pixels together a double click is triggered.
+                if (down == 1) {
+                    if (this._doubleClickTimer === null) {
+                        this._lastTouchPos = pos;
+                    } else {
+                        clearTimeout(this._doubleClickTimer);
+
+                        // When the distance between the two touches is small enough
+                        // force the position of the latter touch to the position of
+                        // the first.
+
+                        var xs = this._lastTouchPos.x - pos.x;
+                        var ys = this._lastTouchPos.y - pos.y;
+                        var d = Math.sqrt((xs * xs) + (ys * ys));
+
+                        // The goal is to trigger on a certain physical width, the
+                        // devicePixelRatio brings us a bit closer but is not optimal.
+                        if (d < 20 * window.devicePixelRatio) {
+                            pos = this._lastTouchPos;
+                        }
+                    }
+                    this._doubleClickTimer = setTimeout(this._resetDoubleClickTimer.bind(this), 500);
+                }
+                bmask = this._touchButton;
+                // If bmask is set
+            } else if (evt.which) {
+                /* everything except IE */
+                bmask = 1 << evt.button;
+            } else {
+                /* IE including 9 */
+                bmask = (evt.button & 0x1) +      // Left
+                        (evt.button & 0x2) * 2 +  // Right
+                        (evt.button & 0x4) / 2;   // Middle
+            }
+
+            if (this._onMouseButton) {
+                Util.Debug("onMouseButton " + (down ? "down" : "up") +
+                           ", x: " + pos.x + ", y: " + pos.y + ", bmask: " + bmask);
+                this._onMouseButton(pos.x, pos.y, down, bmask);
+            }
+            Util.stopEvent(e);
+            return false;
+        },
+
+        _handleMouseDown: function (e) {
+            this._captureMouse();
+            this._handleMouseButton(e, 1);
+        },
+
+        _handleMouseUp: function (e) {
+            if (!this._mouseCaptured) { return; }
+
+            this._handleMouseButton(e, 0);
+            this._releaseMouse();
+        },
+
+        _handleMouseWheel: function (e) {
+            if (!this._focused) { return true; }
+
+            if (this._notify) {
+                this._notify(e);
+            }
+
+            var evt = (e ? e : window.event);
+            var pos = Util.getEventPosition(e, this._target, this._scale);
+            var wheelData = evt.detail ? evt.detail * -1 : evt.wheelDelta / 40;
+            var bmask;
+            if (wheelData > 0) {
+                bmask = 1 << 3;
+            } else {
+                bmask = 1 << 4;
+            }
+
+            if (this._onMouseButton) {
+                this._onMouseButton(pos.x, pos.y, 1, bmask);
+                this._onMouseButton(pos.x, pos.y, 0, bmask);
+            }
+            Util.stopEvent(e);
+            return false;
+        },
+
+        _handleMouseMove: function (e) {
+            if (! this._focused) { return true; }
+
+            if (this._notify) {
+                this._notify(e);
+            }
+
+            var evt = (e ? e : window.event);
+            var pos = Util.getEventPosition(e, this._target, this._scale);
+            if (this._onMouseMove) {
+                this._onMouseMove(pos.x, pos.y);
+            }
+            Util.stopEvent(e);
+            return false;
+        },
+
+        _handleMouseDisable: function (e) {
+            if (!this._focused) { return true; }
+
+            var evt = (e ? e : window.event);
+            var pos = Util.getEventPosition(e, this._target, this._scale);
+
+            /* Stop propagation if inside canvas area */
+            if ((pos.realx >= 0) && (pos.realy >= 0) &&
+                (pos.realx < this._target.offsetWidth) &&
+                (pos.realy < this._target.offsetHeight)) {
+                //Util.Debug("mouse event disabled");
+                Util.stopEvent(e);
+                return false;
+            }
+
+            return true;
+        },
+
+
+        // Public methods
+        grab: function () {
+            var c = this._target;
+
+            if ('ontouchstart' in document.documentElement) {
+                Util.addEvent(c, 'touchstart', this._eventHandlers.mousedown);
+                Util.addEvent(window, 'touchend', this._eventHandlers.mouseup);
+                Util.addEvent(c, 'touchend', this._eventHandlers.mouseup);
+                Util.addEvent(c, 'touchmove', this._eventHandlers.mousemove);
+            } else {
+                Util.addEvent(c, 'mousedown', this._eventHandlers.mousedown);
+                Util.addEvent(window, 'mouseup', this._eventHandlers.mouseup);
+                Util.addEvent(c, 'mouseup', this._eventHandlers.mouseup);
+                Util.addEvent(c, 'mousemove', this._eventHandlers.mousemove);
+                Util.addEvent(c, (Util.Engine.gecko) ? 'DOMMouseScroll' : 'mousewheel',
+                              this._eventHandlers.mousewheel);
+            }
+
+            /* Work around right and middle click browser behaviors */
+            Util.addEvent(document, 'click', this._eventHandlers.mousedisable);
+            Util.addEvent(document.body, 'contextmenu', this._eventHandlers.mousedisable);
+        },
+
+        ungrab: function () {
+            var c = this._target;
+
+            if ('ontouchstart' in document.documentElement) {
+                Util.removeEvent(c, 'touchstart', this._eventHandlers.mousedown);
+                Util.removeEvent(window, 'touchend', this._eventHandlers.mouseup);
+                Util.removeEvent(c, 'touchend', this._eventHandlers.mouseup);
+                Util.removeEvent(c, 'touchmove', this._eventHandlers.mousemove);
+            } else {
+                Util.removeEvent(c, 'mousedown', this._eventHandlers.mousedown);
+                Util.removeEvent(window, 'mouseup', this._eventHandlers.mouseup);
+                Util.removeEvent(c, 'mouseup', this._eventHandlers.mouseup);
+                Util.removeEvent(c, 'mousemove', this._eventHandlers.mousemove);
+                Util.removeEvent(c, (Util.Engine.gecko) ? 'DOMMouseScroll' : 'mousewheel',
+                                 this._eventHandlers.mousewheel);
+            }
+
+            /* Work around right and middle click browser behaviors */
+            Util.removeEvent(document, 'click', this._eventHandlers.mousedisable);
+            Util.removeEvent(document.body, 'contextmenu', this._eventHandlers.mousedisable);
+
+        }
+    };
+
+    Util.make_properties(Mouse, [
+        ['target',         'ro', 'dom'],   // DOM element that captures mouse input
+        ['notify',         'ro', 'func'],  // Function to call to notify whenever a mouse event is received
+        ['focused',        'rw', 'bool'],  // Capture and send mouse clicks/movement
+        ['scale',          'rw', 'float'], // Viewport scale factor 0.0 - 1.0
+
+        ['onMouseButton',  'rw', 'func'],  // Handler for mouse button click/release
+        ['onMouseMove',    'rw', 'func'],  // Handler for mouse movement
+        ['touchButton',    'rw', 'int']    // Button mask (1, 2, 4) for touch devices (0 means ignore clicks)
+    ]);
+})();
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/jsunzip.js
@@ -0,0 +1,676 @@
+/*
+ * JSUnzip
+ *
+ * Copyright (c) 2011 by Erik Moller
+ * All Rights Reserved
+ *
+ * This software is provided 'as-is', without any express
+ * or implied warranty.  In no event will the authors be
+ * held liable for any damages arising from the use of
+ * this software.
+ *
+ * Permission is granted to anyone to use this software
+ * for any purpose, including commercial applications,
+ * and to alter it and redistribute it freely, subject to
+ * the following restrictions:
+ *
+ * 1. The origin of this software must not be
+ *    misrepresented; you must not claim that you
+ *    wrote the original software. If you use this
+ *    software in a product, an acknowledgment in
+ *    the product documentation would be appreciated
+ *    but is not required.
+ *
+ * 2. Altered source versions must be plainly marked
+ *    as such, and must not be misrepresented as
+ *    being the original software.
+ *
+ * 3. This notice may not be removed or altered from
+ *    any source distribution.
+ */
+ 
+var tinf;
+
+function JSUnzip() {
+
+    this.getInt = function(offset, size) {
+        switch (size) {
+        case 4:
+            return  (this.data.charCodeAt(offset + 3) & 0xff) << 24 | 
+                    (this.data.charCodeAt(offset + 2) & 0xff) << 16 | 
+                    (this.data.charCodeAt(offset + 1) & 0xff) << 8 | 
+                    (this.data.charCodeAt(offset + 0) & 0xff);
+            break;
+        case 2:
+            return  (this.data.charCodeAt(offset + 1) & 0xff) << 8 | 
+                    (this.data.charCodeAt(offset + 0) & 0xff);
+            break;
+        default:
+            return this.data.charCodeAt(offset) & 0xff;
+            break;
+        }
+    };
+
+    this.getDOSDate = function(dosdate, dostime) {
+        var day = dosdate & 0x1f;
+        var month = ((dosdate >> 5) & 0xf) - 1;
+        var year = 1980 + ((dosdate >> 9) & 0x7f)
+        var second = (dostime & 0x1f) * 2;
+        var minute = (dostime >> 5) & 0x3f;
+        hour = (dostime >> 11) & 0x1f;
+        return new Date(year, month, day, hour, minute, second);
+    }
+
+    this.open = function(data) {
+        this.data = data;
+        this.files = [];
+
+        if (this.data.length < 22)
+            return { 'status' : false, 'error' : 'Invalid data' };
+        var endOfCentralDirectory = this.data.length - 22;
+        while (endOfCentralDirectory >= 0 && this.getInt(endOfCentralDirectory, 4) != 0x06054b50)
+            --endOfCentralDirectory;
+        if (endOfCentralDirectory < 0)
+            return { 'status' : false, 'error' : 'Invalid data' };
+        if (this.getInt(endOfCentralDirectory + 4, 2) != 0 || this.getInt(endOfCentralDirectory + 6, 2) != 0)
+            return { 'status' : false, 'error' : 'No multidisk support' };
+
+        var entriesInThisDisk = this.getInt(endOfCentralDirectory + 8, 2);
+        var centralDirectoryOffset = this.getInt(endOfCentralDirectory + 16, 4);
+        var globalCommentLength = this.getInt(endOfCentralDirectory + 20, 2);
+        this.comment = this.data.slice(endOfCentralDirectory + 22, endOfCentralDirectory + 22 + globalCommentLength);
+
+        var fileOffset = centralDirectoryOffset;
+
+        for (var i = 0; i < entriesInThisDisk; ++i) {
+            if (this.getInt(fileOffset + 0, 4) != 0x02014b50)
+                return { 'status' : false, 'error' : 'Invalid data' };
+            if (this.getInt(fileOffset + 6, 2) > 20)
+                return { 'status' : false, 'error' : 'Unsupported version' };
+            if (this.getInt(fileOffset + 8, 2) & 1)
+                return { 'status' : false, 'error' : 'Encryption not implemented' };
+
+            var compressionMethod = this.getInt(fileOffset + 10, 2);
+            if (compressionMethod != 0 && compressionMethod != 8)
+                return { 'status' : false, 'error' : 'Unsupported compression method' };
+
+            var lastModFileTime = this.getInt(fileOffset + 12, 2);
+            var lastModFileDate = this.getInt(fileOffset + 14, 2);
+            var lastModifiedDate = this.getDOSDate(lastModFileDate, lastModFileTime);
+
+            var crc = this.getInt(fileOffset + 16, 4);
+            // TODO: crc
+
+            var compressedSize = this.getInt(fileOffset + 20, 4);
+            var uncompressedSize = this.getInt(fileOffset + 24, 4);
+
+            var fileNameLength = this.getInt(fileOffset + 28, 2);
+            var extraFieldLength = this.getInt(fileOffset + 30, 2);
+            var fileCommentLength = this.getInt(fileOffset + 32, 2);
+
+            var relativeOffsetOfLocalHeader = this.getInt(fileOffset + 42, 4);
+
+            var fileName = this.data.slice(fileOffset + 46, fileOffset + 46 + fileNameLength);
+            var fileComment = this.data.slice(fileOffset + 46 + fileNameLength + extraFieldLength, fileOffset + 46 + fileNameLength + extraFieldLength + fileCommentLength);
+
+            if (this.getInt(relativeOffsetOfLocalHeader + 0, 4) != 0x04034b50)
+                return { 'status' : false, 'error' : 'Invalid data' };
+            var localFileNameLength = this.getInt(relativeOffsetOfLocalHeader + 26, 2);
+            var localExtraFieldLength = this.getInt(relativeOffsetOfLocalHeader + 28, 2);
+            var localFileContent = relativeOffsetOfLocalHeader + 30 + localFileNameLength + localExtraFieldLength;
+
+            this.files[fileName] = 
+            {
+                'fileComment' : fileComment,
+                'compressionMethod' : compressionMethod,
+                'compressedSize' : compressedSize,
+                'uncompressedSize' : uncompressedSize,
+                'localFileContent' : localFileContent,
+                'lastModifiedDate' : lastModifiedDate
+            };
+
+            fileOffset += 46 + fileNameLength + extraFieldLength + fileCommentLength;
+        }
+        return { 'status' : true }
+    };     
+    
+
+    this.read = function(fileName) {
+        var fileInfo = this.files[fileName];
+        if (fileInfo) {
+            if (fileInfo.compressionMethod == 8) {
+                if (!tinf) {
+                    tinf = new TINF();
+                    tinf.init();
+                }
+                var result = tinf.uncompress(this.data, fileInfo.localFileContent);
+                if (result.status == tinf.OK)
+                    return { 'status' : true, 'data' : result.data };
+                else
+                    return { 'status' : false, 'error' : result.error };
+            } else {
+                return { 'status' : true, 'data' : this.data.slice(fileInfo.localFileContent, fileInfo.localFileContent + fileInfo.uncompressedSize) };
+            }
+        }
+        return { 'status' : false, 'error' : "File '" + fileName + "' doesn't exist in zip" };
+    };
+    
+};
+
+
+
+/*
+ * tinflate  -  tiny inflate
+ *
+ * Copyright (c) 2003 by Joergen Ibsen / Jibz
+ * All Rights Reserved
+ *
+ * http://www.ibsensoftware.com/
+ *
+ * This software is provided 'as-is', without any express
+ * or implied warranty.  In no event will the authors be
+ * held liable for any damages arising from the use of
+ * this software.
+ *
+ * Permission is granted to anyone to use this software
+ * for any purpose, including commercial applications,
+ * and to alter it and redistribute it freely, subject to
+ * the following restrictions:
+ *
+ * 1. The origin of this software must not be
+ *    misrepresented; you must not claim that you
+ *    wrote the original software. If you use this
+ *    software in a product, an acknowledgment in
+ *    the product documentation would be appreciated
+ *    but is not required.
+ *
+ * 2. Altered source versions must be plainly marked
+ *    as such, and must not be misrepresented as
+ *    being the original software.
+ *
+ * 3. This notice may not be removed or altered from
+ *    any source distribution.
+ */
+
+/*
+ * tinflate javascript port by Erik Moller in May 2011.
+ * emoller@opera.com
+ * 
+ * read_bits() patched by mike@imidio.com to allow
+ * reading more then 8 bits (needed in some zlib streams)
+ */
+
+"use strict";
+
+function TINF() {
+    
+this.OK = 0;
+this.DATA_ERROR = (-3);
+this.WINDOW_SIZE = 32768;
+
+/* ------------------------------ *
+ * -- internal data structures -- *
+ * ------------------------------ */
+
+this.TREE = function() {
+   this.table = new Array(16);  /* table of code length counts */
+   this.trans = new Array(288); /* code -> symbol translation table */
+};
+
+this.DATA = function(that) {
+   this.source = '';
+   this.sourceIndex = 0;
+   this.tag = 0;
+   this.bitcount = 0;
+
+   this.dest = [];
+   
+   this.history = [];
+
+   this.ltree = new that.TREE(); /* dynamic length/symbol tree */
+   this.dtree = new that.TREE(); /* dynamic distance tree */
+};
+
+/* --------------------------------------------------- *
+ * -- uninitialized global data (static structures) -- *
+ * --------------------------------------------------- */
+
+this.sltree = new this.TREE(); /* fixed length/symbol tree */
+this.sdtree = new this.TREE(); /* fixed distance tree */
+
+/* extra bits and base tables for length codes */
+this.length_bits = new Array(30);
+this.length_base = new Array(30);
+
+/* extra bits and base tables for distance codes */
+this.dist_bits = new Array(30);
+this.dist_base = new Array(30);
+
+/* special ordering of code length codes */
+this.clcidx = [
+   16, 17, 18, 0, 8, 7, 9, 6,
+   10, 5, 11, 4, 12, 3, 13, 2,
+   14, 1, 15
+];
+
+/* ----------------------- *
+ * -- utility functions -- *
+ * ----------------------- */
+
+/* build extra bits and base tables */
+this.build_bits_base = function(bits, base, delta, first)
+{
+   var i, sum;
+
+   /* build bits table */
+   for (i = 0; i < delta; ++i) bits[i] = 0;
+   for (i = 0; i < 30 - delta; ++i) bits[i + delta] = Math.floor(i / delta);
+
+   /* build base table */
+   for (sum = first, i = 0; i < 30; ++i)
+   {
+      base[i] = sum;
+      sum += 1 << bits[i];
+   }
+}
+
+/* build the fixed huffman trees */
+this.build_fixed_trees = function(lt, dt)
+{
+   var i;
+
+   /* build fixed length tree */
+   for (i = 0; i < 7; ++i) lt.table[i] = 0;
+
+   lt.table[7] = 24;
+   lt.table[8] = 152;
+   lt.table[9] = 112;
+
+   for (i = 0; i < 24; ++i) lt.trans[i] = 256 + i;
+   for (i = 0; i < 144; ++i) lt.trans[24 + i] = i;
+   for (i = 0; i < 8; ++i) lt.trans[24 + 144 + i] = 280 + i;
+   for (i = 0; i < 112; ++i) lt.trans[24 + 144 + 8 + i] = 144 + i;
+
+   /* build fixed distance tree */
+   for (i = 0; i < 5; ++i) dt.table[i] = 0;
+
+   dt.table[5] = 32;
+
+   for (i = 0; i < 32; ++i) dt.trans[i] = i;
+}
+
+/* given an array of code lengths, build a tree */
+this.build_tree = function(t, lengths, loffset, num)
+{
+   var offs = new Array(16);
+   var i, sum;
+
+   /* clear code length count table */
+   for (i = 0; i < 16; ++i) t.table[i] = 0;
+
+   /* scan symbol lengths, and sum code length counts */
+   for (i = 0; i < num; ++i) t.table[lengths[loffset + i]]++;
+
+   t.table[0] = 0;
+
+   /* compute offset table for distribution sort */
+   for (sum = 0, i = 0; i < 16; ++i)
+   {
+      offs[i] = sum;
+      sum += t.table[i];
+   }
+
+   /* create code->symbol translation table (symbols sorted by code) */
+   for (i = 0; i < num; ++i)
+   {
+      if (lengths[loffset + i]) t.trans[offs[lengths[loffset + i]]++] = i;
+   }
+}
+
+/* ---------------------- *
+ * -- decode functions -- *
+ * ---------------------- */
+
+/* get one bit from source stream */
+this.getbit = function(d)
+{
+   var bit;
+
+   /* check if tag is empty */
+   if (!d.bitcount--)
+   {
+      /* load next tag */
+      d.tag = d.source[d.sourceIndex++] & 0xff;
+      d.bitcount = 7;
+   }
+
+   /* shift bit out of tag */
+   bit = d.tag & 0x01;
+   d.tag >>= 1;
+
+   return bit;
+}
+
+/* read a num bit value from a stream and add base */
+function read_bits_direct(source, bitcount, tag, idx, num)
+{
+    var val = 0;
+    while (bitcount < 24) {
+        tag = tag | (source[idx++] & 0xff) << bitcount;
+        bitcount += 8;
+    }
+    val = tag & (0xffff >> (16 - num));
+    tag >>= num;
+    bitcount -= num;
+    return [bitcount, tag, idx, val];
+}
+this.read_bits = function(d, num, base)
+{
+    if (!num)
+        return base;
+
+    var ret = read_bits_direct(d.source, d.bitcount, d.tag, d.sourceIndex, num);
+    d.bitcount = ret[0];
+    d.tag = ret[1];
+    d.sourceIndex = ret[2];
+    return ret[3] + base;
+}
+
+/* given a data stream and a tree, decode a symbol */
+this.decode_symbol = function(d, t)
+{
+    while (d.bitcount < 16) {
+        d.tag = d.tag | (d.source[d.sourceIndex++] & 0xff) << d.bitcount;
+        d.bitcount += 8;
+    }
+    
+    var sum = 0, cur = 0, len = 0;
+    do {
+        cur = 2 * cur + ((d.tag & (1 << len)) >> len);
+
+        ++len;
+
+        sum += t.table[len];
+        cur -= t.table[len];
+
+    } while (cur >= 0);
+
+    d.tag >>= len;
+    d.bitcount -= len;
+
+    return t.trans[sum + cur];
+}
+
+/* given a data stream, decode dynamic trees from it */
+this.decode_trees = function(d, lt, dt)
+{
+   var code_tree = new this.TREE();
+   var lengths = new Array(288+32);
+   var hlit, hdist, hclen;
+   var i, num, length;
+
+   /* get 5 bits HLIT (257-286) */
+   hlit = this.read_bits(d, 5, 257);
+
+   /* get 5 bits HDIST (1-32) */
+   hdist = this.read_bits(d, 5, 1);
+
+   /* get 4 bits HCLEN (4-19) */
+   hclen = this.read_bits(d, 4, 4);
+
+   for (i = 0; i < 19; ++i) lengths[i] = 0;
+
+   /* read code lengths for code length alphabet */
+   for (i = 0; i < hclen; ++i)
+   {
+      /* get 3 bits code length (0-7) */
+      var clen = this.read_bits(d, 3, 0);
+
+      lengths[this.clcidx[i]] = clen;
+   }
+
+   /* build code length tree */
+   this.build_tree(code_tree, lengths, 0, 19);
+
+   /* decode code lengths for the dynamic trees */
+   for (num = 0; num < hlit + hdist; )
+   {
+      var sym = this.decode_symbol(d, code_tree);
+
+      switch (sym)
+      {
+      case 16:
+         /* copy previous code length 3-6 times (read 2 bits) */
+         {
+            var prev = lengths[num - 1];
+            for (length = this.read_bits(d, 2, 3); length; --length)
+            {
+               lengths[num++] = prev;
+            }
+         }
+         break;
+      case 17:
+         /* repeat code length 0 for 3-10 times (read 3 bits) */
+         for (length = this.read_bits(d, 3, 3); length; --length)
+         {
+            lengths[num++] = 0;
+         }
+         break;
+      case 18:
+         /* repeat code length 0 for 11-138 times (read 7 bits) */
+         for (length = this.read_bits(d, 7, 11); length; --length)
+         {
+            lengths[num++] = 0;
+         }
+         break;
+      default:
+         /* values 0-15 represent the actual code lengths */
+         lengths[num++] = sym;
+         break;
+      }
+   }
+
+   /* build dynamic trees */
+   this.build_tree(lt, lengths, 0, hlit);
+   this.build_tree(dt, lengths, hlit, hdist);
+}
+
+/* ----------------------------- *
+ * -- block inflate functions -- *
+ * ----------------------------- */
+
+/* given a stream and two trees, inflate a block of data */
+this.inflate_block_data = function(d, lt, dt)
+{
+   // js optimization.
+   var ddest = d.dest;
+   var ddestlength = ddest.length;
+
+   while (1)
+   {
+      var sym = this.decode_symbol(d, lt);
+
+      /* check for end of block */
+      if (sym == 256)
+      {
+         return this.OK;
+      }
+
+      if (sym < 256)
+      {
+         ddest[ddestlength++] = sym; // ? String.fromCharCode(sym);
+         d.history.push(sym);
+      } else {
+
+         var length, dist, offs;
+         var i;
+
+         sym -= 257;
+
+         /* possibly get more bits from length code */
+         length = this.read_bits(d, this.length_bits[sym], this.length_base[sym]);
+
+         dist = this.decode_symbol(d, dt);
+
+         /* possibly get more bits from distance code */
+         offs = d.history.length - this.read_bits(d, this.dist_bits[dist], this.dist_base[dist]);
+
+         if (offs < 0)
+             throw ("Invalid zlib offset " + offs);
+         
+         /* copy match */
+         for (i = offs; i < offs + length; ++i) {
+            //ddest[ddestlength++] = ddest[i];
+            ddest[ddestlength++] = d.history[i];
+            d.history.push(d.history[i]);
+         }
+      }
+   }
+}
+
+/* inflate an uncompressed block of data */
+this.inflate_uncompressed_block = function(d)
+{
+   var length, invlength;
+   var i;
+
+   if (d.bitcount > 7) {
+       var overflow = Math.floor(d.bitcount / 8);
+       d.sourceIndex -= overflow;
+       d.bitcount = 0;
+       d.tag = 0;
+   }
+   
+   /* get length */
+   length = d.source[d.sourceIndex+1];
+   length = 256*length + d.source[d.sourceIndex];
+
+   /* get one's complement of length */
+   invlength = d.source[d.sourceIndex+3];
+   invlength = 256*invlength + d.source[d.sourceIndex+2];
+
+   /* check length */
+   if (length != (~invlength & 0x0000ffff)) return this.DATA_ERROR;
+
+   d.sourceIndex += 4;
+
+   /* copy block */
+   for (i = length; i; --i) {
+       d.history.push(d.source[d.sourceIndex]);
+       d.dest[d.dest.length] = d.source[d.sourceIndex++];
+   }
+
+   /* make sure we start next block on a byte boundary */
+   d.bitcount = 0;
+
+   return this.OK;
+}
+
+/* inflate a block of data compressed with fixed huffman trees */
+this.inflate_fixed_block = function(d)
+{
+   /* decode block using fixed trees */
+   return this.inflate_block_data(d, this.sltree, this.sdtree);
+}
+
+/* inflate a block of data compressed with dynamic huffman trees */
+this.inflate_dynamic_block = function(d)
+{
+   /* decode trees from stream */
+   this.decode_trees(d, d.ltree, d.dtree);
+
+   /* decode block using decoded trees */
+   return this.inflate_block_data(d, d.ltree, d.dtree);
+}
+
+/* ---------------------- *
+ * -- public functions -- *
+ * ---------------------- */
+
+/* initialize global (static) data */
+this.init = function()
+{
+   /* build fixed huffman trees */
+   this.build_fixed_trees(this.sltree, this.sdtree);
+
+   /* build extra bits and base tables */
+   this.build_bits_base(this.length_bits, this.length_base, 4, 3);
+   this.build_bits_base(this.dist_bits, this.dist_base, 2, 1);
+
+   /* fix a special case */
+   this.length_bits[28] = 0;
+   this.length_base[28] = 258;
+
+   this.reset();   
+}
+
+this.reset = function()
+{
+   this.d = new this.DATA(this);
+   delete this.header;
+}
+
+/* inflate stream from source to dest */
+this.uncompress = function(source, offset)
+{
+
+   var d = this.d;
+   var bfinal;
+
+   /* initialise data */
+   d.source = source;
+   d.sourceIndex = offset;
+   d.bitcount = 0;
+
+   d.dest = [];
+
+   // Skip zlib header at start of stream
+   if (typeof this.header == 'undefined') {
+       this.header = this.read_bits(d, 16, 0);
+       /* byte 0: 0x78, 7 = 32k window size, 8 = deflate */
+       /* byte 1: check bits for header and other flags */
+   }
+
+   var blocks = 0;
+   
+   do {
+
+      var btype;
+      var res;
+
+      /* read final block flag */
+      bfinal = this.getbit(d);
+
+      /* read block type (2 bits) */
+      btype = this.read_bits(d, 2, 0);
+
+      /* decompress block */
+      switch (btype)
+      {
+      case 0:
+         /* decompress uncompressed block */
+         res = this.inflate_uncompressed_block(d);
+         break;
+      case 1:
+         /* decompress block with fixed huffman trees */
+         res = this.inflate_fixed_block(d);
+         break;
+      case 2:
+         /* decompress block with dynamic huffman trees */
+         res = this.inflate_dynamic_block(d);
+         break;
+      default:
+         return { 'status' : this.DATA_ERROR };
+      }
+
+      if (res != this.OK) return { 'status' : this.DATA_ERROR };
+      blocks++;
+      
+   } while (!bfinal && d.sourceIndex < d.source.length);
+
+   d.history = d.history.slice(-this.WINDOW_SIZE);
+   
+   return { 'status' : this.OK, 'data' : d.dest };
+}
+
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/keyboard.js
@@ -0,0 +1,543 @@
+var kbdUtil = (function() {
+    "use strict";
+
+    function substituteCodepoint(cp) {
+        // Any Unicode code points which do not have corresponding keysym entries
+        // can be swapped out for another code point by adding them to this table
+        var substitutions = {
+            // {S,s} with comma below -> {S,s} with cedilla
+            0x218 : 0x15e,
+            0x219 : 0x15f,
+            // {T,t} with comma below -> {T,t} with cedilla
+            0x21a : 0x162,
+            0x21b : 0x163
+        };
+
+        var sub = substitutions[cp];
+        return sub ? sub : cp;
+    }
+
+    function isMac() {
+        return navigator && !!(/mac/i).exec(navigator.platform);
+    }
+    function isWindows() {
+        return navigator && !!(/win/i).exec(navigator.platform);
+    }
+    function isLinux() {
+        return navigator && !!(/linux/i).exec(navigator.platform);
+    }
+
+    // Return true if a modifier which is not the specified char modifier (and is not shift) is down
+    function hasShortcutModifier(charModifier, currentModifiers) {
+        var mods = {};
+        for (var key in currentModifiers) {
+            if (parseInt(key) !== XK_Shift_L) {
+                mods[key] = currentModifiers[key];
+            }
+        }
+
+        var sum = 0;
+        for (var k in currentModifiers) {
+            if (mods[k]) {
+                ++sum;
+            }
+        }
+        if (hasCharModifier(charModifier, mods)) {
+            return sum > charModifier.length;
+        }
+        else {
+            return sum > 0;
+        }
+    }
+
+    // Return true if the specified char modifier is currently down
+    function hasCharModifier(charModifier, currentModifiers) {
+        if (charModifier.length === 0) { return false; }
+
+        for (var i = 0; i < charModifier.length; ++i) {
+            if (!currentModifiers[charModifier[i]]) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    // Helper object tracking modifier key state
+    // and generates fake key events to compensate if it gets out of sync
+    function ModifierSync(charModifier) {
+        if (!charModifier) {
+            if (isMac()) {
+                // on Mac, Option (AKA Alt) is used as a char modifier
+                charModifier = [XK_Alt_L];
+            }
+            else if (isWindows()) {
+                // on Windows, Ctrl+Alt is used as a char modifier
+                charModifier = [XK_Alt_L, XK_Control_L];
+            }
+            else if (isLinux()) {
+                // on Linux, ISO Level 3 Shift (AltGr) is used as a char modifier
+                charModifier = [XK_ISO_Level3_Shift];
+            }
+            else {
+                charModifier = [];
+            }
+        }
+
+        var state = {};
+        state[XK_Control_L] = false;
+        state[XK_Alt_L] = false;
+        state[XK_ISO_Level3_Shift] = false;
+        state[XK_Shift_L] = false;
+        state[XK_Meta_L] = false;
+
+        function sync(evt, keysym) {
+            var result = [];
+            function syncKey(keysym) {
+                return {keysym: keysyms.lookup(keysym), type: state[keysym] ? 'keydown' : 'keyup'};
+            }
+
+            if (evt.ctrlKey !== undefined &&
+                evt.ctrlKey !== state[XK_Control_L] && keysym !== XK_Control_L) {
+                state[XK_Control_L] = evt.ctrlKey;
+                result.push(syncKey(XK_Control_L));
+            }
+            if (evt.altKey !== undefined &&
+                evt.altKey !== state[XK_Alt_L] && keysym !== XK_Alt_L) {
+                state[XK_Alt_L] = evt.altKey;
+                result.push(syncKey(XK_Alt_L));
+            }
+            if (evt.altGraphKey !== undefined &&
+                evt.altGraphKey !== state[XK_ISO_Level3_Shift] && keysym !== XK_ISO_Level3_Shift) {
+                state[XK_ISO_Level3_Shift] = evt.altGraphKey;
+                result.push(syncKey(XK_ISO_Level3_Shift));
+            }
+            if (evt.shiftKey !== undefined &&
+                evt.shiftKey !== state[XK_Shift_L] && keysym !== XK_Shift_L) {
+                state[XK_Shift_L] = evt.shiftKey;
+                result.push(syncKey(XK_Shift_L));
+            }
+            if (evt.metaKey !== undefined &&
+                evt.metaKey !== state[XK_Meta_L] && keysym !== XK_Meta_L) {
+                state[XK_Meta_L] = evt.metaKey;
+                result.push(syncKey(XK_Meta_L));
+            }
+            return result;
+        }
+        function syncKeyEvent(evt, down) {
+            var obj = getKeysym(evt);
+            var keysym = obj ? obj.keysym : null;
+
+            // first, apply the event itself, if relevant
+            if (keysym !== null && state[keysym] !== undefined) {
+                state[keysym] = down;
+            }
+            return sync(evt, keysym);
+        }
+
+        return {
+            // sync on the appropriate keyboard event
+            keydown: function(evt) { return syncKeyEvent(evt, true);},
+            keyup: function(evt) { return syncKeyEvent(evt, false);},
+            // Call this with a non-keyboard event (such as mouse events) to use its modifier state to synchronize anyway
+            syncAny: function(evt) { return sync(evt);},
+
+            // is a shortcut modifier down?
+            hasShortcutModifier: function() { return hasShortcutModifier(charModifier, state); },
+            // if a char modifier is down, return the keys it consists of, otherwise return null
+            activeCharModifier: function() { return hasCharModifier(charModifier, state) ? charModifier : null; }
+        };
+    }
+
+    // Get a key ID from a keyboard event
+    // May be a string or an integer depending on the available properties
+    function getKey(evt){
+        if ('keyCode' in evt && 'key' in evt) {
+            return evt.key + ':' + evt.keyCode;
+        }
+        else if ('keyCode' in evt) {
+            return evt.keyCode;
+        }
+        else {
+            return evt.key;
+        }
+    }
+
+    // Get the most reliable keysym value we can get from a key event
+    // if char/charCode is available, prefer those, otherwise fall back to key/keyCode/which
+    function getKeysym(evt){
+        var codepoint;
+        if (evt.char && evt.char.length === 1) {
+            codepoint = evt.char.charCodeAt();
+        }
+        else if (evt.charCode) {
+            codepoint = evt.charCode;
+        }
+        else if (evt.keyCode && evt.type === 'keypress') {
+            // IE10 stores the char code as keyCode, and has no other useful properties
+            codepoint = evt.keyCode;
+        }
+        if (codepoint) {
+            var res = keysyms.fromUnicode(substituteCodepoint(codepoint));
+            if (res) {
+                return res;
+            }
+        }
+        // we could check evt.key here.
+        // Legal values are defined in http://www.w3.org/TR/DOM-Level-3-Events/#key-values-list,
+        // so we "just" need to map them to keysym, but AFAIK this is only available in IE10, which also provides evt.key
+        // so we don't *need* it yet
+        if (evt.keyCode) {
+            return keysyms.lookup(keysymFromKeyCode(evt.keyCode, evt.shiftKey));
+        }
+        if (evt.which) {
+            return keysyms.lookup(keysymFromKeyCode(evt.which, evt.shiftKey));
+        }
+        return null;
+    }
+
+    // Given a keycode, try to predict which keysym it might be.
+    // If the keycode is unknown, null is returned.
+    function keysymFromKeyCode(keycode, shiftPressed) {
+        if (typeof(keycode) !== 'number') {
+            return null;
+        }
+        // won't be accurate for azerty
+        if (keycode >= 0x30 && keycode <= 0x39) {
+            return keycode; // digit
+        }
+        if (keycode >= 0x41 && keycode <= 0x5a) {
+            // remap to lowercase unless shift is down
+            return shiftPressed ? keycode : keycode + 32; // A-Z
+        }
+        if (keycode >= 0x60 && keycode <= 0x69) {
+            return XK_KP_0 + (keycode - 0x60); // numpad 0-9
+        }
+
+        switch(keycode) {
+            case 0x20: return XK_space;
+            case 0x6a: return XK_KP_Multiply;
+            case 0x6b: return XK_KP_Add;
+            case 0x6c: return XK_KP_Separator;
+            case 0x6d: return XK_KP_Subtract;
+            case 0x6e: return XK_KP_Decimal;
+            case 0x6f: return XK_KP_Divide;
+            case 0xbb: return XK_plus;
+            case 0xbc: return XK_comma;
+            case 0xbd: return XK_minus;
+            case 0xbe: return XK_period;
+        }
+
+        return nonCharacterKey({keyCode: keycode});
+    }
+
+    // if the key is a known non-character key (any key which doesn't generate character data)
+    // return its keysym value. Otherwise return null
+    function nonCharacterKey(evt) {
+        // evt.key not implemented yet
+        if (!evt.keyCode) { return null; }
+        var keycode = evt.keyCode;
+
+        if (keycode >= 0x70 && keycode <= 0x87) {
+            return XK_F1 + keycode - 0x70; // F1-F24
+        }
+        switch (keycode) {
+
+            case 8 : return XK_BackSpace;
+            case 13 : return XK_Return;
+
+            case 9 : return XK_Tab;
+
+            case 27 : return XK_Escape;
+            case 46 : return XK_Delete;
+
+            case 36 : return XK_Home;
+            case 35 : return XK_End;
+            case 33 : return XK_Page_Up;
+            case 34 : return XK_Page_Down;
+            case 45 : return XK_Insert;
+
+            case 37 : return XK_Left;
+            case 38 : return XK_Up;
+            case 39 : return XK_Right;
+            case 40 : return XK_Down;
+
+            case 16 : return XK_Shift_L;
+            case 17 : return XK_Control_L;
+            case 18 : return XK_Alt_L; // also: Option-key on Mac
+
+            case 224 : return XK_Meta_L;
+            case 225 : return XK_ISO_Level3_Shift; // AltGr
+            case 91 : return XK_Super_L; // also: Windows-key
+            case 92 : return XK_Super_R; // also: Windows-key
+            case 93 : return XK_Menu; // also: Windows-Menu, Command on Mac
+            default: return null;
+        }
+    }
+    return {
+        hasShortcutModifier : hasShortcutModifier,
+        hasCharModifier : hasCharModifier,
+        ModifierSync : ModifierSync,
+        getKey : getKey,
+        getKeysym : getKeysym,
+        keysymFromKeyCode : keysymFromKeyCode,
+        nonCharacterKey : nonCharacterKey,
+        substituteCodepoint : substituteCodepoint
+    };
+})();
+
+// Takes a DOM keyboard event and:
+// - determines which keysym it represents
+// - determines a keyId  identifying the key that was pressed (corresponding to the key/keyCode properties on the DOM event)
+// - synthesizes events to synchronize modifier key state between which modifiers are actually down, and which we thought were down
+// - marks each event with an 'escape' property if a modifier was down which should be "escaped"
+// - generates a "stall" event in cases where it might be necessary to wait and see if a keypress event follows a keydown
+// This information is collected into an object which is passed to the next() function. (one call per event)
+function KeyEventDecoder(modifierState, next) {
+    "use strict";
+    function sendAll(evts) {
+        for (var i = 0; i < evts.length; ++i) {
+            next(evts[i]);
+        }
+    }
+    function process(evt, type) {
+        var result = {type: type};
+        var keyId = kbdUtil.getKey(evt);
+        if (keyId) {
+            result.keyId = keyId;
+        }
+
+        var keysym = kbdUtil.getKeysym(evt);
+
+        var hasModifier = modifierState.hasShortcutModifier() || !!modifierState.activeCharModifier();
+        // Is this a case where we have to decide on the keysym right away, rather than waiting for the keypress?
+        // "special" keys like enter, tab or backspace don't send keypress events,
+        // and some browsers don't send keypresses at all if a modifier is down
+        if (keysym && (type !== 'keydown' || kbdUtil.nonCharacterKey(evt) || hasModifier)) {
+            result.keysym = keysym;
+        }
+
+        var isShift = evt.keyCode === 0x10 || evt.key === 'Shift';
+
+        // Should we prevent the browser from handling the event?
+        // Doing so on a keydown (in most browsers) prevents keypress from being generated
+        // so only do that if we have to.
+        var suppress = !isShift && (type !== 'keydown' || modifierState.hasShortcutModifier() || !!kbdUtil.nonCharacterKey(evt));
+
+        // If a char modifier is down on a keydown, we need to insert a stall,
+        // so VerifyCharModifier knows to wait and see if a keypress is comnig
+        var stall = type === 'keydown' && modifierState.activeCharModifier() && !kbdUtil.nonCharacterKey(evt);
+
+        // if a char modifier is pressed, get the keys it consists of (on Windows, AltGr is equivalent to Ctrl+Alt)
+        var active = modifierState.activeCharModifier();
+
+        // If we have a char modifier down, and we're able to determine a keysym reliably
+        // then (a) we know to treat the modifier as a char modifier,
+        // and (b) we'll have to "escape" the modifier to undo the modifier when sending the char.
+        if (active && keysym) {
+            var isCharModifier = false;
+            for (var i  = 0; i < active.length; ++i) {
+                if (active[i] === keysym.keysym) {
+                    isCharModifier = true;
+                }
+            }
+            if (type === 'keypress' && !isCharModifier) {
+                result.escape = modifierState.activeCharModifier();
+            }
+        }
+
+        if (stall) {
+            // insert a fake "stall" event
+            next({type: 'stall'});
+        }
+        next(result);
+
+        return suppress;
+    }
+
+    return {
+        keydown: function(evt) {
+            sendAll(modifierState.keydown(evt));
+            return process(evt, 'keydown');
+        },
+        keypress: function(evt) {
+            return process(evt, 'keypress');
+        },
+        keyup: function(evt) {
+            sendAll(modifierState.keyup(evt));
+            return process(evt, 'keyup');
+        },
+        syncModifiers: function(evt) {
+            sendAll(modifierState.syncAny(evt));
+        },
+        releaseAll: function() { next({type: 'releaseall'}); }
+    };
+}
+
+// Combines keydown and keypress events where necessary to handle char modifiers.
+// On some OS'es, a char modifier is sometimes used as a shortcut modifier.
+// For example, on Windows, AltGr is synonymous with Ctrl-Alt. On a Danish keyboard layout, AltGr-2 yields a @, but Ctrl-Alt-D does nothing
+// so when used with the '2' key, Ctrl-Alt counts as a char modifier (and should be escaped), but when used with 'D', it does not.
+// The only way we can distinguish these cases is to wait and see if a keypress event arrives
+// When we receive a "stall" event, wait a few ms before processing the next keydown. If a keypress has also arrived, merge the two
+function VerifyCharModifier(next) {
+    "use strict";
+    var queue = [];
+    var timer = null;
+    function process() {
+        if (timer) {
+            return;
+        }
+
+        var delayProcess = function () {
+            clearTimeout(timer);
+            timer = null;
+            process();
+        };
+
+        while (queue.length !== 0) {
+            var cur = queue[0];
+            queue = queue.splice(1);
+            switch (cur.type) {
+            case 'stall':
+                // insert a delay before processing available events.
+                /* jshint loopfunc: true */
+                timer = setTimeout(delayProcess, 5);
+                /* jshint loopfunc: false */
+                return;
+            case 'keydown':
+                // is the next element a keypress? Then we should merge the two
+                if (queue.length !== 0 && queue[0].type === 'keypress') {
+                    // Firefox sends keypress even when no char is generated.
+                    // so, if keypress keysym is the same as we'd have guessed from keydown,
+                    // the modifier didn't have any effect, and should not be escaped
+                    if (queue[0].escape && (!cur.keysym || cur.keysym.keysym !== queue[0].keysym.keysym)) {
+                        cur.escape = queue[0].escape;
+                    }
+                    cur.keysym = queue[0].keysym;
+                    queue = queue.splice(1);
+                }
+                break;
+            }
+
+            // swallow stall events, and pass all others to the next stage
+            if (cur.type !== 'stall') {
+                next(cur);
+            }
+        }
+    }
+    return function(evt) {
+        queue.push(evt);
+        process();
+    };
+}
+
+// Keeps track of which keys we (and the server) believe are down
+// When a keyup is received, match it against this list, to determine the corresponding keysym(s)
+// in some cases, a single key may produce multiple keysyms, so the corresponding keyup event must release all of these chars
+// key repeat events should be merged into a single entry.
+// Because we can't always identify which entry a keydown or keyup event corresponds to, we sometimes have to guess
+function TrackKeyState(next) {
+    "use strict";
+    var state = [];
+
+    return function (evt) {
+        var last = state.length !== 0 ? state[state.length-1] : null;
+
+        switch (evt.type) {
+        case 'keydown':
+            // insert a new entry if last seen key was different.
+            if (!last || !evt.keyId || last.keyId !== evt.keyId) {
+                last = {keyId: evt.keyId, keysyms: {}};
+                state.push(last);
+            }
+            if (evt.keysym) {
+                // make sure last event contains this keysym (a single "logical" keyevent
+                // can cause multiple key events to be sent to the VNC server)
+                last.keysyms[evt.keysym.keysym] = evt.keysym;
+                last.ignoreKeyPress = true;
+                next(evt);
+            }
+            break;
+        case 'keypress':
+            if (!last) {
+                last = {keyId: evt.keyId, keysyms: {}};
+                state.push(last);
+            }
+            if (!evt.keysym) {
+                console.log('keypress with no keysym:', evt);
+            }
+
+            // If we didn't expect a keypress, and already sent a keydown to the VNC server
+            // based on the keydown, make sure to skip this event.
+            if (evt.keysym && !last.ignoreKeyPress) {
+                last.keysyms[evt.keysym.keysym] = evt.keysym;
+                evt.type = 'keydown';
+                next(evt);
+            }
+            break;
+        case 'keyup':
+            if (state.length === 0) {
+                return;
+            }
+            var idx = null;
+            // do we have a matching key tracked as being down?
+            for (var i = 0; i !== state.length; ++i) {
+                if (state[i].keyId === evt.keyId) {
+                    idx = i;
+                    break;
+                }
+            }
+            // if we couldn't find a match (it happens), assume it was the last key pressed
+            if (idx === null) {
+                idx = state.length - 1;
+            }
+
+            var item = state.splice(idx, 1)[0];
+            // for each keysym tracked by this key entry, clone the current event and override the keysym
+            var clone = (function(){
+                function Clone(){}
+                return function (obj) { Clone.prototype=obj; return new Clone(); };
+            }());
+            for (var key in item.keysyms) {
+                var out = clone(evt);
+                out.keysym = item.keysyms[key];
+                next(out);
+            }
+            break;
+        case 'releaseall':
+            /* jshint shadow: true */
+            for (var i = 0; i < state.length; ++i) {
+                for (var key in state[i].keysyms) {
+                    var keysym = state[i].keysyms[key];
+                    next({keyId: 0, keysym: keysym, type: 'keyup'});
+                }
+            }
+            /* jshint shadow: false */
+            state = [];
+        }
+    };
+}
+
+// Handles "escaping" of modifiers: if a char modifier is used to produce a keysym (such as AltGr-2 to generate an @),
+// then the modifier must be "undone" before sending the @, and "redone" afterwards.
+function EscapeModifiers(next) {
+    "use strict";
+    return function(evt) {
+        if (evt.type !== 'keydown' || evt.escape === undefined) {
+            next(evt);
+            return;
+        }
+        // undo modifiers
+        for (var i = 0; i < evt.escape.length; ++i) {
+            next({type: 'keyup', keyId: 0, keysym: keysyms.lookup(evt.escape[i])});
+        }
+        // send the character event
+        next(evt);
+        // redo modifiers
+        /* jshint shadow: true */
+        for (var i = 0; i < evt.escape.length; ++i) {
+            next({type: 'keydown', keyId: 0, keysym: keysyms.lookup(evt.escape[i])});
+        }
+        /* jshint shadow: false */
+    };
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/keysym.js
@@ -0,0 +1,378 @@
+var XK_VoidSymbol =                0xffffff, /* Void symbol */
+
+XK_BackSpace =                   0xff08, /* Back space, back char */
+XK_Tab =                         0xff09,
+XK_Linefeed =                    0xff0a, /* Linefeed, LF */
+XK_Clear =                       0xff0b,
+XK_Return =                      0xff0d, /* Return, enter */
+XK_Pause =                       0xff13, /* Pause, hold */
+XK_Scroll_Lock =                 0xff14,
+XK_Sys_Req =                     0xff15,
+XK_Escape =                      0xff1b,
+XK_Delete =                      0xffff, /* Delete, rubout */
+
+/* Cursor control & motion */
+
+XK_Home =                        0xff50,
+XK_Left =                        0xff51, /* Move left, left arrow */
+XK_Up =                          0xff52, /* Move up, up arrow */
+XK_Right =                       0xff53, /* Move right, right arrow */
+XK_Down =                        0xff54, /* Move down, down arrow */
+XK_Prior =                       0xff55, /* Prior, previous */
+XK_Page_Up =                     0xff55,
+XK_Next =                        0xff56, /* Next */
+XK_Page_Down =                   0xff56,
+XK_End =                         0xff57, /* EOL */
+XK_Begin =                       0xff58, /* BOL */
+
+
+/* Misc functions */
+
+XK_Select =                      0xff60, /* Select, mark */
+XK_Print =                       0xff61,
+XK_Execute =                     0xff62, /* Execute, run, do */
+XK_Insert =                      0xff63, /* Insert, insert here */
+XK_Undo =                        0xff65,
+XK_Redo =                        0xff66, /* Redo, again */
+XK_Menu =                        0xff67,
+XK_Find =                        0xff68, /* Find, search */
+XK_Cancel =                      0xff69, /* Cancel, stop, abort, exit */
+XK_Help =                        0xff6a, /* Help */
+XK_Break =                       0xff6b,
+XK_Mode_switch =                 0xff7e, /* Character set switch */
+XK_script_switch =               0xff7e, /* Alias for mode_switch */
+XK_Num_Lock =                    0xff7f,
+
+/* Keypad functions, keypad numbers cleverly chosen to map to ASCII */
+
+XK_KP_Space =                    0xff80, /* Space */
+XK_KP_Tab =                      0xff89,
+XK_KP_Enter =                    0xff8d, /* Enter */
+XK_KP_F1 =                       0xff91, /* PF1, KP_A, ... */
+XK_KP_F2 =                       0xff92,
+XK_KP_F3 =                       0xff93,
+XK_KP_F4 =                       0xff94,
+XK_KP_Home =                     0xff95,
+XK_KP_Left =                     0xff96,
+XK_KP_Up =                       0xff97,
+XK_KP_Right =                    0xff98,
+XK_KP_Down =                     0xff99,
+XK_KP_Prior =                    0xff9a,
+XK_KP_Page_Up =                  0xff9a
+XK_KP_Next =                     0xff9b,
+XK_KP_Page_Down =                0xff9b,
+XK_KP_End =                      0xff9c,
+XK_KP_Begin =                    0xff9d,
+XK_KP_Insert =                   0xff9e,
+XK_KP_Delete =                   0xff9f,
+XK_KP_Equal =                    0xffbd, /* Equals */
+XK_KP_Multiply =                 0xffaa,
+XK_KP_Add =                      0xffab,
+XK_KP_Separator =                0xffac, /* Separator, often comma */
+XK_KP_Subtract =                 0xffad,
+XK_KP_Decimal =                  0xffae,
+XK_KP_Divide =                   0xffaf,
+
+XK_KP_0 =                        0xffb0,
+XK_KP_1 =                        0xffb1,
+XK_KP_2 =                        0xffb2,
+XK_KP_3 =                        0xffb3,
+XK_KP_4 =                        0xffb4,
+XK_KP_5 =                        0xffb5,
+XK_KP_6 =                        0xffb6,
+XK_KP_7 =                        0xffb7,
+XK_KP_8 =                        0xffb8,
+XK_KP_9 =                        0xffb9,
+
+/*
+ * Auxiliary functions; note the duplicate definitions for left and right
+ * function keys;  Sun keyboards and a few other manufacturers have such
+ * function key groups on the left and/or right sides of the keyboard.
+ * We've not found a keyboard with more than 35 function keys total.
+ */
+
+XK_F1 =                          0xffbe,
+XK_F2 =                          0xffbf,
+XK_F3 =                          0xffc0,
+XK_F4 =                          0xffc1,
+XK_F5 =                          0xffc2,
+XK_F6 =                          0xffc3,
+XK_F7 =                          0xffc4,
+XK_F8 =                          0xffc5,
+XK_F9 =                          0xffc6,
+XK_F10 =                         0xffc7,
+XK_F11 =                         0xffc8,
+XK_L1 =                          0xffc8,
+XK_F12 =                         0xffc9,
+XK_L2 =                          0xffc9,
+XK_F13 =                         0xffca,
+XK_L3 =                          0xffca,
+XK_F14 =                         0xffcb,
+XK_L4 =                          0xffcb,
+XK_F15 =                         0xffcc,
+XK_L5 =                          0xffcc,
+XK_F16 =                         0xffcd,
+XK_L6 =                          0xffcd,
+XK_F17 =                         0xffce,
+XK_L7 =                          0xffce,
+XK_F18 =                         0xffcf,
+XK_L8 =                          0xffcf,
+XK_F19 =                         0xffd0,
+XK_L9 =                          0xffd0,
+XK_F20 =                         0xffd1,
+XK_L10 =                         0xffd1,
+XK_F21 =                         0xffd2,
+XK_R1 =                          0xffd2,
+XK_F22 =                         0xffd3,
+XK_R2 =                          0xffd3,
+XK_F23 =                         0xffd4,
+XK_R3 =                          0xffd4,
+XK_F24 =                         0xffd5,
+XK_R4 =                          0xffd5,
+XK_F25 =                         0xffd6,
+XK_R5 =                          0xffd6,
+XK_F26 =                         0xffd7,
+XK_R6 =                          0xffd7,
+XK_F27 =                         0xffd8,
+XK_R7 =                          0xffd8,
+XK_F28 =                         0xffd9,
+XK_R8 =                          0xffd9,
+XK_F29 =                         0xffda,
+XK_R9 =                          0xffda,
+XK_F30 =                         0xffdb,
+XK_R10 =                         0xffdb,
+XK_F31 =                         0xffdc,
+XK_R11 =                         0xffdc,
+XK_F32 =                         0xffdd,
+XK_R12 =                         0xffdd,
+XK_F33 =                         0xffde,
+XK_R13 =                         0xffde,
+XK_F34 =                         0xffdf,
+XK_R14 =                         0xffdf,
+XK_F35 =                         0xffe0,
+XK_R15 =                         0xffe0,
+
+/* Modifiers */
+
+XK_Shift_L =                     0xffe1, /* Left shift */
+XK_Shift_R =                     0xffe2, /* Right shift */
+XK_Control_L =                   0xffe3, /* Left control */
+XK_Control_R =                   0xffe4, /* Right control */
+XK_Caps_Lock =                   0xffe5, /* Caps lock */
+XK_Shift_Lock =                  0xffe6, /* Shift lock */
+
+XK_Meta_L =                      0xffe7, /* Left meta */
+XK_Meta_R =                      0xffe8, /* Right meta */
+XK_Alt_L =                       0xffe9, /* Left alt */
+XK_Alt_R =                       0xffea, /* Right alt */
+XK_Super_L =                     0xffeb, /* Left super */
+XK_Super_R =                     0xffec, /* Right super */
+XK_Hyper_L =                     0xffed, /* Left hyper */
+XK_Hyper_R =                     0xffee, /* Right hyper */
+
+XK_ISO_Level3_Shift =            0xfe03, /* AltGr */
+
+/*
+ * Latin 1
+ * (ISO/IEC 8859-1 = Unicode U+0020..U+00FF)
+ * Byte 3 = 0
+ */
+
+XK_space =                       0x0020, /* U+0020 SPACE */
+XK_exclam =                      0x0021, /* U+0021 EXCLAMATION MARK */
+XK_quotedbl =                    0x0022, /* U+0022 QUOTATION MARK */
+XK_numbersign =                  0x0023, /* U+0023 NUMBER SIGN */
+XK_dollar =                      0x0024, /* U+0024 DOLLAR SIGN */
+XK_percent =                     0x0025, /* U+0025 PERCENT SIGN */
+XK_ampersand =                   0x0026, /* U+0026 AMPERSAND */
+XK_apostrophe =                  0x0027, /* U+0027 APOSTROPHE */
+XK_quoteright =                  0x0027, /* deprecated */
+XK_parenleft =                   0x0028, /* U+0028 LEFT PARENTHESIS */
+XK_parenright =                  0x0029, /* U+0029 RIGHT PARENTHESIS */
+XK_asterisk =                    0x002a, /* U+002A ASTERISK */
+XK_plus =                        0x002b, /* U+002B PLUS SIGN */
+XK_comma =                       0x002c, /* U+002C COMMA */
+XK_minus =                       0x002d, /* U+002D HYPHEN-MINUS */
+XK_period =                      0x002e, /* U+002E FULL STOP */
+XK_slash =                       0x002f, /* U+002F SOLIDUS */
+XK_0 =                           0x0030, /* U+0030 DIGIT ZERO */
+XK_1 =                           0x0031, /* U+0031 DIGIT ONE */
+XK_2 =                           0x0032, /* U+0032 DIGIT TWO */
+XK_3 =                           0x0033, /* U+0033 DIGIT THREE */
+XK_4 =                           0x0034, /* U+0034 DIGIT FOUR */
+XK_5 =                           0x0035, /* U+0035 DIGIT FIVE */
+XK_6 =                           0x0036, /* U+0036 DIGIT SIX */
+XK_7 =                           0x0037, /* U+0037 DIGIT SEVEN */
+XK_8 =                           0x0038, /* U+0038 DIGIT EIGHT */
+XK_9 =                           0x0039, /* U+0039 DIGIT NINE */
+XK_colon =                       0x003a, /* U+003A COLON */
+XK_semicolon =                   0x003b, /* U+003B SEMICOLON */
+XK_less =                        0x003c, /* U+003C LESS-THAN SIGN */
+XK_equal =                       0x003d, /* U+003D EQUALS SIGN */
+XK_greater =                     0x003e, /* U+003E GREATER-THAN SIGN */
+XK_question =                    0x003f, /* U+003F QUESTION MARK */
+XK_at =                          0x0040, /* U+0040 COMMERCIAL AT */
+XK_A =                           0x0041, /* U+0041 LATIN CAPITAL LETTER A */
+XK_B =                           0x0042, /* U+0042 LATIN CAPITAL LETTER B */
+XK_C =                           0x0043, /* U+0043 LATIN CAPITAL LETTER C */
+XK_D =                           0x0044, /* U+0044 LATIN CAPITAL LETTER D */
+XK_E =                           0x0045, /* U+0045 LATIN CAPITAL LETTER E */
+XK_F =                           0x0046, /* U+0046 LATIN CAPITAL LETTER F */
+XK_G =                           0x0047, /* U+0047 LATIN CAPITAL LETTER G */
+XK_H =                           0x0048, /* U+0048 LATIN CAPITAL LETTER H */
+XK_I =                           0x0049, /* U+0049 LATIN CAPITAL LETTER I */
+XK_J =                           0x004a, /* U+004A LATIN CAPITAL LETTER J */
+XK_K =                           0x004b, /* U+004B LATIN CAPITAL LETTER K */
+XK_L =                           0x004c, /* U+004C LATIN CAPITAL LETTER L */
+XK_M =                           0x004d, /* U+004D LATIN CAPITAL LETTER M */
+XK_N =                           0x004e, /* U+004E LATIN CAPITAL LETTER N */
+XK_O =                           0x004f, /* U+004F LATIN CAPITAL LETTER O */
+XK_P =                           0x0050, /* U+0050 LATIN CAPITAL LETTER P */
+XK_Q =                           0x0051, /* U+0051 LATIN CAPITAL LETTER Q */
+XK_R =                           0x0052, /* U+0052 LATIN CAPITAL LETTER R */
+XK_S =                           0x0053, /* U+0053 LATIN CAPITAL LETTER S */
+XK_T =                           0x0054, /* U+0054 LATIN CAPITAL LETTER T */
+XK_U =                           0x0055, /* U+0055 LATIN CAPITAL LETTER U */
+XK_V =                           0x0056, /* U+0056 LATIN CAPITAL LETTER V */
+XK_W =                           0x0057, /* U+0057 LATIN CAPITAL LETTER W */
+XK_X =                           0x0058, /* U+0058 LATIN CAPITAL LETTER X */
+XK_Y =                           0x0059, /* U+0059 LATIN CAPITAL LETTER Y */
+XK_Z =                           0x005a, /* U+005A LATIN CAPITAL LETTER Z */
+XK_bracketleft =                 0x005b, /* U+005B LEFT SQUARE BRACKET */
+XK_backslash =                   0x005c, /* U+005C REVERSE SOLIDUS */
+XK_bracketright =                0x005d, /* U+005D RIGHT SQUARE BRACKET */
+XK_asciicircum =                 0x005e, /* U+005E CIRCUMFLEX ACCENT */
+XK_underscore =                  0x005f, /* U+005F LOW LINE */
+XK_grave =                       0x0060, /* U+0060 GRAVE ACCENT */
+XK_quoteleft =                   0x0060, /* deprecated */
+XK_a =                           0x0061, /* U+0061 LATIN SMALL LETTER A */
+XK_b =                           0x0062, /* U+0062 LATIN SMALL LETTER B */
+XK_c =                           0x0063, /* U+0063 LATIN SMALL LETTER C */
+XK_d =                           0x0064, /* U+0064 LATIN SMALL LETTER D */
+XK_e =                           0x0065, /* U+0065 LATIN SMALL LETTER E */
+XK_f =                           0x0066, /* U+0066 LATIN SMALL LETTER F */
+XK_g =                           0x0067, /* U+0067 LATIN SMALL LETTER G */
+XK_h =                           0x0068, /* U+0068 LATIN SMALL LETTER H */
+XK_i =                           0x0069, /* U+0069 LATIN SMALL LETTER I */
+XK_j =                           0x006a, /* U+006A LATIN SMALL LETTER J */
+XK_k =                           0x006b, /* U+006B LATIN SMALL LETTER K */
+XK_l =                           0x006c, /* U+006C LATIN SMALL LETTER L */
+XK_m =                           0x006d, /* U+006D LATIN SMALL LETTER M */
+XK_n =                           0x006e, /* U+006E LATIN SMALL LETTER N */
+XK_o =                           0x006f, /* U+006F LATIN SMALL LETTER O */
+XK_p =                           0x0070, /* U+0070 LATIN SMALL LETTER P */
+XK_q =                           0x0071, /* U+0071 LATIN SMALL LETTER Q */
+XK_r =                           0x0072, /* U+0072 LATIN SMALL LETTER R */
+XK_s =                           0x0073, /* U+0073 LATIN SMALL LETTER S */
+XK_t =                           0x0074, /* U+0074 LATIN SMALL LETTER T */
+XK_u =                           0x0075, /* U+0075 LATIN SMALL LETTER U */
+XK_v =                           0x0076, /* U+0076 LATIN SMALL LETTER V */
+XK_w =                           0x0077, /* U+0077 LATIN SMALL LETTER W */
+XK_x =                           0x0078, /* U+0078 LATIN SMALL LETTER X */
+XK_y =                           0x0079, /* U+0079 LATIN SMALL LETTER Y */
+XK_z =                           0x007a, /* U+007A LATIN SMALL LETTER Z */
+XK_braceleft =                   0x007b, /* U+007B LEFT CURLY BRACKET */
+XK_bar =                         0x007c, /* U+007C VERTICAL LINE */
+XK_braceright =                  0x007d, /* U+007D RIGHT CURLY BRACKET */
+XK_asciitilde =                  0x007e, /* U+007E TILDE */
+
+XK_nobreakspace =                0x00a0, /* U+00A0 NO-BREAK SPACE */
+XK_exclamdown =                  0x00a1, /* U+00A1 INVERTED EXCLAMATION MARK */
+XK_cent =                        0x00a2, /* U+00A2 CENT SIGN */
+XK_sterling =                    0x00a3, /* U+00A3 POUND SIGN */
+XK_currency =                    0x00a4, /* U+00A4 CURRENCY SIGN */
+XK_yen =                         0x00a5, /* U+00A5 YEN SIGN */
+XK_brokenbar =                   0x00a6, /* U+00A6 BROKEN BAR */
+XK_section =                     0x00a7, /* U+00A7 SECTION SIGN */
+XK_diaeresis =                   0x00a8, /* U+00A8 DIAERESIS */
+XK_copyright =                   0x00a9, /* U+00A9 COPYRIGHT SIGN */
+XK_ordfeminine =                 0x00aa, /* U+00AA FEMININE ORDINAL INDICATOR */
+XK_guillemotleft =               0x00ab, /* U+00AB LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */
+XK_notsign =                     0x00ac, /* U+00AC NOT SIGN */
+XK_hyphen =                      0x00ad, /* U+00AD SOFT HYPHEN */
+XK_registered =                  0x00ae, /* U+00AE REGISTERED SIGN */
+XK_macron =                      0x00af, /* U+00AF MACRON */
+XK_degree =                      0x00b0, /* U+00B0 DEGREE SIGN */
+XK_plusminus =                   0x00b1, /* U+00B1 PLUS-MINUS SIGN */
+XK_twosuperior =                 0x00b2, /* U+00B2 SUPERSCRIPT TWO */
+XK_threesuperior =               0x00b3, /* U+00B3 SUPERSCRIPT THREE */
+XK_acute =                       0x00b4, /* U+00B4 ACUTE ACCENT */
+XK_mu =                          0x00b5, /* U+00B5 MICRO SIGN */
+XK_paragraph =                   0x00b6, /* U+00B6 PILCROW SIGN */
+XK_periodcentered =              0x00b7, /* U+00B7 MIDDLE DOT */
+XK_cedilla =                     0x00b8, /* U+00B8 CEDILLA */
+XK_onesuperior =                 0x00b9, /* U+00B9 SUPERSCRIPT ONE */
+XK_masculine =                   0x00ba, /* U+00BA MASCULINE ORDINAL INDICATOR */
+XK_guillemotright =              0x00bb, /* U+00BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */
+XK_onequarter =                  0x00bc, /* U+00BC VULGAR FRACTION ONE QUARTER */
+XK_onehalf =                     0x00bd, /* U+00BD VULGAR FRACTION ONE HALF */
+XK_threequarters =               0x00be, /* U+00BE VULGAR FRACTION THREE QUARTERS */
+XK_questiondown =                0x00bf, /* U+00BF INVERTED QUESTION MARK */
+XK_Agrave =                      0x00c0, /* U+00C0 LATIN CAPITAL LETTER A WITH GRAVE */
+XK_Aacute =                      0x00c1, /* U+00C1 LATIN CAPITAL LETTER A WITH ACUTE */
+XK_Acircumflex =                 0x00c2, /* U+00C2 LATIN CAPITAL LETTER A WITH CIRCUMFLEX */
+XK_Atilde =                      0x00c3, /* U+00C3 LATIN CAPITAL LETTER A WITH TILDE */
+XK_Adiaeresis =                  0x00c4, /* U+00C4 LATIN CAPITAL LETTER A WITH DIAERESIS */
+XK_Aring =                       0x00c5, /* U+00C5 LATIN CAPITAL LETTER A WITH RING ABOVE */
+XK_AE =                          0x00c6, /* U+00C6 LATIN CAPITAL LETTER AE */
+XK_Ccedilla =                    0x00c7, /* U+00C7 LATIN CAPITAL LETTER C WITH CEDILLA */
+XK_Egrave =                      0x00c8, /* U+00C8 LATIN CAPITAL LETTER E WITH GRAVE */
+XK_Eacute =                      0x00c9, /* U+00C9 LATIN CAPITAL LETTER E WITH ACUTE */
+XK_Ecircumflex =                 0x00ca, /* U+00CA LATIN CAPITAL LETTER E WITH CIRCUMFLEX */
+XK_Ediaeresis =                  0x00cb, /* U+00CB LATIN CAPITAL LETTER E WITH DIAERESIS */
+XK_Igrave =                      0x00cc, /* U+00CC LATIN CAPITAL LETTER I WITH GRAVE */
+XK_Iacute =                      0x00cd, /* U+00CD LATIN CAPITAL LETTER I WITH ACUTE */
+XK_Icircumflex =                 0x00ce, /* U+00CE LATIN CAPITAL LETTER I WITH CIRCUMFLEX */
+XK_Idiaeresis =                  0x00cf, /* U+00CF LATIN CAPITAL LETTER I WITH DIAERESIS */
+XK_ETH =                         0x00d0, /* U+00D0 LATIN CAPITAL LETTER ETH */
+XK_Eth =                         0x00d0, /* deprecated */
+XK_Ntilde =                      0x00d1, /* U+00D1 LATIN CAPITAL LETTER N WITH TILDE */
+XK_Ograve =                      0x00d2, /* U+00D2 LATIN CAPITAL LETTER O WITH GRAVE */
+XK_Oacute =                      0x00d3, /* U+00D3 LATIN CAPITAL LETTER O WITH ACUTE */
+XK_Ocircumflex =                 0x00d4, /* U+00D4 LATIN CAPITAL LETTER O WITH CIRCUMFLEX */
+XK_Otilde =                      0x00d5, /* U+00D5 LATIN CAPITAL LETTER O WITH TILDE */
+XK_Odiaeresis =                  0x00d6, /* U+00D6 LATIN CAPITAL LETTER O WITH DIAERESIS */
+XK_multiply =                    0x00d7, /* U+00D7 MULTIPLICATION SIGN */
+XK_Oslash =                      0x00d8, /* U+00D8 LATIN CAPITAL LETTER O WITH STROKE */
+XK_Ooblique =                    0x00d8, /* U+00D8 LATIN CAPITAL LETTER O WITH STROKE */
+XK_Ugrave =                      0x00d9, /* U+00D9 LATIN CAPITAL LETTER U WITH GRAVE */
+XK_Uacute =                      0x00da, /* U+00DA LATIN CAPITAL LETTER U WITH ACUTE */
+XK_Ucircumflex =                 0x00db, /* U+00DB LATIN CAPITAL LETTER U WITH CIRCUMFLEX */
+XK_Udiaeresis =                  0x00dc, /* U+00DC LATIN CAPITAL LETTER U WITH DIAERESIS */
+XK_Yacute =                      0x00dd, /* U+00DD LATIN CAPITAL LETTER Y WITH ACUTE */
+XK_THORN =                       0x00de, /* U+00DE LATIN CAPITAL LETTER THORN */
+XK_Thorn =                       0x00de, /* deprecated */
+XK_ssharp =                      0x00df, /* U+00DF LATIN SMALL LETTER SHARP S */
+XK_agrave =                      0x00e0, /* U+00E0 LATIN SMALL LETTER A WITH GRAVE */
+XK_aacute =                      0x00e1, /* U+00E1 LATIN SMALL LETTER A WITH ACUTE */
+XK_acircumflex =                 0x00e2, /* U+00E2 LATIN SMALL LETTER A WITH CIRCUMFLEX */
+XK_atilde =                      0x00e3, /* U+00E3 LATIN SMALL LETTER A WITH TILDE */
+XK_adiaeresis =                  0x00e4, /* U+00E4 LATIN SMALL LETTER A WITH DIAERESIS */
+XK_aring =                       0x00e5, /* U+00E5 LATIN SMALL LETTER A WITH RING ABOVE */
+XK_ae =                          0x00e6, /* U+00E6 LATIN SMALL LETTER AE */
+XK_ccedilla =                    0x00e7, /* U+00E7 LATIN SMALL LETTER C WITH CEDILLA */
+XK_egrave =                      0x00e8, /* U+00E8 LATIN SMALL LETTER E WITH GRAVE */
+XK_eacute =                      0x00e9, /* U+00E9 LATIN SMALL LETTER E WITH ACUTE */
+XK_ecircumflex =                 0x00ea, /* U+00EA LATIN SMALL LETTER E WITH CIRCUMFLEX */
+XK_ediaeresis =                  0x00eb, /* U+00EB LATIN SMALL LETTER E WITH DIAERESIS */
+XK_igrave =                      0x00ec, /* U+00EC LATIN SMALL LETTER I WITH GRAVE */
+XK_iacute =                      0x00ed, /* U+00ED LATIN SMALL LETTER I WITH ACUTE */
+XK_icircumflex =                 0x00ee, /* U+00EE LATIN SMALL LETTER I WITH CIRCUMFLEX */
+XK_idiaeresis =                  0x00ef, /* U+00EF LATIN SMALL LETTER I WITH DIAERESIS */
+XK_eth =                         0x00f0, /* U+00F0 LATIN SMALL LETTER ETH */
+XK_ntilde =                      0x00f1, /* U+00F1 LATIN SMALL LETTER N WITH TILDE */
+XK_ograve =                      0x00f2, /* U+00F2 LATIN SMALL LETTER O WITH GRAVE */
+XK_oacute =                      0x00f3, /* U+00F3 LATIN SMALL LETTER O WITH ACUTE */
+XK_ocircumflex =                 0x00f4, /* U+00F4 LATIN SMALL LETTER O WITH CIRCUMFLEX */
+XK_otilde =                      0x00f5, /* U+00F5 LATIN SMALL LETTER O WITH TILDE */
+XK_odiaeresis =                  0x00f6, /* U+00F6 LATIN SMALL LETTER O WITH DIAERESIS */
+XK_division =                    0x00f7, /* U+00F7 DIVISION SIGN */
+XK_oslash =                      0x00f8, /* U+00F8 LATIN SMALL LETTER O WITH STROKE */
+XK_ooblique =                    0x00f8, /* U+00F8 LATIN SMALL LETTER O WITH STROKE */
+XK_ugrave =                      0x00f9, /* U+00F9 LATIN SMALL LETTER U WITH GRAVE */
+XK_uacute =                      0x00fa, /* U+00FA LATIN SMALL LETTER U WITH ACUTE */
+XK_ucircumflex =                 0x00fb, /* U+00FB LATIN SMALL LETTER U WITH CIRCUMFLEX */
+XK_udiaeresis =                  0x00fc, /* U+00FC LATIN SMALL LETTER U WITH DIAERESIS */
+XK_yacute =                      0x00fd, /* U+00FD LATIN SMALL LETTER Y WITH ACUTE */
+XK_thorn =                       0x00fe, /* U+00FE LATIN SMALL LETTER THORN */
+XK_ydiaeresis =                  0x00ff; /* U+00FF LATIN SMALL LETTER Y WITH DIAERESIS */
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/keysymdef.js
@@ -0,0 +1,15 @@
+// This file describes mappings from Unicode codepoints to the keysym values
+// (and optionally, key names) expected by the RFB protocol
+// How this file was generated:
+// node /Users/jalf/dev/mi/novnc/utils/parse.js /opt/X11/include/X11/keysymdef.h
+var keysyms = (function(){
+    "use strict";
+    var keynames = null;
+    var codepoints = {"32":32,"33":33,"34":34,"35":35,"36":36,"37":37,"38":38,"39":39,"40":40,"41":41,"42":42,"43":43,"44":44,"45":45,"46":46,"47":47,"48":48,"49":49,"50":50,"51":51,"52":52,"53":53,"54":54,"55":55,"56":56,"57":57,"58":58,"59":59,"60":60,"61":61,"62":62,"63":63,"64":64,"65":65,"66":66,"67":67,"68":68,"69":69,"70":70,"71":71,"72":72,"73":73,"74":74,"75":75,"76":76,"77":77,"78":78,"79":79,"80":80,"81":81,"82":82,"83":83,"84":84,"85":85,"86":86,"87":87,"88":88,"89":89,"90":90,"91":91,"92":92,"93":93,"94":94,"95":95,"96":96,"97":97,"98":98,"99":99,"100":100,"101":101,"102":102,"103":103,"104":104,"105":105,"106":106,"107":107,"108":108,"109":109,"110":110,"111":111,"112":112,"113":113,"114":114,"115":115,"116":116,"117":117,"118":118,"119":119,"120":120,"121":121,"122":122,"123":123,"124":124,"125":125,"126":126,"160":160,"161":161,"162":162,"163":163,"164":164,"165":165,"166":166,"167":167,"168":168,"169":169,"170":170,"171":171,"172":172,"173":173,"174":174,"175":175,"176":176,"177":177,"178":178,"179":179,"180":180,"181":181,"182":182,"183":183,"184":184,"185":185,"186":186,"187":187,"188":188,"189":189,"190":190,"191":191,"192":192,"193":193,"194":194,"195":195,"196":196,"197":197,"198":198,"199":199,"200":200,"201":201,"202":202,"203":203,"204":204,"205":205,"206":206,"207":207,"208":208,"209":209,"210":210,"211":211,"212":212,"213":213,"214":214,"215":215,"216":216,"217":217,"218":218,"219":219,"220":220,"221":221,"222":222,"223":223,"224":224,"225":225,"226":226,"227":227,"228":228,"229":229,"230":230,"231":231,"232":232,"233":233,"234":234,"235":235,"236":236,"237":237,"238":238,"239":239,"240":240,"241":241,"242":242,"243":243,"244":244,"245":245,"246":246,"247":247,"248":248,"249":249,"250":250,"251":251,"252":252,"253":253,"254":254,"255":255,"256":960,"257":992,"258":451,"259":483,"260":417,"261":433,"262":454,"263":486,"264":710,"265":742,"266":709,"267":741,"268":456,"269":488,"270":463,"271":495,"272":464,"273":496,"274":938,"275":954,"278":972,"279":1004,"280":458,"281":490,"282":460,"283":492,"284":728,"285":760,"286":683,"287":699,"288":725,"289":757,"290":939,"291":955,"292":678,"293":694,"294":673,"295":689,"296":933,"297":949,"298":975,"299":1007,"300":16777516,"301":16777517,"302":967,"303":999,"304":681,"305":697,"308":684,"309":700,"310":979,"311":1011,"312":930,"313":453,"314":485,"315":934,"316":950,"317":421,"318":437,"321":419,"322":435,"323":465,"324":497,"325":977,"326":1009,"327":466,"328":498,"330":957,"331":959,"332":978,"333":1010,"336":469,"337":501,"338":5052,"339":5053,"340":448,"341":480,"342":931,"343":947,"344":472,"345":504,"346":422,"347":438,"348":734,"349":766,"350":426,"351":442,"352":425,"353":441,"354":478,"355":510,"356":427,"357":443,"358":940,"359":956,"360":989,"361":1021,"362":990,"363":1022,"364":733,"365":765,"366":473,"367":505,"368":475,"369":507,"370":985,"371":1017,"372":16777588,"373":16777589,"374":16777590,"375":16777591,"376":5054,"377":428,"378":444,"379":431,"380":447,"381":430,"382":446,"399":16777615,"402":2294,"415":16777631,"416":16777632,"417":16777633,"431":16777647,"432":16777648,"437":16777653,"438":16777654,"439":16777655,"466":16777681,"486":16777702,"487":16777703,"601":16777817,"629":16777845,"658":16777874,"711":439,"728":418,"729":511,"731":434,"733":445,"901":1966,"902":1953,"904":1954,"905":1955,"906":1956,"908":1959,"910":1960,"911":1963,"912":1974,"913":1985,"914":1986,"915":1987,"916":1988,"917":1989,"918":1990,"919":1991,"920":1992,"921":1993,"922":1994,"923":1995,"924":1996,"925":1997,"926":1998,"927":1999,"928":2000,"929":2001,"931":2002,"932":2004,"933":2005,"934":2006,"935":2007,"936":2008,"937":2009,"938":1957,"939":1961,"940":1969,"941":1970,"942":1971,"943":1972,"944":1978,"945":2017,"946":2018,"947":2019,"948":2020,"949":2021,"950":2022,"951":2023,"952":2024,"953":2025,"954":2026,"955":2027,"956":2028,"957":2029,"958":2030,"959":2031,"960":2032,"961":2033,"962":2035,"963":2034,"964":2036,"965":2037,"966":2038,"967":2039,"968":2040,"969":2041,"970":1973,"971":1977,"972":1975,"973":1976,"974":1979,"1025":1715,"1026":1713,"1027":1714,"1028":1716,"1029":1717,"1030":1718,"1031":1719,"1032":1720,"1033":1721,"1034":1722,"1035":1723,"1036":1724,"1038":1726,"1039":1727,"1040":1761,"1041":1762,"1042":1783,"1043":1767,"1044":1764,"1045":1765,"1046":1782,"1047":1786,"1048":1769,"1049":1770,"1050":1771,"1051":1772,"1052":1773,"1053":1774,"1054":1775,"1055":1776,"1056":1778,"1057":1779,"1058":1780,"1059":1781,"1060":1766,"1061":1768,"1062":1763,"1063":1790,"1064":1787,"1065":1789,"1066":1791,"1067":1785,"1068":1784,"1069":1788,"1070":1760,"1071":1777,"1072":1729,"1073":1730,"1074":1751,"1075":1735,"1076":1732,"1077":1733,"1078":1750,"1079":1754,"1080":1737,"1081":1738,"1082":1739,"1083":1740,"1084":1741,"1085":1742,"1086":1743,"1087":1744,"1088":1746,"1089":1747,"1090":1748,"1091":1749,"1092":1734,"1093":1736,"1094":1731,"1095":1758,"1096":1755,"1097":1757,"1098":1759,"1099":1753,"1100":1752,"1101":1756,"1102":1728,"1103":1745,"1105":1699,"1106":1697,"1107":1698,"1108":1700,"1109":1701,"1110":1702,"1111":1703,"1112":1704,"1113":1705,"1114":1706,"1115":1707,"1116":1708,"1118":1710,"1119":1711,"1168":1725,"1169":1709,"1170":16778386,"1171":16778387,"1174":16778390,"1175":16778391,"1178":16778394,"1179":16778395,"1180":16778396,"1181":16778397,"1186":16778402,"1187":16778403,"1198":16778414,"1199":16778415,"1200":16778416,"1201":16778417,"1202":16778418,"1203":16778419,"1206":16778422,"1207":16778423,"1208":16778424,"1209":16778425,"1210":16778426,"1211":16778427,"1240":16778456,"1241":16778457,"1250":16778466,"1251":16778467,"1256":16778472,"1257":16778473,"1262":16778478,"1263":16778479,"1329":16778545,"1330":16778546,"1331":16778547,"1332":16778548,"1333":16778549,"1334":16778550,"1335":16778551,"1336":16778552,"1337":16778553,"1338":16778554,"1339":16778555,"1340":16778556,"1341":16778557,"1342":16778558,"1343":16778559,"1344":16778560,"1345":16778561,"1346":16778562,"1347":16778563,"1348":16778564,"1349":16778565,"1350":16778566,"1351":16778567,"1352":16778568,"1353":16778569,"1354":16778570,"1355":16778571,"1356":16778572,"1357":16778573,"1358":16778574,"1359":16778575,"1360":16778576,"1361":16778577,"1362":16778578,"1363":16778579,"1364":16778580,"1365":16778581,"1366":16778582,"1370":16778586,"1371":16778587,"1372":16778588,"1373":16778589,"1374":16778590,"1377":16778593,"1378":16778594,"1379":16778595,"1380":16778596,"1381":16778597,"1382":16778598,"1383":16778599,"1384":16778600,"1385":16778601,"1386":16778602,"1387":16778603,"1388":16778604,"1389":16778605,"1390":16778606,"1391":16778607,"1392":16778608,"1393":16778609,"1394":16778610,"1395":16778611,"1396":16778612,"1397":16778613,"1398":16778614,"1399":16778615,"1400":16778616,"1401":16778617,"1402":16778618,"1403":16778619,"1404":16778620,"1405":16778621,"1406":16778622,"1407":16778623,"1408":16778624,"1409":16778625,"1410":16778626,"1411":16778627,"1412":16778628,"1413":16778629,"1414":16778630,"1415":16778631,"1417":16778633,"1418":16778634,"1488":3296,"1489":3297,"1490":3298,"1491":3299,"1492":3300,"1493":3301,"1494":3302,"1495":3303,"1496":3304,"1497":3305,"1498":3306,"1499":3307,"1500":3308,"1501":3309,"1502":3310,"1503":3311,"1504":3312,"1505":3313,"1506":3314,"1507":3315,"1508":3316,"1509":3317,"1510":3318,"1511":3319,"1512":3320,"1513":3321,"1514":3322,"1548":1452,"1563":1467,"1567":1471,"1569":1473,"1570":1474,"1571":1475,"1572":1476,"1573":1477,"1574":1478,"1575":1479,"1576":1480,"1577":1481,"1578":1482,"1579":1483,"1580":1484,"1581":1485,"1582":1486,"1583":1487,"1584":1488,"1585":1489,"1586":1490,"1587":1491,"1588":1492,"1589":1493,"1590":1494,"1591":1495,"1592":1496,"1593":1497,"1594":1498,"1600":1504,"1601":1505,"1602":1506,"1603":1507,"1604":1508,"1605":1509,"1606":1510,"1607":1511,"1608":1512,"1609":1513,"1610":1514,"1611":1515,"1612":1516,"1613":1517,"1614":1518,"1615":1519,"1616":1520,"1617":1521,"1618":1522,"1619":16778835,"1620":16778836,"1621":16778837,"1632":16778848,"1633":16778849,"1634":16778850,"1635":16778851,"1636":16778852,"1637":16778853,"1638":16778854,"1639":16778855,"1640":16778856,"1641":16778857,"1642":16778858,"1648":16778864,"1657":16778873,"1662":16778878,"1670":16778886,"1672":16778888,"1681":16778897,"1688":16778904,"1700":16778916,"1705":16778921,"1711":16778927,"1722":16778938,"1726":16778942,"1729":16778945,"1740":16778956,"1746":16778962,"1748":16778964,"1776":16778992,"1777":16778993,"1778":16778994,"1779":16778995,"1780":16778996,"1781":16778997,"1782":16778998,"1783":16778999,"1784":16779000,"1785":16779001,"3458":16780674,"3459":16780675,"3461":16780677,"3462":16780678,"3463":16780679,"3464":16780680,"3465":16780681,"3466":16780682,"3467":16780683,"3468":16780684,"3469":16780685,"3470":16780686,"3471":16780687,"3472":16780688,"3473":16780689,"3474":16780690,"3475":16780691,"3476":16780692,"3477":16780693,"3478":16780694,"3482":16780698,"3483":16780699,"3484":16780700,"3485":16780701,"3486":16780702,"3487":16780703,"3488":16780704,"3489":16780705,"3490":16780706,"3491":16780707,"3492":16780708,"3493":16780709,"3494":16780710,"3495":16780711,"3496":16780712,"3497":16780713,"3498":16780714,"3499":16780715,"3500":16780716,"3501":16780717,"3502":16780718,"3503":16780719,"3504":16780720,"3505":16780721,"3507":16780723,"3508":16780724,"3509":16780725,"3510":16780726,"3511":16780727,"3512":16780728,"3513":16780729,"3514":16780730,"3515":16780731,"3517":16780733,"3520":16780736,"3521":16780737,"3522":16780738,"3523":16780739,"3524":16780740,"3525":16780741,"3526":16780742,"3530":16780746,"3535":16780751,"3536":16780752,"3537":16780753,"3538":16780754,"3539":16780755,"3540":16780756,"3542":16780758,"3544":16780760,"3545":16780761,"3546":16780762,"3547":16780763,"3548":16780764,"3549":16780765,"3550":16780766,"3551":16780767,"3570":16780786,"3571":16780787,"3572":16780788,"3585":3489,"3586":3490,"3587":3491,"3588":3492,"3589":3493,"3590":3494,"3591":3495,"3592":3496,"3593":3497,"3594":3498,"3595":3499,"3596":3500,"3597":3501,"3598":3502,"3599":3503,"3600":3504,"3601":3505,"3602":3506,"3603":3507,"3604":3508,"3605":3509,"3606":3510,"3607":3511,"3608":3512,"3609":3513,"3610":3514,"3611":3515,"3612":3516,"3613":3517,"3614":3518,"3615":3519,"3616":3520,"3617":3521,"3618":3522,"3619":3523,"3620":3524,"3621":3525,"3622":3526,"3623":3527,"3624":3528,"3625":3529,"3626":3530,"3627":3531,"3628":3532,"3629":3533,"3630":3534,"3631":3535,"3632":3536,"3633":3537,"3634":3538,"3635":3539,"3636":3540,"3637":3541,"3638":3542,"3639":3543,"3640":3544,"3641":3545,"3642":3546,"3647":3551,"3648":3552,"3649":3553,"3650":3554,"3651":3555,"3652":3556,"3653":3557,"3654":3558,"3655":3559,"3656":3560,"3657":3561,"3658":3562,"3659":3563,"3660":3564,"3661":3565,"3664":3568,"3665":3569,"3666":3570,"3667":3571,"3668":3572,"3669":3573,"3670":3574,"3671":3575,"3672":3576,"3673":3577,"4304":16781520,"4305":16781521,"4306":16781522,"4307":16781523,"4308":16781524,"4309":16781525,"4310":16781526,"4311":16781527,"4312":16781528,"4313":16781529,"4314":16781530,"4315":16781531,"4316":16781532,"4317":16781533,"4318":16781534,"4319":16781535,"4320":16781536,"4321":16781537,"4322":16781538,"4323":16781539,"4324":16781540,"4325":16781541,"4326":16781542,"4327":16781543,"4328":16781544,"4329":16781545,"4330":16781546,"4331":16781547,"4332":16781548,"4333":16781549,"4334":16781550,"4335":16781551,"4336":16781552,"4337":16781553,"4338":16781554,"4339":16781555,"4340":16781556,"4341":16781557,"4342":16781558,"7682":16784898,"7683":16784899,"7690":16784906,"7691":16784907,"7710":16784926,"7711":16784927,"7734":16784950,"7735":16784951,"7744":16784960,"7745":16784961,"7766":16784982,"7767":16784983,"7776":16784992,"7777":16784993,"7786":16785002,"7787":16785003,"7808":16785024,"7809":16785025,"7810":16785026,"7811":16785027,"7812":16785028,"7813":16785029,"7818":16785034,"7819":16785035,"7840":16785056,"7841":16785057,"7842":16785058,"7843":16785059,"7844":16785060,"7845":16785061,"7846":16785062,"7847":16785063,"7848":16785064,"7849":16785065,"7850":16785066,"7851":16785067,"7852":16785068,"7853":16785069,"7854":16785070,"7855":16785071,"7856":16785072,"7857":16785073,"7858":16785074,"7859":16785075,"7860":16785076,"7861":16785077,"7862":16785078,"7863":16785079,"7864":16785080,"7865":16785081,"7866":16785082,"7867":16785083,"7868":16785084,"7869":16785085,"7870":16785086,"7871":16785087,"7872":16785088,"7873":16785089,"7874":16785090,"7875":16785091,"7876":16785092,"7877":16785093,"7878":16785094,"7879":16785095,"7880":16785096,"7881":16785097,"7882":16785098,"7883":16785099,"7884":16785100,"7885":16785101,"7886":16785102,"7887":16785103,"7888":16785104,"7889":16785105,"7890":16785106,"7891":16785107,"7892":16785108,"7893":16785109,"7894":16785110,"7895":16785111,"7896":16785112,"7897":16785113,"7898":16785114,"7899":16785115,"7900":16785116,"7901":16785117,"7902":16785118,"7903":16785119,"7904":16785120,"7905":16785121,"7906":16785122,"7907":16785123,"7908":16785124,"7909":16785125,"7910":16785126,"7911":16785127,"7912":16785128,"7913":16785129,"7914":16785130,"7915":16785131,"7916":16785132,"7917":16785133,"7918":16785134,"7919":16785135,"7920":16785136,"7921":16785137,"7922":16785138,"7923":16785139,"7924":16785140,"7925":16785141,"7926":16785142,"7927":16785143,"7928":16785144,"7929":16785145,"8194":2722,"8195":2721,"8196":2723,"8197":2724,"8199":2725,"8200":2726,"8201":2727,"8202":2728,"8210":2747,"8211":2730,"8212":2729,"8213":1967,"8215":3295,"8216":2768,"8217":2769,"8218":2813,"8220":2770,"8221":2771,"8222":2814,"8224":2801,"8225":2802,"8226":2790,"8229":2735,"8230":2734,"8240":2773,"8242":2774,"8243":2775,"8248":2812,"8254":1150,"8304":16785520,"8308":16785524,"8309":16785525,"8310":16785526,"8311":16785527,"8312":16785528,"8313":16785529,"8320":16785536,"8321":16785537,"8322":16785538,"8323":16785539,"8324":16785540,"8325":16785541,"8326":16785542,"8327":16785543,"8328":16785544,"8329":16785545,"8352":16785568,"8353":16785569,"8354":16785570,"8355":16785571,"8356":16785572,"8357":16785573,"8358":16785574,"8359":16785575,"8360":16785576,"8361":3839,"8362":16785578,"8363":16785579,"8364":8364,"8453":2744,"8470":1712,"8471":2811,"8478":2772,"8482":2761,"8531":2736,"8532":2737,"8533":2738,"8534":2739,"8535":2740,"8536":2741,"8537":2742,"8538":2743,"8539":2755,"8540":2756,"8541":2757,"8542":2758,"8592":2299,"8593":2300,"8594":2301,"8595":2302,"8658":2254,"8660":2253,"8706":2287,"8709":16785925,"8711":2245,"8712":16785928,"8713":16785929,"8715":16785931,"8728":3018,"8730":2262,"8731":16785947,"8732":16785948,"8733":2241,"8734":2242,"8743":2270,"8744":2271,"8745":2268,"8746":2269,"8747":2239,"8748":16785964,"8749":16785965,"8756":2240,"8757":16785973,"8764":2248,"8771":2249,"8773":16785992,"8775":16785991,"8800":2237,"8801":2255,"8802":16786018,"8803":16786019,"8804":2236,"8805":2238,"8834":2266,"8835":2267,"8866":3068,"8867":3036,"8868":3010,"8869":3022,"8968":3027,"8970":3012,"8981":2810,"8992":2212,"8993":2213,"9109":3020,"9115":2219,"9117":2220,"9118":2221,"9120":2222,"9121":2215,"9123":2216,"9124":2217,"9126":2218,"9128":2223,"9132":2224,"9143":2209,"9146":2543,"9147":2544,"9148":2546,"9149":2547,"9225":2530,"9226":2533,"9227":2537,"9228":2531,"9229":2532,"9251":2732,"9252":2536,"9472":2211,"9474":2214,"9484":2210,"9488":2539,"9492":2541,"9496":2538,"9500":2548,"9508":2549,"9516":2551,"9524":2550,"9532":2542,"9618":2529,"9642":2791,"9643":2785,"9644":2779,"9645":2786,"9646":2783,"9647":2767,"9650":2792,"9651":2787,"9654":2781,"9655":2765,"9660":2793,"9661":2788,"9664":2780,"9665":2764,"9670":2528,"9675":2766,"9679":2782,"9702":2784,"9734":2789,"9742":2809,"9747":2762,"9756":2794,"9758":2795,"9792":2808,"9794":2807,"9827":2796,"9829":2798,"9830":2797,"9837":2806,"9839":2805,"10003":2803,"10007":2804,"10013":2777,"10016":2800,"10216":2748,"10217":2750,"10240":16787456,"10241":16787457,"10242":16787458,"10243":16787459,"10244":16787460,"10245":16787461,"10246":16787462,"10247":16787463,"10248":16787464,"10249":16787465,"10250":16787466,"10251":16787467,"10252":16787468,"10253":16787469,"10254":16787470,"10255":16787471,"10256":16787472,"10257":16787473,"10258":16787474,"10259":16787475,"10260":16787476,"10261":16787477,"10262":16787478,"10263":16787479,"10264":16787480,"10265":16787481,"10266":16787482,"10267":16787483,"10268":16787484,"10269":16787485,"10270":16787486,"10271":16787487,"10272":16787488,"10273":16787489,"10274":16787490,"10275":16787491,"10276":16787492,"10277":16787493,"10278":16787494,"10279":16787495,"10280":16787496,"10281":16787497,"10282":16787498,"10283":16787499,"10284":16787500,"10285":16787501,"10286":16787502,"10287":16787503,"10288":16787504,"10289":16787505,"10290":16787506,"10291":16787507,"10292":16787508,"10293":16787509,"10294":16787510,"10295":16787511,"10296":16787512,"10297":16787513,"10298":16787514,"10299":16787515,"10300":16787516,"10301":16787517,"10302":16787518,"10303":16787519,"10304":16787520,"10305":16787521,"10306":16787522,"10307":16787523,"10308":16787524,"10309":16787525,"10310":16787526,"10311":16787527,"10312":16787528,"10313":16787529,"10314":16787530,"10315":16787531,"10316":16787532,"10317":16787533,"10318":16787534,"10319":16787535,"10320":16787536,"10321":16787537,"10322":16787538,"10323":16787539,"10324":16787540,"10325":16787541,"10326":16787542,"10327":16787543,"10328":16787544,"10329":16787545,"10330":16787546,"10331":16787547,"10332":16787548,"10333":16787549,"10334":16787550,"10335":16787551,"10336":16787552,"10337":16787553,"10338":16787554,"10339":16787555,"10340":16787556,"10341":16787557,"10342":16787558,"10343":16787559,"10344":16787560,"10345":16787561,"10346":16787562,"10347":16787563,"10348":16787564,"10349":16787565,"10350":16787566,"10351":16787567,"10352":16787568,"10353":16787569,"10354":16787570,"10355":16787571,"10356":16787572,"10357":16787573,"10358":16787574,"10359":16787575,"10360":16787576,"10361":16787577,"10362":16787578,"10363":16787579,"10364":16787580,"10365":16787581,"10366":16787582,"10367":16787583,"10368":16787584,"10369":16787585,"10370":16787586,"10371":16787587,"10372":16787588,"10373":16787589,"10374":16787590,"10375":16787591,"10376":16787592,"10377":16787593,"10378":16787594,"10379":16787595,"10380":16787596,"10381":16787597,"10382":16787598,"10383":16787599,"10384":16787600,"10385":16787601,"10386":16787602,"10387":16787603,"10388":16787604,"10389":16787605,"10390":16787606,"10391":16787607,"10392":16787608,"10393":16787609,"10394":16787610,"10395":16787611,"10396":16787612,"10397":16787613,"10398":16787614,"10399":16787615,"10400":16787616,"10401":16787617,"10402":16787618,"10403":16787619,"10404":16787620,"10405":16787621,"10406":16787622,"10407":16787623,"10408":16787624,"10409":16787625,"10410":16787626,"10411":16787627,"10412":16787628,"10413":16787629,"10414":16787630,"10415":16787631,"10416":16787632,"10417":16787633,"10418":16787634,"10419":16787635,"10420":16787636,"10421":16787637,"10422":16787638,"10423":16787639,"10424":16787640,"10425":16787641,"10426":16787642,"10427":16787643,"10428":16787644,"10429":16787645,"10430":16787646,"10431":16787647,"10432":16787648,"10433":16787649,"10434":16787650,"10435":16787651,"10436":16787652,"10437":16787653,"10438":16787654,"10439":16787655,"10440":16787656,"10441":16787657,"10442":16787658,"10443":16787659,"10444":16787660,"10445":16787661,"10446":16787662,"10447":16787663,"10448":16787664,"10449":16787665,"10450":16787666,"10451":16787667,"10452":16787668,"10453":16787669,"10454":16787670,"10455":16787671,"10456":16787672,"10457":16787673,"10458":16787674,"10459":16787675,"10460":16787676,"10461":16787677,"10462":16787678,"10463":16787679,"10464":16787680,"10465":16787681,"10466":16787682,"10467":16787683,"10468":16787684,"10469":16787685,"10470":16787686,"10471":16787687,"10472":16787688,"10473":16787689,"10474":16787690,"10475":16787691,"10476":16787692,"10477":16787693,"10478":16787694,"10479":16787695,"10480":16787696,"10481":16787697,"10482":16787698,"10483":16787699,"10484":16787700,"10485":16787701,"10486":16787702,"10487":16787703,"10488":16787704,"10489":16787705,"10490":16787706,"10491":16787707,"10492":16787708,"10493":16787709,"10494":16787710,"10495":16787711,"12289":1188,"12290":1185,"12300":1186,"12301":1187,"12443":1246,"12444":1247,"12449":1191,"12450":1201,"12451":1192,"12452":1202,"12453":1193,"12454":1203,"12455":1194,"12456":1204,"12457":1195,"12458":1205,"12459":1206,"12461":1207,"12463":1208,"12465":1209,"12467":1210,"12469":1211,"12471":1212,"12473":1213,"12475":1214,"12477":1215,"12479":1216,"12481":1217,"12483":1199,"12484":1218,"12486":1219,"12488":1220,"12490":1221,"12491":1222,"12492":1223,"12493":1224,"12494":1225,"12495":1226,"12498":1227,"12501":1228,"12504":1229,"12507":1230,"12510":1231,"12511":1232,"12512":1233,"12513":1234,"12514":1235,"12515":1196,"12516":1236,"12517":1197,"12518":1237,"12519":1198,"12520":1238,"12521":1239,"12522":1240,"12523":1241,"12524":1242,"12525":1243,"12527":1244,"12530":1190,"12531":1245,"12539":1189,"12540":1200};
+
+    function lookup(k) { return k ? {keysym: k, keyname: keynames ? keynames[k] : k} : undefined; }
+    return {
+        fromUnicode : function(u) { return lookup(codepoints[u]); },
+        lookup : lookup
+    };
+})();
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/logo.js
@@ -0,0 +1 @@
+noVNC_logo = {"width": 640, "height": 435, "data": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAGzCAYAAAC/y6a9AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAStAAAErQBBHTWggAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAACAASURBVHic7N13fBvlwQfw3522ZMm2vPdIGCFkA4GyoYyGsCmjk+7dQksHL2/H2/dtC4W2tLTlfelu2VA2lEILFCgQIHEGJCQkdjzkLdmWZGvfvX8oOkmJEy/pNO73/Xz44DtLzz2RT7qfnnXC8uXLZUxDlqfdnUYQhIP+bjbPn+5xhypzrmUf6rGzOc5cjzVduXN9/nTPyfRrMt/jzOcY05U5n3L2f95s/34LPW4m/p6FbLp/73xe+5nKnWuZs/07ZOOcnusx5nucbJU727LneuxslDmdTBxn/2NmusyEuZS7kHMxG/XP5Gf3TOVmQzY+u/PhPMnkMcSsH5WIiIiI8goDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMAASERERaQwDIBEREZHGMADSrMmynOsqEBERUQboc10Bym+SJMHv92NiYgJ+vx+CIECv18NgMCj/N5lMcDgcua4qERERzRIDIE0rEfp8Ph8kSVL2y7KMcDiMcDic9niPx4O6ujqYTCa1q1qU/H4/fD4fBEFQ9iV+NplMKC0tTfsdERHRXDAA0gFcLhcmJibS9pkrAJ1ZgBxD/D9JhhQBwt747wOBALq6uuB0OlFZWQlR5OiCuZJlGV6vF263+4CAvT+3242KigoGQSIimhcGQErT19cHr9erbFuqBSy6SETN8QKmyxnurTJ23iNhalCGLMtwu93wer2oq6uDzWZTseaFS5IkjI+Pw+PxIBqNHvB7vQWwVArwu2TI+xpjI5EIBgcH4Xa74XQ6UVZWxiBIRESzJixfvnzakf2zGfB/qAvObCcM7P+42VzE5jIZ4WCPne3Fcq4TH/Yvdz4TJ7L9mkz3HFmW0d/fr4Q/UxnQdoGIhlNECLoZyokBPc9K6HpMQjSQrHN9fT1KS0szUtf9nzefsDOf42bi7zmT3t5eTE5OKtuliwWULRbgaBVgbwWs1QIgABE/MNIhYXijDM/2eAtsgtlsRktLS8ZD4HT/3kwcYz7n+KGefzAzlZuJv2e23p/ZKne2Zc/12NkoczrZOMez9eVpLuUu5FzMRv2nK1Ot90smZOOzOx/Ok0wegwEwg8eartxCCID7h7+K5QJWfEEH0Ti38sJe4J0/xzC8MVmXhoaGA0IgA2DS0NAQxsbG9h0MWHypiNbzZu4+j4WAgX9L2HmXpLQKOhwO1NfXZ7R+DIALP8Z8j8MAOD0GwIUdZyFl5nOImuk4+Vz3XAVAdgETxsbGlPCntwBHXT338AcARgew7As6bP9dDAP/jr/ZXC4XAEzbEqh14+PjSvjTGYGln9ahes3sPgh0JqDxDBE6k4C3fxcDZMDr9cJisaC8vDyb1Z6TcDiMQCCAQCCAYDDIpYRySKfTQa/XQ6/Xo7S0lBO2iDSOAZDSJnwcdrkI0wLygyAAR31CB0GU0P9SvGnK5XJBlmWUlZUttKpFY2pqCkNDQwDi3e0rvqKDo3Xu3wLrThQQDYrYeWf8tR4eHobZbIbFYslofefC6/XC6/UiEAggFovlrB50cB6PByUlJXA6nbBarbmuDhHlAAOgxoXDYQSDQQBA+RECGk5d+OxdQQCO+lh87KDrhXgw6e/vhyzLedU6lSuSJCmhGABWf10HW/38uwCazhQRCwG7H5AgyzJcLhfa2tqg080weDPDZFnG0NAQxsfHD/idIALWOgGiulWiBBmYGpERCyZ3+f1++P1+mM1mVFRUwG63565+RKQ6BkCNS7T+CSKw5GMikKmhCAKw5CMiBBHoey4eAgcGBgBA8y2BU1NTSstY6WJhQeEvoXWdCPdbMsZ2yIhGo/D7/ap2u0ejUbhcLgQCAWWfrUFAxVECyo8SUH6EAH3uGiUJ8cla47tluLfKcG+T4euNfwEJBoNwuVwoLy9HTU1NjmtJRGphANS4RAC01gqw1mR4IKoAHPnheEtg77PJEChJEpxOZ2aPVUCmpqaUn+tPzNxrXrFUwNiO+EU9EAioFgCnpqbQ39+vLGFjbxGw4ss6mLX7J85Lgi7eyl9+hIDF7wdC48DuB5PjdcfGxmAymTT/BY1IKxgANSwQCCASia8lYsvs5NE0R3wg3hLY8/d4CEyMfdNqCEwEQNEA1ByXuQWzy49MhsnUlrhsCgaD6O3tVbqzyw4TsPJaHVv7CoCpDFi633jdoaEhGI1Gjgsk0gDerkHDUu82UdKQ3Wnoh18pomVd8nQbGhqC2+3O6jHzUSwWU8ZcVq0SoM/gddbRJkBnjv8cCoVUmYDhdruV8FdxtIBV1zH8FZR943XrT46/NxNjSGe6Ew0RFT4GQA1LDQhGFXoLD3u/iLb1yVNueHgYo6Oj2T9wHkltmXMuzWzoFkSg/PBkmYmgmS2hUAg+nw8AULVSwIqv6KCbx/JBlGP7hcBYLIa+vr4cV4qIso0BkABg2tu8ZcOiS0W0X5g87UZGRjQVAlNDmd6U+Rfd3qJeN3Dq323RJSJEDigpXAKw5GpRab0Nh8MIhUK5rRMRZRUDIKmu/SIRiy5JD4EjIyM5rFGOZCF0p962L5uLLqe2/lmqBJQ08T7EhU4Q01ulU29PSETFhwGQcqLtfBGLL0uefqOjoxgeHs5hjWguPB6P8vNs715C+a9yRfJvmTpbnYiKDwMg5UzreSIOuyJ5CrrdbobAApHaPVi1mgGwWFQcnVwLVK2Z5ESUGwyAlFMt54o4/Kr0EJhYJobyV2L5IKM9vpg1FQdTGWBvjv89U2esE1HxYQCknGs+W8QRH0qeih6PhyEwj8myrMwgN1cJqk0gInUkAiCQ/ZnkRJQ7DICUF5rOFHHkR5LdTx6PB4ODg7mtFE1LkiTlZ4a/4pM6mzv1b01ExYUBkPJG4+killydDIFjY2PK/YOJSB2iIflzNmeSE1FuMQBSXmk4RcRRHxeVlqXx8XGGQCIVMQASaQMDIOWd+pNEHPVJHYR9Z+f4+Dj6+/tzWykijUjtAmYAJCpeDICUl+reI2Dpp5MhcGJigiGQSAVsASTSBgZAylu1awUc/dlkCPR6vXC5XLwoEWURAyCRNjAAUl6rOVbAss/rlFuc+Xw+9Pf388JElCXsAibSBgZAynvVawQs/4JOuTD5fD62BBJlCZeBIdIGBkAqCFWrBCz/YnoI7OvrYwgkyjDBkFzcke8vouLFAEgFo3KFgBVf1iljlPx+P0MgUYaxC5hIG/QzP4Qof1QsE7DyKzps/kUMUjgeAnt7e9HU1ASBt6UoCtEA8MLno7muRkFoO1/Eoksy+z2ek0CItIEtgFRwnEsFrLxGB50xvj05OYne3l6OVyLNkbKQk9kCSKQNDIBUkJxLBKz8qg46U3ybIZC0SIpkvky2ABJpA7uAqWCVHyFg1dd06PhpDLEgMDU1pXQHiyK/2xQDQRDQ0tKS62rklXA4rCyKzhZAIpovBkAqaGWHCVi9LwRGA/EQ2NPTg+bmZobAImE2mw/YN9tgMtO40EwEnNmMPZ3PcQ5Wbup+KZL5gMYWQCJt4BWSCl7pYgGrr9NBb41vBwIB9PT0sDuYilJaAMxyCyDfQ0TFiwGQioKjXcDqr+tgsMW3A4EAuru7EYvFclsxogxLbwHMfPlsASTSBgZAKhqOVgGrv6GDoSS+HQwG0dPTwxBIRSX7LYBcCJpICxgAKWv8fTJklXuQ7M0C1nxDB6M9vs0QSMUmNQDKbAEkonliAKSs8eyQsfVXMcgqZ6+SJgFrvqmD0RHfDgaD7A6mopH1FkAGQCJNYACkrBrZJGPrL2NZuVAdiq1hXwgsjW+HQiH09PQgGuUdJqiwpc5uz8oYQC4DQ6QJDICUdSObZWy9LQchsF7AMd/SwVQW32YIpGKTjQAo6ACkrEDDEEhUnBgASRWjW2Vs+XksKxesQ7HWClhzvQ6m8vh2OBxmCKSCl2gFzNaXKrYCEhU/BkBSjfstGZtvjSEWVve41moBx1yvg7kivh0Oh9Hd3Y1IROU0SpQhiXGAUjQ74YzjAImKHwMgqcqzXcbmn8UQC6l7XEuVgGOu18NSFb9wRiIR9PT0MARSQVICYJZOXy4GTVT8GABJFTqdTvl57B05fv9elUOguQJY8y0dLNUMgVTYsh4A2QJIVPQYAEkVDocD1dXVyvb4Lhmbbonfv1dNZidwzLd0sNYkQ2B3dzfCYZX7pYkWINkFnJ3yuRg0UfFjACTVVFZWpoXAid0yOnIQAk3l8ZZAa238IheNRtHT08MQSAUj6wGQLYBERY8BkFR1QAjslLHp5hgik+rWw1QGHHO9DrZ6hkAqPMpi0DKystA6ZwETFT8GQFJdRUUFampqlG1vV25CoNEBrPmmDiUNyRDY3d2NUEjlwYlEc5R2NxDeDo6I5oEBkHLC6XSitrZW2fZ1y9h0UwwRv7r1MDri3cH2pvgFNRaLoaenhyGQ8lra3UCycTs4tgASFT0GQMqZ8vLy9BDYK2PjTTGEverWw1ACrP6mDvaW9BAYDAbVrQjRLGW7BVBIaQHkMjBExYkBkHKqvLwcdXV1yra/L0ch0Aas/roOjtZkCOzt7WUIpLyUFgCzsBi0jl3AREWPAZByrqysLC0ETvbL2HhjDKFxdethsAGrv6FDaXt6S2AgoPI0ZaIZZL0FkF3AREWPAZDyQllZGerr65XtyYF9IXBM3XroLcCq63QoXcwQSPkr65NAGACJih4DIOWN0tLStBA4NSTjzRtjCHrUrYfeAqy+Toeyw/ettSZJ6OnpwdTUlLoVITqI9C7gzJcvGrgQNFGxYwCkvFJaWoqGhgblAhcYjrcEBt3q1kNnAlZ9VYfyI5MhsLe3lyGQ8kL2A2DyZwZAouLEAEh5x+FwoL6+PhkCR2S8+aMoAiPqXoh0JmDltTo4j0qGwL6+PoZAyjl2ARPRQjEAUl5yOBxpLYFBN/Dmj2KYGlY5BBqBldfoUHF0ekvg5KTKq1YTpVAzAHIZGKLixABIectut6eFwNAYsPFHMUwNqhsCRQOw4is6VC6P10OWZfT19TEEUs5kfSFodgETFT0GQMprdrsdjY2NyRA4Drx5YwyT/SqHQD2w/Es6VK1MD4F+v8q3LiGCCmMA2QVMVPQYACnvlZSUoKmpSbnohSeAjTfFMOnKQQj8og5Vq5Mh0OVyMQSS6tK7gDP/PmALIFHxYwCkgmCz2dJaAsPeeAj096p7cRJ0wPIv6FB9THoI9Pl8qtaDtI2TQIhooRgAqWDYbDY0NTUp45/CPmDjj2Pw9agcAkVg2ed0qDkuGQL7+/sZAkk1qQFQ5jqARDQPDIBUUKxWKxobG5UQGPEDm34cg3ev+iHw6M/oUHtCekug16vyTYxJkzgGkIgWigGQCo7Vak1rCYxMAptujsHbqX4IXPopHepOTF6M+/v7GQIp67LeBcwxgERFjwGQCpLVakVzc7MSAqNTwKZbYpjYrXIIFICjPqFD/cnJt1J/fz8mJiZUrQdpS9oyMBwDSETzwABIBctisaSHwACw6ScxjL+bgxD4MRENpyXfTgMDAxgfH1e1HqQd2e4CFlJaALkQNFFxYgCkgmaxWNDS0gKdTgcAiAWBjp/EMLZT5VYLAVjyERGNZyTfUoODgwyBlBWcBUxEC8UASAXPbDajubk5GQJDwOafxjC2Q/0QeOSHRTSdlR4Cx8bG1K0HFT2OASSihWIApKJwQAgMAx23xuB5W/2L1xEfENF8TvKtNTQ0xBBIGZXeBcyFoIlo7hgAqWiYzWa0tLRAr4/3X0lhYPPPY3BvU/8CdviVIlrWpYdAj8ejej2oOHEZGCJaKAZAKiomkwnNzc3JEBgBtvwihtEt6l/EDnu/iLb1ybfY8PAwl4ihjMj+GEAuBE1U7BgAqeiYTKb0lsAosPWXMYx0qH8hW3SpiPYLk2+zcDiseh2o+GS9BZBdwERFjwGQipLRaDwwBP4qhuGN6l/M2i8SsegSvtUoc9ScBMJlYIiKE69KVLQSIdBgiF/N5Biw7dcxDL2hfghsO1/E4sv4dqPMSFsImmMAiWgeeEWionZACJSAt/43hsEN6l/UWs8TcdgVfMvRwqW2AMpZXgcQYAgkKka8GlHRMxgMB4TAt++IYeAV9S9qLeeKOPwqvu1o4RIhMBstgBAAQZfcZAAkKj76mR9CVPgMBgOam5vR09ODSCQCWQK2/zYGWRJRf5K6gaz5bDHt4ko0H4IgQJblrIwBBOKtgLFY/GcGQKLiw6YI0oxES6DRaAQAyDKw/fcSXC+qP8i96UwRVauEmR9IdBDJFsDshDPOBCYqbgyApCl6vR7Nzc1KCIQM7PijhL7n1Q+BqRdYorlSAmC2WgAZAImKGgMgaU4iBJpMpvgOGXjnLxJ6/8nlLqhwZHUMILgYNFGxYwAkTZouBO68U0LPMwyBVBjUbAHkWoBExYcBkDRLp9Olh0AAu+6R0P00L3aU/xIBUJbi/2Uau4CJihsDIGlaIgSazWZl37v3Sdj7JEMg5bes3w6Oi0ETFTUGQNI8nU6HpqamtBC4+0EJXY8zBFL+SrsbSJYXg2YAJCo+DIBEmD4E7nlIQucjDIGUn9S8HzADIFHxYQAk2ifRHWyxWJR9nY9K2PNXhkDKP+ldwJkPaAyARMWNAZAohSiKaGpqSguBXU9IePcBhkDKL2n3A+YYQCKaIwZAov0kQqDValX2dT8lYde9DIGUP7LeBZwSALkMDFHxYQAkmoYoimhsbEwLgT1/l7Dzbl4IKT9kOwAKBi4ETVTMGACJDkIURTQ3N8Nmsyn7ep+V8M5fJIDXQ8oxLgNDRAvBAEh0CIIgoKmpKS0E9j0nYcefGQIpt7IeADkJhKioMQASzSARAktKSpR9rhckbP+DBF4XKVe4DiARLQQDINEsCIKAxsbGtBDY/5KE7b+LMQRSTnAdQCJaCP3MDyEiIH7BbWhoQH9/P3w+HwBg4N8yZCmGpZ/UQeDXqayIRA5MN7MNJKkhaTqZCDYzHWO+x5mp3NSZuRwDSERzxQBINAeCIKC+vj4tBA6+KkOOxXD0ZxgCM02WZezZsyfX1ch78YWgZw6ic8EWQKLixssV0RwlQqDD4VD2Db0uY9vtMchcJYZygF3ARDRXbAEkmodECAQAr9cLABh+U8bWX8Ww/PM6CLpc1q6wiQag/SJ+N50Le0tmW/8ALgRNVOwYAIkWoL6+HoIgYGJiAgAwsknG1l/GsOwLurQLKM2eqAfaL2QAzDVRz4WgiYoZP2WJFqiurg6lpaXK9shmGVtvi2VlYD6RWtgFTFTcGACJMqCurg5lZWXK9uhWGVt+HsvK2CwiNTAAEhU3BkCiDKmtrU0Lge63ZGy+NYZYOIeVIponLgNDVNwYAIkyqLa2FuXl5cq2Z7uMzT+LIRbKYaWI5kFgACQqagyAGpZ6K6mgJ/Ply7Hkz7NZLLdY1NTUwOl0Kttj78jo+Kk6ITD1NSdaCHYBExU3BkANs1gsys+eHZn/gA+MJH82m80ZLz+fVVdXp4XA8V0yNt0SQzSQ3eNODSf/jloK3ZR5qQGQy8AQFR8GQA0zmUzQ6eIL1nm75Iy2UElRYGhD8qJhtVozV3iBqK6uRkVFhbI9sVtGR5ZD4NRA8meDwXDwBxLNgGMAiYobA6DGJVoB5Rgw/m7mPuRHOmREJuM/GwwGGI3GjJVdSKqqqtJDYKeMTT+OKa9NJskyMDUY/xsKgoCSkpLMH4Q0gwGQqLgxAGpctrqB+19Otv7ZbLaMlVuIqqqqUFlZqWx798rYdHPmQ2Dfc5Iy49hmsymtu0TzIRq4EDRRMWMA1LjUrtnBVyWExhZeZmgM8LyVvGBosft3f5WVlaiqqlK2fd0yNt0UQ8SfmfKDbmD3A8nQnbowdaalTh4KjTEYFK2UP23q35yIigPf1RpnsViUCRqhMWDjj2MIe+dfXiwE7PhjDPK+LCKKIrsi96moqEgPgb0yNt64sNc7YfsfkrOMs/2aC4KgnDNBT/rEEyoenneSf1e9nvc1JCo2DIAaJwgCGhsble7CqcH4bNX5dE+GxoA3fxjD6NbkhaOxsZEXjxQVFRWorq5Wtv0uGRtvWlgI7H9Jguft5GvucDiyPgM4dejAWBZmkFPujWxKtijzPUxUfBgACQaDAfX19cq2v3ffunXB2Zfh65bx+vej8PUkw0BNTQ1b/6bhdDrTQuBkv4wN34ti8FU5rdttJrIMDLwqY9c9yQu10WhMG2+YLdleQohyS4oA7m3Jv6tWJ3ERFTNdTU3N9+b75Gy0Mqi1dlm2jlOor4nRaIQoipicjDf9hcaAgX9LCIzE1wMzOwUI+31dkCVg0iVj6HUZb90hpbUalpWVobq6uqBeZzWPY7FYoNPplNc7FgSGN8pwvy3D3iTAVH7o4450yNj2KwmuFyRI0fg+o9GI5ubmrLfWCIIAnU4Hjye+enjEB7S8j98li8noNhkD/07OKK+vr59xHGAhvyf5OaVOmdksV43jFPJrMt0x2K5PisrKSgQCAfh8PgBAaDw+s7TvOUBvBapWCCg9TMDUYHzdQF+3PO19bq1WK2pra1WufeEpLy+HKIoYGhpSFtqd2C3j9f+Oof5EETVrBYg6QEj5L+wFuh6TMLEnvdVNrfCXoNfrYTAYEIlEEPbGZ33Xn8QQWCxS1/AsLS1lFzBRERKWL18+bf/NbKb9Hyq1znbZgP0fN5skPJclCQ722Nkm7rkuf7B/ufNZPiHbr8lMx/H5fBgZGUEwOIc+YMS7kp1OJ8rKypTWgunqPt8lJVKfN59vTPM5bib+njOJRqMYHh6G1zu/gYDZDH/T/XsTr4nb7cbISPx2L4IILPucDtXH8O4jhW7PwxK6HosHQEEQ0N7ePu2i4vP5nJrJQq878z1mPrTsLOSzRa3Wrkx8/uWqBTCf684WQMobdrsddrsdPp8Po6OjCAQOfesKk8mEiooKVSYfFCO9Xo/6+nqUlpZicHAQkUhkVs8zGo1wOBwoLy/PyZp/FRUVCAaD8Pl8kCXgrf+LYYVRh4rlPAcK1a57JPQ8k976xzvKEBUntgBm8FjTlVuILYD78/v9CAQCkGVZeU7i/zab7ZATPdgCODeyLMPj8SAYDCISiSAajSIajSq/NxgMsNvtcDgcqtxf+VAtgED8HrF79+5FOBwfCyAagVXX6lB+JENgIZFl4J0/SXD9Kxn+DtX6F38OWwBnwhbA2ZWbDWwBnPkYDIAZPNZ05RZDAFzIMRgAMyMajSIWi8FkMql63JkCIACEw2Hs3btXGcco6gHnUgHVawRUrhRhtKtSVZqHoBvw7JAwtEGGO2Xx9kSr9KEWcWcAnBkD4OzKzQYGwJmPwS5gogKg1+vzdiC+0WhEXV0dXC4XAECKAqNbZIxukSEIEsoOF1C1SoClSgDYMJhz0SlgfJcMzw4ZgZEDL4oWiwUNDQ15e74RUWbwHU5EC2a329He3g63242JiQllvywDYztljO3kWoGFoLy8PKvLNxFR/mAAJKKMSLQEVlRUHBAEKX+JogiLxYLS0lI4HI5cV4eIVMIASEQZlRoEJyYmEA6HD5jMQrkjCAIsFovyn9rjSokoPzAAElFWGI1GVFVVTfu7hU4gmO2A7mxMbJrrMeZ7nGyVO9uyiai4cel+IiIiIo1hACQiIiLSGAZAIiIiIo1hACQiIiLSGAZAIiIiIo1hACQiIiLSGAZAIiIiIo1hACQiIiLSGAZAIiIiIo1hACQiIiLSGAZAIiIiIo3hvYBp3iRJQigUUu4rmnp/UaPRyPuN0rQkSYLX64XP50MkEoFer1f+MxgM0Ov1sNlsEEV+PyUiyhYGQJqzWCwGj8eDsbExxGKxaR9jMBhQUVGB8vJyBsEFkGUZExMTymudGrYFQYAoiigvL4fD4chxTQ9NkiT4/X54vV5MTk5ClmXld+Fw+IDH6/V61NTUwG63q1nNopUI3YlzKPU8EkURdru9oAJ3NBpFIBBAIBBAJBJJO5/yyVw++xbyb8jlZ6zZbIbVaoXFYuFnfYERli9fPu1ZN5uT8VB/7NmezPs/bjYn0FzeKAd77GxP1Lm+Kfcvdz5v6my/JvM9Tjgchtvtxvj4+KyPZzAYUFlZibKyMqX8+X7QpT5vPh808zluJv6e8yFJEsbHx+HxeBCNRmd8vNFoREVFBRwOR0Y/hKf79861/HA4jJ6engP+HSUlOsSiMiJRGdHo9K9rSUkJampqYDAYZqzXdGaqayb+ntl6f2ai3FgshrGxMYyPjx/0yxoA6HQ6lJeXw+l0zjoIzudzaq5lppqYmMDU1JQS+ii/CIIAi8UCm80Gm80Gi8Vy0MepVZ9Uar3X86ncmY7BAJjBY01Xnw4y4QAAIABJREFUbrEEwOHhYYyOjqbtq6o0YsXyEqxaYcfKFXZUVBjwzD88ePzJEby7eyrtsXq9HnV1dbDb7QyAMxgdHZ22dbWkRIeVy+1YtdKOvr4QnvmnG5OT6Y9JBO7S0tKM1GWhATAUCqG3tzct/J1+mhPfu6Edq1amt+5FozLe3T2F//jObvzzeY+yXxRFVFZWwul0HrJe09FqAIxEIhgbG8PExAQkSTrg9xaLDtGohEgk/fmJFmWn0wmdTjenY2crAMZiMfT392NqamqaZwBmU+G0XBabmCQfcA4lVFVVobKy8oD9DIDqlTvTMRgAM3is6cothgA4Pj6O/v5+Zfvs91bg1psPR2Oj+aBl73p3Co8/OYI77xnAns4AgPjFpbW1FSaTac513b++xRoAR0ZG4Ha7le2zzqzA+y+pxupVDixeZIEoJusTCkt44V9jePzJEfzt726MjCa7Uqurq9MC03wtJACGQiH09PQoQfbYYxz47g3tOOWk8hmf+9TTo7j+27vRtTeg7HM4HKivrz9ovaajxQAYDAbR09Oj/M5gELDsaDvWrIp/eVi10oEjD7fC74/h6WfcePypETz7Tw8CgeSXCVEU0djYCKvVOutjZyMABoNBuFyutC8QTU1mnHZyOU47pRynnFyOmmrjgo9L8+f1RvHI4yO48+4BvPb6RNrvEu/Z1HODAVC9cmc6BgNgBo81XbmFHgCnpqbQ3d2tPPYzn2zEjf+zGDrd7F4/tyeC913QgXd2TgKIt1C1tbXN2LowU32LMQBOTExgYGBA2f7yF5rx/e+0p4W+g4nFZHzmiztw/4NDAOL1bmpqOuQFfDbmGwBTw58gAL/59VG4/LKaOR07HJbwy9t78T83dildxHa7XQmBs6G1ABiNRtHd3a0EptoaI+79yzKsXnXoMaKBoITnnvfg+m/vxt7ueOjW6/VobW2FXj/9UPFsB8CJiQkMDQ0p+654fw3+4xttaGudvmuRcm/3nincde8g7rpnAIND8S+kZrMZTU1NynnEAKheuTMdgwEwg8eartxCDoCRSASdnZ2IxWLQ6QTc+D+L8ZlPNs75OINDYZyzfpPSmmOz2dDc3Lyg+hZbAAwEAkqrjV4v4Kc/PhxXf3j2QQeId6F++ONv4cm/xbvqdTod2traDnoBn435BEBZlrFnzx4lhFz94Xr84qdHzLsOjz0xgo99+m2lq8lut6Ourm5W54CWAqAsy+jp6UEwGAQArFhWgnvvXI6G+tm3uPf0BnHO+k1w9YcAABaLBc3NzdPWJZsB0OPxYGRkRNn/6U804OYfHQ7OMSgMA4MhnHHORuU80uv1aGlpUXV1CAbAmY/BwRM0LUmS0rrv7vnzsnmFPyDeCvHEQyvR2BC/EE1OTmJ4eDhjdS10kUgELpcLsizD4dDjr/eumHP4AwC9XsAff7sUp58a72KNxWJKuWqamppSwl9drQn/871FCyrvgvVV+Mvvj4bRGP+48vl86O/vz9uZn7kyODiohL/zz6vC359YPafwBwDNTWY89teVqKqMd6sGAgHV36uSJKUNg7jumhbcciPDXyGpqzXhvruWw2aL9/REo9EDxpBT7jEA0rT8fj9Cofi3t+OPK8W5Z1csqLymfReWxIBtt9vNmXz7DA8PK4HpG19tUQLcfJiMIu758zIce0y8yy8QCKj+wTsxkRwH9LObD4fDsfDVptadW4m7/ng0TPtCoN/vz0m4zVdjY2Pwer0AgHPPrsCdfzgaVuvch1kAwGGLrXjkwRUoK9MrZaf+TbNtbGxMmbjyX99ehO/c0K7asSlzlh9dgj/csVQZwuL1evmZn2cYAGlak5OTys8fuLI2I2UuXmTF8WuTs1MPNqtPaxKvtV4v4MrLF/5aW606XP/1NmXb7/cvuMzZSqz3BwAXX1CNdeceOAtwvs45qwL3/GWZ8iVicnKSIXCfRPgDgE9+rGHBrWXLlpbgFz89Utn2eDyHeHTmSJKEsbExAMDSJTZc++W5DxWh/HHu2RX40X8vBhDvglXrPKLZYQCkaSVCidkk4pILqzNW7skpM0ADgcAhHqkNwWBQae04+70VqK7KzIzG9xxfqnSZhkKhQ64Bl0l+v1/591xycebOm4T3nuHEfXcug8XMEJggSZLS9VtTbcSZpy989jcAnHlauTLZKxQKTbucTKalLn+0fl1V1o9H2ffZTzUqvQAzrUdJ6mIApANEo1Hl7gzr11VmpAsv4dSTypSfGQDTW0E/dFVdxsq1WnU4dk1y5mciIGRbakvUkYfbsnKM009z4v67l8NiiXdxTk5Ooq+vT5WAko9S30eXX1Yz6xn6M7Hb9WlrNWb7/SrLstL6BwDrz2MALAaCAKxcHj+PJEliK2AeYQCkA6R2/1568dyW7pjJ6lUOZWBwauuXViVe68oKA845a2HjLPd36inJ1la1utsTQdNoFLGoPXvLdZx6cjn+eu9yZZzb1NQUXC6XJs+n1L/tB67M3JcIAGlrNmY7AEYiEaV1qKnJjBXLSrJ6PFLP6lXJLxIc+pM/GADpAKlv0LnOIpyJXi/g+OOS4wC13Aooy7Ly719ypA0GQ2anOZ52ivrd7YkAVl1thF6f3WmbJ72nDA/fvwIlJckQqMWWwMT7tbHRjKVLMtvqqmaLfeoEgfXvy9zYUcq9/e/6Q/mBAZAOkDpGQ5eFi3h5WbJLeTb3uS1WsVhMCSuJ8XqZlLpgbmJGd7YlxuLNYu3qjDhhbSkeuX8F7Pb4ORUIBDQVAmVZVlpdyzI4VCPhmJRhBGoGwCOyNHyAcmNNykLkaq0DSDNjACTKA9n4TEwts5gnSRx3bCkee3AFSkuTIbC3t1czITBBzMKnuTHlPrvZfj219vfSktSPNwbA/MEASEQFb81qBx7/60pl7bpgMIje3l7OOCTKA08+nVyLlAEwfzAAElFRWLnCjscfWgWn0wCAIZAoXzz+5MjMDyLVMQASUdFYsawETzy8EhUpITD1loZEpC6PJ4JXXkveScZm4/jOfMEASERF5eijSvDkI6uU+9mGQiGGQKIc+dszbsRi8THIBoMBZWVlMzyD1MIASERF56glNjz16CrUVKeHQC3POidS2+BQGD/7RbeyXVFRwTGAeYQBkIiK0hGHW/HUo6tQVxtfy5IhkEg9Pb1BnLN+E3a9G1+nUq/Xs/UvzzAAElHROmxxPAQmFjQPh8MMgURZtuvdKZyzfhO69ibXjmTrX/5hACSiorao3YK/PbYKjY1mAPEQ2N3dnbbwMBFlxqsbJnDu+Zvg6k8uPm+1Wtn6l4cyv3Q8EVGeaW2x4OnHVmHdhR3o6Q0iEomgp6cHTU1NMBgMua4eUcHq7Q3ihZfG8MKLY3jxpTEMDYfTfu90OlFTk9l7ylNmMAASkSY0N5njIfCizdjbHUAkEkFvby9DoEbcc98gfvLz7pkfSLM2NRVDn2v620yKooi6ujo4HI5pf0+5xwBIRJrR2GjG3x5bhfMu6kBnV0BpCWxubmYILHLjE1FlQgJll9FoRGNjI0wmU66rQofAMYBEpCkN9Sb87bFVWLzICgCIRqPo6elBOBye4ZlENB29Xg+73Y6amhq0traivb2d4a8AsAWQiDSnrjYeAtdf3IGdu6YQjUaV7mCj0Zjr6lGW2Ww2lJaWZv04c5n1KsuyKsdZSJn711EQBJjNZraeFygGQCLSpJpqI556dBXWX7wZO96ZZAjUEIPBoIxNk2U5a8uTFHsApMLGLmAi0qyqSiOefGQVjj6qBECyOzgUmn5gOxFRsWAAJCJNq6ww4ImHV2L50fEQGIvF0NvbyxBIREWNAZCINM/pNOCJh1dh5Qo7gGQIDAaDOa4ZEVF2MAASEQEoK9Pj8b+uxJrV8bFhsVgMfX19DIFEVJQYAImI9ikt1eOxB1fg2GOSIZAtgURUjBgAiYhS2O16PPrAShx/XHyZEEmS0Nvbi0AgMMMziYgKBwMgEdF+Skp0ePj+FTjxhPgN7CVJQl9fH0MgERUNBkAiomnYbDo8dN9ynHJSOYBkCJya4u3EiKjwMQASUcHo6VV3LJ7FosMD9yzH6acmQ6DL5WIIJKKCxwBIRAVj/cWb8e5udcOXxSzivruW48zTnQCSLYGTk5Oq1oOIKJMYAImoYAwOhrDuwvj9e9VkNom4985lOPu9FQDit8RyuVwMgURUsBgAiaigDA2Hse7CDux4R93wZTKKuPtPR2PduZUAkiHQ7/erWg8iokxgACSigjMyGsZ5F3Xgre3qhi+jUcRffn80zj+vCgBDIBEVLgZAyqnJyUlIkpTralABGnVHsP7izdiyTd3wZTAI+NNvl+Ki89NDoM/nU7UeREQLwQBIqjOakqfdxMQEOjs74fV6c1gjKlQeTwTnX9KBzVvUDV96vYDf37EUl11cDSAeAvv7+xkCiahgMACS6m695Qhc/402mPcFwUgkApfLhZ6eHoRCoRzXjgqFKMbPn/HxKM6/dDM2blL3S4ReL+A3tx+Fyy+rAZBsCeSXGSIqBAyApDqzScT1X2/Fm6+uxfp1lcr+yclJdHV1YWhoiN3CNKP6+nolBE5MRHHBZVvw+hsTqtZBpxNwx6+W4ANX1ir7+vv7MTGhbj2IiOaKAZByprnJjLv/tAwP378CixdZAcRbUTweD/bs2cOLKB2SxWJBU1MTdDodAMDni+Kiy7fg1Q3qnjeiKODXPz8SH/lgnbJvYGCA5y8R5TUGQMq5M0934rUXj8V/fXsRrNb4xTwajaK/vx/d3d0IBtW9+wMVDrPZnBYC/f4YLr58C15+ZVzVeoiigNt+diQ+9pF6Zd/AwADGx9WtBxHRbDEAUl4wGkVc++VmbHptrTKwHgCmpqbQ1dWFwcFBxGKxHNaQ8pXJZEoLgVNTMVx65Vb866UxVeshCPHxrZ/6eIOyb3BwkCGQiPISAyAdktpD8errTPj9HUvx5COrcNQSm7J/bGwMnZ2dvJjStBIhUK/XAwACgRgu/8BWPP+CR9V6CALwk5sOx2c/1ajsGxwcxNiYumGUiGgmDIB0gMRFFAB27MjNArcnn1iGl587Fjf94DA4HPH6xGIxDA4OYu/evQgEAjmpF+WvA0JgUMIVH9qGfzynbggEgB//8DB88XNNyvbw8DBDIBHlFQZAOoDValV+fvHl3LW46fUCPvfpRnRsWIsPXlkLQYjvDwaD2Lt3LwYGBtgtTGmMRmNaCAyGJFz14W14+hm36nX54fcX45ovNSvbw8PD8HjUD6NERNNhAKQDWCwW5ed/vZz7VouqSiNuv20J/vHUGqxYblf2j4+PY8+ePWxZoTT7h8BQWMKHPvYWnvzbqOp1+f53FuG6a1qU7ZGREYZAIsoLDIB0AIPBAIPBAADo7Q2iuyc/ZuEee4wD/3p2DW695Qg4nfH6JbqFu7q62C1MCqPRiObmZuU8DoclfOQTb+GxJ0ZUr8t3bmjHt65rVbZHRkbgdqvfIklElIoBkKaV1gqo8mzKQxFFAR//aD06XluLT1zdAFGM9wsnuoX7+/sRjUZzXEvKBwaDIS0ERiIyrv7U23jo0WHV6/If32zDDd9qU7ZHR0cxOqp+iyQRUQIDIE0rdRzgD27sQtfe/GpdKy834Gc3H45/PbsGxx1bquyfmJjAnj174PF4IMtyDmtI+WD/EBiNyvjEZ7bjwYeGVK/LN7/Wiu/e0K5su91uhkAiyhkGQJpWWVkZTCYTAGBgMITzL9kMV3/+3ad3xXI7nn1yNf73tiWorjICACRJwtDQELq6ujA5OZnjGlKuGQwGtLS0wGiMnx+xmIxPfX4H7r1/UPW6fO2aFvz3dxcp2263GyMj6ndLExExANK0RFFEU1OTcq/Vnt4gzr9kM0ZGwzmu2YEEAfjAlbXo2LAWn/9ME/T6eLdwKBRCT08PXC4XIpFIjmtJuaTX69Hc3JwWAj/7pXdw5z0DqtflK19sxo/+e7Gy7fF4GAKJSHUMgHRQRqMRDQ3Juxrs3jOFCy/dglF3foYpu12PG/9nMf79/LE45aRyZb/X60VnZyfcbje7hTVs/xAoSTK+8JV38Me/9Ktely98tgk3/+gwZdvj8WB4WP2xiUSkXQyAdEh2ux2VlZXK9lvb/Vhzwgb87o8uSFJ+hqklR9rwxMMr8YffLEVDfbwbW5IkjIyMsFtY4xIhMDG8QZaBr3xtJ373R5fqdfnMJxvx0x8frqxvOTY2xhBIRKphAKQZVVdXw+FwKNtjYxFc+/VdOPWsjXj9jYkc1uzQLr2oGhtfXYuvfqUFRmP8VA+Hw+jt7UVfXx+7hTVquhB47dd34Y7f9qlel09+rAE//8kRaSFwaEj9CSpEpD0MgDQrjY2NqK+vh06nU/Zt2erDWedtwue+tAPDI/k3NhAArFYdvvef7djw0nF47xlOZb/f70dnZydGR0fZLaxBOp0uLQQCwHXXv4tf/1+v6nW5+sP1+NXPj1SWNBofH8fgoPoTVIhIWxgAadZKS0uxaNEilJWVKftkGbjr3kGsPn4Dbr+jD9FofoapRe0WPHTfCtzz52VoaTYDAGRZxujoKDo7O+Hz+XJcQ1KbTqdDU1MTzGazsu9b/7kbv/hVj+p1+dBVdbj9F8kQODExgYEB9SeoEJF2MADSnOh0OtTV1aGtrS1tsWivN4pv3vAuTjrjDbz8Su7uHzyT895XiTdeWYvrv9EGizl++kciEbhcLvT29iIczs+WTMqO6ULgf35vD35ya7fqdbnqilr85tdLoNMxBBJR9jEA0ryYzWa0trairq5OuecqAGzfMYl1F3bg459+G/0D+bduIACYTSKu/3or3nhlLdavS05wmZycRFdXF0ZGRiBJUg5rSGpKLHmUGgL/6weduOkne1Wvy/svrcFv//coZSmjiYkJ9PerP0uZiIofAyAtSFlZGRYtWgSn05m2/8GHh7HmhA249bYehMP5Gaaam8y4+0/L8PD9K7B4UfzOJ7Isw+12o7OzE16vN8c1JLUkQmBqq/YPbuzCD2/qUr0ul15UjT/8ZikMhngI9Hq9cLlcHKtKRBnFAEgLJooiampq0N7ennYLucnJGL7z/T044dQ38NzznhzW8NDOPN2J1148Fv/17UWw2eKTXKLRKPr7+9Hd3Y1QKD9bMimzRFFEY2NjWgi88Za9+P4POlWvy4Xrq/Cn3x6thECfz4f+/n6GQCLKGAZAyhiTyYSWlhY0NDSkdQu/u3sKF12+BR+8+i309gZzWMODMxpFXPvlZmx8dS0uu7ha2T81NYWuri4MDQ2xW1gDEiEw9YvMLbd24zvf36N6Xdavq8SdfzhaWcLI5/OxJZCIMoYBkDLO4XBg0aJFqKiogJBY4AzA40+O4Jj3bMCNt+xFMJSfYaq+zoTf37EUTz26CkctsQGIdwt7PB7s2bMHExP5u+4hZYYoimhoaEgLgbfe1oPrv71b9bq875xK3PPno2HaFwL9fj9DIBFlBAMgZYUoiqiurkZ7eztsNpuyPxCU8MObunDcia/jqadHc1jDQzvpPWV4+bljcdMPDoPDEW/NjEajGBgYQHd3N4LB/GzJpMxItASmnru/+t9efP36d1Wvy1lnVuC+O5fBbEqGwL6+PoZAIloQBkDKqkS3cGNjIwwGg7J/b3cAV354Gy69cis6uwI5rOHB6fUCPvfpRnRsWIsPXlmr3K0hEAhg7969GBwcRCwWy20lKWsEQUBDQ0NaCPy/3/bhq9/YBbWz1xmnO3H/3cthscTHqE5OTqKvr4/DEoho3hgASRWJbuHKysq0buFn/+nGcSe9ju//oBOBQH6GqapKI26/bQn+8dQarFxhV/aPj4+js7MT4+P5u+4hLUwiBJaUlCj7fvsHF665bqfqIfC0U8rx4D3LYbUmQ6DLpf49jImoODAAkmpSu4VTL6jhsIRbbu3GmhM24OHHhnNYw0M79hgHXnhmDW695Qg4nfHWzFgshsHBQezduxeBQH62ZNLCCIKA+vr6tHP2D3/uxxeveQeSpG4KPPnEMjx033JltjrPOSKaLwZAUp3RaERTUxOamppgNBqV/X2uED76ibdx/iWb8c7OyRzW8OBEUcDHP1qPjtfW4hNXNyi37goGg+ju7sbAwAC7hYtQIgTa7ckW4L/cPYDPfVn9EPie48vwyAMrUFKim/nBREQHwQBIOVNSUoL29nZUVVVBFJOn4r9eGsN7TnsD//Gd3fD78zNMlZcb8LObD8e//nEM1h5bquyfmJjAnj17MDY2lsPaUTYIgoC6urq0EHjPfYP41Od3IBZTNwSuPbYUjz24UpmgREQ0VwyAlFOCIKCyshLt7e1pF9ZoVMYvb+/FqrWv4b4HhnJYw0NbsawEzzy5Gv/3yyWoroq3ZkqShKGhIXR1dWFqairHNaRMSrQEOhwOZd8Dfx3CJz+7HdGouiHwmDUOPPbgCpSWMgQS0dwxAFJeMBgMaGxsRHNzc1q38NBwGJ/6/Hacs34Ttr3tz2END04QgKuuqEXHhrX4wmeblPu4hkIh9PT0oL+/H9FoNMe1pEyqq6tLC4F/fWQYH/vU24hE1A2Bq1c58MRDK1Febpj5wUREKRgAKa/YbDa0t7ejuro6rVv41Q0TOOXMN3Hdt3ZhfDw/w5TdrseP/nsx/v38sTjlpHJlv9frRWdnJ9xuN9duKyJ1dXUoLU12/z/6xAg++sm3VA+BK5bb8cTDK1FRwRBIRLPHAEh5RxAEVFRUYNGiRWmtLLGYjDt+58Kqta/hT3cOqL4Mx2wtOdKGJx5eiT/+dika6k0A4t3CIyMj6OrqwuRkfk5wobmrra1FWVmZsv3EU6P44NXbEA6ruz7fsqUl+N3/LVX1mERU2BgAKW/p9Xo0NDSgpaUFJpNJ2e/2RPCla9/B6edsxMZN3hzW8NAuubAaG19di69d06LczzUcDqO3txculwuRSCTHNaRM2D8EPv2MG1d95C3Vb3dYyRZAIpoDBkDKe1arFe3t7aipqYFOl1z6YlOHF2ecuxFfvOYdjLrzM0xZrTp894Z2bHjpOJx1ZoWy3+fzoaenJ4c1o0yqra1FeXmy2//Zf7px5Ye3IRDknTqIKD8xAFLBKC8vR3t7e9q4K1kG/nzXAFYf/xru+J1L9eU4ZmtRuwV/vXc57v3LMrQ0mwGA4wGLTE1NTVoIfO55D6744Na8vcMNEWkbAyAVFJ1Oh7q6OrS2tsJsNiv7x8ejuO5bu3DKmW/i1Q0TOazhoa07txJvvLIW//HNNljMfPsVm5qaGjidTmX7hRfHcNlVWzE1xRBIRPmFVyAqSBaLBW1tbairq0vrFt72th/nrN+ET31+OwaHwjms4cGZTSK+dV0r3nhlLc4/ryrX1aEMq66uRkVFsrv/pX+P45IrtmJykiGQiPIHAyAVtLKyMixatCit6w0A7ntgCKuPfw23/bpX9WU5Zqu5yYy7/ng0Hrl/BQ5bbM11dSiDqqqq0kLgK6+N46L3b4HPl59LGBGR9jAAUsHT6XSora1FW1sbLBaLst/vj+GG7+7Ge057HS+8mL+3ZjvjdCdu+sFhua4GZVhVVRUqKyuV7Q1vTODC92+B18sQSES5xwBIRcNsNqO1tRX19fXQ65O3x9q5awoXXLoZH/3E2+hzhXJYQ9KaysrKtBD45kYvzr90c94uZk5E2sEASEWntLQUixYtgtPphCAIyv6HHxvGmhM24JZbuxFSeaFe0q79Q2DHZh/Ov6QDY2P5uXQREWkDAyAVJVEUUVNTg7a2NlityfF1gUAM3/9BJ9ae9Dqe+Yc7hzUkLamoqEBVVXLCz5Ztfqy/eDPcHoZAIsoNBkAqaiaTCS0tLWhoaEjrFu7sCuCyq7biig9tw97uQA5rSFrhdDpRXV2tbG9724/zLurAyGh+zlYnouKmn/khRIXP4XDAZrPB7XbD4/EoizD/7e+jeP4FD77yxWZ89ZoWrs1HWZWYrT48PAwA2L5jEuddtBmPP7QSNdXGXFZNU8bHxzE+Pp7rahQVURRhtVphtVphs9nS1mml/MSrHWmGKIqoqqpCW1sbbDabsj8YknDTT/bimPdswONPjuSwhqQF5eXlqKmpUbbf2TmJdRd2YGCQE5SocEmSBL/fj+HhYXR1dWHnzp3o7e3F1NRUrqtGB8EWQNIco9GIpqYm+Hw+DA8PIxKJj8Pq7Q3ig1e/hTNOd+LmHx7Gtfkoa8rKygAAQ0NDAIB3d09h3YUdeOLhVWioN+WyakVr8SILLru4euYH0pzJMhAKS9iyzY/e3iCAZCCcnJw84DaJlB8YAEmz7HY7SkpK4Ha74Xa7lW7h55734PhTXscXPtuEb36tFTabboaSiOaurKwMgiBgcHAQALCnM4D3XdCBpx5ZicZGdp9l2llnVuCsMytmfiDNmywDL78yjrvvHcAjj49gcjIGWZYxODiIUCiEmpqatJUZKHdEUWQXMGmbIAiorKxEe3s7SkpKlP2RiIxbb+vBmhM24MGHhnJYQypmpaWlqK2tVbb3dgdw7gUd6NnXikJUSAQBOPnEMtx+2xLs2X4i7vjVEmVs69jYGHp7exGL8ZaIuSTLMkRRhCAIDIBEAGAwGNDY2IjGxkYYjcnB+P0DIXz8M9ux7sIOvL1jMoc1pGJVWlqKuro6ZbunN4hzL+jg7HQqaFarDldeXov77lymTK6bnJxEd3d3jmumXbIsQ6fTKa2wDIBEKUpKStDW1oaqqiqIYvLt8fIr4zj5jDfwzRve5a28KOMcDkdaCOzrC+J9F3Sgs4shkArb6lUO/Ob2o5Do+Q0Gg/D5fLmtlEbp9fq0LngGQKL9CIKAiooKtLW1weFwKPujURm339GHVWs34K57B7FvyCBRRjgcDtTX1ysf0K7+EN53QQfe3c1ZlFTYLlhfhf/69iJle3R0NIe10R5BEKDTHTiWnQGQ6CAMBgMaGhrQ3NwMkyk5M3NkNIzPfWkH3rtuI7Zs5TdZyhy73Y7vreEdAAAQDUlEQVS6ujolBA4MhrDuwg7s3MUQSIXtmi814+IL4rOwA4EAl4dRiSiK04Y/gAGQaEY2mw1tbW2oqalJ6xZ+400vTj1rI665bic8vKUXZYjdbk9rCRwaDmPdhR3YzjGoVODOPy95T2y3m7fizCZBEOIzfcWDxzwGQKJZEAQBTqcT7e3tad3CkiTj93/qx6rjN+B3f3RBktgvTAtXUlKChoYGJQSOjIax/uIOvLXdn+OaEc3fyhV25Wefz4dwmLdBzIbZhD+AAZBoTvR6Perr69HS0pLWLTw2FsG1X9+FU8/aiNffmMhhDalYlJSUoLGxUQmBo+4I1l+8GVu2MQRSYVrUbkVJSbI7MhrlhLpMS4S/2ay3yABINA8Wi0XpFk4dX7Flqw9nnbcJn/vSDgyP8NstLYzNZksLgR5PBOdf0oHNWzj2lAqPIAArltlnfiDNS2Kyx2wX22YAJFqA8vJytLe3K7f2AuKr4d917yBWH78Bt9/Rh2g0N93CqbOU1Vp9P9HlMDYezUp3eEyDXeyJEJh4bcfHozj/0s3YuMmb9WNLMfVe79TuKjfH1BatZUcnF9znXUEy52AzfQ+FAZBogXQ6HWpra9Ha2gqzOXkLL683im/e8C5OOuMNvPzKuOr1GhtLXkT1enXu+pj49/t8UWzNcFel2xNBJBIPJHq9fsbxLcVk/xA4MRHFBZdtyfpwg+6e5B1Jsn2xTn3vvPzvsawei3JnF5c1yrhDzfQ95POyUBciTTKbzWhtbUVtbW3am3H7jkmsu7ADH//02+gfCKlWnyf/llxrK/XuJtlksViUn//1UmYv4vc9MKj8bLVaM1p2IbBarWkh0OeL4qLLt+DVDdkLgbveTV6ss/0lwmQyKSHztQ0TCIelrB6P1DcxEcVLLyc/F9gCuDCJVr/5fhlmACTKsLKyMrS3t6O8vDxt/4MPD2PNCRtw6209qlzcHki5h3HqhJVsymYAvPNubQdAIP7vbmpqUj7w/f4YLr58S9ZamFNba1LvlZ0NgiAorYCBoIQ3VejiJnX9/Vm30ooPMAAuxFzH+02HAZAoC3Q6HWpqatDa2poWiiYnY/jO9/fghFPfwHPPe7J2/O07JtPWjctFAHx1w0TGxj9u2epLWwJFqwEQiL/GqSFwaiqGS6/cmvHAHQpLuPf+ZOguLS3NaPnTST1/XnxZ/WETlF1PPDWi/Gy1WlX7XCo28xnvNx0GQKIsMpvNaGlpQV1dXVoX2ru7p3DR5VvwwavfQm9v8BAlzE9q658oimkX1mwSRVFpxZmcjOG+B4dmeMbs/OXuAeVng8EAg8GQkXILlcViQXNzsxICA4EYLv/AVjz/Qua+VNx4816lC9hoNKaN0cuW1PP0oUeG4ffHsn5MUkcgEMOzzyXPz6qqqhzWpnDNd7zftGVlpBQiOqTS0lK0t7fD6XSmNdk//uQIjnnPBtx4y14EQ5npFh51R9JabqqqqlSbBAIgbaHsL137Dp56emH3/XzjTS/uuT8ZJLPdFVkozGYzmpqalItBICjhig9twz+eW3gI3LLVh5//skfZVqP1D4i3CiXO1Xd2TuLyD25FIMixgIVuaiqGKz60DZOT8UBvtVphs9lyXKvCstDxftNhACRSiSiKqK6uRmtra1oXZiAo4Yc3deG4E19fcFjq2hvAe9+3Ea7++GQTs9l8wFjEbHM6nbDb42t9RaMyPvqJt/H8v+bXPfnQo8M476IO+HzxBWPNZjNbDlLsHwKDIQlXfXgbnn5m/rfZikRkfP7L76R136eG+mwSRTHtDigvvzKOD350GyeEFDCvN4oLL9uCF15MfgZUVlYe4hm0v0yM95uOrqam5nvzfXI2BnCqNSg0W8fha5L9MrNZrhrH0ev1KC0thclkQiAQgCTFL27jE1E8+PAw3tzkw7FrHCgvn1s356YOL9ZfvFkJfwDQ2NiY8da/2bwmJSUl8Pl8iMViiMVkPPr4CE4+sQyNDbPvRrzl1m589Ru7lCCi1+vR3Nw8p+4PNc6TXJ/jer0eNpsNPp8PsizHX+8nRhCNyjhmjQMGw+y/53u9UXzrP3fjmX8kA6TT6ZxVAMzU66DX66HT6TA5GR/D2tkVwDu7pnDh+VUQRU4aKCRuTwQXXLIZGzuSC5dbLBbU1NRk/djFcj3LZJfv/hgAC6DcQn5NCul1Vvs4JpNJWUA6GEyOA+zsCuD3f+pHICjhsMVWOOwzB7hn/uHGZR/Yhglv8tZKZWVlaQtUZ8psXhNBEGC1WuH1eiHLMqJRGQ89Oozu7gD0egGNjWbodQeWI0ky3t0dwA3f241f3t6bVl5zc/Ocl7PRQgAEkiHQ7/dDkiTEYjJefmUc994/iJpqI45acuhu80BQwq9u78VHPvk2XktZVsbpdKK6ujrj9Z2J2WxGNBpFKBT/MrNz1xSee8GDUFBCba1pVu8Jyp3BoTCeenoUn//yDrydMhnNYrGgsbExa4EmVTFczzLd5XvAcZcvXz7tND1Znnn23qFejNk8f7rHzeYFnm3Zh3rsbP+QcznWdOXO9fnTPSfTr8l8jzOfY0xX5nzK2f9583kjZqL+8637TMLhMIaGhpRWj1RLl9hw9lkVOPu9FVh7bCn0egG790zh9Te8eP3NCWx4fQI7dk6l3XmjpKQE9fX1C/7wmO7fO5fX3ufzweVyHbC/pESHs8+swPp1lRBEAR2bfejY7EXHFt+0A//r6+vTWqFm+3fIxjk912PM9zjzKTccDsPlciEcTr8N4fHHleK7/9mO+joT9DoBeoMAvV6AThTw8GPD+PFPujEwmL5G5Uzhbz6fUzNJLVOWZfT09KR9OYofB1i10oHz11XitFPKYTRxJFOuyXL8i+uLL43hxZfH0taPTCgrK0Ntba1qC7hn47NbrQA4l/v5Lui4DICZO9Z05TIAMgDOhd/vx9DQECKR6W+F5XDoYdALB71VVmL5mUyN2VpoAASAQCAAt9sNv3/udwaxWCyoqKg4YOIHA+DBy5VlGR6PB263e97/vtm0/GU7AAKAJEkYHx+Hx+NBLMYZwYVIEATU1tYqvRG56r0plACYqSVeZnVcBsDMHWu6chkAGQDnKnEB93q9ShfYbDgcDtTU1GT0wyMTATAhGAxidHR0VkGwpKQETqfzoOv9MQDOXG44HMbw8PC0rcoHYzab/7+9e1mO4gYDMKq+mAIvhuL9H9IuXCzMDDSbaCLL3fZc+q5zNoCTjG2STL78aknh+/fvF20cmiMAoxiCT09P4XQ69f45rEtVVefn/dIjhATg8OvWdT3rFZcCcMTP1fe6AlAA3uP379/h5eUlvLy8vFsKa9v2fCbe4XCY5HiUMQMwen19DU9PT+fNL+nnaJom/Pjx49MDYgXg5a/78+fP8Pz8HE6nUzidTu/+mi9fvoTD4RAOh8NVz1jOGYDpH39+fg6/fv0Kx+MxHI/H2f+dpF/TNOHx8TF8+/YtPD4+hq9fv/b+MyEA34vhN/fNKAJwxM/V97oCUACO5Xg8htfX13P0zfF/ilMEYN/rXvuaAvD21z2dTuHPnz/heDyGh4eHmw94XiIA+z7PvX8Pu65bxUaee76PuTY8fPQ1Xvo1CMC3ptzl+xlbqWAj3IDBGOLkeI6bPeYwxn+U1xCAa/s8c0+jShOf9Vvy91kAAgDMZMmpX0oAAgBMLB7vMudGj48IQACACa1hyTcnAAEAJrKWJd+cAAQAGNkap34pAQgAMKK1Tv1SAhAAYCRN06xmo8dHBCAAwJ3WvuSbE4AAAHfYytQvJQABAG6wtalfSgACAFxpi1O/lAAEALjQlqd+KQEIAHCBLRzvcikBCADwgRh+W5/6pQQgAECPuNy75Wf9hghAAIBM0zS7We7tIwABAP6z56lfSgACAIT9T/1SAhAAKFpVVaFt211t8viMAAQAitW27e6Xe/sIQACgOHs82uUaAhAAKEo+9YsR2HXdUl/S7AQgAFCEfJNHqdO/EAQgALBz+XJvyeEXCUAAYLfSM/2E3/8EIACwK13XvVnuFX7vCUAAYDfS5V7hN0wAAgCbF69wK+Umj3sJQABgs9K7e038LicAAYBNiuFX4k0e9xKAAMCmxLt7hd/tBCAAsAnCbzwCEABYvaZpQtvKlrH4nQQAVivu7LXBY1wCEABYnbquQ9u2wm8iAhAAWA3hNw8BCAAszgaPeQlAAGAxVVWFh4cHE7+ZCUAAYHYmfssSgADAbITfOghAAGBydV2fj3RheQIQAJhMvKvXWX7rIgABgNEJv3UTgADAaKqqcnvHBghAAOBucdpX17Xw2wABCADcTPhtkwAEAK5SVdX5OJf4c7ZFAAIAF0nDzzl+2yYAAYAPpeEXz/Hrum7hr4p7CEAAoFcMPwc4748ABADesNS7fwIQADhv5KjrWvgVQAACQMFi+MVlXuFXBgEIAAXKn+9zlEtZBCAAFCJd5nV4c9kEIADsXJz22dFLJAABYKdi9KUTPwhBAALArqRXs8XoE37kBCAA7EC6zBsnfp7vY4gABIANS8PP+X1cSgACwMbk0762bU37uIoABICN6Jv2CT9uIQABYMX6NnU4xoV7CUAAWKG+s/tM+xiLAASAlcif7TPtYyoCEAAWlC7xptFn2seUBCAALCCd9qVn98EcBCAAzCQNvhCCaR+LEYAAMKG+6HM9G0sTgAAwsrikm0720nP7uq5b8KsDAQgAo4nhl/48nt0HayIAAeAOQ8/1uaWDNROAAHClPPriYc2e7WMrBCAAXGAo+uziZYsEIAAMMOljrwQgACTy6AshnKPPQc3shQAEoHh90VfXdWjb9t3HYQ8EIABFSq9gGzqvD/ZKAAJQjDz4uq47P89nMwclEYAA7FrflC+NPiiRAARgdz6LvvTjrmWjRAIQgM1LN3Hk0edWDnhPAAKwSekmjvRj6ZRP9EE/AQjAZsRJXh52zumD6whAAFYrX9qN4Ref53MjB9xGAAKwKukGjnTSV1WVM/pgJAIQgEXld+3mP3dGH4xPAAIwu74pX3oo89CzfsA4BCAAkxta1g0hvIs+YHoCEIDRDd2zG8LwBg4HMsN8BCAAd0t36fbtyo3HtJjywToIQABuEmNu6CiWpmls3oCVEoAAXOSj5/jix9zAAdsgAAHolQZfPuFLl3xN+WB7BCAAIYT3E778EOY0BgUfbJsABChUumnjs926wL4IQICCpLdqpGGX37qRcjwL7I8ABNixvp26+a8t6UJ5BCDATgw9p5du1kgjECiXAATYqDz2YtSlv47RZxkXSLXpG0PXdaGqKm8UACuTX60W37vzjRyWc4FLtCGEN8sE8ceu696EIQDzyXfnpu/PYg+41+AScN9J7qIQYBpp1KVhF3fkOmwZGNNVzwDmUSgGAa7XN8WLP6ZXqcX3W++xwNju2gSSLx2HIAoBUvlze0PRBzCn0XcB58sW0d+/f0MIwhDYv/xQ5aE7deNjNafTacGvtl9J79WlfK+lfJ8hlPW93uofobzfbYnRxloAAAAASUVORK5CYII="};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/playback.js
@@ -0,0 +1,102 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2012 Joel Martin
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ */
+
+"use strict";
+/*jslint browser: true, white: false */
+/*global Util, VNC_frame_data, finish */
+
+var rfb, mode, test_state, frame_idx, frame_length,
+    iteration, iterations, istart_time,
+
+    // Pre-declarations for jslint
+    send_array, next_iteration, queue_next_packet, do_packet;
+
+// Override send_array
+send_array = function (arr) {
+    // Stub out send_array
+};
+
+next_iteration = function () {
+    if (iteration === 0) {
+        frame_length = VNC_frame_data.length;
+        test_state = 'running';
+    } else {
+        rfb.disconnect();
+    }
+    
+    if (test_state !== 'running') { return; }
+
+    iteration += 1;
+    if (iteration > iterations) {
+        finish();
+        return;
+    }
+
+    frame_idx = 0;
+    istart_time = (new Date()).getTime();
+    rfb.connect('test', 0, "bogus");
+
+    queue_next_packet();
+
+};
+
+queue_next_packet = function () {
+    var frame, foffset, toffset, delay;
+    if (test_state !== 'running') { return; }
+
+    frame = VNC_frame_data[frame_idx];
+    while ((frame_idx < frame_length) && (frame.charAt(0) === "}")) {
+        //Util.Debug("Send frame " + frame_idx);
+        frame_idx += 1;
+        frame = VNC_frame_data[frame_idx];
+    }
+
+    if (frame === 'EOF') {
+        Util.Debug("Finished, found EOF");
+        next_iteration();
+        return;
+    }
+    if (frame_idx >= frame_length) {
+        Util.Debug("Finished, no more frames");
+        next_iteration();
+        return;
+    }
+
+    if (mode === 'realtime') {
+        foffset = frame.slice(1, frame.indexOf('{', 1));
+        toffset = (new Date()).getTime() - istart_time;
+        delay = foffset - toffset;
+        if (delay < 1) {
+            delay = 1;
+        }
+
+        setTimeout(do_packet, delay);
+    } else {
+        setTimeout(do_packet, 1);
+    }
+};
+
+var bytes_processed = 0;
+
+do_packet = function () {
+    //Util.Debug("Processing frame: " + frame_idx);
+    var frame = VNC_frame_data[frame_idx],
+        start = frame.indexOf('{', 1) + 1;
+    bytes_processed += frame.length - start;
+    if (VNC_frame_encoding === 'binary') {
+        var u8 = new Uint8Array(frame.length - start);
+        for (var i = 0; i < frame.length - start; i++) {
+            u8[i] = frame.charCodeAt(start + i);
+        }
+        rfb.recv_message({'data' : u8});
+    } else {
+        rfb.recv_message({'data' : frame.slice(start)});
+    }
+    frame_idx += 1;
+
+    queue_next_packet();
+};
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/rfb.js
@@ -0,0 +1,1882 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2012 Joel Martin
+ * Copyright (C) 2013 Samuel Mannehed for Cendio AB
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ *
+ * TIGHT decoder portion:
+ * (c) 2012 Michael Tinglof, Joe Balaz, Les Piech (Mercuri.ca)
+ */
+
+/*jslint white: false, browser: true */
+/*global window, Util, Display, Keyboard, Mouse, Websock, Websock_native, Base64, DES */
+
+var RFB;
+
+(function () {
+    "use strict";
+    RFB = function (defaults) {
+        if (!defaults) {
+            defaults = {};
+        }
+
+        this._rfb_host = '';
+        this._rfb_port = 5900;
+        this._rfb_password = '';
+        this._rfb_path = '';
+
+        this._rfb_state = 'disconnected';
+        this._rfb_version = 0;
+        this._rfb_max_version = 3.8;
+        this._rfb_auth_scheme = '';
+
+        this._rfb_tightvnc = false;
+        this._rfb_xvp_ver = 0;
+
+        // In preference order
+        this._encodings = [
+            ['COPYRECT',         0x01 ],
+            ['TIGHT',            0x07 ],
+            ['TIGHT_PNG',        -260 ],
+            ['HEXTILE',          0x05 ],
+            ['RRE',              0x02 ],
+            ['RAW',              0x00 ],
+            ['DesktopSize',      -223 ],
+            ['Cursor',           -239 ],
+
+            // Psuedo-encoding settings
+            //['JPEG_quality_lo',   -32 ],
+            ['JPEG_quality_med',    -26 ],
+            //['JPEG_quality_hi',   -23 ],
+            //['compress_lo',      -255 ],
+            ['compress_hi',        -247 ],
+            ['last_rect',          -224 ],
+            ['xvp',                -309 ]
+        ];
+
+        this._encHandlers = {};
+        this._encNames = {};
+        this._encStats = {};
+
+        this._sock = null;              // Websock object
+        this._display = null;           // Display object
+        this._keyboard = null;          // Keyboard input handler object
+        this._mouse = null;             // Mouse input handler object
+        this._sendTimer = null;         // Send Queue check timer
+        this._disconnTimer = null;      // disconnection timer
+        this._msgTimer = null;          // queued handle_msg timer
+
+        // Frame buffer update state
+        this._FBU = {
+            rects: 0,
+            subrects: 0,            // RRE
+            lines: 0,               // RAW
+            tiles: 0,               // HEXTILE
+            bytes: 0,
+            x: 0,
+            y: 0,
+            width: 0,
+            height: 0,
+            encoding: 0,
+            subencoding: -1,
+            background: null,
+            zlib: []                // TIGHT zlib streams
+        };
+
+        this._fb_Bpp = 4;
+        this._fb_depth = 3;
+        this._fb_width = 0;
+        this._fb_height = 0;
+        this._fb_name = "";
+
+        this._rre_chunk_sz = 100;
+
+        this._timing = {
+            last_fbu: 0,
+            fbu_total: 0,
+            fbu_total_cnt: 0,
+            full_fbu_total: 0,
+            full_fbu_cnt: 0,
+
+            fbu_rt_start: 0,
+            fbu_rt_total: 0,
+            fbu_rt_cnt: 0,
+            pixels: 0
+        };
+
+        // Mouse state
+        this._mouse_buttonMask = 0;
+        this._mouse_arr = [];
+        this._viewportDragging = false;
+        this._viewportDragPos = {};
+
+        // set the default value on user-facing properties
+        Util.set_defaults(this, defaults, {
+            'target': 'null',                       // VNC display rendering Canvas object
+            'focusContainer': document,             // DOM element that captures keyboard input
+            'encrypt': false,                       // Use TLS/SSL/wss encryption
+            'true_color': true,                     // Request true color pixel data
+            'local_cursor': false,                  // Request locally rendered cursor
+            'shared': true,                         // Request shared mode
+            'view_only': false,                     // Disable client mouse/keyboard
+            'xvp_password_sep': '@',                // Separator for XVP password fields
+            'disconnectTimeout': 3,                 // Time (s) to wait for disconnection
+            'wsProtocols': ['binary', 'base64'],    // Protocols to use in the WebSocket connection
+            'repeaterID': '',                       // [UltraVNC] RepeaterID to connect to
+            'viewportDrag': false,                  // Move the viewport on mouse drags
+
+            // Callback functions
+            'onUpdateState': function () { },       // onUpdateState(rfb, state, oldstate, statusMsg): state update/change
+            'onPasswordRequired': function () { },  // onPasswordRequired(rfb): VNC password is required
+            'onClipboard': function () { },         // onClipboard(rfb, text): RFB clipboard contents received
+            'onBell': function () { },              // onBell(rfb): RFB Bell message received
+            'onFBUReceive': function () { },        // onFBUReceive(rfb, fbu): RFB FBU received but not yet processed
+            'onFBUComplete': function () { },       // onFBUComplete(rfb, fbu): RFB FBU received and processed
+            'onFBResize': function () { },          // onFBResize(rfb, width, height): frame buffer resized
+            'onDesktopName': function () { },       // onDesktopName(rfb, name): desktop name received
+            'onXvpInit': function () { },           // onXvpInit(version): XVP extensions active for this connection
+        });
+
+        // main setup
+        Util.Debug(">> RFB.constructor");
+
+        // populate encHandlers with bound versions
+        Object.keys(RFB.encodingHandlers).forEach(function (encName) {
+            this._encHandlers[encName] = RFB.encodingHandlers[encName].bind(this);
+        }.bind(this));
+
+        // Create lookup tables based on encoding number
+        for (var i = 0; i < this._encodings.length; i++) {
+            this._encHandlers[this._encodings[i][1]] = this._encHandlers[this._encodings[i][0]];
+            this._encNames[this._encodings[i][1]] = this._encodings[i][0];
+            this._encStats[this._encodings[i][1]] = [0, 0];
+        }
+
+        try {
+            this._display = new Display({target: this._target});
+        } catch (exc) {
+            Util.Error("Display exception: " + exc);
+            this._updateState('fatal', "No working Display");
+        }
+
+        this._keyboard = new Keyboard({target: this._focusContainer,
+                                       onKeyPress: this._handleKeyPress.bind(this)});
+
+        this._mouse = new Mouse({target: this._target,
+                                 onMouseButton: this._handleMouseButton.bind(this),
+                                 onMouseMove: this._handleMouseMove.bind(this),
+                                 notify: this._keyboard.sync.bind(this._keyboard)});
+
+        this._sock = new Websock();
+        this._sock.on('message', this._handle_message.bind(this));
+        this._sock.on('open', function () {
+            if (this._rfb_state === 'connect') {
+                this._updateState('ProtocolVersion', "Starting VNC handshake");
+            } else {
+                this._fail("Got unexpected WebSocket connection");
+            }
+        }.bind(this));
+        this._sock.on('close', function (e) {
+            Util.Warn("WebSocket on-close event");
+            var msg = "";
+            if (e.code) {
+                msg = " (code: " + e.code;
+                if (e.reason) {
+                    msg += ", reason: " + e.reason;
+                }
+                msg += ")";
+            }
+            if (this._rfb_state === 'disconnect') {
+                this._updateState('disconnected', 'VNC disconnected' + msg);
+            } else if (this._rfb_state === 'ProtocolVersion') {
+                this._fail('Failed to connect to server' + msg);
+            } else if (this._rfb_state in {'failed': 1, 'disconnected': 1}) {
+                Util.Error("Received onclose while disconnected" + msg);
+            } else {
+                this._fail("Server disconnected" + msg);
+            }
+        }.bind(this));
+        this._sock.on('error', function (e) {
+            Util.Warn("WebSocket on-error event");
+        });
+
+        this._init_vars();
+
+        var rmode = this._display.get_render_mode();
+        if (Websock_native) {
+            Util.Info("Using native WebSockets");
+            this._updateState('loaded', 'noVNC ready: native WebSockets, ' + rmode);
+        } else {
+            Util.Warn("Using web-socket-js bridge.  Flash version: " + Util.Flash.version);
+            if (!Util.Flash || Util.Flash.version < 9) {
+                this._updateState('fatal', "WebSockets or <a href='http://get.adobe.com/flashplayer'>Adobe Flash</a> is required");
+            } else if (document.location.href.substr(0, 7) === 'file://') {
+                this._updateState('fatal', "'file://' URL is incompatible with Adobe Flash");
+            } else {
+                this._updateState('loaded', 'noVNC ready: WebSockets emulation, ' + rmode);
+            }
+        }
+
+        Util.Debug("<< RFB.constructor");
+    };
+
+    RFB.prototype = {
+        // Public methods
+        connect: function (host, port, password, path) {
+            this._rfb_host = host;
+            this._rfb_port = port;
+            this._rfb_password = (password !== undefined) ? password : "";
+            this._rfb_path = (path !== undefined) ? path : "";
+
+            if (!this._rfb_host || !this._rfb_port) {
+                return this._fail("Must set host and port");
+            }
+
+            this._updateState('connect');
+        },
+
+        disconnect: function () {
+            this._updateState('disconnect', 'Disconnecting');
+        },
+
+        sendPassword: function (passwd) {
+            this._rfb_password = passwd;
+            this._rfb_state = 'Authentication';
+            setTimeout(this._init_msg.bind(this), 1);
+        },
+
+        sendCtrlAltDel: function () {
+            if (this._rfb_state !== 'normal' || this._view_only) { return false; }
+            Util.Info("Sending Ctrl-Alt-Del");
+
+            var arr = [];
+            arr = arr.concat(RFB.messages.keyEvent(XK_Control_L, 1));
+            arr = arr.concat(RFB.messages.keyEvent(XK_Alt_L, 1));
+            arr = arr.concat(RFB.messages.keyEvent(XK_Delete, 1));
+            arr = arr.concat(RFB.messages.keyEvent(XK_Delete, 0));
+            arr = arr.concat(RFB.messages.keyEvent(XK_Alt_L, 0));
+            arr = arr.concat(RFB.messages.keyEvent(XK_Control_L, 0));
+            this._sock.send(arr);
+        },
+
+        xvpOp: function (ver, op) {
+            if (this._rfb_xvp_ver < ver) { return false; }
+            Util.Info("Sending XVP operation " + op + " (version " + ver + ")");
+            this._sock.send_string("\xFA\x00" + String.fromCharCode(ver) + String.fromCharCode(op));
+            return true;
+        },
+
+        xvpShutdown: function () {
+            return this.xvpOp(1, 2);
+        },
+
+        xvpReboot: function () {
+            return this.xvpOp(1, 3);
+        },
+
+        xvpReset: function () {
+            return this.xvpOp(1, 4);
+        },
+
+        // Send a key press. If 'down' is not specified then send a down key
+        // followed by an up key.
+        sendKey: function (code, down) {
+            if (this._rfb_state !== "normal" || this._view_only) { return false; }
+            var arr = [];
+            if (typeof down !== 'undefined') {
+                Util.Info("Sending key code (" + (down ? "down" : "up") + "): " + code);
+                arr = arr.concat(RFB.messages.keyEvent(code, down ? 1 : 0));
+            } else {
+                Util.Info("Sending key code (down + up): " + code);
+                arr = arr.concat(RFB.messages.keyEvent(code, 1));
+                arr = arr.concat(RFB.messages.keyEvent(code, 0));
+            }
+            this._sock.send(arr);
+        },
+
+        clipboardPasteFrom: function (text) {
+            if (this._rfb_state !== 'normal') { return; }
+            this._sock.send(RFB.messages.clientCutText(text));
+        },
+
+        // Private methods
+
+        _connect: function () {
+            Util.Debug(">> RFB.connect");
+
+            var uri;
+            if (typeof UsingSocketIO !== 'undefined') {
+                uri = 'http';
+            } else {
+                uri = this._encrypt ? 'wss' : 'ws';
+            }
+
+            uri += '://' + this._rfb_host + ':' + this._rfb_port + '/' + this._rfb_path;
+            Util.Info("connecting to " + uri);
+
+            this._sock.open(uri, this._wsProtocols);
+
+            Util.Debug("<< RFB.connect");
+        },
+
+        _init_vars: function () {
+            // reset state
+            this._sock.init();
+
+            this._FBU.rects        = 0;
+            this._FBU.subrects     = 0;  // RRE and HEXTILE
+            this._FBU.lines        = 0;  // RAW
+            this._FBU.tiles        = 0;  // HEXTILE
+            this._FBU.zlibs        = []; // TIGHT zlib encoders
+            this._mouse_buttonMask = 0;
+            this._mouse_arr        = [];
+            this._rfb_tightvnc     = false;
+
+            // Clear the per connection encoding stats
+            var i;
+            for (i = 0; i < this._encodings.length; i++) {
+                this._encStats[this._encodings[i][1]][0] = 0;
+            }
+
+            for (i = 0; i < 4; i++) {
+                this._FBU.zlibs[i] = new TINF();
+                this._FBU.zlibs[i].init();
+            }
+        },
+
+        _print_stats: function () {
+            Util.Info("Encoding stats for this connection:");
+            var i, s;
+            for (i = 0; i < this._encodings.length; i++) {
+                s = this._encStats[this._encodings[i][1]];
+                if (s[0] + s[1] > 0) {
+                    Util.Info("    " + this._encodings[i][0] + ": " + s[0] + " rects");
+                }
+            }
+
+            Util.Info("Encoding stats since page load:");
+            for (i = 0; i < this._encodings.length; i++) {
+                s = this._encStats[this._encodings[i][1]];
+                Util.Info("    " + this._encodings[i][0] + ": " + s[1] + " rects");
+            }
+        },
+
+
+        /*
+         * Page states:
+         *   loaded       - page load, equivalent to disconnected
+         *   disconnected - idle state
+         *   connect      - starting to connect (to ProtocolVersion)
+         *   normal       - connected
+         *   disconnect   - starting to disconnect
+         *   failed       - abnormal disconnect
+         *   fatal        - failed to load page, or fatal error
+         *
+         * RFB protocol initialization states:
+         *   ProtocolVersion
+         *   Security
+         *   Authentication
+         *   password     - waiting for password, not part of RFB
+         *   SecurityResult
+         *   ClientInitialization - not triggered by server message
+         *   ServerInitialization (to normal)
+         */
+        _updateState: function (state, statusMsg) {
+            var oldstate = this._rfb_state;
+
+            if (state === oldstate) {
+                // Already here, ignore
+                Util.Debug("Already in state '" + state + "', ignoring");
+            }
+
+            /*
+             * These are disconnected states. A previous connect may
+             * asynchronously cause a connection so make sure we are closed.
+             */
+            if (state in {'disconnected': 1, 'loaded': 1, 'connect': 1,
+                          'disconnect': 1, 'failed': 1, 'fatal': 1}) {
+
+                if (this._sendTimer) {
+                    clearInterval(this._sendTimer);
+                    this._sendTimer = null;
+                }
+
+                if (this._msgTimer) {
+                    clearInterval(this._msgTimer);
+                    this._msgTimer = null;
+                }
+
+                if (this._display && this._display.get_context()) {
+                    this._keyboard.ungrab();
+                    this._mouse.ungrab();
+                    this._display.defaultCursor();
+                    if (Util.get_logging() !== 'debug' || state === 'loaded') {
+                        // Show noVNC logo on load and when disconnected, unless in
+                        // debug mode
+                        this._display.clear();
+                    }
+                }
+
+                this._sock.close();
+            }
+
+            if (oldstate === 'fatal') {
+                Util.Error('Fatal error, cannot continue');
+            }
+
+            var cmsg = typeof(statusMsg) !== 'undefined' ? (" Msg: " + statusMsg) : "";
+            var fullmsg = "New state '" + state + "', was '" + oldstate + "'." + cmsg;
+            if (state === 'failed' || state === 'fatal') {
+                Util.Error(cmsg);
+            } else {
+                Util.Warn(cmsg);
+            }
+
+            if (oldstate === 'failed' && state === 'disconnected') {
+                // do disconnect action, but stay in failed state
+                this._rfb_state = 'failed';
+            } else {
+                this._rfb_state = state;
+            }
+
+            if (this._disconnTimer && this._rfb_state !== 'disconnect') {
+                Util.Debug("Clearing disconnect timer");
+                clearTimeout(this._disconnTimer);
+                this._disconnTimer = null;
+            }
+
+            switch (state) {
+                case 'normal':
+                    if (oldstate === 'disconnected' || oldstate === 'failed') {
+                        Util.Error("Invalid transition from 'disconnected' or 'failed' to 'normal'");
+                    }
+                    break;
+
+                case 'connect':
+                    this._init_vars();
+                    this._connect();
+                    // WebSocket.onopen transitions to 'ProtocolVersion'
+                    break;
+
+                case 'disconnect':
+                    this._disconnTimer = setTimeout(function () {
+                        this._fail("Disconnect timeout");
+                    }.bind(this), this._disconnectTimeout * 1000);
+
+                    this._print_stats();
+
+                    // WebSocket.onclose transitions to 'disconnected'
+                    break;
+
+                case 'failed':
+                    if (oldstate === 'disconnected') {
+                        Util.Error("Invalid transition from 'disconnected' to 'failed'");
+                    } else if (oldstate === 'normal') {
+                        Util.Error("Error while connected.");
+                    } else if (oldstate === 'init') {
+                        Util.Error("Error while initializing.");
+                    }
+
+                    // Make sure we transition to disconnected
+                    setTimeout(function () {
+                        this._updateState('disconnected');
+                    }.bind(this), 50);
+
+                    break;
+
+                default:
+                    // No state change action to take
+            }
+
+            if (oldstate === 'failed' && state === 'disconnected') {
+                this._onUpdateState(this, state, oldstate);
+            } else {
+                this._onUpdateState(this, state, oldstate, statusMsg);
+            }
+        },
+
+        _fail: function (msg) {
+            this._updateState('failed', msg);
+            return false;
+        },
+
+        _handle_message: function () {
+            if (this._sock.rQlen() === 0) {
+                Util.Warn("handle_message called on an empty receive queue");
+                return;
+            }
+
+            switch (this._rfb_state) {
+                case 'disconnected':
+                case 'failed':
+                    Util.Error("Got data while disconnected");
+                    break;
+                case 'normal':
+                    if (this._normal_msg() && this._sock.rQlen() > 0) {
+                        // true means we can continue processing
+                        // Give other events a chance to run
+                        if (this._msgTimer === null) {
+                            Util.Debug("More data to process, creating timer");
+                            this._msgTimer = setTimeout(function () {
+                                this._msgTimer = null;
+                                this._handle_message();
+                            }.bind(this), 10);
+                        } else {
+                            Util.Debug("More data to process, existing timer");
+                        }
+                    }
+                    break;
+                default:
+                    this._init_msg();
+                    break;
+            }
+        },
+
+        _checkEvents: function () {
+            if (this._rfb_state === 'normal' && !this._viewportDragging && this._mouse_arr.length > 0) {
+                this._sock.send(this._mouse_arr);
+                this._mouse_arr = [];
+            }
+        },
+
+        _handleKeyPress: function (keysym, down) {
+            if (this._view_only) { return; } // View only, skip keyboard, events
+            this._sock.send(RFB.messages.keyEvent(keysym, down));
+        },
+
+        _handleMouseButton: function (x, y, down, bmask) {
+            if (down) {
+                this._mouse_buttonMask |= bmask;
+            } else {
+                this._mouse_buttonMask ^= bmask;
+            }
+
+            if (this._viewportDrag) {
+                if (down && !this._viewportDragging) {
+                    this._viewportDragging = true;
+                    this._viewportDragPos = {'x': x, 'y': y};
+
+                    // Skip sending mouse events
+                    return;
+                } else {
+                    this._viewportDragging = false;
+                }
+            }
+
+            if (this._view_only) { return; } // View only, skip mouse events
+
+            this._mouse_arr = this._mouse_arr.concat(
+                    RFB.messages.pointerEvent(this._display.absX(x), this._display.absY(y), this._mouse_buttonMask));
+            this._sock.send(this._mouse_arr);
+            this._mouse_arr = [];
+        },
+
+        _handleMouseMove: function (x, y) {
+            if (this._viewportDragging) {
+                var deltaX = this._viewportDragPos.x - x;
+                var deltaY = this._viewportDragPos.y - y;
+                this._viewportDragPos = {'x': x, 'y': y};
+
+                this._display.viewportChange(deltaX, deltaY);
+
+                // Skip sending mouse events
+                return;
+            }
+
+            if (this._view_only) { return; } // View only, skip mouse events
+
+            this._mouse_arr = this._mouse_arr.concat(
+                    RFB.messages.pointerEvent(this._display.absX(x), this._display.absY(y), this._mouse_buttonMask));
+
+            this._checkEvents();
+        },
+
+        // Message Handlers
+
+        _negotiate_protocol_version: function () {
+            if (this._sock.rQlen() < 12) {
+                return this._fail("Incomplete protocol version");
+            }
+
+            var sversion = this._sock.rQshiftStr(12).substr(4, 7);
+            Util.Info("Server ProtocolVersion: " + sversion);
+            var is_repeater = 0;
+            switch (sversion) {
+                case "000.000":  // UltraVNC repeater
+                    is_repeater = 1;
+                    break;
+                case "003.003":
+                case "003.006":  // UltraVNC
+                case "003.889":  // Apple Remote Desktop
+                    this._rfb_version = 3.3;
+                    break;
+                case "003.007":
+                    this._rfb_version = 3.7;
+                    break;
+                case "003.008":
+                case "004.000":  // Intel AMT KVM
+                case "004.001":  // RealVNC 4.6
+                    this._rfb_version = 3.8;
+                    break;
+                default:
+                    return this._fail("Invalid server version " + sversion);
+            }
+
+            if (is_repeater) {
+                var repeaterID = this._repeaterID;
+                while (repeaterID.length < 250) {
+                    repeaterID += "\0";
+                }
+                this._sock.send_string(repeaterID);
+                return true;
+            }
+
+            if (this._rfb_version > this._rfb_max_version) {
+                this._rfb_version = this._rfb_max_version;
+            }
+
+            // Send updates either at a rate of 1 update per 50ms, or
+            // whatever slower rate the network can handle
+            this._sendTimer = setInterval(this._sock.flush.bind(this._sock), 50);
+
+            var cversion = "00" + parseInt(this._rfb_version, 10) +
+                           ".00" + ((this._rfb_version * 10) % 10);
+            this._sock.send_string("RFB " + cversion + "\n");
+            this._updateState('Security', 'Sent ProtocolVersion: ' + cversion);
+        },
+
+        _negotiate_security: function () {
+            if (this._rfb_version >= 3.7) {
+                // Server sends supported list, client decides
+                var num_types = this._sock.rQshift8();
+                if (this._sock.rQwait("security type", num_types, 1)) { return false; }
+
+                if (num_types === 0) {
+                    var strlen = this._sock.rQshift32();
+                    var reason = this._sock.rQshiftStr(strlen);
+                    return this._fail("Security failure: " + reason);
+                }
+
+                this._rfb_auth_scheme = 0;
+                var types = this._sock.rQshiftBytes(num_types);
+                Util.Debug("Server security types: " + types);
+                for (var i = 0; i < types.length; i++) {
+                    if (types[i] > this._rfb_auth_scheme && (types[i] <= 16 || types[i] == 22)) {
+                        this._rfb_auth_scheme = types[i];
+                    }
+                }
+
+                if (this._rfb_auth_scheme === 0) {
+                    return this._fail("Unsupported security types: " + types);
+                }
+
+                this._sock.send([this._rfb_auth_scheme]);
+            } else {
+                // Server decides
+                if (this._sock.rQwait("security scheme", 4)) { return false; }
+                this._rfb_auth_scheme = this._sock.rQshift32();
+            }
+
+            this._updateState('Authentication', 'Authenticating using scheme: ' + this._rfb_auth_scheme);
+            return this._init_msg(); // jump to authentication
+        },
+
+        // authentication
+        _negotiate_xvp_auth: function () {
+            var xvp_sep = this._xvp_password_sep;
+            var xvp_auth = this._rfb_password.split(xvp_sep);
+            if (xvp_auth.length < 3) {
+                this._updateState('password', 'XVP credentials required (user' + xvp_sep +
+                                  'target' + xvp_sep + 'password) -- got only ' + this._rfb_password);
+                this._onPasswordRequired(this);
+                return false;
+            }
+
+            var xvp_auth_str = String.fromCharCode(xvp_auth[0].length) +
+                               String.fromCharCode(xvp_auth[1].length) +
+                               xvp_auth[0] +
+                               xvp_auth[1];
+            this._sock.send_string(xvp_auth_str);
+            this._rfb_password = xvp_auth.slice(2).join(xvp_sep);
+            this._rfb_auth_scheme = 2;
+            return this._negotiate_authentication();
+        },
+
+        _negotiate_std_vnc_auth: function () {
+            if (this._rfb_password.length === 0) {
+                // Notify via both callbacks since it's kind of
+                // an RFB state change and a UI interface issue
+                this._updateState('password', "Password Required");
+                this._onPasswordRequired(this);
+            }
+
+            if (this._sock.rQwait("auth challenge", 16)) { return false; }
+
+            var challenge = this._sock.rQshiftBytes(16);
+            var response = RFB.genDES(this._rfb_password, challenge);
+            this._sock.send(response);
+            this._updateState("SecurityResult");
+            return true;
+        },
+
+        _negotiate_tight_tunnels: function (numTunnels) {
+            var clientSupportedTunnelTypes = {
+                0: { vendor: 'TGHT', signature: 'NOTUNNEL' }
+            };
+            var serverSupportedTunnelTypes = {};
+            // receive tunnel capabilities
+            for (var i = 0; i < numTunnels; i++) {
+                var cap_code = this._sock.rQshift32();
+                var cap_vendor = this._sock.rQshiftStr(4);
+                var cap_signature = this._sock.rQshiftStr(8);
+                serverSupportedTunnelTypes[cap_code] = { vendor: cap_vendor, signature: cap_signature };
+            }
+
+            // choose the notunnel type
+            if (serverSupportedTunnelTypes[0]) {
+                if (serverSupportedTunnelTypes[0].vendor != clientSupportedTunnelTypes[0].vendor ||
+                    serverSupportedTunnelTypes[0].signature != clientSupportedTunnelTypes[0].signature) {
+                    return this._fail("Client's tunnel type had the incorrect vendor or signature");
+                }
+                this._sock.send([0, 0, 0, 0]);  // use NOTUNNEL
+                return false; // wait until we receive the sub auth count to continue
+            } else {
+                return this._fail("Server wanted tunnels, but doesn't support the notunnel type");
+            }
+        },
+
+        _negotiate_tight_auth: function () {
+            if (!this._rfb_tightvnc) {  // first pass, do the tunnel negotiation
+                if (this._sock.rQwait("num tunnels", 4)) { return false; }
+                var numTunnels = this._sock.rQshift32();
+                if (numTunnels > 0 && this._sock.rQwait("tunnel capabilities", 16 * numTunnels, 4)) { return false; }
+
+                this._rfb_tightvnc = true;
+
+                if (numTunnels > 0) {
+                    this._negotiate_tight_tunnels(numTunnels);
+                    return false;  // wait until we receive the sub auth to continue
+                }
+            }
+
+            // second pass, do the sub-auth negotiation
+            if (this._sock.rQwait("sub auth count", 4)) { return false; }
+            var subAuthCount = this._sock.rQshift32();
+            if (this._sock.rQwait("sub auth capabilities", 16 * subAuthCount, 4)) { return false; }
+
+            var clientSupportedTypes = {
+                'STDVNOAUTH__': 1,
+                'STDVVNCAUTH_': 2
+            };
+
+            var serverSupportedTypes = [];
+
+            for (var i = 0; i < subAuthCount; i++) {
+                var capNum = this._sock.rQshift32();
+                var capabilities = this._sock.rQshiftStr(12);
+                serverSupportedTypes.push(capabilities);
+            }
+
+            for (var authType in clientSupportedTypes) {
+                if (serverSupportedTypes.indexOf(authType) != -1) {
+                    this._sock.send([0, 0, 0, clientSupportedTypes[authType]]);
+
+                    switch (authType) {
+                        case 'STDVNOAUTH__':  // no auth
+                            this._updateState('SecurityResult');
+                            return true;
+                        case 'STDVVNCAUTH_': // VNC auth
+                            this._rfb_auth_scheme = 2;
+                            return this._init_msg();
+                        default:
+                            return this._fail("Unsupported tiny auth scheme: " + authType);
+                    }
+                }
+            }
+
+            this._fail("No supported sub-auth types!");
+        },
+
+        _negotiate_authentication: function () {
+            switch (this._rfb_auth_scheme) {
+                case 0:  // connection failed
+                    if (this._sock.rQwait("auth reason", 4)) { return false; }
+                    var strlen = this._sock.rQshift32();
+                    var reason = this._sock.rQshiftStr(strlen);
+                    return this._fail("Auth failure: " + reason);
+
+                case 1:  // no auth
+                    if (this._rfb_version >= 3.8) {
+                        this._updateState('SecurityResult');
+                        return true;
+                    }
+                    this._updateState('ClientInitialisation', "No auth required");
+                    return this._init_msg();
+
+                case 22:  // XVP auth
+                    return this._negotiate_xvp_auth();
+
+                case 2:  // VNC authentication
+                    return this._negotiate_std_vnc_auth();
+
+                case 16:  // TightVNC Security Type
+                    return this._negotiate_tight_auth();
+
+                default:
+                    return this._fail("Unsupported auth scheme: " + this._rfb_auth_scheme);
+            }
+        },
+
+        _handle_security_result: function () {
+            if (this._sock.rQwait('VNC auth response ', 4)) { return false; }
+            switch (this._sock.rQshift32()) {
+                case 0:  // OK
+                    this._updateState('ClientInitialisation', 'Authentication OK');
+                    return this._init_msg();
+                case 1:  // failed
+                    if (this._rfb_version >= 3.8) {
+                        var length = this._sock.rQshift32();
+                        if (this._sock.rQwait("SecurityResult reason", length, 8)) { return false; }
+                        var reason = this._sock.rQshiftStr(length);
+                        return this._fail(reason);
+                    } else {
+                        return this._fail("Authentication failure");
+                    }
+                    return false;
+                case 2:
+                    return this._fail("Too many auth attempts");
+            }
+        },
+
+        _negotiate_server_init: function () {
+            if (this._sock.rQwait("server initialization", 24)) { return false; }
+
+            /* Screen size */
+            this._fb_width  = this._sock.rQshift16();
+            this._fb_height = this._sock.rQshift16();
+
+            /* PIXEL_FORMAT */
+            var bpp         = this._sock.rQshift8();
+            var depth       = this._sock.rQshift8();
+            var big_endian  = this._sock.rQshift8();
+            var true_color  = this._sock.rQshift8();
+
+            var red_max     = this._sock.rQshift16();
+            var green_max   = this._sock.rQshift16();
+            var blue_max    = this._sock.rQshift16();
+            var red_shift   = this._sock.rQshift8();
+            var green_shift = this._sock.rQshift8();
+            var blue_shift  = this._sock.rQshift8();
+            this._sock.rQskipBytes(3);  // padding
+
+            // NB(directxman12): we don't want to call any callbacks or print messages until
+            //                   *after* we're past the point where we could backtrack
+
+            /* Connection name/title */
+            var name_length = this._sock.rQshift32();
+            if (this._sock.rQwait('server init name', name_length, 24)) { return false; }
+            this._fb_name = Util.decodeUTF8(this._sock.rQshiftStr(name_length));
+
+            if (this._rfb_tightvnc) {
+                if (this._sock.rQwait('TightVNC extended server init header', 8, 24 + name_length)) { return false; }
+                // In TightVNC mode, ServerInit message is extended
+                var numServerMessages = this._sock.rQshift16();
+                var numClientMessages = this._sock.rQshift16();
+                var numEncodings = this._sock.rQshift16();
+                this._sock.rQskipBytes(2);  // padding
+
+                var totalMessagesLength = (numServerMessages + numClientMessages + numEncodings) * 16;
+                if (this._sock.rQwait('TightVNC extended server init header', totalMessagesLength, 32 + name_length)) { return false; }
+
+                var i;
+                for (i = 0; i < numServerMessages; i++) {
+                    var srvMsg = this._sock.rQshiftStr(16);
+                }
+
+                for (i = 0; i < numClientMessages; i++) {
+                    var clientMsg = this._sock.rQshiftStr(16);
+                }
+
+                for (i = 0; i < numEncodings; i++) {
+                    var encoding = this._sock.rQshiftStr(16);
+                }
+            }
+
+            // NB(directxman12): these are down here so that we don't run them multiple times
+            //                   if we backtrack
+            Util.Info("Screen: " + this._fb_width + "x" + this._fb_height +
+                      ", bpp: " + bpp + ", depth: " + depth +
+                      ", big_endian: " + big_endian +
+                      ", true_color: " + true_color +
+                      ", red_max: " + red_max +
+                      ", green_max: " + green_max +
+                      ", blue_max: " + blue_max +
+                      ", red_shift: " + red_shift +
+                      ", green_shift: " + green_shift +
+                      ", blue_shift: " + blue_shift);
+
+            if (big_endian !== 0) {
+                Util.Warn("Server native endian is not little endian");
+            }
+
+            if (red_shift !== 16) {
+                Util.Warn("Server native red-shift is not 16");
+            }
+
+            if (blue_shift !== 0) {
+                Util.Warn("Server native blue-shift is not 0");
+            }
+
+            // we're past the point where we could backtrack, so it's safe to call this
+            this._onDesktopName(this, this._fb_name);
+
+            if (this._true_color && this._fb_name === "Intel(r) AMT KVM") {
+                Util.Warn("Intel AMT KVM only supports 8/16 bit depths.  Disabling true color");
+                this._true_color = false;
+            }
+
+            this._display.set_true_color(this._true_color);
+            this._onFBResize(this, this._fb_width, this._fb_height);
+            this._display.resize(this._fb_width, this._fb_height);
+            this._keyboard.grab();
+            this._mouse.grab();
+
+            if (this._true_color) {
+                this._fb_Bpp = 4;
+                this._fb_depth = 3;
+            } else {
+                this._fb_Bpp = 1;
+                this._fb_depth = 1;
+            }
+
+            var response = RFB.messages.pixelFormat(this._fb_Bpp, this._fb_depth, this._true_color);
+            response = response.concat(
+                            RFB.messages.clientEncodings(this._encodings, this._local_cursor, this._true_color));
+            response = response.concat(
+                            RFB.messages.fbUpdateRequests(this._display.getCleanDirtyReset(),
+                                                          this._fb_width, this._fb_height));
+
+            this._timing.fbu_rt_start = (new Date()).getTime();
+            this._timing.pixels = 0;
+            this._sock.send(response);
+
+            this._checkEvents();
+
+            if (this._encrypt) {
+                this._updateState('normal', 'Connected (encrypted) to: ' + this._fb_name);
+            } else {
+                this._updateState('normal', 'Connected (unencrypted) to: ' + this._fb_name);
+            }
+        },
+
+        _init_msg: function () {
+            switch (this._rfb_state) {
+                case 'ProtocolVersion':
+                    return this._negotiate_protocol_version();
+
+                case 'Security':
+                    return this._negotiate_security();
+
+                case 'Authentication':
+                    return this._negotiate_authentication();
+
+                case 'SecurityResult':
+                    return this._handle_security_result();
+
+                case 'ClientInitialisation':
+                    this._sock.send([this._shared ? 1 : 0]); // ClientInitialisation
+                    this._updateState('ServerInitialisation', "Authentication OK");
+                    return true;
+
+                case 'ServerInitialisation':
+                    return this._negotiate_server_init();
+            }
+        },
+
+        _handle_set_colour_map_msg: function () {
+            Util.Debug("SetColorMapEntries");
+            this._sock.rQskip8();  // Padding
+
+            var first_colour = this._sock.rQshift16();
+            var num_colours = this._sock.rQshift16();
+            if (this._sock.rQwait('SetColorMapEntries', num_colours * 6, 6)) { return false; }
+
+            for (var c = 0; c < num_colours; c++) {
+                var red = parseInt(this._sock.rQshift16() / 256, 10);
+                var green = parseInt(this._sock.rQshift16() / 256, 10);
+                var blue = parseInt(this._sock.rQshift16() / 256, 10);
+                this._display.set_colourMap([blue, green, red], first_colour + c);
+            }
+            Util.Debug("colourMap: " + this._display.get_colourMap());
+            Util.Info("Registered " + num_colours + " colourMap entries");
+
+            return true;
+        },
+
+        _handle_server_cut_text: function () {
+            Util.Debug("ServerCutText");
+            if (this._sock.rQwait("ServerCutText header", 7, 1)) { return false; }
+            this._sock.rQskipBytes(3);  // Padding
+            var length = this._sock.rQshift32();
+            if (this._sock.rQwait("ServerCutText", length, 8)) { return false; }
+
+            var text = this._sock.rQshiftStr(length);
+            this._onClipboard(this, text);
+
+            return true;
+        },
+
+        _handle_xvp_msg: function () {
+            if (this._sock.rQwait("XVP version and message", 3, 1)) { return false; }
+            this._sock.rQskip8();  // Padding
+            var xvp_ver = this._sock.rQshift8();
+            var xvp_msg = this._sock.rQshift8();
+
+            switch (xvp_msg) {
+                case 0:  // XVP_FAIL
+                    this._updateState(this._rfb_state, "Operation Failed");
+                    break;
+                case 1:  // XVP_INIT
+                    this._rfb_xvp_ver = xvp_ver;
+                    Util.Info("XVP extensions enabled (version " + this._rfb_xvp_ver + ")");
+                    this._onXvpInit(this._rfb_xvp_ver);
+                    break;
+                default:
+                    this._fail("Disconnected: illegal server XVP message " + xvp_msg);
+                    break;
+            }
+
+            return true;
+        },
+
+        _normal_msg: function () {
+            var msg_type;
+
+            if (this._FBU.rects > 0) {
+                msg_type = 0;
+            } else {
+                msg_type = this._sock.rQshift8();
+            }
+
+            switch (msg_type) {
+                case 0:  // FramebufferUpdate
+                    var ret = this._framebufferUpdate();
+                    if (ret) {
+                        this._sock.send(RFB.messages.fbUpdateRequests(this._display.getCleanDirtyReset(),
+                                                                      this._fb_width, this._fb_height));
+                    }
+                    return ret;
+
+                case 1:  // SetColorMapEntries
+                    return this._handle_set_colour_map_msg();
+
+                case 2:  // Bell
+                    Util.Debug("Bell");
+                    this._onBell(this);
+                    return true;
+
+                case 3:  // ServerCutText
+                    return this._handle_server_cut_text();
+
+                case 250:  // XVP
+                    return this._handle_xvp_msg();
+
+                default:
+                    this._fail("Disconnected: illegal server message type " + msg_type);
+                    Util.Debug("sock.rQslice(0, 30): " + this._sock.rQslice(0, 30));
+                    return true;
+            }
+        },
+
+        _framebufferUpdate: function () {
+            var ret = true;
+            var now;
+
+            if (this._FBU.rects === 0) {
+                if (this._sock.rQwait("FBU header", 3, 1)) { return false; }
+                this._sock.rQskip8();  // Padding
+                this._FBU.rects = this._sock.rQshift16();
+                this._FBU.bytes = 0;
+                this._timing.cur_fbu = 0;
+                if (this._timing.fbu_rt_start > 0) {
+                    now = (new Date()).getTime();
+                    Util.Info("First FBU latency: " + (now - this._timing.fbu_rt_start));
+                }
+            }
+
+            while (this._FBU.rects > 0) {
+                if (this._rfb_state !== "normal") { return false; }
+
+                if (this._sock.rQwait("FBU", this._FBU.bytes)) { return false; }
+                if (this._FBU.bytes === 0) {
+                    if (this._sock.rQwait("rect header", 12)) { return false; }
+                    /* New FramebufferUpdate */
+
+                    var hdr = this._sock.rQshiftBytes(12);
+                    this._FBU.x        = (hdr[0] << 8) + hdr[1];
+                    this._FBU.y        = (hdr[2] << 8) + hdr[3];
+                    this._FBU.width    = (hdr[4] << 8) + hdr[5];
+                    this._FBU.height   = (hdr[6] << 8) + hdr[7];
+                    this._FBU.encoding = parseInt((hdr[8] << 24) + (hdr[9] << 16) +
+                                                  (hdr[10] << 8) + hdr[11], 10);
+
+                    this._onFBUReceive(this,
+                        {'x': this._FBU.x, 'y': this._FBU.y,
+                         'width': this._FBU.width, 'height': this._FBU.height,
+                         'encoding': this._FBU.encoding,
+                         'encodingName': this._encNames[this._FBU.encoding]});
+
+                    if (!this._encNames[this._FBU.encoding]) {
+                        this._fail("Disconnected: unsupported encoding " +
+                                   this._FBU.encoding);
+                        return false;
+                    }
+                }
+
+                this._timing.last_fbu = (new Date()).getTime();
+
+                ret = this._encHandlers[this._FBU.encoding]();
+
+                now = (new Date()).getTime();
+                this._timing.cur_fbu += (now - this._timing.last_fbu);
+
+                if (ret) {
+                    this._encStats[this._FBU.encoding][0]++;
+                    this._encStats[this._FBU.encoding][1]++;
+                    this._timing.pixels += this._FBU.width * this._FBU.height;
+                }
+
+                if (this._timing.pixels >= (this._fb_width * this._fb_height)) {
+                    if ((this._FBU.width === this._fb_width && this._FBU.height === this._fb_height) ||
+                        this._timing.fbu_rt_start > 0) {
+                        this._timing.full_fbu_total += this._timing.cur_fbu;
+                        this._timing.full_fbu_cnt++;
+                        Util.Info("Timing of full FBU, curr: " +
+                                  this._timing.cur_fbu + ", total: " +
+                                  this._timing.full_fbu_total + ", cnt: " +
+                                  this._timing.full_fbu_cnt + ", avg: " +
+                                  (this._timing.full_fbu_total / this._timing.full_fbu_cnt));
+                    }
+
+                    if (this._timing.fbu_rt_start > 0) {
+                        var fbu_rt_diff = now - this._timing.fbu_rt_start;
+                        this._timing.fbu_rt_total += fbu_rt_diff;
+                        this._timing.fbu_rt_cnt++;
+                        Util.Info("full FBU round-trip, cur: " +
+                                  fbu_rt_diff + ", total: " +
+                                  this._timing.fbu_rt_total + ", cnt: " +
+                                  this._timing.fbu_rt_cnt + ", avg: " +
+                                  (this._timing.fbu_rt_total / this._timing.fbu_rt_cnt));
+                        this._timing.fbu_rt_start = 0;
+                    }
+                }
+
+                if (!ret) { return ret; }  // need more data
+            }
+
+            this._onFBUComplete(this,
+                    {'x': this._FBU.x, 'y': this._FBU.y,
+                     'width': this._FBU.width, 'height': this._FBU.height,
+                     'encoding': this._FBU.encoding,
+                     'encodingName': this._encNames[this._FBU.encoding]});
+
+            return true;  // We finished this FBU
+        },
+    };
+
+    Util.make_properties(RFB, [
+        ['target', 'wo', 'dom'],                // VNC display rendering Canvas object
+        ['focusContainer', 'wo', 'dom'],        // DOM element that captures keyboard input
+        ['encrypt', 'rw', 'bool'],              // Use TLS/SSL/wss encryption
+        ['true_color', 'rw', 'bool'],           // Request true color pixel data
+        ['local_cursor', 'rw', 'bool'],         // Request locally rendered cursor
+        ['shared', 'rw', 'bool'],               // Request shared mode
+        ['view_only', 'rw', 'bool'],            // Disable client mouse/keyboard
+        ['xvp_password_sep', 'rw', 'str'],      // Separator for XVP password fields
+        ['disconnectTimeout', 'rw', 'int'],     // Time (s) to wait for disconnection
+        ['wsProtocols', 'rw', 'arr'],           // Protocols to use in the WebSocket connection
+        ['repeaterID', 'rw', 'str'],            // [UltraVNC] RepeaterID to connect to
+        ['viewportDrag', 'rw', 'bool'],         // Move the viewport on mouse drags
+
+        // Callback functions
+        ['onUpdateState', 'rw', 'func'],        // onUpdateState(rfb, state, oldstate, statusMsg): RFB state update/change
+        ['onPasswordRequired', 'rw', 'func'],   // onPasswordRequired(rfb): VNC password is required
+        ['onClipboard', 'rw', 'func'],          // onClipboard(rfb, text): RFB clipboard contents received
+        ['onBell', 'rw', 'func'],               // onBell(rfb): RFB Bell message received
+        ['onFBUReceive', 'rw', 'func'],         // onFBUReceive(rfb, fbu): RFB FBU received but not yet processed
+        ['onFBUComplete', 'rw', 'func'],        // onFBUComplete(rfb, fbu): RFB FBU received and processed
+        ['onFBResize', 'rw', 'func'],           // onFBResize(rfb, width, height): frame buffer resized
+        ['onDesktopName', 'rw', 'func'],        // onDesktopName(rfb, name): desktop name received
+        ['onXvpInit', 'rw', 'func'],            // onXvpInit(version): XVP extensions active for this connection
+    ]);
+
+    RFB.prototype.set_local_cursor = function (cursor) {
+        if (!cursor || (cursor in {'0': 1, 'no': 1, 'false': 1})) {
+            this._local_cursor = false;
+        } else {
+            if (this._display.get_cursor_uri()) {
+                this._local_cursor = true;
+            } else {
+                Util.Warn("Browser does not support local cursor");
+            }
+        }
+    };
+
+    RFB.prototype.get_display = function () { return this._display; };
+    RFB.prototype.get_keyboard = function () { return this._keyboard; };
+    RFB.prototype.get_mouse = function () { return this._mouse; };
+
+    // Class Methods
+    RFB.messages = {
+        keyEvent: function (keysym, down) {
+            var arr = [4];
+            arr.push8(down);
+            arr.push16(0);
+            arr.push32(keysym);
+            return arr;
+        },
+
+        pointerEvent: function (x, y, mask) {
+            var arr = [5];  // msg-type
+            arr.push8(mask);
+            arr.push16(x);
+            arr.push16(y);
+            return arr;
+        },
+
+        // TODO(directxman12): make this unicode compatible?
+        clientCutText: function (text) {
+            var arr = [6];  // msg-type
+            arr.push8(0);   // padding
+            arr.push8(0);   // padding
+            arr.push8(0);   // padding
+            arr.push32(text.length);
+            var n = text.length;
+            for (var i = 0; i < n; i++) {
+                arr.push(text.charCodeAt(i));
+            }
+
+            return arr;
+        },
+
+        pixelFormat: function (bpp, depth, true_color) {
+            var arr = [0]; // msg-type
+            arr.push8(0);  // padding
+            arr.push8(0);  // padding
+            arr.push8(0);  // padding
+
+            arr.push8(bpp * 8); // bits-per-pixel
+            arr.push8(depth * 8); // depth
+            arr.push8(0);  // little-endian
+            arr.push8(true_color ? 1 : 0);  // true-color
+
+            arr.push16(255);  // red-max
+            arr.push16(255);  // green-max
+            arr.push16(255);  // blue-max
+            arr.push8(16);    // red-shift
+            arr.push8(8);     // green-shift
+            arr.push8(0);     // blue-shift
+
+            arr.push8(0);     // padding
+            arr.push8(0);     // padding
+            arr.push8(0);     // padding
+            return arr;
+        },
+
+        clientEncodings: function (encodings, local_cursor, true_color) {
+            var i, encList = [];
+
+            for (i = 0; i < encodings.length; i++) {
+                if (encodings[i][0] === "Cursor" && !local_cursor) {
+                    Util.Debug("Skipping Cursor pseudo-encoding");
+                } else if (encodings[i][0] === "TIGHT" && !true_color) {
+                    // TODO: remove this when we have tight+non-true-color
+                    Util.Warn("Skipping tight as it is only supported with true color");
+                } else {
+                    encList.push(encodings[i][1]);
+                }
+            }
+
+            var arr = [2];  // msg-type
+            arr.push8(0);   // padding
+
+            arr.push16(encList.length);  // encoding count
+            for (i = 0; i < encList.length; i++) {
+                arr.push32(encList[i]);
+            }
+
+            return arr;
+        },
+
+        fbUpdateRequests: function (cleanDirty, fb_width, fb_height) {
+            var arr = [];
+
+            var cb = cleanDirty.cleanBox;
+            var w, h;
+            if (cb.w > 0 && cb.h > 0) {
+                w = typeof cb.w === "undefined" ? fb_width : cb.w;
+                h = typeof cb.h === "undefined" ? fb_height : cb.h;
+                // Request incremental for clean box
+                arr = arr.concat(RFB.messages.fbUpdateRequest(1, cb.x, cb.y, w, h));
+            }
+
+            for (var i = 0; i < cleanDirty.dirtyBoxes.length; i++) {
+                var db = cleanDirty.dirtyBoxes[i];
+                // Force all (non-incremental) for dirty box
+                w = typeof db.w === "undefined" ? fb_width : db.w;
+                h = typeof db.h === "undefined" ? fb_height : db.h;
+                arr = arr.concat(RFB.messages.fbUpdateRequest(0, db.x, db.y, w, h));
+            }
+
+            return arr;
+        },
+
+        fbUpdateRequest: function (incremental, x, y, w, h) {
+            if (typeof(x) === "undefined") { x = 0; }
+            if (typeof(y) === "undefined") { y = 0; }
+
+            var arr = [3];  // msg-type
+            arr.push8(incremental);
+            arr.push16(x);
+            arr.push16(y);
+            arr.push16(w);
+            arr.push16(h);
+
+            return arr;
+        }
+    };
+
+    RFB.genDES = function (password, challenge) {
+        var passwd = [];
+        for (var i = 0; i < password.length; i++) {
+            passwd.push(password.charCodeAt(i));
+        }
+        return (new DES(passwd)).encrypt(challenge);
+    };
+
+    RFB.extract_data_uri = function (arr) {
+        return ";base64," + Base64.encode(arr);
+    };
+
+    RFB.encodingHandlers = {
+        RAW: function () {
+            if (this._FBU.lines === 0) {
+                this._FBU.lines = this._FBU.height;
+            }
+
+            this._FBU.bytes = this._FBU.width * this._fb_Bpp;  // at least a line
+            if (this._sock.rQwait("RAW", this._FBU.bytes)) { return false; }
+            var cur_y = this._FBU.y + (this._FBU.height - this._FBU.lines);
+            var curr_height = Math.min(this._FBU.lines,
+                                       Math.floor(this._sock.rQlen() / (this._FBU.width * this._fb_Bpp)));
+            this._display.blitImage(this._FBU.x, cur_y, this._FBU.width,
+                                    curr_height, this._sock.get_rQ(),
+                                    this._sock.get_rQi());
+            this._sock.rQskipBytes(this._FBU.width * curr_height * this._fb_Bpp);
+            this._FBU.lines -= curr_height;
+
+            if (this._FBU.lines > 0) {
+                this._FBU.bytes = this._FBU.width * this._fb_Bpp;  // At least another line
+            } else {
+                this._FBU.rects--;
+                this._FBU.bytes = 0;
+            }
+
+            return true;
+        },
+
+        COPYRECT: function () {
+            this._FBU.bytes = 4;
+            if (this._sock.rQwait("COPYRECT", 4)) { return false; }
+            this._display.renderQ_push({
+                'type': 'copy',
+                'old_x': this._sock.rQshift16(),
+                'old_y': this._sock.rQshift16(),
+                'x': this._FBU.x,
+                'y': this._FBU.y,
+                'width': this._FBU.width,
+                'height': this._FBU.height
+            });
+            this._FBU.rects--;
+            this._FBU.bytes = 0;
+            return true;
+        },
+
+        RRE: function () {
+            var color;
+            if (this._FBU.subrects === 0) {
+                this._FBU.bytes = 4 + this._fb_Bpp;
+                if (this._sock.rQwait("RRE", 4 + this._fb_Bpp)) { return false; }
+                this._FBU.subrects = this._sock.rQshift32();
+                color = this._sock.rQshiftBytes(this._fb_Bpp);  // Background
+                this._display.fillRect(this._FBU.x, this._FBU.y, this._FBU.width, this._FBU.height, color);
+            }
+
+            while (this._FBU.subrects > 0 && this._sock.rQlen() >= (this._fb_Bpp + 8)) {
+                color = this._sock.rQshiftBytes(this._fb_Bpp);
+                var x = this._sock.rQshift16();
+                var y = this._sock.rQshift16();
+                var width = this._sock.rQshift16();
+                var height = this._sock.rQshift16();
+                this._display.fillRect(this._FBU.x + x, this._FBU.y + y, width, height, color);
+                this._FBU.subrects--;
+            }
+
+            if (this._FBU.subrects > 0) {
+                var chunk = Math.min(this._rre_chunk_sz, this._FBU.subrects);
+                this._FBU.bytes = (this._fb_Bpp + 8) * chunk;
+            } else {
+                this._FBU.rects--;
+                this._FBU.bytes = 0;
+            }
+
+            return true;
+        },
+
+        HEXTILE: function () {
+            var rQ = this._sock.get_rQ();
+            var rQi = this._sock.get_rQi();
+
+            if (this._FBU.tiles === 0) {
+                this._FBU.tiles_x = Math.ceil(this._FBU.width / 16);
+                this._FBU.tiles_y = Math.ceil(this._FBU.height / 16);
+                this._FBU.total_tiles = this._FBU.tiles_x * this._FBU.tiles_y;
+                this._FBU.tiles = this._FBU.total_tiles;
+            }
+
+            while (this._FBU.tiles > 0) {
+                this._FBU.bytes = 1;
+                if (this._sock.rQwait("HEXTILE subencoding", this._FBU.bytes)) { return false; }
+                var subencoding = rQ[rQi];  // Peek
+                if (subencoding > 30) {  // Raw
+                    this._fail("Disconnected: illegal hextile subencoding " + subencoding);
+                    return false;
+                }
+
+                var subrects = 0;
+                var curr_tile = this._FBU.total_tiles - this._FBU.tiles;
+                var tile_x = curr_tile % this._FBU.tiles_x;
+                var tile_y = Math.floor(curr_tile / this._FBU.tiles_x);
+                var x = this._FBU.x + tile_x * 16;
+                var y = this._FBU.y + tile_y * 16;
+                var w = Math.min(16, (this._FBU.x + this._FBU.width) - x);
+                var h = Math.min(16, (this._FBU.y + this._FBU.height) - y);
+
+                // Figure out how much we are expecting
+                if (subencoding & 0x01) {  // Raw
+                    this._FBU.bytes += w * h * this._fb_Bpp;
+                } else {
+                    if (subencoding & 0x02) {  // Background
+                        this._FBU.bytes += this._fb_Bpp;
+                    }
+                    if (subencoding & 0x04) {  // Foreground
+                        this._FBU.bytes += this._fb_Bpp;
+                    }
+                    if (subencoding & 0x08) {  // AnySubrects
+                        this._FBU.bytes++;  // Since we aren't shifting it off
+                        if (this._sock.rQwait("hextile subrects header", this._FBU.bytes)) { return false; }
+                        subrects = rQ[rQi + this._FBU.bytes - 1];  // Peek
+                        if (subencoding & 0x10) {  // SubrectsColoured
+                            this._FBU.bytes += subrects * (this._fb_Bpp + 2);
+                        } else {
+                            this._FBU.bytes += subrects * 2;
+                        }
+                    }
+                }
+
+                if (this._sock.rQwait("hextile", this._FBU.bytes)) { return false; }
+
+                // We know the encoding and have a whole tile
+                this._FBU.subencoding = rQ[rQi];
+                rQi++;
+                if (this._FBU.subencoding === 0) {
+                    if (this._FBU.lastsubencoding & 0x01) {
+                        // Weird: ignore blanks are RAW
+                        Util.Debug("     Ignoring blank after RAW");
+                    } else {
+                        this._display.fillRect(x, y, w, h, this._FBU.background);
+                    }
+                } else if (this._FBU.subencoding & 0x01) {  // Raw
+                    this._display.blitImage(x, y, w, h, rQ, rQi);
+                    rQi += this._FBU.bytes - 1;
+                } else {
+                    if (this._FBU.subencoding & 0x02) {  // Background
+                        this._FBU.background = rQ.slice(rQi, rQi + this._fb_Bpp);
+                        rQi += this._fb_Bpp;
+                    }
+                    if (this._FBU.subencoding & 0x04) {  // Foreground
+                        this._FBU.foreground = rQ.slice(rQi, rQi + this._fb_Bpp);
+                        rQi += this._fb_Bpp;
+                    }
+
+                    this._display.startTile(x, y, w, h, this._FBU.background);
+                    if (this._FBU.subencoding & 0x08) {  // AnySubrects
+                        subrects = rQ[rQi];
+                        rQi++;
+
+                        for (var s = 0; s < subrects; s++) {
+                            var color;
+                            if (this._FBU.subencoding & 0x10) {  // SubrectsColoured
+                                color = rQ.slice(rQi, rQi + this._fb_Bpp);
+                                rQi += this._fb_Bpp;
+                            } else {
+                                color = this._FBU.foreground;
+                            }
+                            var xy = rQ[rQi];
+                            rQi++;
+                            var sx = (xy >> 4);
+                            var sy = (xy & 0x0f);
+
+                            var wh = rQ[rQi];
+                            rQi++;
+                            var sw = (wh >> 4) + 1;
+                            var sh = (wh & 0x0f) + 1;
+
+                            this._display.subTile(sx, sy, sw, sh, color);
+                        }
+                    }
+                    this._display.finishTile();
+                }
+                this._sock.set_rQi(rQi);
+                this._FBU.lastsubencoding = this._FBU.subencoding;
+                this._FBU.bytes = 0;
+                this._FBU.tiles--;
+            }
+
+            if (this._FBU.tiles === 0) {
+                this._FBU.rects--;
+            }
+
+            return true;
+        },
+
+        getTightCLength: function (arr) {
+            var header = 1, data = 0;
+            data += arr[0] & 0x7f;
+            if (arr[0] & 0x80) {
+                header++;
+                data += (arr[1] & 0x7f) << 7;
+                if (arr[1] & 0x80) {
+                    header++;
+                    data += arr[2] << 14;
+                }
+            }
+            return [header, data];
+        },
+
+        display_tight: function (isTightPNG) {
+            if (this._fb_depth === 1) {
+                this._fail("Tight protocol handler only implements true color mode");
+            }
+
+            this._FBU.bytes = 1;  // compression-control byte
+            if (this._sock.rQwait("TIGHT compression-control", this._FBU.bytes)) { return false; }
+
+            var checksum = function (data) {
+                var sum = 0;
+                for (var i = 0; i < data.length; i++) {
+                    sum += data[i];
+                    if (sum > 65536) sum -= 65536;
+                }
+                return sum;
+            };
+
+            var resetStreams = 0;
+            var streamId = -1;
+            var decompress = function (data) {
+                for (var i = 0; i < 4; i++) {
+                    if ((resetStreams >> i) & 1) {
+                        this._FBU.zlibs[i].reset();
+                        Util.Info("Reset zlib stream " + i);
+                    }
+                }
+
+                var uncompressed = this._FBU.zlibs[streamId].uncompress(data, 0);
+                if (uncompressed.status !== 0) {
+                    Util.Error("Invalid data in zlib stream");
+                }
+
+                return uncompressed.data;
+            }.bind(this);
+
+            var indexedToRGB = function (data, numColors, palette, width, height) {
+                // Convert indexed (palette based) image data to RGB
+                // TODO: reduce number of calculations inside loop
+                var dest = [];
+                var x, y, dp, sp;
+                if (numColors === 2) {
+                    var w = Math.floor((width + 7) / 8);
+                    var w1 = Math.floor(width / 8);
+
+                    for (y = 0; y < height; y++) {
+                        var b;
+                        for (x = 0; x < w1; x++) {
+                            for (b = 7; b >= 0; b--) {
+                                dp = (y * width + x * 8 + 7 - b) * 3;
+                                sp = (data[y * w + x] >> b & 1) * 3;
+                                dest[dp] = palette[sp];
+                                dest[dp + 1] = palette[sp + 1];
+                                dest[dp + 2] = palette[sp + 2];
+                            }
+                        }
+
+                        for (b = 7; b >= 8 - width % 8; b--) {
+                            dp = (y * width + x * 8 + 7 - b) * 3;
+                            sp = (data[y * w + x] >> b & 1) * 3;
+                            dest[dp] = palette[sp];
+                            dest[dp + 1] = palette[sp + 1];
+                            dest[dp + 2] = palette[sp + 2];
+                        }
+                    }
+                } else {
+                    for (y = 0; y < height; y++) {
+                        for (x = 0; x < width; x++) {
+                            dp = (y * width + x) * 3;
+                            sp = data[y * width + x] * 3;
+                            dest[dp] = palette[sp];
+                            dest[dp + 1] = palette[sp + 1];
+                            dest[dp + 2] = palette[sp + 2];
+                        }
+                    }
+                }
+
+                return dest;
+            }.bind(this);
+
+            var rQ = this._sock.get_rQ();
+            var rQi = this._sock.get_rQi();
+            var cmode, clength, data;
+
+            var handlePalette = function () {
+                var numColors = rQ[rQi + 2] + 1;
+                var paletteSize = numColors * this._fb_depth;
+                this._FBU.bytes += paletteSize;
+                if (this._sock.rQwait("TIGHT palette " + cmode, this._FBU.bytes)) { return false; }
+
+                var bpp = (numColors <= 2) ? 1 : 8;
+                var rowSize = Math.floor((this._FBU.width * bpp + 7) / 8);
+                var raw = false;
+                if (rowSize * this._FBU.height < 12) {
+                    raw = true;
+                    clength = [0, rowSize * this._FBU.height];
+                } else {
+                    clength = RFB.encodingHandlers.getTightCLength(this._sock.rQslice(3 + paletteSize,
+                                                                                      3 + paletteSize + 3));
+                }
+
+                this._FBU.bytes += clength[0] + clength[1];
+                if (this._sock.rQwait("TIGHT " + cmode, this._FBU.bytes)) { return false; }
+
+                // Shift ctl, filter id, num colors, palette entries, and clength off
+                this._sock.rQskipBytes(3);
+                var palette = this._sock.rQshiftBytes(paletteSize);
+                this._sock.rQskipBytes(clength[0]);
+
+                if (raw) {
+                    data = this._sock.rQshiftBytes(clength[1]);
+                } else {
+                    data = decompress(this._sock.rQshiftBytes(clength[1]));
+                }
+
+                // Convert indexed (palette based) image data to RGB
+                var rgb = indexedToRGB(data, numColors, palette, this._FBU.width, this._FBU.height);
+
+                this._display.renderQ_push({
+                    'type': 'blitRgb',
+                    'data': rgb,
+                    'x': this._FBU.x,
+                    'y': this._FBU.y,
+                    'width': this._FBU.width,
+                    'height': this._FBU.height
+                });
+
+                return true;
+            }.bind(this);
+
+            var handleCopy = function () {
+                var raw = false;
+                var uncompressedSize = this._FBU.width * this._FBU.height * this._fb_depth;
+                if (uncompressedSize < 12) {
+                    raw = true;
+                    clength = [0, uncompressedSize];
+                } else {
+                    clength = RFB.encodingHandlers.getTightCLength(this._sock.rQslice(1, 4));
+                }
+                this._FBU.bytes = 1 + clength[0] + clength[1];
+                if (this._sock.rQwait("TIGHT " + cmode, this._FBU.bytes)) { return false; }
+
+                // Shift ctl, clength off
+                this._sock.rQshiftBytes(1 + clength[0]);
+
+                if (raw) {
+                    data = this._sock.rQshiftBytes(clength[1]);
+                } else {
+                    data = decompress(this._sock.rQshiftBytes(clength[1]));
+                }
+
+                this._display.renderQ_push({
+                    'type': 'blitRgb',
+                    'data': data,
+                    'x': this._FBU.x,
+                    'y': this._FBU.y,
+                    'width': this._FBU.width,
+                    'height': this._FBU.height
+                });
+
+                return true;
+            }.bind(this);
+
+            var ctl = this._sock.rQpeek8();
+
+            // Keep tight reset bits
+            resetStreams = ctl & 0xF;
+
+            // Figure out filter
+            ctl = ctl >> 4;
+            streamId = ctl & 0x3;
+
+            if (ctl === 0x08)       cmode = "fill";
+            else if (ctl === 0x09)  cmode = "jpeg";
+            else if (ctl === 0x0A)  cmode = "png";
+            else if (ctl & 0x04)    cmode = "filter";
+            else if (ctl < 0x04)    cmode = "copy";
+            else return this._fail("Illegal tight compression received, ctl: " + ctl);
+
+            if (isTightPNG && (cmode === "filter" || cmode === "copy")) {
+                return this._fail("filter/copy received in tightPNG mode");
+            }
+
+            switch (cmode) {
+                // fill use fb_depth because TPIXELs drop the padding byte
+                case "fill":  // TPIXEL
+                    this._FBU.bytes += this._fb_depth;
+                    break;
+                case "jpeg":  // max clength
+                    this._FBU.bytes += 3;
+                    break;
+                case "png":  // max clength
+                    this._FBU.bytes += 3;
+                    break;
+                case "filter":  // filter id + num colors if palette
+                    this._FBU.bytes += 2;
+                    break;
+                case "copy":
+                    break;
+            }
+
+            if (this._sock.rQwait("TIGHT " + cmode, this._FBU.bytes)) { return false; }
+
+            // Determine FBU.bytes
+            switch (cmode) {
+                case "fill":
+                    this._sock.rQskip8();  // shift off ctl
+                    var color = this._sock.rQshiftBytes(this._fb_depth);
+                    this._display.renderQ_push({
+                        'type': 'fill',
+                        'x': this._FBU.x,
+                        'y': this._FBU.y,
+                        'width': this._FBU.width,
+                        'height': this._FBU.height,
+                        'color': [color[2], color[1], color[0]]
+                    });
+                    break;
+                case "png":
+                case "jpeg":
+                    clength = RFB.encodingHandlers.getTightCLength(this._sock.rQslice(1, 4));
+                    this._FBU.bytes = 1 + clength[0] + clength[1];  // ctl + clength size + jpeg-data
+                    if (this._sock.rQwait("TIGHT " + cmode, this._FBU.bytes)) { return false; }
+
+                    // We have everything, render it
+                    this._sock.rQskipBytes(1 + clength[0]);  // shift off clt + compact length
+                    var img = new Image();
+                    img.src = "data: image/" + cmode +
+                        RFB.extract_data_uri(this._sock.rQshiftBytes(clength[1]));
+                    this._display.renderQ_push({
+                        'type': 'img',
+                        'img': img,
+                        'x': this._FBU.x,
+                        'y': this._FBU.y
+                    });
+                    img = null;
+                    break;
+                case "filter":
+                    var filterId = rQ[rQi + 1];
+                    if (filterId === 1) {
+                        if (!handlePalette()) { return false; }
+                    } else {
+                        // Filter 0, Copy could be valid here, but servers don't send it as an explicit filter
+                        // Filter 2, Gradient is valid but not use if jpeg is enabled
+                        // TODO(directxman12): why aren't we just calling '_fail' here
+                        throw new Error("Unsupported tight subencoding received, filter: " + filterId);
+                    }
+                    break;
+                case "copy":
+                    if (!handleCopy()) { return false; }
+                    break;
+            }
+
+
+            this._FBU.bytes = 0;
+            this._FBU.rects--;
+
+            return true;
+        },
+
+        TIGHT: function () { return this._encHandlers.display_tight(false); },
+        TIGHT_PNG: function () { return this._encHandlers.display_tight(true); },
+
+        last_rect: function () {
+            this._FBU.rects = 0;
+            return true;
+        },
+
+        DesktopSize: function () {
+            Util.Debug(">> set_desktopsize");
+            this._fb_width = this._FBU.width;
+            this._fb_height = this._FBU.height;
+            this._onFBResize(this, this._fb_width, this._fb_height);
+            this._display.resize(this._fb_width, this._fb_height);
+            this._timing.fbu_rt_start = (new Date()).getTime();
+
+            this._FBU.bytes = 0;
+            this._FBU.rects--;
+
+            Util.Debug("<< set_desktopsize");
+            return true;
+        },
+
+        Cursor: function () {
+            Util.Debug(">> set_cursor");
+            var x = this._FBU.x;  // hotspot-x
+            var y = this._FBU.y;  // hotspot-y
+            var w = this._FBU.width;
+            var h = this._FBU.height;
+
+            var pixelslength = w * h * this._fb_Bpp;
+            var masklength = Math.floor((w + 7) / 8) * h;
+
+            this._FBU.bytes = pixelslength + masklength;
+            if (this._sock.rQwait("cursor encoding", this._FBU.bytes)) { return false; }
+
+            this._display.changeCursor(this._sock.rQshiftBytes(pixelslength),
+                                       this._sock.rQshiftBytes(masklength),
+                                       x, y, w, h);
+
+            this._FBU.bytes = 0;
+            this._FBU.rects--;
+
+            Util.Debug("<< set_cursor");
+            return true;
+        },
+
+        JPEG_quality_lo: function () {
+            Util.Error("Server sent jpeg_quality pseudo-encoding");
+        },
+
+        compress_lo: function () {
+            Util.Error("Server sent compress level pseudo-encoding");
+        }
+    };
+})();
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/ui.js
@@ -0,0 +1,979 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2012 Joel Martin
+ * Copyright (C) 2013 Samuel Mannehed for Cendio AB
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+/* jslint white: false, browser: true */
+/* global window, $D, Util, WebUtil, RFB, Display */
+
+var UI;
+
+(function () {
+    "use strict";
+
+    // Load supporting scripts
+    window.onscriptsload = function () { UI.load(); };
+    window.onload = function () { UI.keyboardinputReset(); };
+    Util.load_scripts(["webutil.js", "base64.js", "websock.js", "des.js",
+                       "keysymdef.js", "keyboard.js", "input.js", "display.js",
+                       "jsunzip.js", "rfb.js", "keysym.js"]);
+
+    UI = {
+
+        rfb_state : 'loaded',
+        settingsOpen : false,
+        connSettingsOpen : false,
+        popupStatusOpen : false,
+        clipboardOpen: false,
+        keyboardVisible: false,
+        hideKeyboardTimeout: null,
+        lastKeyboardinput: null,
+        defaultKeyboardinputLen: 100,
+        extraKeysVisible: false,
+        ctrlOn: false,
+        altOn: false,
+        isTouchDevice: false,
+
+        // Setup rfb object, load settings from browser storage, then call
+        // UI.init to setup the UI/menus
+        load: function (callback) {
+            WebUtil.initSettings(UI.start, callback);
+        },
+
+        // Render default UI and initialize settings menu
+        start: function(callback) {
+            UI.isTouchDevice = 'ontouchstart' in document.documentElement;
+
+            // Stylesheet selection dropdown
+            var sheet = WebUtil.selectStylesheet();
+            var sheets = WebUtil.getStylesheets();
+            var i;
+            for (i = 0; i < sheets.length; i += 1) {
+                UI.addOption($D('noVNC_stylesheet'),sheets[i].title, sheets[i].title);
+            }
+
+            // Logging selection dropdown
+            var llevels = ['error', 'warn', 'info', 'debug'];
+            for (i = 0; i < llevels.length; i += 1) {
+                UI.addOption($D('noVNC_logging'),llevels[i], llevels[i]);
+            }
+
+            // Settings with immediate effects
+            UI.initSetting('logging', 'warn');
+            WebUtil.init_logging(UI.getSetting('logging'));
+
+            UI.initSetting('stylesheet', 'default');
+            WebUtil.selectStylesheet(null);
+            // call twice to get around webkit bug
+            WebUtil.selectStylesheet(UI.getSetting('stylesheet'));
+
+            // if port == 80 (or 443) then it won't be present and should be
+            // set manually
+            var port = window.location.port;
+            if (!port) {
+                if (window.location.protocol.substring(0,5) == 'https') {
+                    port = 443;
+                }
+                else if (window.location.protocol.substring(0,4) == 'http') {
+                    port = 80;
+                }
+            }
+
+            /* Populate the controls if defaults are provided in the URL */
+            UI.initSetting('host', window.location.hostname);
+            UI.initSetting('port', port);
+            UI.initSetting('password', '');
+            UI.initSetting('encrypt', (window.location.protocol === "https:"));
+            UI.initSetting('true_color', true);
+            UI.initSetting('cursor', !UI.isTouchDevice);
+            UI.initSetting('shared', true);
+            UI.initSetting('view_only', false);
+            UI.initSetting('path', 'websockify');
+            UI.initSetting('repeaterID', '');
+
+            UI.rfb = new RFB({'target': $D('noVNC_canvas'),
+                              'onUpdateState': UI.updateState,
+                              'onXvpInit': UI.updateXvpVisualState,
+                              'onClipboard': UI.clipReceive,
+                              'onDesktopName': UI.updateDocumentTitle});
+
+            var autoconnect = WebUtil.getQueryVar('autoconnect', false);
+            if (autoconnect === 'true' || autoconnect == '1') {
+                autoconnect = true;
+                UI.connect();
+            } else {
+                autoconnect = false;
+            }
+
+            UI.updateVisualState();
+
+            // Show mouse selector buttons on touch screen devices
+            if (UI.isTouchDevice) {
+                // Show mobile buttons
+                $D('noVNC_mobile_buttons').style.display = "inline";
+                UI.setMouseButton();
+                // Remove the address bar
+                setTimeout(function() { window.scrollTo(0, 1); }, 100);
+                UI.forceSetting('clip', true);
+                $D('noVNC_clip').disabled = true;
+            } else {
+                UI.initSetting('clip', false);
+            }
+
+            //iOS Safari does not support CSS position:fixed.
+            //This detects iOS devices and enables javascript workaround.
+            if ((navigator.userAgent.match(/iPhone/i)) ||
+                (navigator.userAgent.match(/iPod/i)) ||
+                (navigator.userAgent.match(/iPad/i))) {
+                //UI.setOnscroll();
+                //UI.setResize();
+            }
+            UI.setBarPosition();
+
+            $D('noVNC_host').focus();
+
+            UI.setViewClip();
+            Util.addEvent(window, 'resize', UI.setViewClip);
+
+            Util.addEvent(window, 'beforeunload', function () {
+                if (UI.rfb_state === 'normal') {
+                    return "You are currently connected.";
+                }
+            } );
+
+            // Show description by default when hosted at for kanaka.github.com
+            if (location.host === "kanaka.github.io") {
+                // Open the description dialog
+                $D('noVNC_description').style.display = "block";
+            } else {
+                // Show the connect panel on first load unless autoconnecting
+                if (autoconnect === UI.connSettingsOpen) {
+                    UI.toggleConnectPanel();
+                }
+            }
+
+            // Add mouse event click/focus/blur event handlers to the UI
+            UI.addMouseHandlers();
+
+            if (typeof callback === "function") {
+                callback(UI.rfb);
+            }
+        },
+
+        addMouseHandlers: function() {
+            // Setup interface handlers that can't be inline
+            $D("noVNC_view_drag_button").onclick = UI.setViewDrag;
+            $D("noVNC_mouse_button0").onclick = function () { UI.setMouseButton(1); };
+            $D("noVNC_mouse_button1").onclick = function () { UI.setMouseButton(2); };
+            $D("noVNC_mouse_button2").onclick = function () { UI.setMouseButton(4); };
+            $D("noVNC_mouse_button4").onclick = function () { UI.setMouseButton(0); };
+            $D("showKeyboard").onclick = UI.showKeyboard;
+
+            $D("keyboardinput").oninput = UI.keyInput;
+            $D("keyboardinput").onblur = UI.keyInputBlur;
+
+            $D("showExtraKeysButton").onclick = UI.showExtraKeys;
+            $D("toggleCtrlButton").onclick = UI.toggleCtrl;
+            $D("toggleAltButton").onclick = UI.toggleAlt;
+            $D("sendTabButton").onclick = UI.sendTab;
+            $D("sendEscButton").onclick = UI.sendEsc;
+
+            $D("sendCtrlAltDelButton").onclick = UI.sendCtrlAltDel;
+            $D("xvpShutdownButton").onclick = UI.xvpShutdown;
+            $D("xvpRebootButton").onclick = UI.xvpReboot;
+            $D("xvpResetButton").onclick = UI.xvpReset;
+            $D("noVNC_status").onclick = UI.togglePopupStatusPanel;
+            $D("noVNC_popup_status_panel").onclick = UI.togglePopupStatusPanel;
+            $D("xvpButton").onclick = UI.toggleXvpPanel;
+            $D("clipboardButton").onclick = UI.toggleClipboardPanel;
+            $D("settingsButton").onclick = UI.toggleSettingsPanel;
+            $D("connectButton").onclick = UI.toggleConnectPanel;
+            $D("disconnectButton").onclick = UI.disconnect;
+            $D("descriptionButton").onclick = UI.toggleConnectPanel;
+
+            $D("noVNC_clipboard_text").onfocus = UI.displayBlur;
+            $D("noVNC_clipboard_text").onblur = UI.displayFocus;
+            $D("noVNC_clipboard_text").onchange = UI.clipSend;
+            $D("noVNC_clipboard_clear_button").onclick = UI.clipClear;
+
+            $D("noVNC_settings_menu").onmouseover = UI.displayBlur;
+            $D("noVNC_settings_menu").onmouseover = UI.displayFocus;
+            $D("noVNC_apply").onclick = UI.settingsApply;
+
+            $D("noVNC_connect_button").onclick = UI.connect;
+        },
+
+        // Read form control compatible setting from cookie
+        getSetting: function(name) {
+            var ctrl = $D('noVNC_' + name);
+            var val = WebUtil.readSetting(name);
+            if (val !== null && ctrl.type === 'checkbox') {
+                if (val.toString().toLowerCase() in {'0':1, 'no':1, 'false':1}) {
+                    val = false;
+                } else {
+                    val = true;
+                }
+            }
+            return val;
+        },
+
+        // Update cookie and form control setting. If value is not set, then
+        // updates from control to current cookie setting.
+        updateSetting: function(name, value) {
+
+            // Save the cookie for this session
+            if (typeof value !== 'undefined') {
+                WebUtil.writeSetting(name, value);
+            }
+
+            // Update the settings control
+            value = UI.getSetting(name);
+
+            var ctrl = $D('noVNC_' + name);
+            if (ctrl.type === 'checkbox') {
+                ctrl.checked = value;
+
+            } else if (typeof ctrl.options !== 'undefined') {
+                for (var i = 0; i < ctrl.options.length; i += 1) {
+                    if (ctrl.options[i].value === value) {
+                        ctrl.selectedIndex = i;
+                        break;
+                    }
+                }
+            } else {
+                /*Weird IE9 error leads to 'null' appearring
+                in textboxes instead of ''.*/
+                if (value === null) {
+                    value = "";
+                }
+                ctrl.value = value;
+            }
+        },
+
+        // Save control setting to cookie
+        saveSetting: function(name) {
+            var val, ctrl = $D('noVNC_' + name);
+            if (ctrl.type === 'checkbox') {
+                val = ctrl.checked;
+            } else if (typeof ctrl.options !== 'undefined') {
+                val = ctrl.options[ctrl.selectedIndex].value;
+            } else {
+                val = ctrl.value;
+            }
+            WebUtil.writeSetting(name, val);
+            //Util.Debug("Setting saved '" + name + "=" + val + "'");
+            return val;
+        },
+
+        // Initial page load read/initialization of settings
+        initSetting: function(name, defVal) {
+            // Check Query string followed by cookie
+            var val = WebUtil.getQueryVar(name);
+            if (val === null) {
+                val = WebUtil.readSetting(name, defVal);
+            }
+            UI.updateSetting(name, val);
+            return val;
+        },
+
+        // Force a setting to be a certain value
+        forceSetting: function(name, val) {
+            UI.updateSetting(name, val);
+            return val;
+        },
+
+
+        // Show the popup status panel
+        togglePopupStatusPanel: function() {
+            var psp = $D('noVNC_popup_status_panel');
+            if (UI.popupStatusOpen === true) {
+                psp.style.display = "none";
+                UI.popupStatusOpen = false;
+            } else {
+                psp.innerHTML = $D('noVNC_status').innerHTML;
+                psp.style.display = "block";
+                psp.style.left = window.innerWidth/2 -
+                    parseInt(window.getComputedStyle(psp, false).width)/2 -30 + "px";
+                UI.popupStatusOpen = true;
+            }
+        },
+
+        // Show the XVP panel
+        toggleXvpPanel: function() {
+            // Close the description panel
+            $D('noVNC_description').style.display = "none";
+            // Close settings if open
+            if (UI.settingsOpen === true) {
+                UI.settingsApply();
+                UI.closeSettingsMenu();
+            }
+            // Close connection settings if open
+            if (UI.connSettingsOpen === true) {
+                UI.toggleConnectPanel();
+            }
+            // Close popup status panel if open
+            if (UI.popupStatusOpen === true) {
+                UI.togglePopupStatusPanel();
+            }
+            // Close clipboard panel if open
+            if (UI.clipboardOpen === true) {
+                UI.toggleClipboardPanel();
+            }
+            // Toggle XVP panel
+            if (UI.xvpOpen === true) {
+                $D('noVNC_xvp').style.display = "none";
+                $D('xvpButton').className = "noVNC_status_button";
+                UI.xvpOpen = false;
+            } else {
+                $D('noVNC_xvp').style.display = "block";
+                $D('xvpButton').className = "noVNC_status_button_selected";
+                UI.xvpOpen = true;
+            }
+        },
+
+        // Show the clipboard panel
+        toggleClipboardPanel: function() {
+            // Close the description panel
+            $D('noVNC_description').style.display = "none";
+            // Close settings if open
+            if (UI.settingsOpen === true) {
+                UI.settingsApply();
+                UI.closeSettingsMenu();
+            }
+            // Close connection settings if open
+            if (UI.connSettingsOpen === true) {
+                UI.toggleConnectPanel();
+            }
+            // Close popup status panel if open
+            if (UI.popupStatusOpen === true) {
+                UI.togglePopupStatusPanel();
+            }
+            // Close XVP panel if open
+            if (UI.xvpOpen === true) {
+                UI.toggleXvpPanel();
+            }
+            // Toggle Clipboard Panel
+            if (UI.clipboardOpen === true) {
+                $D('noVNC_clipboard').style.display = "none";
+                $D('clipboardButton').className = "noVNC_status_button";
+                UI.clipboardOpen = false;
+            } else {
+                $D('noVNC_clipboard').style.display = "block";
+                $D('clipboardButton').className = "noVNC_status_button_selected";
+                UI.clipboardOpen = true;
+            }
+        },
+
+        // Show the connection settings panel/menu
+        toggleConnectPanel: function() {
+            // Close the description panel
+            $D('noVNC_description').style.display = "none";
+            // Close connection settings if open
+            if (UI.settingsOpen === true) {
+                UI.settingsApply();
+                UI.closeSettingsMenu();
+                $D('connectButton').className = "noVNC_status_button";
+            }
+            // Close clipboard panel if open
+            if (UI.clipboardOpen === true) {
+                UI.toggleClipboardPanel();
+            }
+            // Close popup status panel if open
+            if (UI.popupStatusOpen === true) {
+                UI.togglePopupStatusPanel();
+            }
+            // Close XVP panel if open
+            if (UI.xvpOpen === true) {
+                UI.toggleXvpPanel();
+            }
+
+            // Toggle Connection Panel
+            if (UI.connSettingsOpen === true) {
+                $D('noVNC_controls').style.display = "none";
+                $D('connectButton').className = "noVNC_status_button";
+                UI.connSettingsOpen = false;
+                UI.saveSetting('host');
+                UI.saveSetting('port');
+                //UI.saveSetting('password');
+            } else {
+                $D('noVNC_controls').style.display = "block";
+                $D('connectButton').className = "noVNC_status_button_selected";
+                UI.connSettingsOpen = true;
+                $D('noVNC_host').focus();
+            }
+        },
+
+        // Toggle the settings menu:
+        //   On open, settings are refreshed from saved cookies.
+        //   On close, settings are applied
+        toggleSettingsPanel: function() {
+            // Close the description panel
+            $D('noVNC_description').style.display = "none";
+            if (UI.settingsOpen) {
+                UI.settingsApply();
+                UI.closeSettingsMenu();
+            } else {
+                UI.updateSetting('encrypt');
+                UI.updateSetting('true_color');
+                if (UI.rfb.get_display().get_cursor_uri()) {
+                    UI.updateSetting('cursor');
+                } else {
+                    UI.updateSetting('cursor', !UI.isTouchDevice);
+                    $D('noVNC_cursor').disabled = true;
+                }
+                UI.updateSetting('clip');
+                UI.updateSetting('shared');
+                UI.updateSetting('view_only');
+                UI.updateSetting('path');
+                UI.updateSetting('repeaterID');
+                UI.updateSetting('stylesheet');
+                UI.updateSetting('logging');
+
+                UI.openSettingsMenu();
+            }
+        },
+
+        // Open menu
+        openSettingsMenu: function() {
+            // Close the description panel
+            $D('noVNC_description').style.display = "none";
+            // Close clipboard panel if open
+            if (UI.clipboardOpen === true) {
+                UI.toggleClipboardPanel();
+            }
+            // Close connection settings if open
+            if (UI.connSettingsOpen === true) {
+                UI.toggleConnectPanel();
+            }
+            // Close popup status panel if open
+            if (UI.popupStatusOpen === true) {
+                UI.togglePopupStatusPanel();
+            }
+            // Close XVP panel if open
+            if (UI.xvpOpen === true) {
+                UI.toggleXvpPanel();
+            }
+            $D('noVNC_settings').style.display = "block";
+            $D('settingsButton').className = "noVNC_status_button_selected";
+            UI.settingsOpen = true;
+        },
+
+        // Close menu (without applying settings)
+        closeSettingsMenu: function() {
+            $D('noVNC_settings').style.display = "none";
+            $D('settingsButton').className = "noVNC_status_button";
+            UI.settingsOpen = false;
+        },
+
+        // Save/apply settings when 'Apply' button is pressed
+        settingsApply: function() {
+            //Util.Debug(">> settingsApply");
+            UI.saveSetting('encrypt');
+            UI.saveSetting('true_color');
+            if (UI.rfb.get_display().get_cursor_uri()) {
+                UI.saveSetting('cursor');
+            }
+            UI.saveSetting('clip');
+            UI.saveSetting('shared');
+            UI.saveSetting('view_only');
+            UI.saveSetting('path');
+            UI.saveSetting('repeaterID');
+            UI.saveSetting('stylesheet');
+            UI.saveSetting('logging');
+
+            // Settings with immediate (non-connected related) effect
+            WebUtil.selectStylesheet(UI.getSetting('stylesheet'));
+            WebUtil.init_logging(UI.getSetting('logging'));
+            UI.setViewClip();
+            UI.setViewDrag(UI.rfb.get_viewportDrag());
+            //Util.Debug("<< settingsApply");
+        },
+
+
+
+        setPassword: function() {
+            UI.rfb.sendPassword($D('noVNC_password').value);
+            //Reset connect button.
+            $D('noVNC_connect_button').value = "Connect";
+            $D('noVNC_connect_button').onclick = UI.Connect;
+            //Hide connection panel.
+            UI.toggleConnectPanel();
+            return false;
+        },
+
+        sendCtrlAltDel: function() {
+            UI.rfb.sendCtrlAltDel();
+        },
+
+        xvpShutdown: function() {
+            UI.rfb.xvpShutdown();
+        },
+
+        xvpReboot: function() {
+            UI.rfb.xvpReboot();
+        },
+
+        xvpReset: function() {
+            UI.rfb.xvpReset();
+        },
+
+        setMouseButton: function(num) {
+            if (typeof num === 'undefined') {
+                // Disable mouse buttons
+                num = -1;
+            }
+            if (UI.rfb) {
+                UI.rfb.get_mouse().set_touchButton(num);
+            }
+
+            var blist = [0, 1,2,4];
+            for (var b = 0; b < blist.length; b++) {
+                var button = $D('noVNC_mouse_button' + blist[b]);
+                if (blist[b] === num) {
+                    button.style.display = "";
+                } else {
+                    button.style.display = "none";
+                }
+            }
+        },
+
+        updateState: function(rfb, state, oldstate, msg) {
+            UI.rfb_state = state;
+            var klass;
+            switch (state) {
+                case 'failed':
+                case 'fatal':
+                    klass = "noVNC_status_error";
+                    break;
+                case 'normal':
+                    klass = "noVNC_status_normal";
+                    break;
+                case 'disconnected':
+                    $D('noVNC_logo').style.display = "block";
+                    /* falls through */
+                case 'loaded':
+                    klass = "noVNC_status_normal";
+                    break;
+                case 'password':
+                    UI.toggleConnectPanel();
+
+                    $D('noVNC_connect_button').value = "Send Password";
+                    $D('noVNC_connect_button').onclick = UI.setPassword;
+                    $D('noVNC_password').focus();
+
+                    klass = "noVNC_status_warn";
+                    break;
+                default:
+                    klass = "noVNC_status_warn";
+                    break;
+            }
+
+            if (typeof(msg) !== 'undefined') {
+                $D('noVNC-control-bar').setAttribute("class", klass);
+                $D('noVNC_status').innerHTML = msg;
+            }
+
+            UI.updateVisualState();
+        },
+
+        // Disable/enable controls depending on connection state
+        updateVisualState: function() {
+            var connected = UI.rfb_state === 'normal' ? true : false;
+
+            //Util.Debug(">> updateVisualState");
+            $D('noVNC_encrypt').disabled = connected;
+            $D('noVNC_true_color').disabled = connected;
+            if (UI.rfb && UI.rfb.get_display() &&
+                UI.rfb.get_display().get_cursor_uri()) {
+                $D('noVNC_cursor').disabled = connected;
+            } else {
+                UI.updateSetting('cursor', !UI.isTouchDevice);
+                $D('noVNC_cursor').disabled = true;
+            }
+            $D('noVNC_shared').disabled = connected;
+            $D('noVNC_view_only').disabled = connected;
+            $D('noVNC_path').disabled = connected;
+            $D('noVNC_repeaterID').disabled = connected;
+
+            if (connected) {
+                UI.setViewClip();
+                UI.setMouseButton(1);
+                $D('clipboardButton').style.display = "inline";
+                $D('showKeyboard').style.display = "inline";
+                $D('noVNC_extra_keys').style.display = "";
+                $D('sendCtrlAltDelButton').style.display = "inline";
+            } else {
+                UI.setMouseButton();
+                $D('clipboardButton').style.display = "none";
+                $D('showKeyboard').style.display = "none";
+                $D('noVNC_extra_keys').style.display = "none";
+                $D('sendCtrlAltDelButton').style.display = "none";
+                UI.updateXvpVisualState(0);
+            }
+
+            // State change disables viewport dragging.
+            // It is enabled (toggled) by direct click on the button
+            UI.setViewDrag(false);
+
+            switch (UI.rfb_state) {
+                case 'fatal':
+                case 'failed':
+                case 'loaded':
+                case 'disconnected':
+                    $D('connectButton').style.display = "";
+                    $D('disconnectButton').style.display = "none";
+                    break;
+                default:
+                    $D('connectButton').style.display = "none";
+                    $D('disconnectButton').style.display = "";
+                    break;
+            }
+
+            //Util.Debug("<< updateVisualState");
+        },
+
+        // Disable/enable XVP button
+        updateXvpVisualState: function(ver) {
+            if (ver >= 1) {
+                $D('xvpButton').style.display = 'inline';
+            } else {
+                $D('xvpButton').style.display = 'none';
+                // Close XVP panel if open
+                if (UI.xvpOpen === true) {
+                    UI.toggleXvpPanel();
+                }
+            }
+        },
+
+        // Display the desktop name in the document title
+        updateDocumentTitle: function(rfb, name) {
+            document.title = name + " - noVNC";
+        },
+
+        clipReceive: function(rfb, text) {
+            Util.Debug(">> UI.clipReceive: " + text.substr(0,40) + "...");
+            $D('noVNC_clipboard_text').value = text;
+            Util.Debug("<< UI.clipReceive");
+        },
+
+        connect: function() {
+            UI.closeSettingsMenu();
+            UI.toggleConnectPanel();
+
+            var host = $D('noVNC_host').value;
+            var port = $D('noVNC_port').value;
+            var password = $D('noVNC_password').value;
+            var path = $D('noVNC_path').value;
+            if ((!host) || (!port)) {
+                throw new Error("Must set host and port");
+            }
+
+            UI.rfb.set_encrypt(UI.getSetting('encrypt'));
+            UI.rfb.set_true_color(UI.getSetting('true_color'));
+            UI.rfb.set_local_cursor(UI.getSetting('cursor'));
+            UI.rfb.set_shared(UI.getSetting('shared'));
+            UI.rfb.set_view_only(UI.getSetting('view_only'));
+            UI.rfb.set_repeaterID(UI.getSetting('repeaterID'));
+
+            UI.rfb.connect(host, port, password, path);
+
+            //Close dialog.
+            setTimeout(UI.setBarPosition, 100);
+            $D('noVNC_logo').style.display = "none";
+        },
+
+        disconnect: function() {
+            UI.closeSettingsMenu();
+            UI.rfb.disconnect();
+
+            $D('noVNC_logo').style.display = "block";
+            UI.connSettingsOpen = false;
+            UI.toggleConnectPanel();
+        },
+
+        displayBlur: function() {
+            UI.rfb.get_keyboard().set_focused(false);
+            UI.rfb.get_mouse().set_focused(false);
+        },
+
+        displayFocus: function() {
+            UI.rfb.get_keyboard().set_focused(true);
+            UI.rfb.get_mouse().set_focused(true);
+        },
+
+        clipClear: function() {
+            $D('noVNC_clipboard_text').value = "";
+            UI.rfb.clipboardPasteFrom("");
+        },
+
+        clipSend: function() {
+            var text = $D('noVNC_clipboard_text').value;
+            Util.Debug(">> UI.clipSend: " + text.substr(0,40) + "...");
+            UI.rfb.clipboardPasteFrom(text);
+            Util.Debug("<< UI.clipSend");
+        },
+
+        // Enable/disable and configure viewport clipping
+        setViewClip: function(clip) {
+            var display;
+            if (UI.rfb) {
+                display = UI.rfb.get_display();
+            } else {
+                return;
+            }
+
+            var cur_clip = display.get_viewport();
+
+            if (typeof(clip) !== 'boolean') {
+                // Use current setting
+                clip = UI.getSetting('clip');
+            }
+
+            if (clip && !cur_clip) {
+                // Turn clipping on
+                UI.updateSetting('clip', true);
+            } else if (!clip && cur_clip) {
+                // Turn clipping off
+                UI.updateSetting('clip', false);
+                display.set_viewport(false);
+                $D('noVNC_canvas').style.position = 'static';
+                display.viewportChange();
+            }
+            if (UI.getSetting('clip')) {
+                // If clipping, update clipping settings
+                $D('noVNC_canvas').style.position = 'absolute';
+                var pos = Util.getPosition($D('noVNC_canvas'));
+                var new_w = window.innerWidth - pos.x;
+                var new_h = window.innerHeight - pos.y;
+                display.set_viewport(true);
+                display.viewportChange(0, 0, new_w, new_h);
+            }
+        },
+
+        // Toggle/set/unset the viewport drag/move button
+        setViewDrag: function(drag) {
+            var vmb = $D('noVNC_view_drag_button');
+            if (!UI.rfb) { return; }
+
+            if (UI.rfb_state === 'normal' &&
+                UI.rfb.get_display().get_viewport()) {
+                vmb.style.display = "inline";
+            } else {
+                vmb.style.display = "none";
+            }
+
+            if (typeof(drag) === "undefined" ||
+                typeof(drag) === "object") {
+                // If not specified, then toggle
+                drag = !UI.rfb.get_viewportDrag();
+            }
+            if (drag) {
+                vmb.className = "noVNC_status_button_selected";
+                UI.rfb.set_viewportDrag(true);
+            } else {
+                vmb.className = "noVNC_status_button";
+                UI.rfb.set_viewportDrag(false);
+            }
+        },
+
+        // On touch devices, show the OS keyboard
+        showKeyboard: function() {
+            var kbi = $D('keyboardinput');
+            var skb = $D('showKeyboard');
+            var l = kbi.value.length;
+            if(UI.keyboardVisible === false) {
+                kbi.focus();
+                try { kbi.setSelectionRange(l, l); } // Move the caret to the end
+                catch (err) {} // setSelectionRange is undefined in Google Chrome
+                UI.keyboardVisible = true;
+                skb.className = "noVNC_status_button_selected";
+            } else if(UI.keyboardVisible === true) {
+                kbi.blur();
+                skb.className = "noVNC_status_button";
+                UI.keyboardVisible = false;
+            }
+        },
+
+        keepKeyboard: function() {
+            clearTimeout(UI.hideKeyboardTimeout);
+            if(UI.keyboardVisible === true) {
+                $D('keyboardinput').focus();
+                $D('showKeyboard').className = "noVNC_status_button_selected";
+            } else if(UI.keyboardVisible === false) {
+                $D('keyboardinput').blur();
+                $D('showKeyboard').className = "noVNC_status_button";
+            }
+        },
+
+        keyboardinputReset: function() {
+            var kbi = $D('keyboardinput');
+            kbi.value = new Array(UI.defaultKeyboardinputLen).join("_");
+            UI.lastKeyboardinput = kbi.value;
+        },
+
+        // When normal keyboard events are left uncought, use the input events from
+        // the keyboardinput element instead and generate the corresponding key events.
+        // This code is required since some browsers on Android are inconsistent in
+        // sending keyCodes in the normal keyboard events when using on screen keyboards.
+        keyInput: function(event) {
+            var newValue = event.target.value;
+            var oldValue = UI.lastKeyboardinput;
+
+            var newLen;
+            try {
+                // Try to check caret position since whitespace at the end
+                // will not be considered by value.length in some browsers
+                newLen = Math.max(event.target.selectionStart, newValue.length);
+            } catch (err) {
+                // selectionStart is undefined in Google Chrome
+                newLen = newValue.length;
+            }
+            var oldLen = oldValue.length;
+
+            var backspaces;
+            var inputs = newLen - oldLen;
+            if (inputs < 0) {
+                backspaces = -inputs;
+            } else {
+                backspaces = 0;
+            }
+
+            // Compare the old string with the new to account for
+            // text-corrections or other input that modify existing text
+            var i;
+            for (i = 0; i < Math.min(oldLen, newLen); i++) {
+                if (newValue.charAt(i) != oldValue.charAt(i)) {
+                    inputs = newLen - i;
+                    backspaces = oldLen - i;
+                    break;
+                }
+            }
+
+            // Send the key events
+            for (i = 0; i < backspaces; i++) {
+                UI.rfb.sendKey(XK_BackSpace);
+            }
+            for (i = newLen - inputs; i < newLen; i++) {
+                UI.rfb.sendKey(newValue.charCodeAt(i));
+            }
+
+            // Control the text content length in the keyboardinput element
+            if (newLen > 2 * UI.defaultKeyboardinputLen) {
+                UI.keyboardinputReset();
+            } else if (newLen < 1) {
+                // There always have to be some text in the keyboardinput
+                // element with which backspace can interact.
+                UI.keyboardinputReset();
+                // This sometimes causes the keyboard to disappear for a second
+                // but it is required for the android keyboard to recognize that
+                // text has been added to the field
+                event.target.blur();
+                // This has to be ran outside of the input handler in order to work
+                setTimeout(function() { UI.keepKeyboard(); }, 0);
+            } else {
+                UI.lastKeyboardinput = newValue;
+            }
+        },
+
+        keyInputBlur: function() {
+            $D('showKeyboard').className = "noVNC_status_button";
+            //Weird bug in iOS if you change keyboardVisible
+            //here it does not actually occur so next time
+            //you click keyboard icon it doesnt work.
+            UI.hideKeyboardTimeout = setTimeout(function() { UI.setKeyboard(); },100);
+        },
+
+        showExtraKeys: function() {
+            UI.keepKeyboard();
+            if(UI.extraKeysVisible === false) {
+                $D('toggleCtrlButton').style.display = "inline";
+                $D('toggleAltButton').style.display = "inline";
+                $D('sendTabButton').style.display = "inline";
+                $D('sendEscButton').style.display = "inline";
+                $D('showExtraKeysButton').className = "noVNC_status_button_selected";
+                UI.extraKeysVisible = true;
+            } else if(UI.extraKeysVisible === true) {
+                $D('toggleCtrlButton').style.display = "";
+                $D('toggleAltButton').style.display = "";
+                $D('sendTabButton').style.display = "";
+                $D('sendEscButton').style.display = "";
+                $D('showExtraKeysButton').className = "noVNC_status_button";
+                UI.extraKeysVisible = false;
+            }
+        },
+
+        toggleCtrl: function() {
+            UI.keepKeyboard();
+            if(UI.ctrlOn === false) {
+                UI.rfb.sendKey(XK_Control_L, true);
+                $D('toggleCtrlButton').className = "noVNC_status_button_selected";
+                UI.ctrlOn = true;
+            } else if(UI.ctrlOn === true) {
+                UI.rfb.sendKey(XK_Control_L, false);
+                $D('toggleCtrlButton').className = "noVNC_status_button";
+                UI.ctrlOn = false;
+            }
+        },
+
+        toggleAlt: function() {
+            UI.keepKeyboard();
+            if(UI.altOn === false) {
+                UI.rfb.sendKey(XK_Alt_L, true);
+                $D('toggleAltButton').className = "noVNC_status_button_selected";
+                UI.altOn = true;
+            } else if(UI.altOn === true) {
+                UI.rfb.sendKey(XK_Alt_L, false);
+                $D('toggleAltButton').className = "noVNC_status_button";
+                UI.altOn = false;
+            }
+        },
+
+        sendTab: function() {
+            UI.keepKeyboard();
+            UI.rfb.sendKey(XK_Tab);
+        },
+
+        sendEsc: function() {
+            UI.keepKeyboard();
+            UI.rfb.sendKey(XK_Escape);
+        },
+
+        setKeyboard: function() {
+            UI.keyboardVisible = false;
+        },
+
+        // iOS < Version 5 does not support position fixed. Javascript workaround:
+        setOnscroll: function() {
+            window.onscroll = function() {
+                UI.setBarPosition();
+            };
+        },
+
+        setResize: function () {
+            window.onResize = function() {
+                UI.setBarPosition();
+            };
+        },
+
+        //Helper to add options to dropdown.
+        addOption: function(selectbox, text, value) {
+            var optn = document.createElement("OPTION");
+            optn.text = text;
+            optn.value = value;
+            selectbox.options.add(optn);
+        },
+
+        setBarPosition: function() {
+            $D('noVNC-control-bar').style.top = (window.pageYOffset) + 'px';
+            $D('noVNC_mobile_buttons').style.left = (window.pageXOffset) + 'px';
+
+            var vncwidth = $D('noVNC_screen').style.offsetWidth;
+            $D('noVNC-control-bar').style.width = vncwidth + 'px';
+        }
+
+    };
+})();
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/util.js
@@ -0,0 +1,656 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2012 Joel Martin
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+/* jshint white: false, nonstandard: true */
+/*global window, console, document, navigator, ActiveXObject, INCLUDE_URI */
+
+// Globals defined here
+var Util = {};
+
+
+/*
+ * Make arrays quack
+ */
+
+var addFunc = function (cl, name, func) {
+    if (!cl.prototype[name]) {
+        Object.defineProperty(cl.prototype, name, { enumerable: false, value: func });
+    }
+};
+
+addFunc(Array, 'push8', function (num) {
+    "use strict";
+    this.push(num & 0xFF);
+});
+
+addFunc(Array, 'push16', function (num) {
+    "use strict";
+    this.push((num >> 8) & 0xFF,
+              num & 0xFF);
+});
+
+addFunc(Array, 'push32', function (num) {
+    "use strict";
+    this.push((num >> 24) & 0xFF,
+              (num >> 16) & 0xFF,
+              (num >>  8) & 0xFF,
+              num & 0xFF);
+});
+
+// IE does not support map (even in IE9)
+//This prototype is provided by the Mozilla foundation and
+//is distributed under the MIT license.
+//http://www.ibiblio.org/pub/Linux/LICENSES/mit.license
+addFunc(Array, 'map', function (fun /*, thisp*/) {
+    "use strict";
+    var len = this.length;
+    if (typeof fun != "function") {
+        throw new TypeError();
+    }
+
+    var res = new Array(len);
+    var thisp = arguments[1];
+    for (var i = 0; i < len; i++) {
+        if (i in this) {
+            res[i] = fun.call(thisp, this[i], i, this);
+        }
+    }
+
+    return res;
+});
+
+// IE <9 does not support indexOf
+//This prototype is provided by the Mozilla foundation and
+//is distributed under the MIT license.
+//http://www.ibiblio.org/pub/Linux/LICENSES/mit.license
+addFunc(Array, 'indexOf', function (elt /*, from*/) {
+    "use strict";
+    var len = this.length >>> 0;
+
+    var from = Number(arguments[1]) || 0;
+    from = (from < 0) ? Math.ceil(from) : Math.floor(from);
+    if (from < 0) {
+        from += len;
+    }
+
+    for (; from < len; from++) {
+        if (from in this &&
+                this[from] === elt) {
+            return from;
+        }
+    }
+    return -1;
+});
+
+// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
+if (!Object.keys) {
+    Object.keys = (function () {
+        'use strict';
+        var hasOwnProperty = Object.prototype.hasOwnProperty,
+            hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
+            dontEnums = [
+                'toString',
+                'toLocaleString',
+                'valueOf',
+                'hasOwnProperty',
+                'isPrototypeOf',
+                'propertyIsEnumerable',
+                'constructor'
+            ],
+            dontEnumsLength = dontEnums.length;
+
+        return function (obj) {
+            if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
+                throw new TypeError('Object.keys called on non-object');
+            }
+
+            var result = [], prop, i;
+
+            for (prop in obj) {
+                if (hasOwnProperty.call(obj, prop)) {
+                    result.push(prop);
+                }
+            }
+
+            if (hasDontEnumBug) {
+                for (i = 0; i < dontEnumsLength; i++) {
+                    if (hasOwnProperty.call(obj, dontEnums[i])) {
+                        result.push(dontEnums[i]);
+                    }
+                }
+            }
+            return result;
+        };
+    })();
+}
+
+// PhantomJS 1.x doesn't support bind,
+// so leave this in until PhantomJS 2.0 is released
+//This prototype is provided by the Mozilla foundation and
+//is distributed under the MIT license.
+//http://www.ibiblio.org/pub/Linux/LICENSES/mit.license
+addFunc(Function, 'bind', function (oThis) {
+    if (typeof this !== "function") {
+        // closest thing possible to the ECMAScript 5
+        // internal IsCallable function
+        throw new TypeError("Function.prototype.bind - " +
+                            "what is trying to be bound is not callable");
+    }
+
+    var aArgs = Array.prototype.slice.call(arguments, 1),
+            fToBind = this,
+            fNOP = function () {},
+            fBound = function () {
+                return fToBind.apply(this instanceof fNOP && oThis ? this
+                                                                   : oThis,
+                                     aArgs.concat(Array.prototype.slice.call(arguments)));
+            };
+
+    fNOP.prototype = this.prototype;
+    fBound.prototype = new fNOP();
+
+    return fBound;
+});
+
+//
+// requestAnimationFrame shim with setTimeout fallback
+//
+
+window.requestAnimFrame = (function () {
+    "use strict";
+    return  window.requestAnimationFrame       ||
+            window.webkitRequestAnimationFrame ||
+            window.mozRequestAnimationFrame    ||
+            window.oRequestAnimationFrame      ||
+            window.msRequestAnimationFrame     ||
+            function (callback) {
+                window.setTimeout(callback, 1000 / 60);
+            };
+})();
+
+/*
+ * ------------------------------------------------------
+ * Namespaced in Util
+ * ------------------------------------------------------
+ */
+
+/*
+ * Logging/debug routines
+ */
+
+Util._log_level = 'warn';
+Util.init_logging = function (level) {
+    "use strict";
+    if (typeof level === 'undefined') {
+        level = Util._log_level;
+    } else {
+        Util._log_level = level;
+    }
+    if (typeof window.console === "undefined") {
+        if (typeof window.opera !== "undefined") {
+            window.console = {
+                'log'  : window.opera.postError,
+                'warn' : window.opera.postError,
+                'error': window.opera.postError
+            };
+        } else {
+            window.console = {
+                'log'  : function (m) {},
+                'warn' : function (m) {},
+                'error': function (m) {}
+            };
+        }
+    }
+
+    Util.Debug = Util.Info = Util.Warn = Util.Error = function (msg) {};
+    /* jshint -W086 */
+    switch (level) {
+        case 'debug':
+            Util.Debug = function (msg) { console.log(msg); };
+        case 'info':
+            Util.Info  = function (msg) { console.log(msg); };
+        case 'warn':
+            Util.Warn  = function (msg) { console.warn(msg); };
+        case 'error':
+            Util.Error = function (msg) { console.error(msg); };
+        case 'none':
+            break;
+        default:
+            throw new Error("invalid logging type '" + level + "'");
+    }
+    /* jshint +W086 */
+};
+Util.get_logging = function () {
+    return Util._log_level;
+};
+// Initialize logging level
+Util.init_logging();
+
+Util.make_property = function (proto, name, mode, type) {
+    "use strict";
+
+    var getter;
+    if (type === 'arr') {
+        getter = function (idx) {
+            if (typeof idx !== 'undefined') {
+                return this['_' + name][idx];
+            } else {
+                return this['_' + name];
+            }
+        };
+    } else {
+        getter = function () {
+            return this['_' + name];
+        };
+    }
+
+    var make_setter = function (process_val) {
+        if (process_val) {
+            return function (val, idx) {
+                if (typeof idx !== 'undefined') {
+                    this['_' + name][idx] = process_val(val);
+                } else {
+                    this['_' + name] = process_val(val);
+                }
+            };
+        } else {
+            return function (val, idx) {
+                if (typeof idx !== 'undefined') {
+                    this['_' + name][idx] = val;
+                } else {
+                    this['_' + name] = val;
+                }
+            };
+        }
+    };
+
+    var setter;
+    if (type === 'bool') {
+        setter = make_setter(function (val) {
+            if (!val || (val in {'0': 1, 'no': 1, 'false': 1})) {
+                return false;
+            } else {
+                return true;
+            }
+        });
+    } else if (type === 'int') {
+        setter = make_setter(function (val) { return parseInt(val, 10); });
+    } else if (type === 'float') {
+        setter = make_setter(parseFloat);
+    } else if (type === 'str') {
+        setter = make_setter(String);
+    } else if (type === 'func') {
+        setter = make_setter(function (val) {
+            if (!val) {
+                return function () {};
+            } else {
+                return val;
+            }
+        });
+    } else if (type === 'arr' || type === 'dom' || type == 'raw') {
+        setter = make_setter();
+    } else {
+        throw new Error('Unknown property type ' + type);  // some sanity checking
+    }
+
+    // set the getter
+    if (typeof proto['get_' + name] === 'undefined') {
+        proto['get_' + name] = getter;
+    }
+
+    // set the setter if needed
+    if (typeof proto['set_' + name] === 'undefined') {
+        if (mode === 'rw') {
+            proto['set_' + name] = setter;
+        } else if (mode === 'wo') {
+            proto['set_' + name] = function (val, idx) {
+                if (typeof this['_' + name] !== 'undefined') {
+                    throw new Error(name + " can only be set once");
+                }
+                setter.call(this, val, idx);
+            };
+        }
+    }
+
+    // make a special setter that we can use in set defaults
+    proto['_raw_set_' + name] = function (val, idx) {
+        setter.call(this, val, idx);
+        //delete this['_init_set_' + name];  // remove it after use
+    };
+};
+
+Util.make_properties = function (constructor, arr) {
+    "use strict";
+    for (var i = 0; i < arr.length; i++) {
+        Util.make_property(constructor.prototype, arr[i][0], arr[i][1], arr[i][2]);
+    }
+};
+
+Util.set_defaults = function (obj, conf, defaults) {
+    var defaults_keys = Object.keys(defaults);
+    var conf_keys = Object.keys(conf);
+    var keys_obj = {};
+    var i;
+    for (i = 0; i < defaults_keys.length; i++) { keys_obj[defaults_keys[i]] = 1; }
+    for (i = 0; i < conf_keys.length; i++) { keys_obj[conf_keys[i]] = 1; }
+    var keys = Object.keys(keys_obj);
+
+    for (i = 0; i < keys.length; i++) {
+        var setter = obj['_raw_set_' + keys[i]];
+        if (!setter) {
+          Util.Warn('Invalid property ' + keys[i]);
+          continue;
+        }
+
+        if (keys[i] in conf) {
+            setter.call(obj, conf[keys[i]]);
+        } else {
+            setter.call(obj, defaults[keys[i]]);
+        }
+    }
+};
+
+/*
+ * Decode from UTF-8
+ */
+Util.decodeUTF8 = function (utf8string) {
+    "use strict";
+    return decodeURIComponent(escape(utf8string));
+};
+
+
+
+/*
+ * Cross-browser routines
+ */
+
+
+// Dynamically load scripts without using document.write()
+// Reference: http://unixpapa.com/js/dyna.html
+//
+// Handles the case where load_scripts is invoked from a script that
+// itself is loaded via load_scripts. Once all scripts are loaded the
+// window.onscriptsloaded handler is called (if set).
+Util.get_include_uri = function () {
+    return (typeof INCLUDE_URI !== "undefined") ? INCLUDE_URI : "include/";
+};
+Util._loading_scripts = [];
+Util._pending_scripts = [];
+Util.load_scripts = function (files) {
+    "use strict";
+    var head = document.getElementsByTagName('head')[0], script,
+        ls = Util._loading_scripts, ps = Util._pending_scripts;
+
+    var loadFunc = function (e) {
+        while (ls.length > 0 && (ls[0].readyState === 'loaded' ||
+                                 ls[0].readyState === 'complete')) {
+            // For IE, append the script to trigger execution
+            var s = ls.shift();
+            //console.log("loaded script: " + s.src);
+            head.appendChild(s);
+        }
+        if (!this.readyState ||
+            (Util.Engine.presto && this.readyState === 'loaded') ||
+            this.readyState === 'complete') {
+            if (ps.indexOf(this) >= 0) {
+                this.onload = this.onreadystatechange = null;
+                //console.log("completed script: " + this.src);
+                ps.splice(ps.indexOf(this), 1);
+
+                // Call window.onscriptsload after last script loads
+                if (ps.length === 0 && window.onscriptsload) {
+                    window.onscriptsload();
+                }
+            }
+        }
+    };
+
+    for (var f = 0; f < files.length; f++) {
+        script = document.createElement('script');
+        script.type = 'text/javascript';
+        script.src = Util.get_include_uri() + files[f];
+        //console.log("loading script: " + script.src);
+        script.onload = script.onreadystatechange = loadFunc;
+        // In-order script execution tricks
+        if (Util.Engine.trident) {
+            // For IE wait until readyState is 'loaded' before
+            // appending it which will trigger execution
+            // http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
+            ls.push(script);
+        } else {
+            // For webkit and firefox set async=false and append now
+            // https://developer.mozilla.org/en-US/docs/HTML/Element/script
+            script.async = false;
+            head.appendChild(script);
+        }
+        ps.push(script);
+    }
+};
+
+
+// Get DOM element position on page
+//  This solution is based based on http://www.greywyvern.com/?post=331
+//  Thanks to Brian Huisman AKA GreyWyvern!
+Util.getPosition = (function () {
+    "use strict";
+    function getStyle(obj, styleProp) {
+        var y;
+        if (obj.currentStyle) {
+            y = obj.currentStyle[styleProp];
+        } else if (window.getComputedStyle)
+            y = window.getComputedStyle(obj, null)[styleProp];
+        return y;
+    }
+
+    function scrollDist() {
+        var myScrollTop = 0, myScrollLeft = 0;
+        var html = document.getElementsByTagName('html')[0];
+
+        // get the scrollTop part
+        if (html.scrollTop && document.documentElement.scrollTop) {
+            myScrollTop = html.scrollTop;
+        } else if (html.scrollTop || document.documentElement.scrollTop) {
+            myScrollTop = html.scrollTop + document.documentElement.scrollTop;
+        } else if (document.body.scrollTop) {
+            myScrollTop = document.body.scrollTop;
+        } else {
+            myScrollTop = 0;
+        }
+
+        // get the scrollLeft part
+        if (html.scrollLeft && document.documentElement.scrollLeft) {
+            myScrollLeft = html.scrollLeft;
+        } else if (html.scrollLeft || document.documentElement.scrollLeft) {
+            myScrollLeft = html.scrollLeft + document.documentElement.scrollLeft;
+        } else if (document.body.scrollLeft) {
+            myScrollLeft = document.body.scrollLeft;
+        } else {
+            myScrollLeft = 0;
+        }
+
+        return [myScrollLeft, myScrollTop];
+    }
+
+    return function (obj) {
+        var curleft = 0, curtop = 0, scr = obj, fixed = false;
+        while ((scr = scr.parentNode) && scr != document.body) {
+            curleft -= scr.scrollLeft || 0;
+            curtop -= scr.scrollTop || 0;
+            if (getStyle(scr, "position") == "fixed") {
+                fixed = true;
+            }
+        }
+        if (fixed && !window.opera) {
+            var scrDist = scrollDist();
+            curleft += scrDist[0];
+            curtop += scrDist[1];
+        }
+
+        do {
+            curleft += obj.offsetLeft;
+            curtop += obj.offsetTop;
+        } while ((obj = obj.offsetParent));
+
+        return {'x': curleft, 'y': curtop};
+    };
+})();
+
+
+// Get mouse event position in DOM element
+Util.getEventPosition = function (e, obj, scale) {
+    "use strict";
+    var evt, docX, docY, pos;
+    //if (!e) evt = window.event;
+    evt = (e ? e : window.event);
+    evt = (evt.changedTouches ? evt.changedTouches[0] : evt.touches ? evt.touches[0] : evt);
+    if (evt.pageX || evt.pageY) {
+        docX = evt.pageX;
+        docY = evt.pageY;
+    } else if (evt.clientX || evt.clientY) {
+        docX = evt.clientX + document.body.scrollLeft +
+            document.documentElement.scrollLeft;
+        docY = evt.clientY + document.body.scrollTop +
+            document.documentElement.scrollTop;
+    }
+    pos = Util.getPosition(obj);
+    if (typeof scale === "undefined") {
+        scale = 1;
+    }
+    var realx = docX - pos.x;
+    var realy = docY - pos.y;
+    var x = Math.max(Math.min(realx, obj.width - 1), 0);
+    var y = Math.max(Math.min(realy, obj.height - 1), 0);
+    return {'x': x / scale, 'y': y / scale, 'realx': realx / scale, 'realy': realy / scale};
+};
+
+
+// Event registration. Based on: http://www.scottandrew.com/weblog/articles/cbs-events
+Util.addEvent = function (obj, evType, fn) {
+    "use strict";
+    if (obj.attachEvent) {
+        var r = obj.attachEvent("on" + evType, fn);
+        return r;
+    } else if (obj.addEventListener) {
+        obj.addEventListener(evType, fn, false);
+        return true;
+    } else {
+        throw new Error("Handler could not be attached");
+    }
+};
+
+Util.removeEvent = function (obj, evType, fn) {
+    "use strict";
+    if (obj.detachEvent) {
+        var r = obj.detachEvent("on" + evType, fn);
+        return r;
+    } else if (obj.removeEventListener) {
+        obj.removeEventListener(evType, fn, false);
+        return true;
+    } else {
+        throw new Error("Handler could not be removed");
+    }
+};
+
+Util.stopEvent = function (e) {
+    "use strict";
+    if (e.stopPropagation) { e.stopPropagation(); }
+    else                   { e.cancelBubble = true; }
+
+    if (e.preventDefault)  { e.preventDefault(); }
+    else                   { e.returnValue = false; }
+};
+
+
+// Set browser engine versions. Based on mootools.
+Util.Features = {xpath: !!(document.evaluate), air: !!(window.runtime), query: !!(document.querySelector)};
+
+(function () {
+    "use strict";
+    // 'presto': (function () { return (!window.opera) ? false : true; }()),
+    var detectPresto = function () {
+        return !!window.opera;
+    };
+
+    // 'trident': (function () { return (!window.ActiveXObject) ? false : ((window.XMLHttpRequest) ? ((document.querySelectorAll) ? 6 : 5) : 4);
+    var detectTrident = function () {
+        if (!window.ActiveXObject) {
+            return false;
+        } else {
+            if (window.XMLHttpRequest) {
+                return (document.querySelectorAll) ? 6 : 5;
+            } else {
+                return 4;
+            }
+        }
+    };
+
+    // 'webkit': (function () { try { return (navigator.taintEnabled) ? false : ((Util.Features.xpath) ? ((Util.Features.query) ? 525 : 420) : 419); } catch (e) { return false; } }()),
+    var detectInitialWebkit = function () {
+        try {
+            if (navigator.taintEnabled) {
+                return false;
+            } else {
+                if (Util.Features.xpath) {
+                    return (Util.Features.query) ? 525 : 420;
+                } else {
+                    return 419;
+                }
+            }
+        } catch (e) {
+            return false;
+        }
+    };
+
+    var detectActualWebkit = function (initial_ver) {
+        var re = /WebKit\/([0-9\.]*) /;
+        var str_ver = (navigator.userAgent.match(re) || ['', initial_ver])[1];
+        return parseFloat(str_ver, 10);
+    };
+
+    // 'gecko': (function () { return (!document.getBoxObjectFor && window.mozInnerScreenX == null) ? false : ((document.getElementsByClassName) ? 19ssName) ? 19 : 18 : 18); }())
+    var detectGecko = function () {
+        /* jshint -W041 */
+        if (!document.getBoxObjectFor && window.mozInnerScreenX == null) {
+            return false;
+        } else {
+            return (document.getElementsByClassName) ? 19 : 18;
+        }
+        /* jshint +W041 */
+    };
+
+    Util.Engine = {
+        // Version detection break in Opera 11.60 (errors on arguments.callee.caller reference)
+        //'presto': (function() {
+        //         return (!window.opera) ? false : ((arguments.callee.caller) ? 960 : ((document.getElementsByClassName) ? 950 : 925)); }()),
+        'presto': detectPresto(),
+        'trident': detectTrident(),
+        'webkit': detectInitialWebkit(),
+        'gecko': detectGecko(),
+    };
+
+    if (Util.Engine.webkit) {
+        // Extract actual webkit version if available
+        Util.Engine.webkit = detectActualWebkit(Util.Engine.webkit);
+    }
+})();
+
+Util.Flash = (function () {
+    "use strict";
+    var v, version;
+    try {
+        v = navigator.plugins['Shockwave Flash'].description;
+    } catch (err1) {
+        try {
+            v = new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version');
+        } catch (err2) {
+            v = '0 r0';
+        }
+    }
+    version = v.match(/\d+/g);
+    return {version: parseInt(version[0] || 0 + '.' + version[1], 10) || 0, build: parseInt(version[2], 10) || 0};
+}());
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/web-socket-js/README.txt
@@ -0,0 +1,109 @@
+* How to try
+
+Assuming you have Web server (e.g. Apache) running at http://example.com/ .
+
+- Download web_socket.rb from:
+  http://github.com/gimite/web-socket-ruby/tree/master
+- Run sample Web Socket server (echo server) in example.com with: (#1)
+  $ ruby web-socket-ruby/samples/echo_server.rb example.com 10081
+- If your server already provides socket policy file at port 843, modify the file to allow access to port 10081. Otherwise you can skip this step. See below for details.
+- Publish the web-socket-js directory with your Web server (e.g. put it in ~/public_html).
+- Change ws://localhost:10081 to ws://example.com:10081 in sample.html.
+- Open sample.html in your browser.
+- After "onopen" is shown, input something, click [Send] and confirm echo back.
+
+#1: First argument of echo_server.rb means that it accepts Web Socket connection from HTML pages in example.com.
+
+
+* Troubleshooting
+
+If it doesn't work, try these:
+
+1. Try Chrome and Firefox 3.x.
+- It doesn't work on Chrome:
+-- It's likely an issue of your code or the server. Debug your code as usual e.g. using console.log.
+- It works on Chrome but it doesn't work on Firefox:
+-- It's likely an issue of web-socket-js specific configuration (e.g. 3 and 4 below).
+- It works on both Chrome and Firefox, but it doesn't work on your browser:
+-- Check "Supported environment" section below. Your browser may not be supported by web-socket-js.
+
+2. Add this line before your code:
+  WEB_SOCKET_DEBUG = true;
+and use Developer Tools (Chrome/Safari) or Firebug (Firefox) to see if console.log outputs any errors.
+
+3. Make sure you do NOT open your HTML page as local file e.g. file:///.../sample.html. web-socket-js doesn't work on local file. Open it via Web server e.g. http:///.../sample.html.
+
+4. If you are NOT using web-socket-ruby as your WebSocket server, you need to place Flash socket policy file on your server. See "Flash socket policy file" section below for details.
+
+5. Check if sample.html bundled with web-socket-js works.
+
+6. Make sure the port used for WebSocket (10081 in example above) is not blocked by your server/client's firewall.
+
+7. Install debugger version of Flash Player available here to see Flash errors:
+http://www.adobe.com/support/flashplayer/downloads.html
+
+
+* Supported environments
+
+It should work on:
+- Google Chrome 4 or later (just uses native implementation)
+- Firefox 3.x, Internet Explorer 8 + Flash Player 9 or later
+
+It may or may not work on other browsers such as Safari, Opera or IE 6. Patch for these browsers are appreciated, but I will not work on fixing issues specific to these browsers by myself.
+
+
+* Flash socket policy file
+
+This implementation uses Flash's socket, which means that your server must provide Flash socket policy file to declare the server accepts connections from Flash.
+
+If you use web-socket-ruby available at
+http://github.com/gimite/web-socket-ruby/tree/master
+, you don't need anything special, because web-socket-ruby handles Flash socket policy file request. But if you already provide socket policy file at port 843, you need to modify the file to allow access to Web Socket port, because it precedes what web-socket-ruby provides.
+
+If you use other Web Socket server implementation, you need to provide socket policy file yourself. See
+http://www.lightsphere.com/dev/articles/flash_socket_policy.html
+for details and sample script to run socket policy file server. node.js implementation is available here:
+http://github.com/LearnBoost/Socket.IO-node/blob/master/lib/socket.io/transports/flashsocket.js
+
+Actually, it's still better to provide socket policy file at port 843 even if you use web-socket-ruby. Flash always try to connect to port 843 first, so providing the file at port 843 makes startup faster.
+
+
+* Cookie considerations
+
+Cookie is sent if Web Socket host is the same as the origin of JavaScript. Otherwise it is not sent, because I don't know way to send right Cookie (which is Cookie of the host of Web Socket, I heard).
+
+Note that it's technically possible that client sends arbitrary string as Cookie and any other headers (by modifying this library for example) once you place Flash socket policy file in your server. So don't trust Cookie and other headers if you allow connection from untrusted origin.
+
+
+* Proxy considerations
+
+The WebSocket spec (http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol) specifies instructions for User Agents to support proxied connections by implementing the HTTP CONNECT method.
+
+The AS3 Socket class doesn't implement this mechanism, which renders it useless for the scenarios where the user trying to open a socket is behind a proxy. 
+
+The class RFC2817Socket (by Christian Cantrell) effectively lets us implement this, as long as the proxy settings are known and provided by the interface that instantiates the WebSocket. As such, if you want to support proxied conncetions, you'll have to supply this information to the WebSocket constructor when Flash is being used. One way to go about it would be to ask the user for proxy settings information if the initial connection fails.
+
+
+* How to host HTML file and SWF file in different domains
+
+By default, HTML file and SWF file must be in the same domain. You can follow steps below to allow hosting them in different domain.
+
+WARNING: If you use the method below, HTML files in ANY domains can send arbitrary TCP data to your WebSocket server, regardless of configuration in Flash socket policy file. Arbitrary TCP data means that they can even fake request headers including Origin and Cookie.
+
+- Unzip WebSocketMainInsecure.zip to extract WebSocketMainInsecure.swf.
+- Put WebSocketMainInsecure.swf on your server, instead of WebSocketMain.swf.
+- In JavaScript, set WEB_SOCKET_SWF_LOCATION to URL of your WebSocketMainInsecure.swf.
+
+
+* How to build WebSocketMain.swf
+
+Install Flex 4 SDK:
+http://opensource.adobe.com/wiki/display/flexsdk/Download+Flex+4
+
+$ cd flash-src
+$ ./build.sh
+
+
+* License
+
+New BSD License.
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/web-socket-js/swfobject.js
@@ -0,0 +1,4 @@
+/*	SWFObject v2.2 <http://code.google.com/p/swfobject/> 
+	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php> 
+*/
+var swfobject=function(){var D="undefined",r="object",S="Shockwave Flash",W="ShockwaveFlash.ShockwaveFlash",q="application/x-shockwave-flash",R="SWFObjectExprInst",x="onreadystatechange",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):false,X=!+"\v1",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\s+(\S+\s+\S+$)/,"$1");ag[0]=parseInt(ab.replace(/^(.*)\..*$/,"$1"),10);ag[1]=parseInt(ab.replace(/^.*\.(.*)\s.*$/,"$1"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,"$1"),10):0}}else{if(typeof O.ActiveXObject!=D){try{var ad=new ActiveXObject(W);if(ad){ab=ad.GetVariable("$version");if(ab){X=true;ab=ab.split(" ")[1].split(",");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState=="complete")||(typeof j.readyState==D&&(j.getElementsByTagName("body")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener("DOMContentLoaded",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState=="complete"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll("left")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName("body")[0].appendChild(C("span"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener("load",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener("load",Y,false)}else{if(typeof O.attachEvent!=D){i(O,"onload",Y)}else{if(typeof O.onload=="function"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName("body")[0];var aa=C(r);aa.setAttribute("type",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable("$version");if(ab){ab=ab.split(" ")[1].split(",");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute("width")||"0";ai.height=ae.getAttribute("height")||"0";if(ae.getAttribute("class")){ai.styleclass=ae.getAttribute("class")}if(ae.getAttribute("align")){ai.align=ae.getAttribute("align")}var ah={};var X=ae.getElementsByTagName("param");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute("name").toLowerCase()!="movie"){ah[X[ad].getAttribute("name")]=X[ad].getAttribute("value")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName=="OBJECT"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F("6.0.65")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName=="OBJECT"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width="310"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height="137"}j.title=j.title.slice(0,47)+" - Flash Player Installation";var ad=M.ie&&M.win?"ActiveX":"PlugIn",ac="MMredirectURL="+O.location.toString().replace(/&/g,"%26")+"&MMplayerType="+ad+"&MMdoctitle="+j.title;if(typeof ab.flashvars!=D){ab.flashvars+="&"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C("div");X+="SWFObjectNew";Y.setAttribute("id",X);ae.parentNode.insertBefore(Y,ae);ae.style.display="none";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C("div");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display="none";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C("div");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName=="PARAM")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah="";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()=="data"){ag.movie=ai[ae]}else{if(ae.toLowerCase()=="styleclass"){ah+=' class="'+ai[ae]+'"'}else{if(ae.toLowerCase()!="classid"){ah+=" "+ae+'="'+ai[ae]+'"'}}}}}var af="";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name="'+ad+'" value="'+ag[ad]+'" />'}}aa.outerHTML='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'+ah+">"+af+"</object>";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute("type",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()=="styleclass"){Z.setAttribute("class",ai[ac])}else{if(ac.toLowerCase()!="classid"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!="movie"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C("param");aa.setAttribute("name",X);aa.setAttribute("value",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName=="OBJECT"){if(M.ie&&M.win){X.style.display="none";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]=="function"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(".");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName("head")[0];if(!aa){return}var X=(ad&&typeof ad=="string")?ad:"screen";if(ab){n=null;G=null}if(!n||G!=X){var Z=C("style");Z.setAttribute("type","text/css");Z.setAttribute("media",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+" {"+Y+"}"))}}}function w(Z,X){if(!m){return}var Y=X?"visible":"hidden";if(J&&c(Z)){c(Z).style.visibility=Y}else{v("#"+Z,"visibility:"+Y)}}function L(Y){var Z=/[\\\"<>\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent("onunload",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+="";ag+="";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+="&"+ai+"="+Z[ai]}else{am.flashvars=ai+"="+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\?/.test(Z)){Z=Z.split("?")[1]}if(aa==null){return L(Z)}var Y=Z.split("&");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf("="))==aa){return L(Y[X].substring((Y[X].indexOf("=")+1)))}}}return""},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display="block"}}if(E){E(B)}}a=false}}}}();
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/web-socket-js/web_socket.js
@@ -0,0 +1,391 @@
+// Copyright: Hiroshi Ichikawa <http://gimite.net/en/>
+// License: New BSD License
+// Reference: http://dev.w3.org/html5/websockets/
+// Reference: http://tools.ietf.org/html/rfc6455
+
+(function() {
+  
+  if (window.WEB_SOCKET_FORCE_FLASH) {
+    // Keeps going.
+  } else if (window.WebSocket) {
+    return;
+  } else if (window.MozWebSocket) {
+    // Firefox.
+    window.WebSocket = MozWebSocket;
+    return;
+  }
+  
+  var logger;
+  if (window.WEB_SOCKET_LOGGER) {
+    logger = WEB_SOCKET_LOGGER;
+  } else if (window.console && window.console.log && window.console.error) {
+    // In some environment, console is defined but console.log or console.error is missing.
+    logger = window.console;
+  } else {
+    logger = {log: function(){ }, error: function(){ }};
+  }
+  
+  // swfobject.hasFlashPlayerVersion("10.0.0") doesn't work with Gnash.
+  if (swfobject.getFlashPlayerVersion().major < 10) {
+    logger.error("Flash Player >= 10.0.0 is required.");
+    return;
+  }
+  if (location.protocol == "file:") {
+    logger.error(
+      "WARNING: web-socket-js doesn't work in file:///... URL " +
+      "unless you set Flash Security Settings properly. " +
+      "Open the page via Web server i.e. http://...");
+  }
+
+  /**
+   * Our own implementation of WebSocket class using Flash.
+   * @param {string} url
+   * @param {array or string} protocols
+   * @param {string} proxyHost
+   * @param {int} proxyPort
+   * @param {string} headers
+   */
+  window.WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {
+    var self = this;
+    self.__id = WebSocket.__nextId++;
+    WebSocket.__instances[self.__id] = self;
+    self.readyState = WebSocket.CONNECTING;
+    self.bufferedAmount = 0;
+    self.__events = {};
+    if (!protocols) {
+      protocols = [];
+    } else if (typeof protocols == "string") {
+      protocols = [protocols];
+    }
+    // Uses setTimeout() to make sure __createFlash() runs after the caller sets ws.onopen etc.
+    // Otherwise, when onopen fires immediately, onopen is called before it is set.
+    self.__createTask = setTimeout(function() {
+      WebSocket.__addTask(function() {
+        self.__createTask = null;
+        WebSocket.__flash.create(
+            self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);
+      });
+    }, 0);
+  };
+
+  /**
+   * Send data to the web socket.
+   * @param {string} data  The data to send to the socket.
+   * @return {boolean}  True for success, false for failure.
+   */
+  WebSocket.prototype.send = function(data) {
+    if (this.readyState == WebSocket.CONNECTING) {
+      throw "INVALID_STATE_ERR: Web Socket connection has not been established";
+    }
+    // We use encodeURIComponent() here, because FABridge doesn't work if
+    // the argument includes some characters. We don't use escape() here
+    // because of this:
+    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Functions#escape_and_unescape_Functions
+    // But it looks decodeURIComponent(encodeURIComponent(s)) doesn't
+    // preserve all Unicode characters either e.g. "\uffff" in Firefox.
+    // Note by wtritch: Hopefully this will not be necessary using ExternalInterface.  Will require
+    // additional testing.
+    var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));
+    if (result < 0) { // success
+      return true;
+    } else {
+      this.bufferedAmount += result;
+      return false;
+    }
+  };
+
+  /**
+   * Close this web socket gracefully.
+   */
+  WebSocket.prototype.close = function() {
+    if (this.__createTask) {
+      clearTimeout(this.__createTask);
+      this.__createTask = null;
+      this.readyState = WebSocket.CLOSED;
+      return;
+    }
+    if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {
+      return;
+    }
+    this.readyState = WebSocket.CLOSING;
+    WebSocket.__flash.close(this.__id);
+  };
+
+  /**
+   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
+   *
+   * @param {string} type
+   * @param {function} listener
+   * @param {boolean} useCapture
+   * @return void
+   */
+  WebSocket.prototype.addEventListener = function(type, listener, useCapture) {
+    if (!(type in this.__events)) {
+      this.__events[type] = [];
+    }
+    this.__events[type].push(listener);
+  };
+
+  /**
+   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
+   *
+   * @param {string} type
+   * @param {function} listener
+   * @param {boolean} useCapture
+   * @return void
+   */
+  WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {
+    if (!(type in this.__events)) return;
+    var events = this.__events[type];
+    for (var i = events.length - 1; i >= 0; --i) {
+      if (events[i] === listener) {
+        events.splice(i, 1);
+        break;
+      }
+    }
+  };
+
+  /**
+   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
+   *
+   * @param {Event} event
+   * @return void
+   */
+  WebSocket.prototype.dispatchEvent = function(event) {
+    var events = this.__events[event.type] || [];
+    for (var i = 0; i < events.length; ++i) {
+      events[i](event);
+    }
+    var handler = this["on" + event.type];
+    if (handler) handler.apply(this, [event]);
+  };
+
+  /**
+   * Handles an event from Flash.
+   * @param {Object} flashEvent
+   */
+  WebSocket.prototype.__handleEvent = function(flashEvent) {
+    
+    if ("readyState" in flashEvent) {
+      this.readyState = flashEvent.readyState;
+    }
+    if ("protocol" in flashEvent) {
+      this.protocol = flashEvent.protocol;
+    }
+    
+    var jsEvent;
+    if (flashEvent.type == "open" || flashEvent.type == "error") {
+      jsEvent = this.__createSimpleEvent(flashEvent.type);
+    } else if (flashEvent.type == "close") {
+      jsEvent = this.__createSimpleEvent("close");
+      jsEvent.wasClean = flashEvent.wasClean ? true : false;
+      jsEvent.code = flashEvent.code;
+      jsEvent.reason = flashEvent.reason;
+    } else if (flashEvent.type == "message") {
+      var data = decodeURIComponent(flashEvent.message);
+      jsEvent = this.__createMessageEvent("message", data);
+    } else {
+      throw "unknown event type: " + flashEvent.type;
+    }
+    
+    this.dispatchEvent(jsEvent);
+    
+  };
+  
+  WebSocket.prototype.__createSimpleEvent = function(type) {
+    if (document.createEvent && window.Event) {
+      var event = document.createEvent("Event");
+      event.initEvent(type, false, false);
+      return event;
+    } else {
+      return {type: type, bubbles: false, cancelable: false};
+    }
+  };
+  
+  WebSocket.prototype.__createMessageEvent = function(type, data) {
+    if (document.createEvent && window.MessageEvent && !window.opera) {
+      var event = document.createEvent("MessageEvent");
+      event.initMessageEvent("message", false, false, data, null, null, window, null);
+      return event;
+    } else {
+      // IE and Opera, the latter one truncates the data parameter after any 0x00 bytes.
+      return {type: type, data: data, bubbles: false, cancelable: false};
+    }
+  };
+  
+  /**
+   * Define the WebSocket readyState enumeration.
+   */
+  WebSocket.CONNECTING = 0;
+  WebSocket.OPEN = 1;
+  WebSocket.CLOSING = 2;
+  WebSocket.CLOSED = 3;
+
+  // Field to check implementation of WebSocket.
+  WebSocket.__isFlashImplementation = true;
+  WebSocket.__initialized = false;
+  WebSocket.__flash = null;
+  WebSocket.__instances = {};
+  WebSocket.__tasks = [];
+  WebSocket.__nextId = 0;
+  
+  /**
+   * Load a new flash security policy file.
+   * @param {string} url
+   */
+  WebSocket.loadFlashPolicyFile = function(url){
+    WebSocket.__addTask(function() {
+      WebSocket.__flash.loadManualPolicyFile(url);
+    });
+  };
+
+  /**
+   * Loads WebSocketMain.swf and creates WebSocketMain object in Flash.
+   */
+  WebSocket.__initialize = function() {
+    
+    if (WebSocket.__initialized) return;
+    WebSocket.__initialized = true;
+    
+    if (WebSocket.__swfLocation) {
+      // For backword compatibility.
+      window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;
+    }
+    if (!window.WEB_SOCKET_SWF_LOCATION) {
+      logger.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf");
+      return;
+    }
+    if (!window.WEB_SOCKET_SUPPRESS_CROSS_DOMAIN_SWF_ERROR &&
+        !WEB_SOCKET_SWF_LOCATION.match(/(^|\/)WebSocketMainInsecure\.swf(\?.*)?$/) &&
+        WEB_SOCKET_SWF_LOCATION.match(/^\w+:\/\/([^\/]+)/)) {
+      var swfHost = RegExp.$1;
+      if (location.host != swfHost) {
+        logger.error(
+            "[WebSocket] You must host HTML and WebSocketMain.swf in the same host " +
+            "('" + location.host + "' != '" + swfHost + "'). " +
+            "See also 'How to host HTML file and SWF file in different domains' section " +
+            "in README.md. If you use WebSocketMainInsecure.swf, you can suppress this message " +
+            "by WEB_SOCKET_SUPPRESS_CROSS_DOMAIN_SWF_ERROR = true;");
+      }
+    }
+    var container = document.createElement("div");
+    container.id = "webSocketContainer";
+    // Hides Flash box. We cannot use display: none or visibility: hidden because it prevents
+    // Flash from loading at least in IE. So we move it out of the screen at (-100, -100).
+    // But this even doesn't work with Flash Lite (e.g. in Droid Incredible). So with Flash
+    // Lite, we put it at (0, 0). This shows 1x1 box visible at left-top corner but this is
+    // the best we can do as far as we know now.
+    container.style.position = "absolute";
+    if (WebSocket.__isFlashLite()) {
+      container.style.left = "0px";
+      container.style.top = "0px";
+    } else {
+      container.style.left = "-100px";
+      container.style.top = "-100px";
+    }
+    var holder = document.createElement("div");
+    holder.id = "webSocketFlash";
+    container.appendChild(holder);
+    document.body.appendChild(container);
+    // See this article for hasPriority:
+    // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html
+    swfobject.embedSWF(
+      WEB_SOCKET_SWF_LOCATION,
+      "webSocketFlash",
+      "1" /* width */,
+      "1" /* height */,
+      "10.0.0" /* SWF version */,
+      null,
+      null,
+      {hasPriority: true, swliveconnect : true, allowScriptAccess: "always"},
+      null,
+      function(e) {
+        if (!e.success) {
+          logger.error("[WebSocket] swfobject.embedSWF failed");
+        }
+      }
+    );
+    
+  };
+  
+  /**
+   * Called by Flash to notify JS that it's fully loaded and ready
+   * for communication.
+   */
+  WebSocket.__onFlashInitialized = function() {
+    // We need to set a timeout here to avoid round-trip calls
+    // to flash during the initialization process.
+    setTimeout(function() {
+      WebSocket.__flash = document.getElementById("webSocketFlash");
+      WebSocket.__flash.setCallerUrl(location.href);
+      WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
+      for (var i = 0; i < WebSocket.__tasks.length; ++i) {
+        WebSocket.__tasks[i]();
+      }
+      WebSocket.__tasks = [];
+    }, 0);
+  };
+  
+  /**
+   * Called by Flash to notify WebSockets events are fired.
+   */
+  WebSocket.__onFlashEvent = function() {
+    setTimeout(function() {
+      try {
+        // Gets events using receiveEvents() instead of getting it from event object
+        // of Flash event. This is to make sure to keep message order.
+        // It seems sometimes Flash events don't arrive in the same order as they are sent.
+        var events = WebSocket.__flash.receiveEvents();
+        for (var i = 0; i < events.length; ++i) {
+          WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);
+        }
+      } catch (e) {
+        logger.error(e);
+      }
+    }, 0);
+    return true;
+  };
+  
+  // Called by Flash.
+  WebSocket.__log = function(message) {
+    logger.log(decodeURIComponent(message));
+  };
+  
+  // Called by Flash.
+  WebSocket.__error = function(message) {
+    logger.error(decodeURIComponent(message));
+  };
+  
+  WebSocket.__addTask = function(task) {
+    if (WebSocket.__flash) {
+      task();
+    } else {
+      WebSocket.__tasks.push(task);
+    }
+  };
+  
+  /**
+   * Test if the browser is running flash lite.
+   * @return {boolean} True if flash lite is running, false otherwise.
+   */
+  WebSocket.__isFlashLite = function() {
+    if (!window.navigator || !window.navigator.mimeTypes) {
+      return false;
+    }
+    var mimeType = window.navigator.mimeTypes["application/x-shockwave-flash"];
+    if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {
+      return false;
+    }
+    return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;
+  };
+  
+  if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {
+    // NOTE:
+    //   This fires immediately if web_socket.js is dynamically loaded after
+    //   the document is loaded.
+    swfobject.addDomLoadEvent(function() {
+      WebSocket.__initialize();
+    });
+  }
+  
+})();
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/websock.js
@@ -0,0 +1,384 @@
+/*
+ * Websock: high-performance binary WebSockets
+ * Copyright (C) 2012 Joel Martin
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * Websock is similar to the standard WebSocket object but Websock
+ * enables communication with raw TCP sockets (i.e. the binary stream)
+ * via websockify. This is accomplished by base64 encoding the data
+ * stream between Websock and websockify.
+ *
+ * Websock has built-in receive queue buffering; the message event
+ * does not contain actual data but is simply a notification that
+ * there is new data available. Several rQ* methods are available to
+ * read binary data off of the receive queue.
+ */
+
+/*jslint browser: true, bitwise: true */
+/*global Util, Base64 */
+
+
+// Load Flash WebSocket emulator if needed
+
+// To force WebSocket emulator even when native WebSocket available
+//window.WEB_SOCKET_FORCE_FLASH = true;
+// To enable WebSocket emulator debug:
+//window.WEB_SOCKET_DEBUG=1;
+
+if (window.WebSocket && !window.WEB_SOCKET_FORCE_FLASH) {
+    Websock_native = true;
+} else if (window.MozWebSocket && !window.WEB_SOCKET_FORCE_FLASH) {
+    Websock_native = true;
+    window.WebSocket = window.MozWebSocket;
+} else {
+    /* no builtin WebSocket so load web_socket.js */
+
+    Websock_native = false;
+    (function () {
+        window.WEB_SOCKET_SWF_LOCATION = Util.get_include_uri() +
+                    "web-socket-js/WebSocketMain.swf";
+        if (Util.Engine.trident) {
+            Util.Debug("Forcing uncached load of WebSocketMain.swf");
+            window.WEB_SOCKET_SWF_LOCATION += "?" + Math.random();
+        }
+        Util.load_scripts(["web-socket-js/swfobject.js",
+                           "web-socket-js/web_socket.js"]);
+    })();
+}
+
+
+function Websock() {
+    "use strict";
+
+    this._websocket = null;  // WebSocket object
+    this._rQ = [];           // Receive queue
+    this._rQi = 0;           // Receive queue index
+    this._rQmax = 10000;     // Max receive queue size before compacting
+    this._sQ = [];           // Send queue
+
+    this._mode = 'base64';    // Current WebSocket mode: 'binary', 'base64'
+    this.maxBufferedAmount = 200;
+
+    this._eventHandlers = {
+        'message': function () {},
+        'open': function () {},
+        'close': function () {},
+        'error': function () {}
+    };
+}
+
+(function () {
+    "use strict";
+    Websock.prototype = {
+        // Getters and Setters
+        get_sQ: function () {
+            return this._sQ;
+        },
+
+        get_rQ: function () {
+            return this._rQ;
+        },
+
+        get_rQi: function () {
+            return this._rQi;
+        },
+
+        set_rQi: function (val) {
+            this._rQi = val;
+        },
+
+        // Receive Queue
+        rQlen: function () {
+            return this._rQ.length - this._rQi;
+        },
+
+        rQpeek8: function () {
+            return this._rQ[this._rQi];
+        },
+
+        rQshift8: function () {
+            return this._rQ[this._rQi++];
+        },
+
+        rQskip8: function () {
+            this._rQi++;
+        },
+
+        rQskipBytes: function (num) {
+            this._rQi += num;
+        },
+
+        rQunshift8: function (num) {
+            if (this._rQi === 0) {
+                this._rQ.unshift(num);
+            } else {
+                this._rQi--;
+                this._rQ[this._rQi] = num;
+            }
+        },
+
+        rQshift16: function () {
+            return (this._rQ[this._rQi++] << 8) +
+                   this._rQ[this._rQi++];
+        },
+
+        rQshift32: function () {
+            return (this._rQ[this._rQi++] << 24) +
+                   (this._rQ[this._rQi++] << 16) +
+                   (this._rQ[this._rQi++] << 8) +
+                   this._rQ[this._rQi++];
+        },
+
+        rQshiftStr: function (len) {
+            if (typeof(len) === 'undefined') { len = this.rQlen(); }
+            var arr = this._rQ.slice(this._rQi, this._rQi + len);
+            this._rQi += len;
+            return String.fromCharCode.apply(null, arr);
+        },
+
+        rQshiftBytes: function (len) {
+            if (typeof(len) === 'undefined') { len = this.rQlen(); }
+            this._rQi += len;
+            return this._rQ.slice(this._rQi - len, this._rQi);
+        },
+
+        rQslice: function (start, end) {
+            if (end) {
+                return this._rQ.slice(this._rQi + start, this._rQi + end);
+            } else {
+                return this._rQ.slice(this._rQi + start);
+            }
+        },
+
+        // Check to see if we must wait for 'num' bytes (default to FBU.bytes)
+        // to be available in the receive queue. Return true if we need to
+        // wait (and possibly print a debug message), otherwise false.
+        rQwait: function (msg, num, goback) {
+            var rQlen = this._rQ.length - this._rQi; // Skip rQlen() function call
+            if (rQlen < num) {
+                if (goback) {
+                    if (this._rQi < goback) {
+                        throw new Error("rQwait cannot backup " + goback + " bytes");
+                    }
+                    this._rQi -= goback;
+                }
+                return true; // true means need more data
+            }
+            return false;
+        },
+
+        // Send Queue
+
+        flush: function () {
+            if (this._websocket.bufferedAmount !== 0) {
+                Util.Debug("bufferedAmount: " + this._websocket.bufferedAmount);
+            }
+
+            if (this._websocket.bufferedAmount < this.maxBufferedAmount) {
+                if (this._sQ.length > 0) {
+                    this._websocket.send(this._encode_message());
+                    this._sQ = [];
+                }
+
+                return true;
+            } else {
+                Util.Info("Delaying send, bufferedAmount: " +
+                        this._websocket.bufferedAmount);
+                return false;
+            }
+        },
+
+        send: function (arr) {
+           this._sQ = this._sQ.concat(arr);
+           return this.flush();
+        },
+
+        send_string: function (str) {
+            this.send(str.split('').map(function (chr) {
+                return chr.charCodeAt(0);
+            }));
+        },
+
+        // Event Handlers
+        on: function (evt, handler) {
+            this._eventHandlers[evt] = handler;
+        },
+
+        init: function (protocols, ws_schema) {
+            this._rQ = [];
+            this._rQi = 0;
+            this._sQ = [];
+            this._websocket = null;
+
+            // Check for full typed array support
+            var bt = false;
+            if (('Uint8Array' in window) &&
+                    ('set' in Uint8Array.prototype)) {
+                bt = true;
+            }
+
+            // Check for full binary type support in WebSockets
+            // Inspired by:
+            // https://github.com/Modernizr/Modernizr/issues/370
+            // https://github.com/Modernizr/Modernizr/blob/master/feature-detects/websockets/binary.js
+            var wsbt = false;
+            try {
+                if (bt && ('binaryType' in WebSocket.prototype ||
+                           !!(new WebSocket(ws_schema + '://.').binaryType))) {
+                    Util.Info("Detected binaryType support in WebSockets");
+                    wsbt = true;
+                }
+            } catch (exc) {
+                // Just ignore failed test localhost connection
+            }
+
+            // Default protocols if not specified
+            if (typeof(protocols) === "undefined") {
+                if (wsbt) {
+                    protocols = ['binary', 'base64'];
+                } else {
+                    protocols = 'base64';
+                }
+            }
+
+            if (!wsbt) {
+                if (protocols === 'binary') {
+                    throw new Error('WebSocket binary sub-protocol requested but not supported');
+                }
+
+                if (typeof(protocols) === 'object') {
+                    var new_protocols = [];
+
+                    for (var i = 0; i < protocols.length; i++) {
+                        if (protocols[i] === 'binary') {
+                            Util.Error('Skipping unsupported WebSocket binary sub-protocol');
+                        } else {
+                            new_protocols.push(protocols[i]);
+                        }
+                    }
+
+                    if (new_protocols.length > 0) {
+                        protocols = new_protocols;
+                    } else {
+                        throw new Error("Only WebSocket binary sub-protocol was requested and is not supported.");
+                    }
+                }
+            }
+
+            return protocols;
+        },
+
+        open: function (uri, protocols) {
+            var ws_schema = uri.match(/^([a-z]+):\/\//)[1];
+            protocols = this.init(protocols, ws_schema);
+
+            this._websocket = new WebSocket(uri, protocols);
+
+            if (protocols.indexOf('binary') >= 0) {
+                this._websocket.binaryType = 'arraybuffer';
+            }
+
+            this._websocket.onmessage = this._recv_message.bind(this);
+            this._websocket.onopen = (function () {
+                Util.Debug('>> WebSock.onopen');
+                if (this._websocket.protocol) {
+                    this._mode = this._websocket.protocol;
+                    Util.Info("Server choose sub-protocol: " + this._websocket.protocol);
+                } else {
+                    this._mode = 'base64';
+                    Util.Error('Server select no sub-protocol!: ' + this._websocket.protocol);
+                }
+                this._eventHandlers.open();
+                Util.Debug("<< WebSock.onopen");
+            }).bind(this);
+            this._websocket.onclose = (function (e) {
+                Util.Debug(">> WebSock.onclose");
+                this._eventHandlers.close(e);
+                Util.Debug("<< WebSock.onclose");
+            }).bind(this);
+            this._websocket.onerror = (function (e) {
+                Util.Debug(">> WebSock.onerror: " + e);
+                this._eventHandlers.error(e);
+                Util.Debug("<< WebSock.onerror: " + e);
+            }).bind(this);
+        },
+
+        close: function () {
+            if (this._websocket) {
+                if ((this._websocket.readyState === WebSocket.OPEN) ||
+                        (this._websocket.readyState === WebSocket.CONNECTING)) {
+                    Util.Info("Closing WebSocket connection");
+                    this._websocket.close();
+                }
+
+                this._websocket.onmessage = function (e) { return; };
+            }
+        },
+
+        // private methods
+        _encode_message: function () {
+            if (this._mode === 'binary') {
+                // Put in a binary arraybuffer
+                return (new Uint8Array(this._sQ)).buffer;
+            } else {
+                // base64 encode
+                return Base64.encode(this._sQ);
+            }
+        },
+
+        _decode_message: function (data) {
+            if (this._mode === 'binary') {
+                // push arraybuffer values onto the end
+                var u8 = new Uint8Array(data);
+                for (var i = 0; i < u8.length; i++) {
+                    this._rQ.push(u8[i]);
+                }
+            } else {
+                // base64 decode and concat to end
+                this._rQ = this._rQ.concat(Base64.decode(data, 0));
+            }
+        },
+
+        _recv_message: function (e) {
+            try {
+                this._decode_message(e.data);
+                if (this.rQlen() > 0) {
+                    this._eventHandlers.message();
+                    // Compact the receive queue
+                    if (this._rQ.length > this._rQmax) {
+                        this._rQ = this._rQ.slice(this._rQi);
+                        this._rQi = 0;
+                    }
+                } else {
+                    Util.Debug("Ignoring empty message");
+                }
+            } catch (exc) {
+                var exception_str = "";
+                if (exc.name) {
+                    exception_str += "\n    name: " + exc.name + "\n";
+                    exception_str += "    message: " + exc.message + "\n";
+                }
+
+                if (typeof exc.description !== 'undefined') {
+                    exception_str += "    description: " + exc.description + "\n";
+                }
+
+                if (typeof exc.stack !== 'undefined') {
+                    exception_str += exc.stack;
+                }
+
+                if (exception_str.length > 0) {
+                    Util.Error("recv_message, caught exception: " + exception_str);
+                } else {
+                    Util.Error("recv_message, caught exception: " + exc);
+                }
+
+                if (typeof exc.name !== 'undefined') {
+                    this._eventHandlers.error(exc.name + ": " + exc.message);
+                } else {
+                    this._eventHandlers.error(exc);
+                }
+            }
+        }
+    };
+})();
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/include/webutil.js
@@ -0,0 +1,239 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2012 Joel Martin
+ * Copyright (C) 2013 NTT corp.
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ *
+ * See README.md for usage and integration instructions.
+ */
+
+/*jslint bitwise: false, white: false, browser: true, devel: true */
+/*global Util, window, document */
+
+// Globals defined here
+var WebUtil = {}, $D;
+
+/*
+ * Simple DOM selector by ID
+ */
+if (!window.$D) {
+    window.$D = function (id) {
+        if (document.getElementById) {
+            return document.getElementById(id);
+        } else if (document.all) {
+            return document.all[id];
+        } else if (document.layers) {
+            return document.layers[id];
+        }
+        return undefined;
+    };
+}
+
+
+/*
+ * ------------------------------------------------------
+ * Namespaced in WebUtil
+ * ------------------------------------------------------
+ */
+
+// init log level reading the logging HTTP param
+WebUtil.init_logging = function (level) {
+    "use strict";
+    if (typeof level !== "undefined") {
+        Util._log_level = level;
+    } else {
+        var param = document.location.href.match(/logging=([A-Za-z0-9\._\-]*)/);
+        Util._log_level = (param || ['', Util._log_level])[1];
+    }
+    Util.init_logging();
+};
+
+
+WebUtil.dirObj = function (obj, depth, parent) {
+    "use strict";
+    if (! depth) { depth = 2; }
+    if (! parent) { parent = ""; }
+
+    // Print the properties of the passed-in object
+    var msg = "";
+    for (var i in obj) {
+        if ((depth > 1) && (typeof obj[i] === "object")) {
+            // Recurse attributes that are objects
+            msg += WebUtil.dirObj(obj[i], depth - 1, parent + "." + i);
+        } else {
+            //val = new String(obj[i]).replace("\n", " ");
+            var val = "";
+            if (typeof(obj[i]) === "undefined") {
+                val = "undefined";
+            } else {
+                val = obj[i].toString().replace("\n", " ");
+            }
+            if (val.length > 30) {
+                val = val.substr(0, 30) + "...";
+            }
+            msg += parent + "." + i + ": " + val + "\n";
+        }
+    }
+    return msg;
+};
+
+// Read a query string variable
+WebUtil.getQueryVar = function (name, defVal) {
+    "use strict";
+    var re = new RegExp('.*[?&]' + name + '=([^&#]*)'),
+        match = document.location.href.match(re);
+    if (typeof defVal === 'undefined') { defVal = null; }
+    if (match) {
+        return decodeURIComponent(match[1]);
+    } else {
+        return defVal;
+    }
+};
+
+
+/*
+ * Cookie handling. Dervied from: http://www.quirksmode.org/js/cookies.html
+ */
+
+// No days means only for this browser session
+WebUtil.createCookie = function (name, value, days) {
+    "use strict";
+    var date, expires;
+    if (days) {
+        date = new Date();
+        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
+        expires = "; expires=" + date.toGMTString();
+    } else {
+        expires = "";
+    }
+
+    var secure;
+    if (document.location.protocol === "https:") {
+        secure = "; secure";
+    } else {
+        secure = "";
+    }
+    document.cookie = name + "=" + value + expires + "; path=/" + secure;
+};
+
+WebUtil.readCookie = function (name, defaultValue) {
+    "use strict";
+    var nameEQ = name + "=",
+        ca = document.cookie.split(';');
+
+    for (var i = 0; i < ca.length; i += 1) {
+        var c = ca[i];
+        while (c.charAt(0) === ' ') { c = c.substring(1, c.length); }
+        if (c.indexOf(nameEQ) === 0) { return c.substring(nameEQ.length, c.length); }
+    }
+    return (typeof defaultValue !== 'undefined') ? defaultValue : null;
+};
+
+WebUtil.eraseCookie = function (name) {
+    "use strict";
+    WebUtil.createCookie(name, "", -1);
+};
+
+/*
+ * Setting handling.
+ */
+
+WebUtil.initSettings = function (callback /*, ...callbackArgs */) {
+    "use strict";
+    var callbackArgs = Array.prototype.slice.call(arguments, 1);
+    if (window.chrome && window.chrome.storage) {
+        window.chrome.storage.sync.get(function (cfg) {
+            WebUtil.settings = cfg;
+            console.log(WebUtil.settings);
+            if (callback) {
+                callback.apply(this, callbackArgs);
+            }
+        });
+    } else {
+        // No-op
+        if (callback) {
+            callback.apply(this, callbackArgs);
+        }
+    }
+};
+
+// No days means only for this browser session
+WebUtil.writeSetting = function (name, value) {
+    "use strict";
+    if (window.chrome && window.chrome.storage) {
+        //console.log("writeSetting:", name, value);
+        if (WebUtil.settings[name] !== value) {
+            WebUtil.settings[name] = value;
+            window.chrome.storage.sync.set(WebUtil.settings);
+        }
+    } else {
+        localStorage.setItem(name, value);
+    }
+};
+
+WebUtil.readSetting = function (name, defaultValue) {
+    "use strict";
+    var value;
+    if (window.chrome && window.chrome.storage) {
+        value = WebUtil.settings[name];
+    } else {
+        value = localStorage.getItem(name);
+    }
+    if (typeof value === "undefined") {
+        value = null;
+    }
+    if (value === null && typeof defaultValue !== undefined) {
+        return defaultValue;
+    } else {
+        return value;
+    }
+};
+
+WebUtil.eraseSetting = function (name) {
+    "use strict";
+    if (window.chrome && window.chrome.storage) {
+        window.chrome.storage.sync.remove(name);
+        delete WebUtil.settings[name];
+    } else {
+        localStorage.removeItem(name);
+    }
+};
+
+/*
+ * Alternate stylesheet selection
+ */
+WebUtil.getStylesheets = function () {
+    "use strict";
+    var links = document.getElementsByTagName("link");
+    var sheets = [];
+
+    for (var i = 0; i < links.length; i += 1) {
+        if (links[i].title &&
+            links[i].rel.toUpperCase().indexOf("STYLESHEET") > -1) {
+            sheets.push(links[i]);
+        }
+    }
+    return sheets;
+};
+
+// No sheet means try and use value from cookie, null sheet used to
+// clear all alternates.
+WebUtil.selectStylesheet = function (sheet) {
+    "use strict";
+    if (typeof sheet === 'undefined') {
+        sheet = 'default';
+    }
+
+    var sheets = WebUtil.getStylesheets();
+    for (var i = 0; i < sheets.length; i += 1) {
+        var link = sheets[i];
+        if (link.title === sheet) {
+            Util.Debug("Using stylesheet " + sheet);
+            link.disabled = false;
+        } else {
+            //Util.Debug("Skipping stylesheet " + link.title);
+            link.disabled = true;
+        }
+    }
+    return sheet;
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/karma.conf.js
@@ -0,0 +1,85 @@
+// Karma configuration
+
+// The Safari launcher is broken, so construct our own
+function SafariBrowser(id, baseBrowserDecorator, args) {
+  baseBrowserDecorator(this);
+
+  this._start = function(url) {
+    this._execCommand('/usr/bin/open', ['-W', '-n', '-a', 'Safari', url]);
+  }
+}
+
+SafariBrowser.prototype = {
+  name: 'Safari'
+}
+
+module.exports = (config) => {
+  let browsers = [];
+
+  if (process.env.TEST_BROWSER_NAME) {
+    browsers = process.env.TEST_BROWSER_NAME.split(',');
+  }
+
+  const my_conf = {
+
+    // base path that will be used to resolve all patterns (eg. files, exclude)
+    basePath: '',
+
+    // frameworks to use
+    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter
+    frameworks: ['mocha', 'sinon-chai'],
+
+    // list of files / patterns to load in the browser (loaded in order)
+    files: [
+      { pattern: 'app/localization.js', included: false, type: 'module' },
+      { pattern: 'app/webutil.js', included: false, type: 'module' },
+      { pattern: 'core/**/*.js', included: false, type: 'module' },
+      { pattern: 'vendor/pako/**/*.js', included: false, type: 'module' },
+      { pattern: 'tests/test.*.js', type: 'module' },
+      { pattern: 'tests/fake.*.js', included: false, type: 'module' },
+      { pattern: 'tests/assertions.js', type: 'module' },
+    ],
+
+    client: {
+      mocha: {
+        // replace Karma debug page with mocha display
+        'reporter': 'html',
+        'ui': 'bdd'
+      }
+    },
+
+    // list of files to exclude
+    exclude: [
+    ],
+
+    plugins: [
+      'karma-*',
+      '@chiragrupani/karma-chromium-edge-launcher',
+      { 'launcher:Safari': [ 'type', SafariBrowser ] },
+    ],
+
+    // start these browsers
+    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
+    browsers: browsers,
+
+    // test results reporter to use
+    // possible values: 'dots', 'progress'
+    // available reporters: https://npmjs.org/browse/keyword/karma-reporter
+    reporters: ['mocha'],
+
+
+    // level of logging
+    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
+    logLevel: config.LOG_INFO,
+
+
+    // enable / disable watching file and executing tests whenever any file changes
+    autoWatch: false,
+
+    // Continuous Integration mode
+    // if true, Karma captures browsers, runs the tests and exits
+    singleRun: true,
+  };
+
+  config.set(my_conf);
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/package.json
@@ -0,0 +1,79 @@
+{
+  "name": "@novnc/novnc",
+  "version": "1.3.0",
+  "description": "An HTML5 VNC client",
+  "browser": "lib/rfb",
+  "directories": {
+    "lib": "lib",
+    "doc": "docs",
+    "test": "tests"
+  },
+  "files": [
+    "lib",
+    "AUTHORS",
+    "VERSION",
+    "docs/API.md",
+    "docs/LIBRARY.md",
+    "docs/LICENSE*",
+    "core",
+    "vendor/pako"
+  ],
+  "scripts": {
+    "lint": "eslint app core po/po2js po/xgettext-html tests utils",
+    "test": "karma start karma.conf.js",
+    "prepublish": "node ./utils/convert.js --clean"
+  },
+  "repository": {
+    "type": "git",
+    "url": "git+https://github.com/novnc/noVNC.git"
+  },
+  "author": "Joel Martin <github@martintribe.org> (https://github.com/kanaka)",
+  "contributors": [
+    "Samuel Mannehed <samuel@cendio.se> (https://github.com/samhed)",
+    "Pierre Ossman <ossman@cendio.se> (https://github.com/CendioOssman)"
+  ],
+  "license": "MPL-2.0",
+  "bugs": {
+    "url": "https://github.com/novnc/noVNC/issues"
+  },
+  "homepage": "https://github.com/novnc/noVNC",
+  "devDependencies": {
+    "@babel/core": "*",
+    "@babel/plugin-syntax-dynamic-import": "*",
+    "@babel/plugin-transform-modules-commonjs": "*",
+    "@babel/preset-env": "*",
+    "@babel/cli": "*",
+    "babel-plugin-import-redirect": "*",
+    "browserify": "*",
+    "babelify": "*",
+    "core-js": "*",
+    "chai": "*",
+    "commander": "*",
+    "es-module-loader": "*",
+    "eslint": "*",
+    "fs-extra": "*",
+    "jsdom": "*",
+    "karma": "*",
+    "karma-mocha": "*",
+    "karma-chrome-launcher": "*",
+    "@chiragrupani/karma-chromium-edge-launcher": "*",
+    "karma-firefox-launcher": "*",
+    "karma-ie-launcher": "*",
+    "karma-mocha-reporter": "*",
+    "karma-safari-launcher": "*",
+    "karma-script-launcher": "*",
+    "karma-sinon-chai": "*",
+    "mocha": "*",
+    "node-getopt": "*",
+    "po2json": "*",
+    "sinon": "*",
+    "sinon-chai": "*"
+  },
+  "dependencies": {},
+  "keywords": [
+    "vnc",
+    "rfb",
+    "novnc",
+    "websockify"
+  ]
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/.eslintrc
@@ -0,0 +1,5 @@
+{
+    "env": {
+        "node": true,
+    },
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/Makefile
@@ -0,0 +1,36 @@
+all:
+.PHONY: update-po update-js update-pot
+.PHONY: FORCE
+
+LINGUAS := cs de el es fr it ja ko nl pl pt_BR ru sv tr zh_CN zh_TW
+
+VERSION := $(shell grep '"version"' ../package.json | cut -d '"' -f 4)
+
+POFILES := $(addsuffix .po,$(LINGUAS))
+JSONFILES := $(addprefix ../app/locale/,$(addsuffix .json,$(LINGUAS)))
+
+update-po: $(POFILES)
+update-js: $(JSONFILES)
+
+%.po: FORCE
+	msgmerge --update --lang=$* $@ noVNC.pot
+../app/locale/%.json: FORCE
+	./po2js $*.po $@
+
+update-pot:
+	xgettext --output=noVNC.js.pot \
+		--copyright-holder="The noVNC Authors" \
+		--package-name="noVNC" \
+		--package-version="$(VERSION)" \
+		--msgid-bugs-address="novnc@googlegroups.com" \
+		--add-comments=TRANSLATORS: \
+		--from-code=UTF-8 \
+		--sort-by-file \
+		../app/*.js \
+		../core/*.js \
+		../core/input/*.js
+	./xgettext-html --output=noVNC.html.pot \
+		../vnc.html
+	msgcat --output-file=noVNC.pot \
+		--sort-by-file noVNC.js.pot noVNC.html.pot
+	rm -f noVNC.js.pot noVNC.html.pot
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/cs.po
@@ -0,0 +1,294 @@
+# Czech translations for noVNC package.
+# Copyright (C) 2018 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+# Petr <petr@kle.cz>, 2018.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 1.0.0-testing.2\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2018-10-19 12:00+0200\n"
+"PO-Revision-Date: 2018-10-19 12:00+0200\n"
+"Last-Translator: Petr <petr@kle.cz>\n"
+"Language-Team: Czech\n"
+"Language: cs\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=3; plural=(n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2;\n"
+
+#: ../app/ui.js:389
+msgid "Connecting..."
+msgstr "Připojení..."
+
+#: ../app/ui.js:396
+msgid "Disconnecting..."
+msgstr "Odpojení..."
+
+#: ../app/ui.js:402
+msgid "Reconnecting..."
+msgstr "Obnova připojení..."
+
+#: ../app/ui.js:407
+msgid "Internal error"
+msgstr "Vnitřní chyba"
+
+#: ../app/ui.js:997
+msgid "Must set host"
+msgstr "Hostitel musí být nastavení"
+
+#: ../app/ui.js:1079
+msgid "Connected (encrypted) to "
+msgstr "Připojení (šifrované) k "
+
+#: ../app/ui.js:1081
+msgid "Connected (unencrypted) to "
+msgstr "Připojení (nešifrované) k "
+
+#: ../app/ui.js:1104
+msgid "Something went wrong, connection is closed"
+msgstr "Něco se pokazilo, odpojeno"
+
+#: ../app/ui.js:1107
+msgid "Failed to connect to server"
+msgstr "Chyba připojení k serveru"
+
+#: ../app/ui.js:1117
+msgid "Disconnected"
+msgstr "Odpojeno"
+
+#: ../app/ui.js:1130
+msgid "New connection has been rejected with reason: "
+msgstr "Nové připojení bylo odmítnuto s odůvodněním: "
+
+#: ../app/ui.js:1133
+msgid "New connection has been rejected"
+msgstr "Nové připojení bylo odmítnuto"
+
+#: ../app/ui.js:1153
+msgid "Password is required"
+msgstr "Je vyžadováno heslo"
+
+#: ../vnc.html:84
+msgid "noVNC encountered an error:"
+msgstr "noVNC narazilo na chybu:"
+
+#: ../vnc.html:94
+msgid "Hide/Show the control bar"
+msgstr "Skrýt/zobrazit ovládací panel"
+
+#: ../vnc.html:101
+msgid "Move/Drag Viewport"
+msgstr "Přesunout/přetáhnout výřez"
+
+#: ../vnc.html:101
+msgid "viewport drag"
+msgstr "přesun výřezu"
+
+#: ../vnc.html:107 ../vnc.html:110 ../vnc.html:113 ../vnc.html:116
+msgid "Active Mouse Button"
+msgstr "Aktivní tlačítka myši"
+
+#: ../vnc.html:107
+msgid "No mousebutton"
+msgstr "Žádné"
+
+#: ../vnc.html:110
+msgid "Left mousebutton"
+msgstr "Levé tlačítko myši"
+
+#: ../vnc.html:113
+msgid "Middle mousebutton"
+msgstr "Prostřední tlačítko myši"
+
+#: ../vnc.html:116
+msgid "Right mousebutton"
+msgstr "Pravé tlačítko myši"
+
+#: ../vnc.html:119
+msgid "Keyboard"
+msgstr "Klávesnice"
+
+#: ../vnc.html:119
+msgid "Show Keyboard"
+msgstr "Zobrazit klávesnici"
+
+#: ../vnc.html:126
+msgid "Extra keys"
+msgstr "Extra klávesy"
+
+#: ../vnc.html:126
+msgid "Show Extra Keys"
+msgstr "Zobrazit extra klávesy"
+
+#: ../vnc.html:131
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:131
+msgid "Toggle Ctrl"
+msgstr "Přepnout Ctrl"
+
+#: ../vnc.html:134
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:134
+msgid "Toggle Alt"
+msgstr "Přepnout Alt"
+
+#: ../vnc.html:137
+msgid "Send Tab"
+msgstr "Odeslat tabulátor"
+
+#: ../vnc.html:137
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:140
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:140
+msgid "Send Escape"
+msgstr "Odeslat Esc"
+
+#: ../vnc.html:143
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl+Alt+Del"
+
+#: ../vnc.html:143
+msgid "Send Ctrl-Alt-Del"
+msgstr "Poslat Ctrl-Alt-Del"
+
+#: ../vnc.html:151
+msgid "Shutdown/Reboot"
+msgstr "Vypnutí/Restart"
+
+#: ../vnc.html:151
+msgid "Shutdown/Reboot..."
+msgstr "Vypnutí/Restart..."
+
+#: ../vnc.html:157
+msgid "Power"
+msgstr "Napájení"
+
+#: ../vnc.html:159
+msgid "Shutdown"
+msgstr "Vypnout"
+
+#: ../vnc.html:160
+msgid "Reboot"
+msgstr "Restart"
+
+#: ../vnc.html:161
+msgid "Reset"
+msgstr "Reset"
+
+#: ../vnc.html:166 ../vnc.html:172
+msgid "Clipboard"
+msgstr "Schránka"
+
+#: ../vnc.html:176
+msgid "Clear"
+msgstr "Vymazat"
+
+#: ../vnc.html:182
+msgid "Fullscreen"
+msgstr "Celá obrazovka"
+
+#: ../vnc.html:187 ../vnc.html:194
+msgid "Settings"
+msgstr "Nastavení"
+
+#: ../vnc.html:197
+msgid "Shared Mode"
+msgstr "Sdílený režim"
+
+#: ../vnc.html:200
+msgid "View Only"
+msgstr "Pouze prohlížení"
+
+#: ../vnc.html:204
+msgid "Clip to Window"
+msgstr "Přizpůsobit oknu"
+
+#: ../vnc.html:207
+msgid "Scaling Mode:"
+msgstr "Přizpůsobení velikosti"
+
+#: ../vnc.html:209
+msgid "None"
+msgstr "Žádné"
+
+#: ../vnc.html:210
+msgid "Local Scaling"
+msgstr "Místní"
+
+#: ../vnc.html:211
+msgid "Remote Resizing"
+msgstr "Vzdálené"
+
+#: ../vnc.html:216
+msgid "Advanced"
+msgstr "Pokročilé"
+
+#: ../vnc.html:219
+msgid "Repeater ID:"
+msgstr "ID opakovače"
+
+#: ../vnc.html:223
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:226
+msgid "Encrypt"
+msgstr "Šifrování:"
+
+#: ../vnc.html:229
+msgid "Host:"
+msgstr "Hostitel:"
+
+#: ../vnc.html:233
+msgid "Port:"
+msgstr "Port:"
+
+#: ../vnc.html:237
+msgid "Path:"
+msgstr "Cesta"
+
+#: ../vnc.html:244
+msgid "Automatic Reconnect"
+msgstr "Automatická obnova připojení"
+
+#: ../vnc.html:247
+msgid "Reconnect Delay (ms):"
+msgstr "Zpoždění připojení (ms)"
+
+#: ../vnc.html:252
+msgid "Show Dot when No Cursor"
+msgstr "Tečka místo chybějícího kurzoru myši"
+
+#: ../vnc.html:257
+msgid "Logging:"
+msgstr "Logování:"
+
+#: ../vnc.html:269
+msgid "Disconnect"
+msgstr "Odpojit"
+
+#: ../vnc.html:288
+msgid "Connect"
+msgstr "Připojit"
+
+#: ../vnc.html:298
+msgid "Password:"
+msgstr "Heslo"
+
+#: ../vnc.html:302
+msgid "Send Password"
+msgstr "Odeslat heslo"
+
+#: ../vnc.html:312
+msgid "Cancel"
+msgstr "Zrušit"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/de.po
@@ -0,0 +1,303 @@
+# German translations for noVNC package
+# German translation for noVNC.
+# Copyright (C) 2018 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+# Loek Janssen <loekjanssen@gmail.com>, 2016.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 0.6.1\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2017-11-24 07:16+0000\n"
+"PO-Revision-Date: 2017-11-24 08:20+0100\n"
+"Last-Translator: Dominik Csapak <d.csapak@proxmox.com>\n"
+"Language-Team: none\n"
+"Language: de\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+"X-Generator: Poedit 1.8.11\n"
+
+#: ../app/ui.js:404
+msgid "Connecting..."
+msgstr "Verbinden..."
+
+#: ../app/ui.js:411
+msgid "Disconnecting..."
+msgstr "Verbindung trennen..."
+
+#: ../app/ui.js:417
+msgid "Reconnecting..."
+msgstr "Verbindung wiederherstellen..."
+
+#: ../app/ui.js:422
+msgid "Internal error"
+msgstr "Interner Fehler"
+
+#: ../app/ui.js:1019
+msgid "Must set host"
+msgstr "Richten Sie den Server ein"
+
+#: ../app/ui.js:1099
+msgid "Connected (encrypted) to "
+msgstr "Verbunden mit (verschlüsselt) "
+
+#: ../app/ui.js:1101
+msgid "Connected (unencrypted) to "
+msgstr "Verbunden mit (unverschlüsselt) "
+
+#: ../app/ui.js:1119
+msgid "Something went wrong, connection is closed"
+msgstr "Etwas lief schief, Verbindung wurde getrennt"
+
+#: ../app/ui.js:1129
+msgid "Disconnected"
+msgstr "Verbindung zum Server getrennt"
+
+#: ../app/ui.js:1142
+msgid "New connection has been rejected with reason: "
+msgstr "Verbindung wurde aus folgendem Grund abgelehnt: "
+
+#: ../app/ui.js:1145
+msgid "New connection has been rejected"
+msgstr "Verbindung wurde abgelehnt"
+
+#: ../app/ui.js:1166
+msgid "Password is required"
+msgstr "Passwort ist erforderlich"
+
+#: ../vnc.html:89
+msgid "noVNC encountered an error:"
+msgstr "Ein Fehler ist aufgetreten:"
+
+#: ../vnc.html:99
+msgid "Hide/Show the control bar"
+msgstr "Kontrollleiste verstecken/anzeigen"
+
+#: ../vnc.html:106
+msgid "Move/Drag Viewport"
+msgstr "Ansichtsfenster verschieben/ziehen"
+
+#: ../vnc.html:106
+msgid "viewport drag"
+msgstr "Ansichtsfenster ziehen"
+
+#: ../vnc.html:112 ../vnc.html:115 ../vnc.html:118 ../vnc.html:121
+msgid "Active Mouse Button"
+msgstr "Aktive Maustaste"
+
+#: ../vnc.html:112
+msgid "No mousebutton"
+msgstr "Keine Maustaste"
+
+#: ../vnc.html:115
+msgid "Left mousebutton"
+msgstr "Linke Maustaste"
+
+#: ../vnc.html:118
+msgid "Middle mousebutton"
+msgstr "Mittlere Maustaste"
+
+#: ../vnc.html:121
+msgid "Right mousebutton"
+msgstr "Rechte Maustaste"
+
+#: ../vnc.html:124
+msgid "Keyboard"
+msgstr "Tastatur"
+
+#: ../vnc.html:124
+msgid "Show Keyboard"
+msgstr "Tastatur anzeigen"
+
+#: ../vnc.html:131
+msgid "Extra keys"
+msgstr "Zusatztasten"
+
+#: ../vnc.html:131
+msgid "Show Extra Keys"
+msgstr "Zusatztasten anzeigen"
+
+#: ../vnc.html:136
+msgid "Ctrl"
+msgstr "Strg"
+
+#: ../vnc.html:136
+msgid "Toggle Ctrl"
+msgstr "Strg umschalten"
+
+#: ../vnc.html:139
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:139
+msgid "Toggle Alt"
+msgstr "Alt umschalten"
+
+#: ../vnc.html:142
+msgid "Send Tab"
+msgstr "Tab senden"
+
+#: ../vnc.html:142
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:145
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:145
+msgid "Send Escape"
+msgstr "Escape senden"
+
+#: ../vnc.html:148
+msgid "Ctrl+Alt+Del"
+msgstr "Strg+Alt+Entf"
+
+#: ../vnc.html:148
+msgid "Send Ctrl-Alt-Del"
+msgstr "Strg+Alt+Entf senden"
+
+#: ../vnc.html:156
+msgid "Shutdown/Reboot"
+msgstr "Herunterfahren/Neustarten"
+
+#: ../vnc.html:156
+msgid "Shutdown/Reboot..."
+msgstr "Herunterfahren/Neustarten..."
+
+#: ../vnc.html:162
+msgid "Power"
+msgstr "Energie"
+
+#: ../vnc.html:164
+msgid "Shutdown"
+msgstr "Herunterfahren"
+
+#: ../vnc.html:165
+msgid "Reboot"
+msgstr "Neustarten"
+
+#: ../vnc.html:166
+msgid "Reset"
+msgstr "Zurücksetzen"
+
+#: ../vnc.html:171 ../vnc.html:177
+msgid "Clipboard"
+msgstr "Zwischenablage"
+
+#: ../vnc.html:181
+msgid "Clear"
+msgstr "Löschen"
+
+#: ../vnc.html:187
+msgid "Fullscreen"
+msgstr "Vollbild"
+
+#: ../vnc.html:192 ../vnc.html:199
+msgid "Settings"
+msgstr "Einstellungen"
+
+#: ../vnc.html:202
+msgid "Shared Mode"
+msgstr "Geteilter Modus"
+
+#: ../vnc.html:205
+msgid "View Only"
+msgstr "Nur betrachten"
+
+#: ../vnc.html:209
+msgid "Clip to Window"
+msgstr "Auf Fenster begrenzen"
+
+#: ../vnc.html:212
+msgid "Scaling Mode:"
+msgstr "Skalierungsmodus:"
+
+#: ../vnc.html:214
+msgid "None"
+msgstr "Keiner"
+
+#: ../vnc.html:215
+msgid "Local Scaling"
+msgstr "Lokales skalieren"
+
+#: ../vnc.html:216
+msgid "Remote Resizing"
+msgstr "Serverseitiges skalieren"
+
+#: ../vnc.html:221
+msgid "Advanced"
+msgstr "Erweitert"
+
+#: ../vnc.html:224
+msgid "Repeater ID:"
+msgstr "Repeater ID:"
+
+#: ../vnc.html:228
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:231
+msgid "Encrypt"
+msgstr "Verschlüsselt"
+
+#: ../vnc.html:234
+msgid "Host:"
+msgstr "Server:"
+
+#: ../vnc.html:238
+msgid "Port:"
+msgstr "Port:"
+
+#: ../vnc.html:242
+msgid "Path:"
+msgstr "Pfad:"
+
+#: ../vnc.html:249
+msgid "Automatic Reconnect"
+msgstr "Automatisch wiederverbinden"
+
+#: ../vnc.html:252
+msgid "Reconnect Delay (ms):"
+msgstr "Wiederverbindungsverzögerung (ms):"
+
+#: ../vnc.html:258
+msgid "Logging:"
+msgstr "Protokollierung:"
+
+#: ../vnc.html:270
+msgid "Disconnect"
+msgstr "Verbindung trennen"
+
+#: ../vnc.html:289
+msgid "Connect"
+msgstr "Verbinden"
+
+#: ../vnc.html:299
+msgid "Password:"
+msgstr "Passwort:"
+
+#: ../vnc.html:313
+msgid "Cancel"
+msgstr "Abbrechen"
+
+#: ../vnc.html:329
+msgid "Canvas not supported."
+msgstr "Canvas nicht unterstützt."
+
+#~ msgid "Disconnect timeout"
+#~ msgstr "Zeitüberschreitung beim Trennen"
+
+#~ msgid "Local Downscaling"
+#~ msgstr "Lokales herunterskalieren"
+
+#~ msgid "Local Cursor"
+#~ msgstr "Lokaler Mauszeiger"
+
+#~ msgid "Forcing clipping mode since scrollbars aren't supported by IE in fullscreen"
+#~ msgstr "'Clipping-Modus' aktiviert, Scrollbalken in 'IE-Vollbildmodus' werden nicht unterstützt"
+
+#~ msgid "True Color"
+#~ msgstr "True Color"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/el.po
@@ -0,0 +1,323 @@
+# Greek translations for noVNC package.
+# Copyright (C) 2018 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+# Giannis Kosmas <kosmasgiannis@gmail.com>, 2016.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 0.6.1\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2017-11-17 21:40+0200\n"
+"PO-Revision-Date: 2017-10-11 16:16+0200\n"
+"Last-Translator: Giannis Kosmas <kosmasgiannis@gmail.com>\n"
+"Language-Team: none\n"
+"Language: el\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+#: ../app/ui.js:404
+msgid "Connecting..."
+msgstr "Συνδέεται..."
+
+#: ../app/ui.js:411
+msgid "Disconnecting..."
+msgstr "Aποσυνδέεται..."
+
+#: ../app/ui.js:417
+msgid "Reconnecting..."
+msgstr "Επανασυνδέεται..."
+
+#: ../app/ui.js:422
+msgid "Internal error"
+msgstr "Εσωτερικό σφάλμα"
+
+#: ../app/ui.js:1019
+msgid "Must set host"
+msgstr "Πρέπει να οριστεί ο διακομιστής"
+
+#: ../app/ui.js:1099
+msgid "Connected (encrypted) to "
+msgstr "Συνδέθηκε (κρυπτογραφημένα) με το "
+
+#: ../app/ui.js:1101
+msgid "Connected (unencrypted) to "
+msgstr "Συνδέθηκε (μη κρυπτογραφημένα) με το "
+
+#: ../app/ui.js:1119
+msgid "Something went wrong, connection is closed"
+msgstr "Κάτι πήγε στραβά, η σύνδεση διακόπηκε"
+
+#: ../app/ui.js:1129
+msgid "Disconnected"
+msgstr "Αποσυνδέθηκε"
+
+#: ../app/ui.js:1142
+msgid "New connection has been rejected with reason: "
+msgstr "Η νέα σύνδεση απορρίφθηκε διότι: "
+
+#: ../app/ui.js:1145
+msgid "New connection has been rejected"
+msgstr "Η νέα σύνδεση απορρίφθηκε "
+
+#: ../app/ui.js:1166
+msgid "Password is required"
+msgstr "Απαιτείται ο κωδικός πρόσβασης"
+
+#: ../vnc.html:89
+msgid "noVNC encountered an error:"
+msgstr "το noVNC αντιμετώπισε ένα σφάλμα:"
+
+#: ../vnc.html:99
+msgid "Hide/Show the control bar"
+msgstr "Απόκρυψη/Εμφάνιση γραμμής ελέγχου"
+
+#: ../vnc.html:106
+msgid "Move/Drag Viewport"
+msgstr "Μετακίνηση/Σύρσιμο Θεατού πεδίου"
+
+#: ../vnc.html:106
+msgid "viewport drag"
+msgstr "σύρσιμο θεατού πεδίου"
+
+#: ../vnc.html:112 ../vnc.html:115 ../vnc.html:118 ../vnc.html:121
+msgid "Active Mouse Button"
+msgstr "Ενεργό Πλήκτρο Ποντικιού"
+
+#: ../vnc.html:112
+msgid "No mousebutton"
+msgstr "Χωρίς Πλήκτρο Ποντικιού"
+
+#: ../vnc.html:115
+msgid "Left mousebutton"
+msgstr "Αριστερό Πλήκτρο Ποντικιού"
+
+#: ../vnc.html:118
+msgid "Middle mousebutton"
+msgstr "Μεσαίο Πλήκτρο Ποντικιού"
+
+#: ../vnc.html:121
+msgid "Right mousebutton"
+msgstr "Δεξί Πλήκτρο Ποντικιού"
+
+#: ../vnc.html:124
+msgid "Keyboard"
+msgstr "Πληκτρολόγιο"
+
+#: ../vnc.html:124
+msgid "Show Keyboard"
+msgstr "Εμφάνιση Πληκτρολογίου"
+
+#: ../vnc.html:131
+msgid "Extra keys"
+msgstr "Επιπλέον πλήκτρα"
+
+#: ../vnc.html:131
+msgid "Show Extra Keys"
+msgstr "Εμφάνιση Επιπλέον Πλήκτρων"
+
+#: ../vnc.html:136
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:136
+msgid "Toggle Ctrl"
+msgstr "Εναλλαγή Ctrl"
+
+#: ../vnc.html:139
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:139
+msgid "Toggle Alt"
+msgstr "Εναλλαγή Alt"
+
+#: ../vnc.html:142
+msgid "Send Tab"
+msgstr "Αποστολή Tab"
+
+#: ../vnc.html:142
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:145
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:145
+msgid "Send Escape"
+msgstr "Αποστολή Escape"
+
+#: ../vnc.html:148
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl+Alt+Del"
+
+#: ../vnc.html:148
+msgid "Send Ctrl-Alt-Del"
+msgstr "Αποστολή Ctrl-Alt-Del"
+
+#: ../vnc.html:156
+msgid "Shutdown/Reboot"
+msgstr "Κλείσιμο/Επανεκκίνηση"
+
+#: ../vnc.html:156
+msgid "Shutdown/Reboot..."
+msgstr "Κλείσιμο/Επανεκκίνηση..."
+
+#: ../vnc.html:162
+msgid "Power"
+msgstr "Απενεργοποίηση"
+
+#: ../vnc.html:164
+msgid "Shutdown"
+msgstr "Κλείσιμο"
+
+#: ../vnc.html:165
+msgid "Reboot"
+msgstr "Επανεκκίνηση"
+
+#: ../vnc.html:166
+msgid "Reset"
+msgstr "Επαναφορά"
+
+#: ../vnc.html:171 ../vnc.html:177
+msgid "Clipboard"
+msgstr "Πρόχειρο"
+
+#: ../vnc.html:181
+msgid "Clear"
+msgstr "Καθάρισμα"
+
+#: ../vnc.html:187
+msgid "Fullscreen"
+msgstr "Πλήρης Οθόνη"
+
+#: ../vnc.html:192 ../vnc.html:199
+msgid "Settings"
+msgstr "Ρυθμίσεις"
+
+#: ../vnc.html:202
+msgid "Shared Mode"
+msgstr "Κοινόχρηστη Λειτουργία"
+
+#: ../vnc.html:205
+msgid "View Only"
+msgstr "Μόνο Θέαση"
+
+#: ../vnc.html:209
+msgid "Clip to Window"
+msgstr "Αποκοπή στο όριο του Παράθυρου"
+
+#: ../vnc.html:212
+msgid "Scaling Mode:"
+msgstr "Λειτουργία Κλιμάκωσης:"
+
+#: ../vnc.html:214
+msgid "None"
+msgstr "Καμία"
+
+#: ../vnc.html:215
+msgid "Local Scaling"
+msgstr "Τοπική Κλιμάκωση"
+
+#: ../vnc.html:216
+msgid "Remote Resizing"
+msgstr "Απομακρυσμένη Αλλαγή μεγέθους"
+
+#: ../vnc.html:221
+msgid "Advanced"
+msgstr "Για προχωρημένους"
+
+#: ../vnc.html:224
+msgid "Repeater ID:"
+msgstr "Repeater ID:"
+
+#: ../vnc.html:228
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:231
+msgid "Encrypt"
+msgstr "Κρυπτογράφηση"
+
+#: ../vnc.html:234
+msgid "Host:"
+msgstr "Όνομα διακομιστή:"
+
+#: ../vnc.html:238
+msgid "Port:"
+msgstr "Πόρτα διακομιστή:"
+
+#: ../vnc.html:242
+msgid "Path:"
+msgstr "Διαδρομή:"
+
+#: ../vnc.html:249
+msgid "Automatic Reconnect"
+msgstr "Αυτόματη επανασύνδεση"
+
+#: ../vnc.html:252
+msgid "Reconnect Delay (ms):"
+msgstr "Καθυστέρηση επανασύνδεσης (ms):"
+
+#: ../vnc.html:258
+msgid "Logging:"
+msgstr "Καταγραφή:"
+
+#: ../vnc.html:270
+msgid "Disconnect"
+msgstr "Αποσύνδεση"
+
+#: ../vnc.html:289
+msgid "Connect"
+msgstr "Σύνδεση"
+
+#: ../vnc.html:299
+msgid "Password:"
+msgstr "Κωδικός Πρόσβασης:"
+
+#: ../vnc.html:313
+msgid "Cancel"
+msgstr "Ακύρωση"
+
+#: ../vnc.html:329
+msgid "Canvas not supported."
+msgstr "Δεν υποστηρίζεται το στοιχείο Canvas"
+
+#~ msgid "Disconnect timeout"
+#~ msgstr "Παρέλευση χρονικού ορίου αποσύνδεσης"
+
+#~ msgid "Local Downscaling"
+#~ msgstr "Τοπική Συρρίκνωση"
+
+#~ msgid "Local Cursor"
+#~ msgstr "Τοπικός Δρομέας"
+
+#~ msgid ""
+#~ "Forcing clipping mode since scrollbars aren't supported by IE in "
+#~ "fullscreen"
+#~ msgstr ""
+#~ "Εφαρμογή λειτουργίας αποκοπής αφού δεν υποστηρίζονται οι λωρίδες κύλισης "
+#~ "σε πλήρη οθόνη στον IE"
+
+#~ msgid "True Color"
+#~ msgstr "Πραγματικά Χρώματα"
+
+#~ msgid "Style:"
+#~ msgstr "Στυλ:"
+
+#~ msgid "default"
+#~ msgstr "προεπιλεγμένο"
+
+#~ msgid "Apply"
+#~ msgstr "Εφαρμογή"
+
+#~ msgid "Connection"
+#~ msgstr "Σύνδεση"
+
+#~ msgid "Token:"
+#~ msgstr "Διακριτικό:"
+
+#~ msgid "Send Password"
+#~ msgstr "Αποστολή Κωδικού Πρόσβασης"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/es.po
@@ -0,0 +1,284 @@
+# Spanish translations for noVNC package
+# Traducciones al español para el paquete noVNC.
+# Copyright (C) 2018 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+# Juanjo Diaz <juanjo.diazmo@gmail.com>, 2018.
+# Adrian Scillato <ascillato@gmail.com>, 2021.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 1.0.0-testing.2\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2017-10-06 10:07+0200\n"
+"PO-Revision-Date: 2021-04-23 12:00-0300\n"
+"Last-Translator: Adrian Scillato <ascillato@gmail.com>\n"
+"Language-Team: Spanish\n"
+"Language: es\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+#: ../app/ui.js:430
+msgid "Connecting..."
+msgstr "Conectando..."
+
+#: ../app/ui.js:438
+msgid "Connected (encrypted) to "
+msgstr "Conectado (con encriptación) a"
+
+#: ../app/ui.js:440
+msgid "Connected (unencrypted) to "
+msgstr "Conectado (sin encriptación) a"
+
+#: ../app/ui.js:446
+msgid "Disconnecting..."
+msgstr "Desconectando..."
+
+#: ../app/ui.js:450
+msgid "Disconnected"
+msgstr "Desconectado"
+
+#: ../app/ui.js:1052 ../core/rfb.js:248
+msgid "Must set host"
+msgstr "Se debe configurar el host"
+
+#: ../app/ui.js:1101
+msgid "Reconnecting..."
+msgstr "Reconectando..."
+
+#: ../app/ui.js:1140
+msgid "Password is required"
+msgstr "La contraseña es obligatoria"
+
+#: ../core/rfb.js:548
+msgid "Disconnect timeout"
+msgstr "Tiempo de desconexión agotado"
+
+#: ../vnc.html:89
+msgid "noVNC encountered an error:"
+msgstr "noVNC ha encontrado un error:"
+
+#: ../vnc.html:99
+msgid "Hide/Show the control bar"
+msgstr "Ocultar/Mostrar la barra de control"
+
+#: ../vnc.html:106
+msgid "Move/Drag Viewport"
+msgstr "Mover/Arrastrar la ventana"
+
+#: ../vnc.html:106
+msgid "viewport drag"
+msgstr "Arrastrar la ventana"
+
+#: ../vnc.html:112 ../vnc.html:115 ../vnc.html:118 ../vnc.html:121
+msgid "Active Mouse Button"
+msgstr "Botón activo del ratón"
+
+#: ../vnc.html:112
+msgid "No mousebutton"
+msgstr "Ningún botón del ratón"
+
+#: ../vnc.html:115
+msgid "Left mousebutton"
+msgstr "Botón izquierdo del ratón"
+
+#: ../vnc.html:118
+msgid "Middle mousebutton"
+msgstr "Botón central del ratón"
+
+#: ../vnc.html:121
+msgid "Right mousebutton"
+msgstr "Botón derecho del ratón"
+
+#: ../vnc.html:124
+msgid "Keyboard"
+msgstr "Teclado"
+
+#: ../vnc.html:124
+msgid "Show Keyboard"
+msgstr "Mostrar teclado"
+
+#: ../vnc.html:131
+msgid "Extra keys"
+msgstr "Teclas adicionales"
+
+#: ../vnc.html:131
+msgid "Show Extra Keys"
+msgstr "Mostrar Teclas Adicionales"
+
+#: ../vnc.html:136
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:136
+msgid "Toggle Ctrl"
+msgstr "Pulsar/Soltar Ctrl"
+
+#: ../vnc.html:139
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:139
+msgid "Toggle Alt"
+msgstr "Pulsar/Soltar Alt"
+
+#: ../vnc.html:142
+msgid "Send Tab"
+msgstr "Enviar Tabulación"
+
+#: ../vnc.html:142
+msgid "Tab"
+msgstr "Tabulación"
+
+#: ../vnc.html:145
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:145
+msgid "Send Escape"
+msgstr "Enviar Escape"
+
+#: ../vnc.html:148
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl+Alt+Del"
+
+#: ../vnc.html:148
+msgid "Send Ctrl-Alt-Del"
+msgstr "Enviar Ctrl+Alt+Del"
+
+#: ../vnc.html:156
+msgid "Shutdown/Reboot"
+msgstr "Apagar/Reiniciar"
+
+#: ../vnc.html:156
+msgid "Shutdown/Reboot..."
+msgstr "Apagar/Reiniciar..."
+
+#: ../vnc.html:162
+msgid "Power"
+msgstr "Encender"
+
+#: ../vnc.html:164
+msgid "Shutdown"
+msgstr "Apagar"
+
+#: ../vnc.html:165
+msgid "Reboot"
+msgstr "Reiniciar"
+
+#: ../vnc.html:166
+msgid "Reset"
+msgstr "Restablecer"
+
+#: ../vnc.html:171 ../vnc.html:177
+msgid "Clipboard"
+msgstr "Portapapeles"
+
+#: ../vnc.html:181
+msgid "Clear"
+msgstr "Vaciar"
+
+#: ../vnc.html:187
+msgid "Fullscreen"
+msgstr "Pantalla Completa"
+
+#: ../vnc.html:192 ../vnc.html:199
+msgid "Settings"
+msgstr "Configuraciones"
+
+#: ../vnc.html:200
+msgid "Encrypt"
+msgstr "Encriptar"
+
+#: ../vnc.html:202
+msgid "Shared Mode"
+msgstr "Modo Compartido"
+
+#: ../vnc.html:205
+msgid "View Only"
+msgstr "Solo visualización"
+
+#: ../vnc.html:209
+msgid "Clip to Window"
+msgstr "Recortar al tamaño de la ventana"
+
+#: ../vnc.html:212
+msgid "Scaling Mode:"
+msgstr "Modo de escalado:"
+
+#: ../vnc.html:214
+msgid "None"
+msgstr "Ninguno"
+
+#: ../vnc.html:215
+msgid "Local Scaling"
+msgstr "Escalado Local"
+
+#: ../vnc.html:216
+msgid "Local Downscaling"
+msgstr "Reducción de escala local"
+
+#: ../vnc.html:217
+msgid "Remote Resizing"
+msgstr "Cambio de tamaño remoto"
+
+#: ../vnc.html:222
+msgid "Advanced"
+msgstr "Avanzado"
+
+#: ../vnc.html:225
+msgid "Local Cursor"
+msgstr "Cursor Local"
+
+#: ../vnc.html:229
+msgid "Repeater ID:"
+msgstr "ID del Repetidor:"
+
+#: ../vnc.html:233
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:239
+msgid "Host:"
+msgstr "Host:"
+
+#: ../vnc.html:243
+msgid "Port:"
+msgstr "Puerto:"
+
+#: ../vnc.html:247
+msgid "Path:"
+msgstr "Ruta:"
+
+#: ../vnc.html:254
+msgid "Automatic Reconnect"
+msgstr "Reconexión automática"
+
+#: ../vnc.html:257
+msgid "Reconnect Delay (ms):"
+msgstr "Retraso en la reconexión (ms):"
+
+#: ../vnc.html:263
+msgid "Logging:"
+msgstr "Registrando:"
+
+#: ../vnc.html:275
+msgid "Disconnect"
+msgstr "Desconectar"
+
+#: ../vnc.html:294
+msgid "Connect"
+msgstr "Conectar"
+
+#: ../vnc.html:304
+msgid "Password:"
+msgstr "Contraseña:"
+
+#: ../vnc.html:318
+msgid "Cancel"
+msgstr "Cancelar"
+
+#: ../vnc.html:334
+msgid "Canvas not supported."
+msgstr "Canvas no soportado."
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/fr.po
@@ -0,0 +1,300 @@
+# French translations for noVNC package
+# Traductions françaises du paquet noVNC.
+# Copyright (C) 2021 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+# Jose <jose.matsuda@canada.ca>, 2021.
+# Lowxorx <lowxorx@lahan.fr>, 2022.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 1.2.0\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2020-07-03 16:11+0200\n"
+"PO-Revision-Date: 2022-04-25 23:40+0200\n"
+"Last-Translator: Lowxorx <lowxorx@lahan.fr>\n"
+"Language-Team: French\n"
+"Language: fr\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n > 1);\n"
+
+#: ../app/ui.js:394
+msgid "Connecting..."
+msgstr "En cours de connexion..."
+
+#: ../app/ui.js:401
+msgid "Disconnecting..."
+msgstr "Déconnexion en cours..."
+
+#: ../app/ui.js:407
+msgid "Reconnecting..."
+msgstr "Reconnexion en cours..."
+
+#: ../app/ui.js:412
+msgid "Internal error"
+msgstr "Erreur interne"
+
+#: ../app/ui.js:1008
+msgid "Must set host"
+msgstr "Doit définir l'hôte"
+
+#: ../app/ui.js:1090
+msgid "Connected (encrypted) to "
+msgstr "Connecté (chiffré) à "
+
+#: ../app/ui.js:1092
+msgid "Connected (unencrypted) to "
+msgstr "Connecté (non chiffré) à "
+
+#: ../app/ui.js:1115
+msgid "Something went wrong, connection is closed"
+msgstr "Quelque chose s'est mal passé, la connexion a été fermée"
+
+#: ../app/ui.js:1118
+msgid "Failed to connect to server"
+msgstr "Échec de connexion au serveur"
+
+#: ../app/ui.js:1128
+msgid "Disconnected"
+msgstr "Déconnecté"
+
+#: ../app/ui.js:1143
+msgid "New connection has been rejected with reason: "
+msgstr "Une nouvelle connexion a été rejetée avec motif : "
+
+#: ../app/ui.js:1146
+msgid "New connection has been rejected"
+msgstr "Une nouvelle connexion a été rejetée"
+
+#: ../app/ui.js:1181
+msgid "Credentials are required"
+msgstr "Les identifiants sont requis"
+
+#: ../vnc.html:74
+msgid "noVNC encountered an error:"
+msgstr "noVNC a rencontré une erreur :"
+
+#: ../vnc.html:84
+msgid "Hide/Show the control bar"
+msgstr "Masquer/Afficher la barre de contrôle"
+
+#: ../vnc.html:91
+msgid "Drag"
+msgstr "Faire glisser"
+
+#: ../vnc.html:91
+msgid "Move/Drag Viewport"
+msgstr "Déplacer/faire glisser le Viewport"
+
+#: ../vnc.html:97
+msgid "Keyboard"
+msgstr "Clavier"
+
+#: ../vnc.html:97
+msgid "Show Keyboard"
+msgstr "Afficher le clavier"
+
+#: ../vnc.html:102
+msgid "Extra keys"
+msgstr "Touches supplémentaires"
+
+#: ../vnc.html:102
+msgid "Show Extra Keys"
+msgstr "Afficher les touches supplémentaires"
+
+#: ../vnc.html:107
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:107
+msgid "Toggle Ctrl"
+msgstr "Basculer Ctrl"
+
+#: ../vnc.html:110
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:110
+msgid "Toggle Alt"
+msgstr "Basculer Alt"
+
+#: ../vnc.html:113
+msgid "Toggle Windows"
+msgstr "Basculer Windows"
+
+#: ../vnc.html:113
+msgid "Windows"
+msgstr "Windows"
+
+#: ../vnc.html:116
+msgid "Send Tab"
+msgstr "Envoyer l'onglet"
+
+#: ../vnc.html:116
+msgid "Tab"
+msgstr "l'onglet"
+
+#: ../vnc.html:119
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:119
+msgid "Send Escape"
+msgstr "Envoyer Escape"
+
+#: ../vnc.html:122
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl+Alt+Del"
+
+#: ../vnc.html:122
+msgid "Send Ctrl-Alt-Del"
+msgstr "Envoyer Ctrl-Alt-Del"
+
+#: ../vnc.html:129
+msgid "Shutdown/Reboot"
+msgstr "Arrêter/Redémarrer"
+
+#: ../vnc.html:129
+msgid "Shutdown/Reboot..."
+msgstr "Arrêter/Redémarrer..."
+
+#: ../vnc.html:135
+msgid "Power"
+msgstr "Alimentation"
+
+#: ../vnc.html:137
+msgid "Shutdown"
+msgstr "Arrêter"
+
+#: ../vnc.html:138
+msgid "Reboot"
+msgstr "Redémarrer"
+
+#: ../vnc.html:139
+msgid "Reset"
+msgstr "Réinitialiser"
+
+#: ../vnc.html:144 ../vnc.html:150
+msgid "Clipboard"
+msgstr "Presse-papiers"
+
+#: ../vnc.html:154
+msgid "Clear"
+msgstr "Effacer"
+
+#: ../vnc.html:160
+msgid "Fullscreen"
+msgstr "Plein écran"
+
+#: ../vnc.html:165 ../vnc.html:172
+msgid "Settings"
+msgstr "Paramètres"
+
+#: ../vnc.html:175
+msgid "Shared Mode"
+msgstr "Mode partagé"
+
+#: ../vnc.html:178
+msgid "View Only"
+msgstr "Afficher uniquement"
+
+#: ../vnc.html:182
+msgid "Clip to Window"
+msgstr "Clip à fenêtre"
+
+#: ../vnc.html:185
+msgid "Scaling Mode:"
+msgstr "Mode mise à l'échelle :"
+
+#: ../vnc.html:187
+msgid "None"
+msgstr "Aucun"
+
+#: ../vnc.html:188
+msgid "Local Scaling"
+msgstr "Mise à l'échelle locale"
+
+#: ../vnc.html:189
+msgid "Remote Resizing"
+msgstr "Redimensionnement à distance"
+
+#: ../vnc.html:194
+msgid "Advanced"
+msgstr "Avancé"
+
+#: ../vnc.html:197
+msgid "Quality:"
+msgstr "Qualité :"
+
+#: ../vnc.html:201
+msgid "Compression level:"
+msgstr "Niveau de compression :"
+
+#: ../vnc.html:206
+msgid "Repeater ID:"
+msgstr "ID Répéteur :"
+
+#: ../vnc.html:210
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:213
+msgid "Encrypt"
+msgstr "Chiffrer"
+
+#: ../vnc.html:216
+msgid "Host:"
+msgstr "Hôte :"
+
+#: ../vnc.html:220
+msgid "Port:"
+msgstr "Port :"
+
+#: ../vnc.html:224
+msgid "Path:"
+msgstr "Chemin :"
+
+#: ../vnc.html:231
+msgid "Automatic Reconnect"
+msgstr "Reconnecter automatiquemen"
+
+#: ../vnc.html:234
+msgid "Reconnect Delay (ms):"
+msgstr "Délai de reconnexion (ms) :"
+
+#: ../vnc.html:239
+msgid "Show Dot when No Cursor"
+msgstr "Afficher le point lorsqu'il n'y a pas de curseur"
+
+#: ../vnc.html:244
+msgid "Logging:"
+msgstr "Se connecter :"
+
+#: ../vnc.html:253
+msgid "Version:"
+msgstr "Version :"
+
+#: ../vnc.html:261
+msgid "Disconnect"
+msgstr "Déconnecter"
+
+#: ../vnc.html:280
+msgid "Connect"
+msgstr "Connecter"
+
+#: ../vnc.html:290
+msgid "Username:"
+msgstr "Nom d'utilisateur :"
+
+#: ../vnc.html:294
+msgid "Password:"
+msgstr "Mot de passe :"
+
+#: ../vnc.html:298
+msgid "Send Credentials"
+msgstr "Envoyer les identifiants"
+
+#: ../vnc.html:308
+msgid "Cancel"
+msgstr "Annuler"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/it.po
@@ -0,0 +1,300 @@
+# Italian translations for noVNC
+# Traduzione italiana di noVNC
+# Copyright (C) 2022 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+# Fabio Fantoni <fabio.fantoni@m2r.biz>, 2022.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 1.3.0\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2021-08-27 16:03+0200\n"
+"PO-Revision-Date: 2022-09-08 13:27+0200\n"
+"Last-Translator: Fabio Fantoni <fabio.fantoni@m2r.biz>\n"
+"Language-Team: Italian\n"
+"Language: it\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+"X-Generator: Poedit 3.1.1\n"
+
+#: ../app/ui.js:400
+msgid "Connecting..."
+msgstr "Connessione in corso..."
+
+#: ../app/ui.js:407
+msgid "Disconnecting..."
+msgstr "Disconnessione..."
+
+#: ../app/ui.js:413
+msgid "Reconnecting..."
+msgstr "Riconnessione..."
+
+#: ../app/ui.js:418
+msgid "Internal error"
+msgstr "Errore interno"
+
+#: ../app/ui.js:1009
+msgid "Must set host"
+msgstr "Devi impostare l'host"
+
+#: ../app/ui.js:1091
+msgid "Connected (encrypted) to "
+msgstr "Connesso (crittografato) a "
+
+#: ../app/ui.js:1093
+msgid "Connected (unencrypted) to "
+msgstr "Connesso (non crittografato) a"
+
+#: ../app/ui.js:1116
+msgid "Something went wrong, connection is closed"
+msgstr "Qualcosa è andato storto, la connessione è stata chiusa"
+
+#: ../app/ui.js:1119
+msgid "Failed to connect to server"
+msgstr "Impossibile connettersi al server"
+
+#: ../app/ui.js:1129
+msgid "Disconnected"
+msgstr "Disconnesso"
+
+#: ../app/ui.js:1144
+msgid "New connection has been rejected with reason: "
+msgstr "La nuova connessione è stata rifiutata con motivo: "
+
+#: ../app/ui.js:1147
+msgid "New connection has been rejected"
+msgstr "La nuova connessione è stata rifiutata"
+
+#: ../app/ui.js:1182
+msgid "Credentials are required"
+msgstr "Le credenziali sono obbligatorie"
+
+#: ../vnc.html:61
+msgid "noVNC encountered an error:"
+msgstr "noVNC ha riscontrato un errore:"
+
+#: ../vnc.html:71
+msgid "Hide/Show the control bar"
+msgstr "Nascondi/Mostra la barra di controllo"
+
+#: ../vnc.html:78
+msgid "Drag"
+msgstr ""
+
+#: ../vnc.html:78
+msgid "Move/Drag Viewport"
+msgstr ""
+
+#: ../vnc.html:84
+msgid "Keyboard"
+msgstr "Tastiera"
+
+#: ../vnc.html:84
+msgid "Show Keyboard"
+msgstr "Mostra tastiera"
+
+#: ../vnc.html:89
+msgid "Extra keys"
+msgstr "Tasti Aggiuntivi"
+
+#: ../vnc.html:89
+msgid "Show Extra Keys"
+msgstr "Mostra Tasti Aggiuntivi"
+
+#: ../vnc.html:94
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:94
+msgid "Toggle Ctrl"
+msgstr "Tieni premuto Ctrl"
+
+#: ../vnc.html:97
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:97
+msgid "Toggle Alt"
+msgstr "Tieni premuto Alt"
+
+#: ../vnc.html:100
+msgid "Toggle Windows"
+msgstr "Tieni premuto Windows"
+
+#: ../vnc.html:100
+msgid "Windows"
+msgstr "Windows"
+
+#: ../vnc.html:103
+msgid "Send Tab"
+msgstr "Invia Tab"
+
+#: ../vnc.html:103
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:106
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:106
+msgid "Send Escape"
+msgstr "Invia Esc"
+
+#: ../vnc.html:109
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl+Alt+Canc"
+
+#: ../vnc.html:109
+msgid "Send Ctrl-Alt-Del"
+msgstr "Invia Ctrl-Alt-Canc"
+
+#: ../vnc.html:116
+msgid "Shutdown/Reboot"
+msgstr "Spegnimento/Riavvio"
+
+#: ../vnc.html:116
+msgid "Shutdown/Reboot..."
+msgstr "Spegnimento/Riavvio..."
+
+#: ../vnc.html:122
+msgid "Power"
+msgstr "Alimentazione"
+
+#: ../vnc.html:124
+msgid "Shutdown"
+msgstr "Spegnimento"
+
+#: ../vnc.html:125
+msgid "Reboot"
+msgstr "Riavvio"
+
+#: ../vnc.html:126
+msgid "Reset"
+msgstr "Reset"
+
+#: ../vnc.html:131 ../vnc.html:137
+msgid "Clipboard"
+msgstr "Clipboard"
+
+#: ../vnc.html:141
+msgid "Clear"
+msgstr "Pulisci"
+
+#: ../vnc.html:147
+msgid "Fullscreen"
+msgstr "Schermo intero"
+
+#: ../vnc.html:152 ../vnc.html:159
+msgid "Settings"
+msgstr "Impostazioni"
+
+#: ../vnc.html:162
+msgid "Shared Mode"
+msgstr "Modalità condivisa"
+
+#: ../vnc.html:165
+msgid "View Only"
+msgstr "Sola Visualizzazione"
+
+#: ../vnc.html:169
+msgid "Clip to Window"
+msgstr ""
+
+#: ../vnc.html:172
+msgid "Scaling Mode:"
+msgstr "Modalità di ridimensionamento:"
+
+#: ../vnc.html:174
+msgid "None"
+msgstr "Nessuna"
+
+#: ../vnc.html:175
+msgid "Local Scaling"
+msgstr "Ridimensionamento Locale"
+
+#: ../vnc.html:176
+msgid "Remote Resizing"
+msgstr "Ridimensionamento Remoto"
+
+#: ../vnc.html:181
+msgid "Advanced"
+msgstr "Avanzate"
+
+#: ../vnc.html:184
+msgid "Quality:"
+msgstr "Qualità:"
+
+#: ../vnc.html:188
+msgid "Compression level:"
+msgstr "Livello Compressione:"
+
+#: ../vnc.html:193
+msgid "Repeater ID:"
+msgstr "ID Ripetitore:"
+
+#: ../vnc.html:197
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:200
+msgid "Encrypt"
+msgstr "Crittografa"
+
+#: ../vnc.html:203
+msgid "Host:"
+msgstr "Host:"
+
+#: ../vnc.html:207
+msgid "Port:"
+msgstr "Porta:"
+
+#: ../vnc.html:211
+msgid "Path:"
+msgstr "Percorso:"
+
+#: ../vnc.html:218
+msgid "Automatic Reconnect"
+msgstr "Riconnessione Automatica"
+
+#: ../vnc.html:221
+msgid "Reconnect Delay (ms):"
+msgstr "Ritardo Riconnessione (ms):"
+
+#: ../vnc.html:226
+msgid "Show Dot when No Cursor"
+msgstr "Mostra Punto quando Nessun Cursore"
+
+#: ../vnc.html:231
+msgid "Logging:"
+msgstr ""
+
+#: ../vnc.html:240
+msgid "Version:"
+msgstr "Versione:"
+
+#: ../vnc.html:248
+msgid "Disconnect"
+msgstr "Disconnetti"
+
+#: ../vnc.html:267
+msgid "Connect"
+msgstr "Connetti"
+
+#: ../vnc.html:277
+msgid "Username:"
+msgstr "Utente:"
+
+#: ../vnc.html:281
+msgid "Password:"
+msgstr "Password:"
+
+#: ../vnc.html:285
+msgid "Send Credentials"
+msgstr "Invia Credenziale"
+
+#: ../vnc.html:295
+msgid "Cancel"
+msgstr "Annulla"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/ja.po
@@ -0,0 +1,324 @@
+# Japanese translations for noVNC package
+# noVNC パッケージに対する日訳
+# Copyright (C) 2019 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+# nnn1590 <nnn1590@nnn1590.org>, 2019-2020.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 1.1.0\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2020-07-03 16:11+0200\n"
+"PO-Revision-Date: 2021-01-15 12:37+0900\n"
+"Last-Translator: nnn1590 <nnn1590@nnn1590.org>\n"
+"Language-Team: Japanese\n"
+"Language: ja\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+"X-Generator: Poedit 2.3\n"
+
+#: ../app/ui.js:394
+msgid "Connecting..."
+msgstr "接続しています..."
+
+#: ../app/ui.js:401
+msgid "Disconnecting..."
+msgstr "切断しています..."
+
+#: ../app/ui.js:407
+msgid "Reconnecting..."
+msgstr "再接続しています..."
+
+#: ../app/ui.js:412
+msgid "Internal error"
+msgstr "内部エラー"
+
+#: ../app/ui.js:1008
+msgid "Must set host"
+msgstr "ホストを設定する必要があります"
+
+#: ../app/ui.js:1090
+msgid "Connected (encrypted) to "
+msgstr "接続しました (暗号化済み): "
+
+#: ../app/ui.js:1092
+msgid "Connected (unencrypted) to "
+msgstr "接続しました (暗号化されていません): "
+
+#: ../app/ui.js:1115
+msgid "Something went wrong, connection is closed"
+msgstr "何らかの問題で、接続が閉じられました"
+
+#: ../app/ui.js:1118
+msgid "Failed to connect to server"
+msgstr "サーバーへの接続に失敗しました"
+
+#: ../app/ui.js:1128
+msgid "Disconnected"
+msgstr "切断しました"
+
+#: ../app/ui.js:1143
+msgid "New connection has been rejected with reason: "
+msgstr "新規接続は次の理由で拒否されました: "
+
+#: ../app/ui.js:1146
+msgid "New connection has been rejected"
+msgstr "新規接続は拒否されました"
+
+#: ../app/ui.js:1181
+msgid "Credentials are required"
+msgstr "資格情報が必要です"
+
+#: ../vnc.html:74
+msgid "noVNC encountered an error:"
+msgstr "noVNC でエラーが発生しました:"
+
+#: ../vnc.html:84
+msgid "Hide/Show the control bar"
+msgstr "コントロールバーを隠す/表示する"
+
+#: ../vnc.html:91
+msgid "Drag"
+msgstr "ドラッグ"
+
+#: ../vnc.html:91
+msgid "Move/Drag Viewport"
+msgstr "ビューポートを移動/ドラッグ"
+
+#: ../vnc.html:97
+msgid "Keyboard"
+msgstr "キーボード"
+
+#: ../vnc.html:97
+msgid "Show Keyboard"
+msgstr "キーボードを表示"
+
+#: ../vnc.html:102
+msgid "Extra keys"
+msgstr "追加キー"
+
+#: ../vnc.html:102
+msgid "Show Extra Keys"
+msgstr "追加キーを表示"
+
+#: ../vnc.html:107
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:107
+msgid "Toggle Ctrl"
+msgstr "Ctrl キーを切り替え"
+
+#: ../vnc.html:110
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:110
+msgid "Toggle Alt"
+msgstr "Alt キーを切り替え"
+
+#: ../vnc.html:113
+msgid "Toggle Windows"
+msgstr "Windows キーを切り替え"
+
+#: ../vnc.html:113
+msgid "Windows"
+msgstr "Windows"
+
+#: ../vnc.html:116
+msgid "Send Tab"
+msgstr "Tab キーを送信"
+
+#: ../vnc.html:116
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:119
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:119
+msgid "Send Escape"
+msgstr "Escape キーを送信"
+
+#: ../vnc.html:122
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl+Alt+Del"
+
+#: ../vnc.html:122
+msgid "Send Ctrl-Alt-Del"
+msgstr "Ctrl-Alt-Del を送信"
+
+#: ../vnc.html:129
+msgid "Shutdown/Reboot"
+msgstr "シャットダウン/再起動"
+
+#: ../vnc.html:129
+msgid "Shutdown/Reboot..."
+msgstr "シャットダウン/再起動..."
+
+#: ../vnc.html:135
+msgid "Power"
+msgstr "電源"
+
+#: ../vnc.html:137
+msgid "Shutdown"
+msgstr "シャットダウン"
+
+#: ../vnc.html:138
+msgid "Reboot"
+msgstr "再起動"
+
+#: ../vnc.html:139
+msgid "Reset"
+msgstr "リセット"
+
+#: ../vnc.html:144 ../vnc.html:150
+msgid "Clipboard"
+msgstr "クリップボード"
+
+#: ../vnc.html:154
+msgid "Clear"
+msgstr "クリア"
+
+#: ../vnc.html:160
+msgid "Fullscreen"
+msgstr "全画面表示"
+
+#: ../vnc.html:165 ../vnc.html:172
+msgid "Settings"
+msgstr "設定"
+
+#: ../vnc.html:175
+msgid "Shared Mode"
+msgstr "共有モード"
+
+#: ../vnc.html:178
+msgid "View Only"
+msgstr "表示のみ"
+
+#: ../vnc.html:182
+msgid "Clip to Window"
+msgstr "ウィンドウにクリップ"
+
+#: ../vnc.html:185
+msgid "Scaling Mode:"
+msgstr "スケーリングモード:"
+
+#: ../vnc.html:187
+msgid "None"
+msgstr "なし"
+
+#: ../vnc.html:188
+msgid "Local Scaling"
+msgstr "ローカルスケーリング"
+
+#: ../vnc.html:189
+msgid "Remote Resizing"
+msgstr "リモートでリサイズ"
+
+#: ../vnc.html:194
+msgid "Advanced"
+msgstr "高度"
+
+#: ../vnc.html:197
+msgid "Quality:"
+msgstr "品質:"
+
+#: ../vnc.html:201
+msgid "Compression level:"
+msgstr "圧縮レベル:"
+
+#: ../vnc.html:206
+msgid "Repeater ID:"
+msgstr "リピーター ID:"
+
+#: ../vnc.html:210
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:213
+msgid "Encrypt"
+msgstr "暗号化"
+
+#: ../vnc.html:216
+msgid "Host:"
+msgstr "ホスト:"
+
+#: ../vnc.html:220
+msgid "Port:"
+msgstr "ポート:"
+
+#: ../vnc.html:224
+msgid "Path:"
+msgstr "パス:"
+
+#: ../vnc.html:231
+msgid "Automatic Reconnect"
+msgstr "自動再接続"
+
+#: ../vnc.html:234
+msgid "Reconnect Delay (ms):"
+msgstr "再接続する遅延 (ミリ秒):"
+
+#: ../vnc.html:239
+msgid "Show Dot when No Cursor"
+msgstr "カーソルがないときにドットを表示"
+
+#: ../vnc.html:244
+msgid "Logging:"
+msgstr "ロギング:"
+
+#: ../vnc.html:253
+msgid "Version:"
+msgstr "バージョン:"
+
+#: ../vnc.html:261
+msgid "Disconnect"
+msgstr "切断"
+
+#: ../vnc.html:280
+msgid "Connect"
+msgstr "接続"
+
+#: ../vnc.html:290
+msgid "Username:"
+msgstr "ユーザー名:"
+
+#: ../vnc.html:294
+msgid "Password:"
+msgstr "パスワード:"
+
+#: ../vnc.html:298
+msgid "Send Credentials"
+msgstr "資格情報を送信"
+
+#: ../vnc.html:308
+msgid "Cancel"
+msgstr "キャンセル"
+
+#~ msgid "Password is required"
+#~ msgstr "パスワードが必要です"
+
+#~ msgid "viewport drag"
+#~ msgstr "ビューポートをドラッグ"
+
+#~ msgid "Active Mouse Button"
+#~ msgstr "アクティブなマウスボタン"
+
+#~ msgid "No mousebutton"
+#~ msgstr "マウスボタンなし"
+
+#~ msgid "Left mousebutton"
+#~ msgstr "左マウスボタン"
+
+#~ msgid "Middle mousebutton"
+#~ msgstr "中マウスボタン"
+
+#~ msgid "Right mousebutton"
+#~ msgstr "右マウスボタン"
+
+#~ msgid "Send Password"
+#~ msgstr "パスワードを送信"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/ko.po
@@ -0,0 +1,290 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) 2018 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+# Baw Appie <pp121324@gmail.com>, 2018.
+#
+#, fuzzy
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 1.0.0-testing.2\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2018-01-31 16:29+0100\n"
+"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
+"Last-Translator: Baw Appie <pp121324@gmail.com>\n"
+"Language-Team: Korean\n"
+"Language: ko\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: ../app/ui.js:395
+msgid "Connecting..."
+msgstr "연결중..."
+
+#: ../app/ui.js:402
+msgid "Disconnecting..."
+msgstr "연결 해제중..."
+
+#: ../app/ui.js:408
+msgid "Reconnecting..."
+msgstr "재연결중..."
+
+#: ../app/ui.js:413
+msgid "Internal error"
+msgstr "내부 오류"
+
+#: ../app/ui.js:1002
+msgid "Must set host"
+msgstr "호스트는 설정되어야 합니다."
+
+#: ../app/ui.js:1083
+msgid "Connected (encrypted) to "
+msgstr "다음과 (암호화되어) 연결되었습니다:"
+
+#: ../app/ui.js:1085
+msgid "Connected (unencrypted) to "
+msgstr "다음과 (암호화 없이) 연결되었습니다:"
+
+#: ../app/ui.js:1108
+msgid "Something went wrong, connection is closed"
+msgstr "무언가 잘못되었습니다, 연결이 닫혔습니다."
+
+#: ../app/ui.js:1111
+msgid "Failed to connect to server"
+msgstr "서버에 연결하지 못했습니다."
+
+#: ../app/ui.js:1121
+msgid "Disconnected"
+msgstr "연결이 해제되었습니다."
+
+#: ../app/ui.js:1134
+msgid "New connection has been rejected with reason: "
+msgstr "새 연결이 다음 이유로 거부되었습니다:"
+
+#: ../app/ui.js:1137
+msgid "New connection has been rejected"
+msgstr "새 연결이 거부되었습니다."
+
+#: ../app/ui.js:1158
+msgid "Password is required"
+msgstr "비밀번호가 필요합니다."
+
+#: ../vnc.html:91
+msgid "noVNC encountered an error:"
+msgstr "noVNC에 오류가 발생했습니다:"
+
+#: ../vnc.html:101
+msgid "Hide/Show the control bar"
+msgstr "컨트롤 바 숨기기/보이기"
+
+#: ../vnc.html:108
+msgid "Move/Drag Viewport"
+msgstr "움직이기/드래그 뷰포트"
+
+#: ../vnc.html:108
+msgid "viewport drag"
+msgstr "뷰포트 드래그"
+
+#: ../vnc.html:114 ../vnc.html:117 ../vnc.html:120 ../vnc.html:123
+msgid "Active Mouse Button"
+msgstr "마우스 버튼 활성화"
+
+#: ../vnc.html:114
+msgid "No mousebutton"
+msgstr "마우스 버튼 없음"
+
+#: ../vnc.html:117
+msgid "Left mousebutton"
+msgstr "왼쪽 마우스 버튼"
+
+#: ../vnc.html:120
+msgid "Middle mousebutton"
+msgstr "중간 마우스 버튼"
+
+#: ../vnc.html:123
+msgid "Right mousebutton"
+msgstr "오른쪽 마우스 버튼"
+
+#: ../vnc.html:126
+msgid "Keyboard"
+msgstr "키보드"
+
+#: ../vnc.html:126
+msgid "Show Keyboard"
+msgstr "키보드 보이기"
+
+#: ../vnc.html:133
+msgid "Extra keys"
+msgstr "기타 키들"
+
+#: ../vnc.html:133
+msgid "Show Extra Keys"
+msgstr "기타 키들 보이기"
+
+#: ../vnc.html:138
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:138
+msgid "Toggle Ctrl"
+msgstr "Ctrl 켜기/끄기"
+
+#: ../vnc.html:141
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:141
+msgid "Toggle Alt"
+msgstr "Alt 켜기/끄기"
+
+#: ../vnc.html:144
+msgid "Send Tab"
+msgstr "Tab 보내기"
+
+#: ../vnc.html:144
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:147
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:147
+msgid "Send Escape"
+msgstr "Esc 보내기"
+
+#: ../vnc.html:150
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl+Alt+Del"
+
+#: ../vnc.html:150
+msgid "Send Ctrl-Alt-Del"
+msgstr "Ctrl+Alt+Del 보내기"
+
+#: ../vnc.html:158
+msgid "Shutdown/Reboot"
+msgstr "셧다운/리붓"
+
+#: ../vnc.html:158
+msgid "Shutdown/Reboot..."
+msgstr "셧다운/리붓..."
+
+#: ../vnc.html:164
+msgid "Power"
+msgstr "전원"
+
+#: ../vnc.html:166
+msgid "Shutdown"
+msgstr "셧다운"
+
+#: ../vnc.html:167
+msgid "Reboot"
+msgstr "리붓"
+
+#: ../vnc.html:168
+msgid "Reset"
+msgstr "리셋"
+
+#: ../vnc.html:173 ../vnc.html:179
+msgid "Clipboard"
+msgstr "클립보드"
+
+#: ../vnc.html:183
+msgid "Clear"
+msgstr "지우기"
+
+#: ../vnc.html:189
+msgid "Fullscreen"
+msgstr "전체화면"
+
+#: ../vnc.html:194 ../vnc.html:201
+msgid "Settings"
+msgstr "설정"
+
+#: ../vnc.html:204
+msgid "Shared Mode"
+msgstr "공유 모드"
+
+#: ../vnc.html:207
+msgid "View Only"
+msgstr "보기 전용"
+
+#: ../vnc.html:211
+msgid "Clip to Window"
+msgstr "창에 클립"
+
+#: ../vnc.html:214
+msgid "Scaling Mode:"
+msgstr "스케일링 모드:"
+
+#: ../vnc.html:216
+msgid "None"
+msgstr "없음"
+
+#: ../vnc.html:217
+msgid "Local Scaling"
+msgstr "로컬 스케일링"
+
+#: ../vnc.html:218
+msgid "Remote Resizing"
+msgstr "원격 크기 조절"
+
+#: ../vnc.html:223
+msgid "Advanced"
+msgstr "고급"
+
+#: ../vnc.html:226
+msgid "Repeater ID:"
+msgstr "중계 ID"
+
+#: ../vnc.html:230
+msgid "WebSocket"
+msgstr "웹소켓"
+
+#: ../vnc.html:233
+msgid "Encrypt"
+msgstr "암호화"
+
+#: ../vnc.html:236
+msgid "Host:"
+msgstr "호스트:"
+
+#: ../vnc.html:240
+msgid "Port:"
+msgstr "포트:"
+
+#: ../vnc.html:244
+msgid "Path:"
+msgstr "위치:"
+
+#: ../vnc.html:251
+msgid "Automatic Reconnect"
+msgstr "자동 재연결"
+
+#: ../vnc.html:254
+msgid "Reconnect Delay (ms):"
+msgstr "재연결 지연 시간 (ms)"
+
+#: ../vnc.html:260
+msgid "Logging:"
+msgstr "로깅"
+
+#: ../vnc.html:272
+msgid "Disconnect"
+msgstr "연결 해제"
+
+#: ../vnc.html:291
+msgid "Connect"
+msgstr "연결"
+
+#: ../vnc.html:301
+msgid "Password:"
+msgstr "비밀번호:"
+
+#: ../vnc.html:305
+msgid "Send Password"
+msgstr "비밀번호 전송"
+
+#: ../vnc.html:315
+msgid "Cancel"
+msgstr "취소"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/nl.po
@@ -0,0 +1,322 @@
+# Dutch translations for noVNC package
+# Nederlandse vertalingen voor het pakket noVNC.
+# Copyright (C) 2018 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+# Loek Janssen <loekjanssen@gmail.com>, 2016.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 1.1.0\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2019-04-09 11:06+0100\n"
+"PO-Revision-Date: 2019-04-09 17:17+0100\n"
+"Last-Translator: Arend Lapere <arend.lapere@gmail.com>\n"
+"Language-Team: none\n"
+"Language: nl\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+#: ../app/ui.js:383
+msgid "Connecting..."
+msgstr "Verbinden..."
+
+#: ../app/ui.js:390
+msgid "Disconnecting..."
+msgstr "Verbinding verbreken..."
+
+#: ../app/ui.js:396
+msgid "Reconnecting..."
+msgstr "Opnieuw verbinding maken..."
+
+#: ../app/ui.js:401
+msgid "Internal error"
+msgstr "Interne fout"
+
+#: ../app/ui.js:991
+msgid "Must set host"
+msgstr "Host moeten worden ingesteld"
+
+#: ../app/ui.js:1073
+msgid "Connected (encrypted) to "
+msgstr "Verbonden (versleuteld) met "
+
+#: ../app/ui.js:1075
+msgid "Connected (unencrypted) to "
+msgstr "Verbonden (onversleuteld) met "
+
+#: ../app/ui.js:1098
+msgid "Something went wrong, connection is closed"
+msgstr "Er iets fout gelopen, verbinding werd verbroken"
+
+#: ../app/ui.js:1101
+msgid "Failed to connect to server"
+msgstr "Verbinding maken met server is mislukt"
+
+#: ../app/ui.js:1111
+msgid "Disconnected"
+msgstr "Verbinding verbroken"
+
+#: ../app/ui.js:1124
+msgid "New connection has been rejected with reason: "
+msgstr "Nieuwe verbinding is geweigerd omwille van de volgende reden: "
+
+#: ../app/ui.js:1127
+msgid "New connection has been rejected"
+msgstr "Nieuwe verbinding is geweigerd"
+
+#: ../app/ui.js:1147
+msgid "Password is required"
+msgstr "Wachtwoord is vereist"
+
+#: ../vnc.html:80
+msgid "noVNC encountered an error:"
+msgstr "noVNC heeft een fout bemerkt:"
+
+#: ../vnc.html:90
+msgid "Hide/Show the control bar"
+msgstr "Verberg/Toon de bedieningsbalk"
+
+#: ../vnc.html:97
+msgid "Move/Drag Viewport"
+msgstr "Verplaats/Versleep Kijkvenster"
+
+#: ../vnc.html:97
+msgid "viewport drag"
+msgstr "kijkvenster slepen"
+
+#: ../vnc.html:103 ../vnc.html:106 ../vnc.html:109 ../vnc.html:112
+msgid "Active Mouse Button"
+msgstr "Actieve Muisknop"
+
+#: ../vnc.html:103
+msgid "No mousebutton"
+msgstr "Geen muisknop"
+
+#: ../vnc.html:106
+msgid "Left mousebutton"
+msgstr "Linker muisknop"
+
+#: ../vnc.html:109
+msgid "Middle mousebutton"
+msgstr "Middelste muisknop"
+
+#: ../vnc.html:112
+msgid "Right mousebutton"
+msgstr "Rechter muisknop"
+
+#: ../vnc.html:115
+msgid "Keyboard"
+msgstr "Toetsenbord"
+
+#: ../vnc.html:115
+msgid "Show Keyboard"
+msgstr "Toon Toetsenbord"
+
+#: ../vnc.html:121
+msgid "Extra keys"
+msgstr "Extra toetsen"
+
+#: ../vnc.html:121
+msgid "Show Extra Keys"
+msgstr "Toon Extra Toetsen"
+
+#: ../vnc.html:126
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:126
+msgid "Toggle Ctrl"
+msgstr "Ctrl omschakelen"
+
+#: ../vnc.html:129
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:129
+msgid "Toggle Alt"
+msgstr "Alt omschakelen"
+
+#: ../vnc.html:132
+msgid "Toggle Windows"
+msgstr "Windows omschakelen"
+
+#: ../vnc.html:132
+msgid "Windows"
+msgstr "Windows"
+
+#: ../vnc.html:135
+msgid "Send Tab"
+msgstr "Tab Sturen"
+
+#: ../vnc.html:135
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:138
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:138
+msgid "Send Escape"
+msgstr "Escape Sturen"
+
+#: ../vnc.html:141
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl-Alt-Del"
+
+#: ../vnc.html:141
+msgid "Send Ctrl-Alt-Del"
+msgstr "Ctrl-Alt-Del Sturen"
+
+#: ../vnc.html:149
+msgid "Shutdown/Reboot"
+msgstr "Uitschakelen/Herstarten"
+
+#: ../vnc.html:149
+msgid "Shutdown/Reboot..."
+msgstr "Uitschakelen/Herstarten..."
+
+#: ../vnc.html:155
+msgid "Power"
+msgstr "Systeem"
+
+#: ../vnc.html:157
+msgid "Shutdown"
+msgstr "Uitschakelen"
+
+#: ../vnc.html:158
+msgid "Reboot"
+msgstr "Herstarten"
+
+#: ../vnc.html:159
+msgid "Reset"
+msgstr "Resetten"
+
+#: ../vnc.html:164 ../vnc.html:170
+msgid "Clipboard"
+msgstr "Klembord"
+
+#: ../vnc.html:174
+msgid "Clear"
+msgstr "Wissen"
+
+#: ../vnc.html:180
+msgid "Fullscreen"
+msgstr "Volledig Scherm"
+
+#: ../vnc.html:185 ../vnc.html:192
+msgid "Settings"
+msgstr "Instellingen"
+
+#: ../vnc.html:195
+msgid "Shared Mode"
+msgstr "Gedeelde Modus"
+
+#: ../vnc.html:198
+msgid "View Only"
+msgstr "Alleen Kijken"
+
+#: ../vnc.html:202
+msgid "Clip to Window"
+msgstr "Randen buiten venster afsnijden"
+
+#: ../vnc.html:205
+msgid "Scaling Mode:"
+msgstr "Schaalmodus:"
+
+#: ../vnc.html:207
+msgid "None"
+msgstr "Geen"
+
+#: ../vnc.html:208
+msgid "Local Scaling"
+msgstr "Lokaal Schalen"
+
+#: ../vnc.html:209
+msgid "Remote Resizing"
+msgstr "Op Afstand Formaat Wijzigen"
+
+#: ../vnc.html:214
+msgid "Advanced"
+msgstr "Geavanceerd"
+
+#: ../vnc.html:217
+msgid "Repeater ID:"
+msgstr "Repeater ID:"
+
+#: ../vnc.html:221
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:224
+msgid "Encrypt"
+msgstr "Versleutelen"
+
+#: ../vnc.html:227
+msgid "Host:"
+msgstr "Host:"
+
+#: ../vnc.html:231
+msgid "Port:"
+msgstr "Poort:"
+
+#: ../vnc.html:235
+msgid "Path:"
+msgstr "Pad:"
+
+#: ../vnc.html:242
+msgid "Automatic Reconnect"
+msgstr "Automatisch Opnieuw Verbinden"
+
+#: ../vnc.html:245
+msgid "Reconnect Delay (ms):"
+msgstr "Vertraging voor Opnieuw Verbinden (ms):"
+
+#: ../vnc.html:250
+msgid "Show Dot when No Cursor"
+msgstr "Geef stip weer indien geen cursor"
+
+#: ../vnc.html:255
+msgid "Logging:"
+msgstr "Logmeldingen:"
+
+#: ../vnc.html:267
+msgid "Disconnect"
+msgstr "Verbinding verbreken"
+
+#: ../vnc.html:286
+msgid "Connect"
+msgstr "Verbinden"
+
+#: ../vnc.html:296
+msgid "Password:"
+msgstr "Wachtwoord:"
+
+#: ../vnc.html:300
+msgid "Send Password"
+msgstr "Verzend Wachtwoord:"
+
+#: ../vnc.html:310
+msgid "Cancel"
+msgstr "Annuleren"
+
+#~ msgid "Disconnect timeout"
+#~ msgstr "Timeout tijdens verbreken van verbinding"
+
+#~ msgid "Local Downscaling"
+#~ msgstr "Lokaal Neerschalen"
+
+#~ msgid "Local Cursor"
+#~ msgstr "Lokale Cursor"
+
+#~ msgid "Canvas not supported."
+#~ msgstr "Canvas wordt niet ondersteund."
+
+#~ msgid ""
+#~ "Forcing clipping mode since scrollbars aren't supported by IE in "
+#~ "fullscreen"
+#~ msgstr ""
+#~ "''Clipping mode' ingeschakeld, omdat schuifbalken in volledige-scherm-"
+#~ "modus in IE niet worden ondersteund"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/pl.po
@@ -0,0 +1,325 @@
+# Polish translations for noVNC package.
+# Copyright (C) 2018 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+# Mariusz Jamro <mariusz.jamro@gmail.com>, 2017.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 0.6.1\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2017-11-21 19:53+0100\n"
+"PO-Revision-Date: 2017-11-21 19:54+0100\n"
+"Last-Translator: Mariusz Jamro <mariusz.jamro@gmail.com>\n"
+"Language-Team: Polish\n"
+"Language: pl\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 "
+"|| n%100>=20) ? 1 : 2);\n"
+"X-Generator: Poedit 2.0.1\n"
+
+#: ../app/ui.js:404
+msgid "Connecting..."
+msgstr "Łączenie..."
+
+#: ../app/ui.js:411
+msgid "Disconnecting..."
+msgstr "Rozłączanie..."
+
+#: ../app/ui.js:417
+msgid "Reconnecting..."
+msgstr "Łączenie..."
+
+#: ../app/ui.js:422
+msgid "Internal error"
+msgstr "Błąd wewnętrzny"
+
+#: ../app/ui.js:1019
+msgid "Must set host"
+msgstr "Host i port są wymagane"
+
+#: ../app/ui.js:1099
+msgid "Connected (encrypted) to "
+msgstr "Połączenie (szyfrowane) z "
+
+#: ../app/ui.js:1101
+msgid "Connected (unencrypted) to "
+msgstr "Połączenie (nieszyfrowane) z "
+
+#: ../app/ui.js:1119
+msgid "Something went wrong, connection is closed"
+msgstr "Coś poszło źle, połączenie zostało zamknięte"
+
+#: ../app/ui.js:1129
+msgid "Disconnected"
+msgstr "Rozłączony"
+
+#: ../app/ui.js:1142
+msgid "New connection has been rejected with reason: "
+msgstr "Nowe połączenie zostało odrzucone z powodu: "
+
+#: ../app/ui.js:1145
+msgid "New connection has been rejected"
+msgstr "Nowe połączenie zostało odrzucone"
+
+#: ../app/ui.js:1166
+msgid "Password is required"
+msgstr "Hasło jest wymagane"
+
+#: ../vnc.html:89
+msgid "noVNC encountered an error:"
+msgstr "noVNC napotkało błąd:"
+
+#: ../vnc.html:99
+msgid "Hide/Show the control bar"
+msgstr "Pokaż/Ukryj pasek ustawień"
+
+#: ../vnc.html:106
+msgid "Move/Drag Viewport"
+msgstr "Ruszaj/Przeciągaj Viewport"
+
+#: ../vnc.html:106
+msgid "viewport drag"
+msgstr "przeciągnij viewport"
+
+#: ../vnc.html:112 ../vnc.html:115 ../vnc.html:118 ../vnc.html:121
+msgid "Active Mouse Button"
+msgstr "Aktywny Przycisk Myszy"
+
+#: ../vnc.html:112
+msgid "No mousebutton"
+msgstr "Brak przycisku myszy"
+
+#: ../vnc.html:115
+msgid "Left mousebutton"
+msgstr "Lewy przycisk myszy"
+
+#: ../vnc.html:118
+msgid "Middle mousebutton"
+msgstr "Środkowy przycisk myszy"
+
+#: ../vnc.html:121
+msgid "Right mousebutton"
+msgstr "Prawy przycisk myszy"
+
+#: ../vnc.html:124
+msgid "Keyboard"
+msgstr "Klawiatura"
+
+#: ../vnc.html:124
+msgid "Show Keyboard"
+msgstr "Pokaż klawiaturę"
+
+#: ../vnc.html:131
+msgid "Extra keys"
+msgstr "Przyciski dodatkowe"
+
+#: ../vnc.html:131
+msgid "Show Extra Keys"
+msgstr "Pokaż przyciski dodatkowe"
+
+#: ../vnc.html:136
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:136
+msgid "Toggle Ctrl"
+msgstr "Przełącz Ctrl"
+
+#: ../vnc.html:139
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:139
+msgid "Toggle Alt"
+msgstr "Przełącz Alt"
+
+#: ../vnc.html:142
+msgid "Send Tab"
+msgstr "Wyślij Tab"
+
+#: ../vnc.html:142
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:145
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:145
+msgid "Send Escape"
+msgstr "Wyślij Escape"
+
+#: ../vnc.html:148
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl+Alt+Del"
+
+#: ../vnc.html:148
+msgid "Send Ctrl-Alt-Del"
+msgstr "Wyślij Ctrl-Alt-Del"
+
+#: ../vnc.html:156
+msgid "Shutdown/Reboot"
+msgstr "Wyłącz/Uruchom ponownie"
+
+#: ../vnc.html:156
+msgid "Shutdown/Reboot..."
+msgstr "Wyłącz/Uruchom ponownie..."
+
+#: ../vnc.html:162
+msgid "Power"
+msgstr "Włączony"
+
+#: ../vnc.html:164
+msgid "Shutdown"
+msgstr "Wyłącz"
+
+#: ../vnc.html:165
+msgid "Reboot"
+msgstr "Uruchom ponownie"
+
+#: ../vnc.html:166
+msgid "Reset"
+msgstr "Resetuj"
+
+#: ../vnc.html:171 ../vnc.html:177
+msgid "Clipboard"
+msgstr "Schowek"
+
+#: ../vnc.html:181
+msgid "Clear"
+msgstr "Wyczyść"
+
+#: ../vnc.html:187
+msgid "Fullscreen"
+msgstr "Pełny ekran"
+
+#: ../vnc.html:192 ../vnc.html:199
+msgid "Settings"
+msgstr "Ustawienia"
+
+#: ../vnc.html:202
+msgid "Shared Mode"
+msgstr "Tryb Współdzielenia"
+
+#: ../vnc.html:205
+msgid "View Only"
+msgstr "Tylko Podgląd"
+
+#: ../vnc.html:209
+msgid "Clip to Window"
+msgstr "Przytnij do Okna"
+
+#: ../vnc.html:212
+msgid "Scaling Mode:"
+msgstr "Tryb Skalowania:"
+
+#: ../vnc.html:214
+msgid "None"
+msgstr "Brak"
+
+#: ../vnc.html:215
+msgid "Local Scaling"
+msgstr "Skalowanie lokalne"
+
+#: ../vnc.html:216
+msgid "Remote Resizing"
+msgstr "Skalowanie zdalne"
+
+#: ../vnc.html:221
+msgid "Advanced"
+msgstr "Zaawansowane"
+
+#: ../vnc.html:224
+msgid "Repeater ID:"
+msgstr "ID Repeatera:"
+
+#: ../vnc.html:228
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:231
+msgid "Encrypt"
+msgstr "Szyfrowanie"
+
+#: ../vnc.html:234
+msgid "Host:"
+msgstr "Host:"
+
+#: ../vnc.html:238
+msgid "Port:"
+msgstr "Port:"
+
+#: ../vnc.html:242
+msgid "Path:"
+msgstr "Ścieżka:"
+
+#: ../vnc.html:249
+msgid "Automatic Reconnect"
+msgstr "Automatycznie wznawiaj połączenie"
+
+#: ../vnc.html:252
+msgid "Reconnect Delay (ms):"
+msgstr "Opóźnienie wznawiania (ms):"
+
+#: ../vnc.html:258
+msgid "Logging:"
+msgstr "Poziom logowania:"
+
+#: ../vnc.html:270
+msgid "Disconnect"
+msgstr "Rozłącz"
+
+#: ../vnc.html:289
+msgid "Connect"
+msgstr "Połącz"
+
+#: ../vnc.html:299
+msgid "Password:"
+msgstr "Hasło:"
+
+#: ../vnc.html:313
+msgid "Cancel"
+msgstr "Anuluj"
+
+#: ../vnc.html:329
+msgid "Canvas not supported."
+msgstr "Element Canvas nie jest wspierany."
+
+#~ msgid "Disconnect timeout"
+#~ msgstr "Timeout rozłączenia"
+
+#~ msgid "Local Downscaling"
+#~ msgstr "Downscaling lokalny"
+
+#~ msgid "Local Cursor"
+#~ msgstr "Lokalny kursor"
+
+#~ msgid ""
+#~ "Forcing clipping mode since scrollbars aren't supported by IE in "
+#~ "fullscreen"
+#~ msgstr ""
+#~ "Wymuszam clipping mode ponieważ paski przewijania nie są wspierane przez "
+#~ "IE w trybie pełnoekranowym"
+
+#~ msgid "True Color"
+#~ msgstr "True Color"
+
+#~ msgid "Style:"
+#~ msgstr "Styl:"
+
+#~ msgid "default"
+#~ msgstr "domyślny"
+
+#~ msgid "Apply"
+#~ msgstr "Zapisz"
+
+#~ msgid "Connection"
+#~ msgstr "Połączenie"
+
+#~ msgid "Token:"
+#~ msgstr "Token:"
+
+#~ msgid "Send Password"
+#~ msgstr "Wyślij Hasło"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/po2js
@@ -0,0 +1,43 @@
+#!/usr/bin/env node
+/*
+ * ps2js: gettext .po to noVNC .js converter
+ * Copyright (C) 2018 The noVNC Authors
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+const getopt = require('node-getopt');
+const fs = require('fs');
+const po2json = require("po2json");
+
+const opt = getopt.create([
+    ['h', 'help', 'display this help'],
+]).bindHelp().parseSystem();
+
+if (opt.argv.length != 2) {
+    console.error("Incorrect number of arguments given");
+    process.exit(1);
+}
+
+const data = po2json.parseFileSync(opt.argv[0]);
+
+const bodyPart = Object.keys(data).filter(msgid => msgid !== "").map((msgid) => {
+    if (msgid === "") return;
+    const msgstr = data[msgid][1];
+    return "    " + JSON.stringify(msgid) + ": " + JSON.stringify(msgstr);
+}).join(",\n");
+
+const output = "{\n" + bodyPart + "\n}";
+
+fs.writeFileSync(opt.argv[1], output);
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/pt.po
@@ -0,0 +1,299 @@
+# Portuguese translations for noVNC package.
+# Copyright (C) 2021 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+#  <liddack@outlook.com>, 2021.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 1.2.0\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2021-03-15 21:55-0300\n"
+"PO-Revision-Date: 2021-03-15 22:09-0300\n"
+"Last-Translator: <liddack@outlook.com>\n"
+"Language-Team: Brazilian Portuguese\n"
+"Language: pt\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n > 1);\n"
+"X-Generator: Poedit 2.4.1\n"
+
+#: ../app/ui.js:400
+msgid "Connecting..."
+msgstr "Conectando..."
+
+#: ../app/ui.js:407
+msgid "Disconnecting..."
+msgstr "Desconectando..."
+
+#: ../app/ui.js:413
+msgid "Reconnecting..."
+msgstr "Reconectando..."
+
+#: ../app/ui.js:418
+msgid "Internal error"
+msgstr "Erro interno"
+
+#: ../app/ui.js:1009
+msgid "Must set host"
+msgstr "É necessário definir o host"
+
+#: ../app/ui.js:1091
+msgid "Connected (encrypted) to "
+msgstr "Conectado (com criptografia) a "
+
+#: ../app/ui.js:1093
+msgid "Connected (unencrypted) to "
+msgstr "Conectado (sem criptografia) a "
+
+#: ../app/ui.js:1116
+msgid "Something went wrong, connection is closed"
+msgstr "Algo deu errado. A conexão foi encerrada."
+
+#: ../app/ui.js:1119
+msgid "Failed to connect to server"
+msgstr "Falha ao conectar-se ao servidor"
+
+#: ../app/ui.js:1129
+msgid "Disconnected"
+msgstr "Desconectado"
+
+#: ../app/ui.js:1144
+msgid "New connection has been rejected with reason: "
+msgstr "A nova conexão foi rejeitada pelo motivo: "
+
+#: ../app/ui.js:1147
+msgid "New connection has been rejected"
+msgstr "A nova conexão foi rejeitada"
+
+#: ../app/ui.js:1182
+msgid "Credentials are required"
+msgstr "Credenciais são obrigatórias"
+
+#: ../vnc.html:61
+msgid "noVNC encountered an error:"
+msgstr "O noVNC encontrou um erro:"
+
+#: ../vnc.html:71
+msgid "Hide/Show the control bar"
+msgstr "Esconder/mostrar a barra de controles"
+
+#: ../vnc.html:78
+msgid "Drag"
+msgstr "Arrastar"
+
+#: ../vnc.html:78
+msgid "Move/Drag Viewport"
+msgstr "Mover/arrastar a janela"
+
+#: ../vnc.html:84
+msgid "Keyboard"
+msgstr "Teclado"
+
+#: ../vnc.html:84
+msgid "Show Keyboard"
+msgstr "Mostrar teclado"
+
+#: ../vnc.html:89
+msgid "Extra keys"
+msgstr "Teclas adicionais"
+
+#: ../vnc.html:89
+msgid "Show Extra Keys"
+msgstr "Mostar teclas adicionais"
+
+#: ../vnc.html:94
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:94
+msgid "Toggle Ctrl"
+msgstr "Pressionar/soltar Ctrl"
+
+#: ../vnc.html:97
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:97
+msgid "Toggle Alt"
+msgstr "Pressionar/soltar Alt"
+
+#: ../vnc.html:100
+msgid "Toggle Windows"
+msgstr "Pressionar/soltar Windows"
+
+#: ../vnc.html:100
+msgid "Windows"
+msgstr "Windows"
+
+#: ../vnc.html:103
+msgid "Send Tab"
+msgstr "Enviar Tab"
+
+#: ../vnc.html:103
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:106
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:106
+msgid "Send Escape"
+msgstr "Enviar Esc"
+
+#: ../vnc.html:109
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl+Alt+Del"
+
+#: ../vnc.html:109
+msgid "Send Ctrl-Alt-Del"
+msgstr "Enviar Ctrl-Alt-Del"
+
+#: ../vnc.html:116
+msgid "Shutdown/Reboot"
+msgstr "Desligar/reiniciar"
+
+#: ../vnc.html:116
+msgid "Shutdown/Reboot..."
+msgstr "Desligar/reiniciar..."
+
+#: ../vnc.html:122
+msgid "Power"
+msgstr "Ligar"
+
+#: ../vnc.html:124
+msgid "Shutdown"
+msgstr "Desligar"
+
+#: ../vnc.html:125
+msgid "Reboot"
+msgstr "Reiniciar"
+
+#: ../vnc.html:126
+msgid "Reset"
+msgstr "Reiniciar (forçado)"
+
+#: ../vnc.html:131 ../vnc.html:137
+msgid "Clipboard"
+msgstr "Área de transferência"
+
+#: ../vnc.html:141
+msgid "Clear"
+msgstr "Limpar"
+
+#: ../vnc.html:147
+msgid "Fullscreen"
+msgstr "Tela cheia"
+
+#: ../vnc.html:152 ../vnc.html:159
+msgid "Settings"
+msgstr "Configurações"
+
+#: ../vnc.html:162
+msgid "Shared Mode"
+msgstr "Modo compartilhado"
+
+#: ../vnc.html:165
+msgid "View Only"
+msgstr "Apenas visualizar"
+
+#: ../vnc.html:169
+msgid "Clip to Window"
+msgstr "Recortar à janela"
+
+#: ../vnc.html:172
+msgid "Scaling Mode:"
+msgstr "Modo de dimensionamento:"
+
+#: ../vnc.html:174
+msgid "None"
+msgstr "Nenhum"
+
+#: ../vnc.html:175
+msgid "Local Scaling"
+msgstr "Local"
+
+#: ../vnc.html:176
+msgid "Remote Resizing"
+msgstr "Remoto"
+
+#: ../vnc.html:181
+msgid "Advanced"
+msgstr "Avançado"
+
+#: ../vnc.html:184
+msgid "Quality:"
+msgstr "Qualidade:"
+
+#: ../vnc.html:188
+msgid "Compression level:"
+msgstr "Nível de compressão:"
+
+#: ../vnc.html:193
+msgid "Repeater ID:"
+msgstr "ID do repetidor:"
+
+#: ../vnc.html:197
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:200
+msgid "Encrypt"
+msgstr "Criptografar"
+
+#: ../vnc.html:203
+msgid "Host:"
+msgstr "Host:"
+
+#: ../vnc.html:207
+msgid "Port:"
+msgstr "Porta:"
+
+#: ../vnc.html:211
+msgid "Path:"
+msgstr "Caminho:"
+
+#: ../vnc.html:218
+msgid "Automatic Reconnect"
+msgstr "Reconexão automática"
+
+#: ../vnc.html:221
+msgid "Reconnect Delay (ms):"
+msgstr "Atraso da reconexão (ms)"
+
+#: ../vnc.html:226
+msgid "Show Dot when No Cursor"
+msgstr "Mostrar ponto quando não há cursor"
+
+#: ../vnc.html:231
+msgid "Logging:"
+msgstr "Registros:"
+
+#: ../vnc.html:240
+msgid "Version:"
+msgstr "Versão:"
+
+#: ../vnc.html:248
+msgid "Disconnect"
+msgstr "Desconectar"
+
+#: ../vnc.html:267
+msgid "Connect"
+msgstr "Conectar"
+
+#: ../vnc.html:277
+msgid "Username:"
+msgstr "Nome de usuário:"
+
+#: ../vnc.html:281
+msgid "Password:"
+msgstr "Senha:"
+
+#: ../vnc.html:285
+msgid "Send Credentials"
+msgstr "Enviar credenciais"
+
+#: ../vnc.html:295
+msgid "Cancel"
+msgstr "Cancelar"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/pt_BR.po
@@ -0,0 +1,299 @@
+# Portuguese translations for noVNC package.
+# Copyright (C) 2021 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+#  <liddack@outlook.com>, 2021.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 1.2.0\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2021-03-15 21:55-0300\n"
+"PO-Revision-Date: 2021-03-15 22:09-0300\n"
+"Last-Translator: <liddack@outlook.com>\n"
+"Language-Team: Brazilian Portuguese\n"
+"Language: pt_BR\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n > 1);\n"
+"X-Generator: Poedit 2.4.1\n"
+
+#: ../app/ui.js:400
+msgid "Connecting..."
+msgstr "Conectando..."
+
+#: ../app/ui.js:407
+msgid "Disconnecting..."
+msgstr "Desconectando..."
+
+#: ../app/ui.js:413
+msgid "Reconnecting..."
+msgstr "Reconectando..."
+
+#: ../app/ui.js:418
+msgid "Internal error"
+msgstr "Erro interno"
+
+#: ../app/ui.js:1009
+msgid "Must set host"
+msgstr "É necessário definir o host"
+
+#: ../app/ui.js:1091
+msgid "Connected (encrypted) to "
+msgstr "Conectado (com criptografia) a "
+
+#: ../app/ui.js:1093
+msgid "Connected (unencrypted) to "
+msgstr "Conectado (sem criptografia) a "
+
+#: ../app/ui.js:1116
+msgid "Something went wrong, connection is closed"
+msgstr "Algo deu errado. A conexão foi encerrada."
+
+#: ../app/ui.js:1119
+msgid "Failed to connect to server"
+msgstr "Falha ao conectar-se ao servidor"
+
+#: ../app/ui.js:1129
+msgid "Disconnected"
+msgstr "Desconectado"
+
+#: ../app/ui.js:1144
+msgid "New connection has been rejected with reason: "
+msgstr "A nova conexão foi rejeitada pelo motivo: "
+
+#: ../app/ui.js:1147
+msgid "New connection has been rejected"
+msgstr "A nova conexão foi rejeitada"
+
+#: ../app/ui.js:1182
+msgid "Credentials are required"
+msgstr "Credenciais são obrigatórias"
+
+#: ../vnc.html:61
+msgid "noVNC encountered an error:"
+msgstr "O noVNC encontrou um erro:"
+
+#: ../vnc.html:71
+msgid "Hide/Show the control bar"
+msgstr "Esconder/mostrar a barra de controles"
+
+#: ../vnc.html:78
+msgid "Drag"
+msgstr "Arrastar"
+
+#: ../vnc.html:78
+msgid "Move/Drag Viewport"
+msgstr "Mover/arrastar a janela"
+
+#: ../vnc.html:84
+msgid "Keyboard"
+msgstr "Teclado"
+
+#: ../vnc.html:84
+msgid "Show Keyboard"
+msgstr "Mostrar teclado"
+
+#: ../vnc.html:89
+msgid "Extra keys"
+msgstr "Teclas adicionais"
+
+#: ../vnc.html:89
+msgid "Show Extra Keys"
+msgstr "Mostar teclas adicionais"
+
+#: ../vnc.html:94
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:94
+msgid "Toggle Ctrl"
+msgstr "Pressionar/soltar Ctrl"
+
+#: ../vnc.html:97
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:97
+msgid "Toggle Alt"
+msgstr "Pressionar/soltar Alt"
+
+#: ../vnc.html:100
+msgid "Toggle Windows"
+msgstr "Pressionar/soltar Windows"
+
+#: ../vnc.html:100
+msgid "Windows"
+msgstr "Windows"
+
+#: ../vnc.html:103
+msgid "Send Tab"
+msgstr "Enviar Tab"
+
+#: ../vnc.html:103
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:106
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:106
+msgid "Send Escape"
+msgstr "Enviar Esc"
+
+#: ../vnc.html:109
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl+Alt+Del"
+
+#: ../vnc.html:109
+msgid "Send Ctrl-Alt-Del"
+msgstr "Enviar Ctrl-Alt-Del"
+
+#: ../vnc.html:116
+msgid "Shutdown/Reboot"
+msgstr "Desligar/reiniciar"
+
+#: ../vnc.html:116
+msgid "Shutdown/Reboot..."
+msgstr "Desligar/reiniciar..."
+
+#: ../vnc.html:122
+msgid "Power"
+msgstr "Ligar"
+
+#: ../vnc.html:124
+msgid "Shutdown"
+msgstr "Desligar"
+
+#: ../vnc.html:125
+msgid "Reboot"
+msgstr "Reiniciar"
+
+#: ../vnc.html:126
+msgid "Reset"
+msgstr "Reiniciar (forçado)"
+
+#: ../vnc.html:131 ../vnc.html:137
+msgid "Clipboard"
+msgstr "Área de transferência"
+
+#: ../vnc.html:141
+msgid "Clear"
+msgstr "Limpar"
+
+#: ../vnc.html:147
+msgid "Fullscreen"
+msgstr "Tela cheia"
+
+#: ../vnc.html:152 ../vnc.html:159
+msgid "Settings"
+msgstr "Configurações"
+
+#: ../vnc.html:162
+msgid "Shared Mode"
+msgstr "Modo compartilhado"
+
+#: ../vnc.html:165
+msgid "View Only"
+msgstr "Apenas visualizar"
+
+#: ../vnc.html:169
+msgid "Clip to Window"
+msgstr "Recortar à janela"
+
+#: ../vnc.html:172
+msgid "Scaling Mode:"
+msgstr "Modo de dimensionamento:"
+
+#: ../vnc.html:174
+msgid "None"
+msgstr "Nenhum"
+
+#: ../vnc.html:175
+msgid "Local Scaling"
+msgstr "Local"
+
+#: ../vnc.html:176
+msgid "Remote Resizing"
+msgstr "Remoto"
+
+#: ../vnc.html:181
+msgid "Advanced"
+msgstr "Avançado"
+
+#: ../vnc.html:184
+msgid "Quality:"
+msgstr "Qualidade:"
+
+#: ../vnc.html:188
+msgid "Compression level:"
+msgstr "Nível de compressão:"
+
+#: ../vnc.html:193
+msgid "Repeater ID:"
+msgstr "ID do repetidor:"
+
+#: ../vnc.html:197
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:200
+msgid "Encrypt"
+msgstr "Criptografar"
+
+#: ../vnc.html:203
+msgid "Host:"
+msgstr "Host:"
+
+#: ../vnc.html:207
+msgid "Port:"
+msgstr "Porta:"
+
+#: ../vnc.html:211
+msgid "Path:"
+msgstr "Caminho:"
+
+#: ../vnc.html:218
+msgid "Automatic Reconnect"
+msgstr "Reconexão automática"
+
+#: ../vnc.html:221
+msgid "Reconnect Delay (ms):"
+msgstr "Atraso da reconexão (ms)"
+
+#: ../vnc.html:226
+msgid "Show Dot when No Cursor"
+msgstr "Mostrar ponto quando não há cursor"
+
+#: ../vnc.html:231
+msgid "Logging:"
+msgstr "Registros:"
+
+#: ../vnc.html:240
+msgid "Version:"
+msgstr "Versão:"
+
+#: ../vnc.html:248
+msgid "Disconnect"
+msgstr "Desconectar"
+
+#: ../vnc.html:267
+msgid "Connect"
+msgstr "Conectar"
+
+#: ../vnc.html:277
+msgid "Username:"
+msgstr "Nome de usuário:"
+
+#: ../vnc.html:281
+msgid "Password:"
+msgstr "Senha:"
+
+#: ../vnc.html:285
+msgid "Send Credentials"
+msgstr "Enviar credenciais"
+
+#: ../vnc.html:295
+msgid "Cancel"
+msgstr "Cancelar"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/pt_PT.po
@@ -0,0 +1,299 @@
+# Portuguese translations for noVNC package.
+# Copyright (C) 2021 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+#  <liddack@outlook.com>, 2021.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 1.2.0\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2021-03-15 21:55-0300\n"
+"PO-Revision-Date: 2021-03-15 22:09-0300\n"
+"Last-Translator: <liddack@outlook.com>\n"
+"Language-Team: Brazilian Portuguese\n"
+"Language: pt_PT\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n > 1);\n"
+"X-Generator: Poedit 2.4.1\n"
+
+#: ../app/ui.js:400
+msgid "Connecting..."
+msgstr "Conectando..."
+
+#: ../app/ui.js:407
+msgid "Disconnecting..."
+msgstr "Desconectando..."
+
+#: ../app/ui.js:413
+msgid "Reconnecting..."
+msgstr "Reconectando..."
+
+#: ../app/ui.js:418
+msgid "Internal error"
+msgstr "Erro interno"
+
+#: ../app/ui.js:1009
+msgid "Must set host"
+msgstr "É necessário definir o host"
+
+#: ../app/ui.js:1091
+msgid "Connected (encrypted) to "
+msgstr "Conectado (com criptografia) a "
+
+#: ../app/ui.js:1093
+msgid "Connected (unencrypted) to "
+msgstr "Conectado (sem criptografia) a "
+
+#: ../app/ui.js:1116
+msgid "Something went wrong, connection is closed"
+msgstr "Algo deu errado. A conexão foi encerrada."
+
+#: ../app/ui.js:1119
+msgid "Failed to connect to server"
+msgstr "Falha ao conectar-se ao servidor"
+
+#: ../app/ui.js:1129
+msgid "Disconnected"
+msgstr "Desconectado"
+
+#: ../app/ui.js:1144
+msgid "New connection has been rejected with reason: "
+msgstr "A nova conexão foi rejeitada pelo motivo: "
+
+#: ../app/ui.js:1147
+msgid "New connection has been rejected"
+msgstr "A nova conexão foi rejeitada"
+
+#: ../app/ui.js:1182
+msgid "Credentials are required"
+msgstr "Credenciais são obrigatórias"
+
+#: ../vnc.html:61
+msgid "noVNC encountered an error:"
+msgstr "O noVNC encontrou um erro:"
+
+#: ../vnc.html:71
+msgid "Hide/Show the control bar"
+msgstr "Esconder/mostrar a barra de controles"
+
+#: ../vnc.html:78
+msgid "Drag"
+msgstr "Arrastar"
+
+#: ../vnc.html:78
+msgid "Move/Drag Viewport"
+msgstr "Mover/arrastar a janela"
+
+#: ../vnc.html:84
+msgid "Keyboard"
+msgstr "Teclado"
+
+#: ../vnc.html:84
+msgid "Show Keyboard"
+msgstr "Mostrar teclado"
+
+#: ../vnc.html:89
+msgid "Extra keys"
+msgstr "Teclas adicionais"
+
+#: ../vnc.html:89
+msgid "Show Extra Keys"
+msgstr "Mostar teclas adicionais"
+
+#: ../vnc.html:94
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:94
+msgid "Toggle Ctrl"
+msgstr "Pressionar/soltar Ctrl"
+
+#: ../vnc.html:97
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:97
+msgid "Toggle Alt"
+msgstr "Pressionar/soltar Alt"
+
+#: ../vnc.html:100
+msgid "Toggle Windows"
+msgstr "Pressionar/soltar Windows"
+
+#: ../vnc.html:100
+msgid "Windows"
+msgstr "Windows"
+
+#: ../vnc.html:103
+msgid "Send Tab"
+msgstr "Enviar Tab"
+
+#: ../vnc.html:103
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:106
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:106
+msgid "Send Escape"
+msgstr "Enviar Esc"
+
+#: ../vnc.html:109
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl+Alt+Del"
+
+#: ../vnc.html:109
+msgid "Send Ctrl-Alt-Del"
+msgstr "Enviar Ctrl-Alt-Del"
+
+#: ../vnc.html:116
+msgid "Shutdown/Reboot"
+msgstr "Desligar/reiniciar"
+
+#: ../vnc.html:116
+msgid "Shutdown/Reboot..."
+msgstr "Desligar/reiniciar..."
+
+#: ../vnc.html:122
+msgid "Power"
+msgstr "Ligar"
+
+#: ../vnc.html:124
+msgid "Shutdown"
+msgstr "Desligar"
+
+#: ../vnc.html:125
+msgid "Reboot"
+msgstr "Reiniciar"
+
+#: ../vnc.html:126
+msgid "Reset"
+msgstr "Reiniciar (forçado)"
+
+#: ../vnc.html:131 ../vnc.html:137
+msgid "Clipboard"
+msgstr "Área de transferência"
+
+#: ../vnc.html:141
+msgid "Clear"
+msgstr "Limpar"
+
+#: ../vnc.html:147
+msgid "Fullscreen"
+msgstr "Tela cheia"
+
+#: ../vnc.html:152 ../vnc.html:159
+msgid "Settings"
+msgstr "Configurações"
+
+#: ../vnc.html:162
+msgid "Shared Mode"
+msgstr "Modo compartilhado"
+
+#: ../vnc.html:165
+msgid "View Only"
+msgstr "Apenas visualizar"
+
+#: ../vnc.html:169
+msgid "Clip to Window"
+msgstr "Recortar à janela"
+
+#: ../vnc.html:172
+msgid "Scaling Mode:"
+msgstr "Modo de dimensionamento:"
+
+#: ../vnc.html:174
+msgid "None"
+msgstr "Nenhum"
+
+#: ../vnc.html:175
+msgid "Local Scaling"
+msgstr "Local"
+
+#: ../vnc.html:176
+msgid "Remote Resizing"
+msgstr "Remoto"
+
+#: ../vnc.html:181
+msgid "Advanced"
+msgstr "Avançado"
+
+#: ../vnc.html:184
+msgid "Quality:"
+msgstr "Qualidade:"
+
+#: ../vnc.html:188
+msgid "Compression level:"
+msgstr "Nível de compressão:"
+
+#: ../vnc.html:193
+msgid "Repeater ID:"
+msgstr "ID do repetidor:"
+
+#: ../vnc.html:197
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:200
+msgid "Encrypt"
+msgstr "Criptografar"
+
+#: ../vnc.html:203
+msgid "Host:"
+msgstr "Host:"
+
+#: ../vnc.html:207
+msgid "Port:"
+msgstr "Porta:"
+
+#: ../vnc.html:211
+msgid "Path:"
+msgstr "Caminho:"
+
+#: ../vnc.html:218
+msgid "Automatic Reconnect"
+msgstr "Reconexão automática"
+
+#: ../vnc.html:221
+msgid "Reconnect Delay (ms):"
+msgstr "Atraso da reconexão (ms)"
+
+#: ../vnc.html:226
+msgid "Show Dot when No Cursor"
+msgstr "Mostrar ponto quando não há cursor"
+
+#: ../vnc.html:231
+msgid "Logging:"
+msgstr "Registros:"
+
+#: ../vnc.html:240
+msgid "Version:"
+msgstr "Versão:"
+
+#: ../vnc.html:248
+msgid "Disconnect"
+msgstr "Desconectar"
+
+#: ../vnc.html:267
+msgid "Connect"
+msgstr "Conectar"
+
+#: ../vnc.html:277
+msgid "Username:"
+msgstr "Nome de usuário:"
+
+#: ../vnc.html:281
+msgid "Password:"
+msgstr "Senha:"
+
+#: ../vnc.html:285
+msgid "Send Credentials"
+msgstr "Enviar credenciais"
+
+#: ../vnc.html:295
+msgid "Cancel"
+msgstr "Cancelar"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/ru.po
@@ -0,0 +1,302 @@
+# Russian translations for noVNC package
+# Русский перевод для пакета noVNC.
+# Copyright (C) 2019 Dmitriy Shweew
+# This file is distributed under the same license as the noVNC package.
+# Dmitriy Shweew <shweew@it-advisor.ru>, 2019.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 1.3.0\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2021-08-27 16:03+0200\n"
+"PO-Revision-Date: 2021-09-09 10:29+0400\n"
+"Last-Translator: Nia Remez <nia.remez@cendio.com>\n"
+"Language-Team: Russian\n"
+"Language: ru\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
+"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
+"X-Generator: Poedit 2.2.1\n"
+"X-Poedit-Flags-xgettext: --add-comments\n"
+
+#: ../app/ui.js:400
+msgid "Connecting..."
+msgstr "Подключение..."
+
+#: ../app/ui.js:407
+msgid "Disconnecting..."
+msgstr "Отключение..."
+
+#: ../app/ui.js:413
+msgid "Reconnecting..."
+msgstr "Переподключение..."
+
+#: ../app/ui.js:418
+msgid "Internal error"
+msgstr "Внутренняя ошибка"
+
+#: ../app/ui.js:1009
+msgid "Must set host"
+msgstr "Задайте имя сервера или IP"
+
+#: ../app/ui.js:1091
+msgid "Connected (encrypted) to "
+msgstr "Подключено (с шифрованием) к "
+
+#: ../app/ui.js:1093
+msgid "Connected (unencrypted) to "
+msgstr "Подключено (без шифрования) к "
+
+#: ../app/ui.js:1116
+msgid "Something went wrong, connection is closed"
+msgstr "Что-то пошло не так, подключение разорвано"
+
+#: ../app/ui.js:1119
+msgid "Failed to connect to server"
+msgstr "Ошибка подключения к серверу"
+
+#: ../app/ui.js:1129
+msgid "Disconnected"
+msgstr "Отключено"
+
+#: ../app/ui.js:1144
+msgid "New connection has been rejected with reason: "
+msgstr "Новое соединение отклонено по причине: "
+
+#: ../app/ui.js:1147
+msgid "New connection has been rejected"
+msgstr "Новое соединение отклонено"
+
+#: ../app/ui.js:1182
+msgid "Credentials are required"
+msgstr "Требуются учетные данные"
+
+#: ../vnc.html:61
+msgid "noVNC encountered an error:"
+msgstr "Ошибка noVNC: "
+
+#: ../vnc.html:71
+msgid "Hide/Show the control bar"
+msgstr "Скрыть/Показать контрольную панель"
+
+#: ../vnc.html:78
+msgid "Drag"
+msgstr "Переместить"
+
+#: ../vnc.html:78
+msgid "Move/Drag Viewport"
+msgstr "Переместить окно"
+
+#: ../vnc.html:84
+msgid "Keyboard"
+msgstr "Клавиатура"
+
+#: ../vnc.html:84
+msgid "Show Keyboard"
+msgstr "Показать клавиатуру"
+
+#: ../vnc.html:89
+msgid "Extra keys"
+msgstr "Дополнительные Кнопки"
+
+#: ../vnc.html:89
+msgid "Show Extra Keys"
+msgstr "Показать Дополнительные Кнопки"
+
+#: ../vnc.html:94
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:94
+msgid "Toggle Ctrl"
+msgstr "Переключение нажатия Ctrl"
+
+#: ../vnc.html:97
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:97
+msgid "Toggle Alt"
+msgstr "Переключение нажатия Alt"
+
+#: ../vnc.html:100
+msgid "Toggle Windows"
+msgstr "Переключение вкладок"
+
+#: ../vnc.html:100
+msgid "Windows"
+msgstr "Вкладка"
+
+#: ../vnc.html:103
+msgid "Send Tab"
+msgstr "Передать нажатие Tab"
+
+#: ../vnc.html:103
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:106
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:106
+msgid "Send Escape"
+msgstr "Передать нажатие Escape"
+
+#: ../vnc.html:109
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl+Alt+Del"
+
+#: ../vnc.html:109
+msgid "Send Ctrl-Alt-Del"
+msgstr "Передать нажатие Ctrl-Alt-Del"
+
+#: ../vnc.html:116
+msgid "Shutdown/Reboot"
+msgstr "Выключить/Перезагрузить"
+
+#: ../vnc.html:116
+msgid "Shutdown/Reboot..."
+msgstr "Выключить/Перезагрузить..."
+
+#: ../vnc.html:122
+msgid "Power"
+msgstr "Питание"
+
+#: ../vnc.html:124
+msgid "Shutdown"
+msgstr "Выключить"
+
+#: ../vnc.html:125
+msgid "Reboot"
+msgstr "Перезагрузить"
+
+#: ../vnc.html:126
+msgid "Reset"
+msgstr "Сброс"
+
+#: ../vnc.html:131 ../vnc.html:137
+msgid "Clipboard"
+msgstr "Буфер обмена"
+
+#: ../vnc.html:141
+msgid "Clear"
+msgstr "Очистить"
+
+#: ../vnc.html:147
+msgid "Fullscreen"
+msgstr "Во весь экран"
+
+#: ../vnc.html:152 ../vnc.html:159
+msgid "Settings"
+msgstr "Настройки"
+
+#: ../vnc.html:162
+msgid "Shared Mode"
+msgstr "Общий режим"
+
+#: ../vnc.html:165
+msgid "View Only"
+msgstr "Только Просмотр"
+
+#: ../vnc.html:169
+msgid "Clip to Window"
+msgstr "В окно"
+
+#: ../vnc.html:172
+msgid "Scaling Mode:"
+msgstr "Масштаб:"
+
+#: ../vnc.html:174
+msgid "None"
+msgstr "Нет"
+
+#: ../vnc.html:175
+msgid "Local Scaling"
+msgstr "Локльный масштаб"
+
+#: ../vnc.html:176
+msgid "Remote Resizing"
+msgstr "Удаленная перенастройка размера"
+
+#: ../vnc.html:181
+msgid "Advanced"
+msgstr "Дополнительно"
+
+#: ../vnc.html:184
+msgid "Quality:"
+msgstr "Качество"
+
+#: ../vnc.html:188
+msgid "Compression level:"
+msgstr "Уровень Сжатия"
+
+#: ../vnc.html:193
+msgid "Repeater ID:"
+msgstr "Идентификатор ID:"
+
+#: ../vnc.html:197
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:200
+msgid "Encrypt"
+msgstr "Шифрование"
+
+#: ../vnc.html:203
+msgid "Host:"
+msgstr "Сервер:"
+
+#: ../vnc.html:207
+msgid "Port:"
+msgstr "Порт:"
+
+#: ../vnc.html:211
+msgid "Path:"
+msgstr "Путь:"
+
+#: ../vnc.html:218
+msgid "Automatic Reconnect"
+msgstr "Автоматическое переподключение"
+
+#: ../vnc.html:221
+msgid "Reconnect Delay (ms):"
+msgstr "Задержка переподключения (мс):"
+
+#: ../vnc.html:226
+msgid "Show Dot when No Cursor"
+msgstr "Показать точку вместо курсора"
+
+#: ../vnc.html:231
+msgid "Logging:"
+msgstr "Лог:"
+
+#: ../vnc.html:240
+msgid "Version:"
+msgstr "Версия"
+
+#: ../vnc.html:248
+msgid "Disconnect"
+msgstr "Отключение"
+
+#: ../vnc.html:267
+msgid "Connect"
+msgstr "Подключение"
+
+#: ../vnc.html:277
+msgid "Username:"
+msgstr "Имя Пользователя"
+
+#: ../vnc.html:281
+msgid "Password:"
+msgstr "Пароль:"
+
+#: ../vnc.html:285
+msgid "Send Credentials"
+msgstr "Передача Учетных Данных"
+
+#: ../vnc.html:295
+msgid "Cancel"
+msgstr "Выход"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/sv.po
@@ -0,0 +1,300 @@
+# Swedish translations for noVNC package
+# Svenska översättningar för paketet noVNC.
+# Copyright (C) 2020 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+# Samuel Mannehed <samuel@cendio.se>, 2020.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 1.3.0\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2021-08-27 16:03+0200\n"
+"PO-Revision-Date: 2021-08-27 16:18+0200\n"
+"Last-Translator: Samuel Mannehed <samuel@cendio.se>\n"
+"Language-Team: none\n"
+"Language: sv\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+"X-Generator: Poedit 2.0.3\n"
+
+#: ../app/ui.js:400
+msgid "Connecting..."
+msgstr "Ansluter..."
+
+#: ../app/ui.js:407
+msgid "Disconnecting..."
+msgstr "Kopplar ner..."
+
+#: ../app/ui.js:413
+msgid "Reconnecting..."
+msgstr "Återansluter..."
+
+#: ../app/ui.js:418
+msgid "Internal error"
+msgstr "Internt fel"
+
+#: ../app/ui.js:1009
+msgid "Must set host"
+msgstr "Du måste specifiera en värd"
+
+#: ../app/ui.js:1091
+msgid "Connected (encrypted) to "
+msgstr "Ansluten (krypterat) till "
+
+#: ../app/ui.js:1093
+msgid "Connected (unencrypted) to "
+msgstr "Ansluten (okrypterat) till "
+
+#: ../app/ui.js:1116
+msgid "Something went wrong, connection is closed"
+msgstr "Något gick fel, anslutningen avslutades"
+
+#: ../app/ui.js:1119
+msgid "Failed to connect to server"
+msgstr "Misslyckades att ansluta till servern"
+
+#: ../app/ui.js:1129
+msgid "Disconnected"
+msgstr "Frånkopplad"
+
+#: ../app/ui.js:1144
+msgid "New connection has been rejected with reason: "
+msgstr "Ny anslutning har blivit nekad med följande skäl: "
+
+#: ../app/ui.js:1147
+msgid "New connection has been rejected"
+msgstr "Ny anslutning har blivit nekad"
+
+#: ../app/ui.js:1182
+msgid "Credentials are required"
+msgstr "Användaruppgifter krävs"
+
+#: ../vnc.html:61
+msgid "noVNC encountered an error:"
+msgstr "noVNC stötte på ett problem:"
+
+#: ../vnc.html:71
+msgid "Hide/Show the control bar"
+msgstr "Göm/Visa kontrollbaren"
+
+#: ../vnc.html:78
+msgid "Drag"
+msgstr "Dra"
+
+#: ../vnc.html:78
+msgid "Move/Drag Viewport"
+msgstr "Flytta/Dra Vyn"
+
+#: ../vnc.html:84
+msgid "Keyboard"
+msgstr "Tangentbord"
+
+#: ../vnc.html:84
+msgid "Show Keyboard"
+msgstr "Visa Tangentbord"
+
+#: ../vnc.html:89
+msgid "Extra keys"
+msgstr "Extraknappar"
+
+#: ../vnc.html:89
+msgid "Show Extra Keys"
+msgstr "Visa Extraknappar"
+
+#: ../vnc.html:94
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:94
+msgid "Toggle Ctrl"
+msgstr "Växla Ctrl"
+
+#: ../vnc.html:97
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:97
+msgid "Toggle Alt"
+msgstr "Växla Alt"
+
+#: ../vnc.html:100
+msgid "Toggle Windows"
+msgstr "Växla Windows"
+
+#: ../vnc.html:100
+msgid "Windows"
+msgstr "Windows"
+
+#: ../vnc.html:103
+msgid "Send Tab"
+msgstr "Skicka Tab"
+
+#: ../vnc.html:103
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:106
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:106
+msgid "Send Escape"
+msgstr "Skicka Escape"
+
+#: ../vnc.html:109
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl+Alt+Del"
+
+#: ../vnc.html:109
+msgid "Send Ctrl-Alt-Del"
+msgstr "Skicka Ctrl-Alt-Del"
+
+#: ../vnc.html:116
+msgid "Shutdown/Reboot"
+msgstr "Stäng av/Boota om"
+
+#: ../vnc.html:116
+msgid "Shutdown/Reboot..."
+msgstr "Stäng av/Boota om..."
+
+#: ../vnc.html:122
+msgid "Power"
+msgstr "Ström"
+
+#: ../vnc.html:124
+msgid "Shutdown"
+msgstr "Stäng av"
+
+#: ../vnc.html:125
+msgid "Reboot"
+msgstr "Boota om"
+
+#: ../vnc.html:126
+msgid "Reset"
+msgstr "Återställ"
+
+#: ../vnc.html:131 ../vnc.html:137
+msgid "Clipboard"
+msgstr "Urklipp"
+
+#: ../vnc.html:141
+msgid "Clear"
+msgstr "Rensa"
+
+#: ../vnc.html:147
+msgid "Fullscreen"
+msgstr "Fullskärm"
+
+#: ../vnc.html:152 ../vnc.html:159
+msgid "Settings"
+msgstr "Inställningar"
+
+#: ../vnc.html:162
+msgid "Shared Mode"
+msgstr "Delat Läge"
+
+#: ../vnc.html:165
+msgid "View Only"
+msgstr "Endast Visning"
+
+#: ../vnc.html:169
+msgid "Clip to Window"
+msgstr "Begränsa till Fönster"
+
+#: ../vnc.html:172
+msgid "Scaling Mode:"
+msgstr "Skalningsläge:"
+
+#: ../vnc.html:174
+msgid "None"
+msgstr "Ingen"
+
+#: ../vnc.html:175
+msgid "Local Scaling"
+msgstr "Lokal Skalning"
+
+#: ../vnc.html:176
+msgid "Remote Resizing"
+msgstr "Ändra Storlek"
+
+#: ../vnc.html:181
+msgid "Advanced"
+msgstr "Avancerat"
+
+#: ../vnc.html:184
+msgid "Quality:"
+msgstr "Kvalitet:"
+
+#: ../vnc.html:188
+msgid "Compression level:"
+msgstr "Kompressionsnivå:"
+
+#: ../vnc.html:193
+msgid "Repeater ID:"
+msgstr "Repeater-ID:"
+
+#: ../vnc.html:197
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:200
+msgid "Encrypt"
+msgstr "Kryptera"
+
+#: ../vnc.html:203
+msgid "Host:"
+msgstr "Värd:"
+
+#: ../vnc.html:207
+msgid "Port:"
+msgstr "Port:"
+
+#: ../vnc.html:211
+msgid "Path:"
+msgstr "Sökväg:"
+
+#: ../vnc.html:218
+msgid "Automatic Reconnect"
+msgstr "Automatisk Återanslutning"
+
+#: ../vnc.html:221
+msgid "Reconnect Delay (ms):"
+msgstr "Fördröjning (ms):"
+
+#: ../vnc.html:226
+msgid "Show Dot when No Cursor"
+msgstr "Visa prick när ingen muspekare finns"
+
+#: ../vnc.html:231
+msgid "Logging:"
+msgstr "Loggning:"
+
+#: ../vnc.html:240
+msgid "Version:"
+msgstr "Version:"
+
+#: ../vnc.html:248
+msgid "Disconnect"
+msgstr "Koppla från"
+
+#: ../vnc.html:267
+msgid "Connect"
+msgstr "Anslut"
+
+#: ../vnc.html:277
+msgid "Username:"
+msgstr "Användarnamn:"
+
+#: ../vnc.html:281
+msgid "Password:"
+msgstr "Lösenord:"
+
+#: ../vnc.html:285
+msgid "Send Credentials"
+msgstr "Skicka Användaruppgifter"
+
+#: ../vnc.html:295
+msgid "Cancel"
+msgstr "Avbryt"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/tr.po
@@ -0,0 +1,288 @@
+# Turkish translations for noVNC package
+# Turkish translation for noVNC.
+# Copyright (C) 2018 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+# Ömer ÇAKMAK <farukomercakmak@gmail.com>, 2018.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 0.6.1\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2017-11-24 07:16+0000\n"
+"PO-Revision-Date: 2018-01-05 19:07+0300\n"
+"Last-Translator: Ömer ÇAKMAK <farukomercakmak@gmail.com>\n"
+"Language-Team: Türkçe <gnome-turk@gnome.org>\n"
+"Language: tr\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+"X-Generator: Gtranslator 2.91.7\n"
+
+#: ../app/ui.js:404
+msgid "Connecting..."
+msgstr "Bağlanıyor..."
+
+#: ../app/ui.js:411
+msgid "Disconnecting..."
+msgstr "Bağlantı kesiliyor..."
+
+#: ../app/ui.js:417
+msgid "Reconnecting..."
+msgstr "Yeniden bağlantı kuruluyor..."
+
+#: ../app/ui.js:422
+msgid "Internal error"
+msgstr "İç hata"
+
+#: ../app/ui.js:1019
+msgid "Must set host"
+msgstr "Sunucuyu kur"
+
+#: ../app/ui.js:1099
+msgid "Connected (encrypted) to "
+msgstr "Bağlı (şifrelenmiş)"
+
+#: ../app/ui.js:1101
+msgid "Connected (unencrypted) to "
+msgstr "Bağlandı (şifrelenmemiş)"
+
+#: ../app/ui.js:1119
+msgid "Something went wrong, connection is closed"
+msgstr "Bir şeyler ters gitti, bağlantı kesildi"
+
+#: ../app/ui.js:1129
+msgid "Disconnected"
+msgstr "Bağlantı kesildi"
+
+#: ../app/ui.js:1142
+msgid "New connection has been rejected with reason: "
+msgstr "Bağlantı aşağıdaki nedenlerden dolayı reddedildi: "
+
+#: ../app/ui.js:1145
+msgid "New connection has been rejected"
+msgstr "Bağlantı reddedildi"
+
+#: ../app/ui.js:1166
+msgid "Password is required"
+msgstr "Şifre gerekli"
+
+#: ../vnc.html:89
+msgid "noVNC encountered an error:"
+msgstr "Bir hata oluştu:"
+
+#: ../vnc.html:99
+msgid "Hide/Show the control bar"
+msgstr "Denetim masasını Gizle/Göster"
+
+#: ../vnc.html:106
+msgid "Move/Drag Viewport"
+msgstr "Görünümü Taşı/Sürükle"
+
+#: ../vnc.html:106
+msgid "viewport drag"
+msgstr "Görüntü penceresini sürükle"
+
+#: ../vnc.html:112 ../vnc.html:115 ../vnc.html:118 ../vnc.html:121
+msgid "Active Mouse Button"
+msgstr "Aktif Fare Düğmesi"
+
+#: ../vnc.html:112
+msgid "No mousebutton"
+msgstr "Fare düğmesi yok"
+
+#: ../vnc.html:115
+msgid "Left mousebutton"
+msgstr "Farenin sol düğmesi"
+
+#: ../vnc.html:118
+msgid "Middle mousebutton"
+msgstr "Farenin orta düğmesi"
+
+#: ../vnc.html:121
+msgid "Right mousebutton"
+msgstr "Farenin sağ düğmesi"
+
+#: ../vnc.html:124
+msgid "Keyboard"
+msgstr "Klavye"
+
+#: ../vnc.html:124
+msgid "Show Keyboard"
+msgstr "Klavye Düzenini Göster"
+
+#: ../vnc.html:131
+msgid "Extra keys"
+msgstr "Ekstra tuşlar"
+
+#: ../vnc.html:131
+msgid "Show Extra Keys"
+msgstr "Ekstra tuşları göster"
+
+#: ../vnc.html:136
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:136
+msgid "Toggle Ctrl"
+msgstr "Ctrl Değiştir "
+
+#: ../vnc.html:139
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:139
+msgid "Toggle Alt"
+msgstr "Alt Değiştir"
+
+#: ../vnc.html:142
+msgid "Send Tab"
+msgstr "Sekme Gönder"
+
+#: ../vnc.html:142
+msgid "Tab"
+msgstr "Sekme"
+
+#: ../vnc.html:145
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:145
+msgid "Send Escape"
+msgstr "Boşluk Gönder"
+
+#: ../vnc.html:148
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl + Alt + Del"
+
+#: ../vnc.html:148
+msgid "Send Ctrl-Alt-Del"
+msgstr "Ctrl-Alt-Del Gönder"
+
+#: ../vnc.html:156
+msgid "Shutdown/Reboot"
+msgstr "Kapat/Yeniden Başlat"
+
+#: ../vnc.html:156
+msgid "Shutdown/Reboot..."
+msgstr "Kapat/Yeniden Başlat..."
+
+#: ../vnc.html:162
+msgid "Power"
+msgstr "Güç"
+
+#: ../vnc.html:164
+msgid "Shutdown"
+msgstr "Kapat"
+
+#: ../vnc.html:165
+msgid "Reboot"
+msgstr "Yeniden Başlat"
+
+#: ../vnc.html:166
+msgid "Reset"
+msgstr "Sıfırla"
+
+#: ../vnc.html:171 ../vnc.html:177
+msgid "Clipboard"
+msgstr "Pano"
+
+#: ../vnc.html:181
+msgid "Clear"
+msgstr "Temizle"
+
+#: ../vnc.html:187
+msgid "Fullscreen"
+msgstr "Tam Ekran"
+
+#: ../vnc.html:192 ../vnc.html:199
+msgid "Settings"
+msgstr "Ayarlar"
+
+#: ../vnc.html:202
+msgid "Shared Mode"
+msgstr "Paylaşım Modu"
+
+#: ../vnc.html:205
+msgid "View Only"
+msgstr "Sadece Görüntüle"
+
+#: ../vnc.html:209
+msgid "Clip to Window"
+msgstr "Pencereye Tıkla"
+
+#: ../vnc.html:212
+msgid "Scaling Mode:"
+msgstr "Ölçekleme Modu:"
+
+#: ../vnc.html:214
+msgid "None"
+msgstr "Bilinmeyen"
+
+#: ../vnc.html:215
+msgid "Local Scaling"
+msgstr "Yerel Ölçeklendirme"
+
+#: ../vnc.html:216
+msgid "Remote Resizing"
+msgstr "Uzaktan Yeniden Boyutlandırma"
+
+#: ../vnc.html:221
+msgid "Advanced"
+msgstr "Gelişmiş"
+
+#: ../vnc.html:224
+msgid "Repeater ID:"
+msgstr "Tekralayıcı ID:"
+
+#: ../vnc.html:228
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:231
+msgid "Encrypt"
+msgstr "Şifrele"
+
+#: ../vnc.html:234
+msgid "Host:"
+msgstr "Ana makine:"
+
+#: ../vnc.html:238
+msgid "Port:"
+msgstr "Port:"
+
+#: ../vnc.html:242
+msgid "Path:"
+msgstr "Yol:"
+
+#: ../vnc.html:249
+msgid "Automatic Reconnect"
+msgstr "Otomatik Yeniden Bağlan"
+
+#: ../vnc.html:252
+msgid "Reconnect Delay (ms):"
+msgstr "Yeniden Bağlanma Süreci (ms):"
+
+#: ../vnc.html:258
+msgid "Logging:"
+msgstr "Giriş yapılıyor:"
+
+#: ../vnc.html:270
+msgid "Disconnect"
+msgstr "Bağlantıyı Kes"
+
+#: ../vnc.html:289
+msgid "Connect"
+msgstr "Bağlan"
+
+#: ../vnc.html:299
+msgid "Password:"
+msgstr "Parola:"
+
+#: ../vnc.html:313
+msgid "Cancel"
+msgstr "Vazgeç"
+
+#: ../vnc.html:329
+msgid "Canvas not supported."
+msgstr "Tuval desteklenmiyor."
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/xgettext-html
@@ -0,0 +1,115 @@
+#!/usr/bin/env node
+/*
+ * xgettext-html: HTML gettext parser
+ * Copyright (C) 2018 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ */
+
+const getopt = require('node-getopt');
+const jsdom = require("jsdom");
+const fs = require("fs");
+
+const opt = getopt.create([
+    ['o', 'output=FILE', 'write output to specified file'],
+    ['h', 'help', 'display this help'],
+]).bindHelp().parseSystem();
+
+const strings = {};
+
+function addString(str, location) {
+    if (str.length == 0) {
+        return;
+    }
+
+    if (strings[str] === undefined) {
+        strings[str] = {};
+    }
+    strings[str][location] = null;
+}
+
+// See https://html.spec.whatwg.org/multipage/dom.html#attr-translate
+function process(elem, locator, enabled) {
+    function isAnyOf(searchElement, items) {
+        return items.indexOf(searchElement) !== -1;
+    }
+
+    if (elem.hasAttribute("translate")) {
+        if (isAnyOf(elem.getAttribute("translate"), ["", "yes"])) {
+            enabled = true;
+        } else if (isAnyOf(elem.getAttribute("translate"), ["no"])) {
+            enabled = false;
+        }
+    }
+
+    if (enabled) {
+        if (elem.hasAttribute("abbr") &&
+            elem.tagName === "TH") {
+            addString(elem.getAttribute("abbr"), locator(elem));
+        }
+        if (elem.hasAttribute("alt") &&
+            isAnyOf(elem.tagName, ["AREA", "IMG", "INPUT"])) {
+            addString(elem.getAttribute("alt"), locator(elem));
+        }
+        if (elem.hasAttribute("download") &&
+            isAnyOf(elem.tagName, ["A", "AREA"])) {
+            addString(elem.getAttribute("download"), locator(elem));
+        }
+        if (elem.hasAttribute("label") &&
+            isAnyOf(elem.tagName, ["MENUITEM", "MENU", "OPTGROUP",
+                                   "OPTION", "TRACK"])) {
+            addString(elem.getAttribute("label"), locator(elem));
+        }
+        if (elem.hasAttribute("placeholder") &&
+            isAnyOf(elem.tagName in ["INPUT", "TEXTAREA"])) {
+            addString(elem.getAttribute("placeholder"), locator(elem));
+        }
+        if (elem.hasAttribute("title")) {
+            addString(elem.getAttribute("title"), locator(elem));
+        }
+        if (elem.hasAttribute("value") &&
+            elem.tagName === "INPUT" &&
+            isAnyOf(elem.getAttribute("type"), ["reset", "button", "submit"])) {
+            addString(elem.getAttribute("value"), locator(elem));
+        }
+    }
+
+    for (let i = 0; i < elem.childNodes.length; i++) {
+        let node = elem.childNodes[i];
+        if (node.nodeType === node.ELEMENT_NODE) {
+            process(node, locator, enabled);
+        } else if (node.nodeType === node.TEXT_NODE && enabled) {
+            addString(node.data.trim(), locator(node));
+        }
+    }
+}
+
+for (let i = 0; i < opt.argv.length; i++) {
+    const fn = opt.argv[i];
+    const file = fs.readFileSync(fn, "utf8");
+    const dom = new jsdom.JSDOM(file, { includeNodeLocations: true });
+    const body = dom.window.document.body;
+
+    let locator = (elem) => {
+        const offset = dom.nodeLocation(elem).startOffset;
+        const line = file.slice(0, offset).split("\n").length;
+        return fn + ":" + line;
+    };
+
+    process(body, locator, true);
+}
+
+let output = "";
+
+for (let str in strings) {
+    output += "#:";
+    for (location in strings[str]) {
+        output += " " + location;
+    }
+    output += "\n";
+
+    output += "msgid " + JSON.stringify(str) + "\n";
+    output += "msgstr \"\"\n";
+    output += "\n";
+}
+
+fs.writeFileSync(opt.options.output, output);
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/zh_CN.po
@@ -0,0 +1,284 @@
+# Simplified Chinese translations for noVNC package.
+# Copyright (C) 2020 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+# Peter Dave Hello <hsu@peterdavehello.org>, 2018.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 1.1.0\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2018-01-10 00:53+0800\n"
+"PO-Revision-Date: 2020-01-02 13:19+0800\n"
+"Last-Translator: CUI Wei <ghostplant@qq.com>\n"
+"Language: zh_CN\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: ../app/ui.js:395
+msgid "Connecting..."
+msgstr "连接中..."
+
+#: ../app/ui.js:402
+msgid "Disconnecting..."
+msgstr "正在断开连接..."
+
+#: ../app/ui.js:408
+msgid "Reconnecting..."
+msgstr "重新连接中..."
+
+#: ../app/ui.js:413
+msgid "Internal error"
+msgstr "内部错误"
+
+#: ../app/ui.js:1015
+msgid "Must set host"
+msgstr "请提供主机名"
+
+#: ../app/ui.js:1097
+msgid "Connected (encrypted) to "
+msgstr "已连接到（加密）"
+
+#: ../app/ui.js:1099
+msgid "Connected (unencrypted) to "
+msgstr "已连接到（未加密）"
+
+#: ../app/ui.js:1120
+msgid "Something went wrong, connection is closed"
+msgstr "发生错误，连接已关闭"
+
+#: ../app/ui.js:1123
+msgid "Failed to connect to server"
+msgstr "无法连接到服务器"
+
+#: ../app/ui.js:1133
+msgid "Disconnected"
+msgstr "已断开连接"
+
+#: ../app/ui.js:1146
+msgid "New connection has been rejected with reason: "
+msgstr "连接被拒绝，原因："
+
+#: ../app/ui.js:1149
+msgid "New connection has been rejected"
+msgstr "连接被拒绝"
+
+#: ../app/ui.js:1170
+msgid "Password is required"
+msgstr "请提供密码"
+
+#: ../vnc.html:89
+msgid "noVNC encountered an error:"
+msgstr "noVNC 遇到一个错误："
+
+#: ../vnc.html:99
+msgid "Hide/Show the control bar"
+msgstr "显示/隐藏控制栏"
+
+#: ../vnc.html:106
+msgid "Move/Drag Viewport"
+msgstr "拖放显示范围"
+
+#: ../vnc.html:106
+msgid "viewport drag"
+msgstr "显示范围拖放"
+
+#: ../vnc.html:112 ../vnc.html:115 ../vnc.html:118 ../vnc.html:121
+msgid "Active Mouse Button"
+msgstr "启动鼠标按鍵"
+
+#: ../vnc.html:112
+msgid "No mousebutton"
+msgstr "禁用鼠标按鍵"
+
+#: ../vnc.html:115
+msgid "Left mousebutton"
+msgstr "鼠标左鍵"
+
+#: ../vnc.html:118
+msgid "Middle mousebutton"
+msgstr "鼠标中鍵"
+
+#: ../vnc.html:121
+msgid "Right mousebutton"
+msgstr "鼠标右鍵"
+
+#: ../vnc.html:124
+msgid "Keyboard"
+msgstr "键盘"
+
+#: ../vnc.html:124
+msgid "Show Keyboard"
+msgstr "显示键盘"
+
+#: ../vnc.html:131
+msgid "Extra keys"
+msgstr "额外按键"
+
+#: ../vnc.html:131
+msgid "Show Extra Keys"
+msgstr "显示额外按键"
+
+#: ../vnc.html:136
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:136
+msgid "Toggle Ctrl"
+msgstr "切换 Ctrl"
+
+#: ../vnc.html:139
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:139
+msgid "Toggle Alt"
+msgstr "切换 Alt"
+
+#: ../vnc.html:142
+msgid "Send Tab"
+msgstr "发送 Tab 键"
+
+#: ../vnc.html:142
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:145
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:145
+msgid "Send Escape"
+msgstr "发送 Escape 键"
+
+#: ../vnc.html:148
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl-Alt-Del"
+
+#: ../vnc.html:148
+msgid "Send Ctrl-Alt-Del"
+msgstr "发送 Ctrl-Alt-Del 键"
+
+#: ../vnc.html:156
+msgid "Shutdown/Reboot"
+msgstr "关机/重新启动"
+
+#: ../vnc.html:156
+msgid "Shutdown/Reboot..."
+msgstr "关机/重新启动..."
+
+#: ../vnc.html:162
+msgid "Power"
+msgstr "电源"
+
+#: ../vnc.html:164
+msgid "Shutdown"
+msgstr "关机"
+
+#: ../vnc.html:165
+msgid "Reboot"
+msgstr "重新启动"
+
+#: ../vnc.html:166
+msgid "Reset"
+msgstr "重置"
+
+#: ../vnc.html:171 ../vnc.html:177
+msgid "Clipboard"
+msgstr "剪贴板"
+
+#: ../vnc.html:181
+msgid "Clear"
+msgstr "清除"
+
+#: ../vnc.html:187
+msgid "Fullscreen"
+msgstr "全屏"
+
+#: ../vnc.html:192 ../vnc.html:199
+msgid "Settings"
+msgstr "设置"
+
+#: ../vnc.html:202
+msgid "Shared Mode"
+msgstr "分享模式"
+
+#: ../vnc.html:205
+msgid "View Only"
+msgstr "仅查看"
+
+#: ../vnc.html:209
+msgid "Clip to Window"
+msgstr "限制/裁切窗口大小"
+
+#: ../vnc.html:212
+msgid "Scaling Mode:"
+msgstr "缩放模式："
+
+#: ../vnc.html:214
+msgid "None"
+msgstr "无"
+
+#: ../vnc.html:215
+msgid "Local Scaling"
+msgstr "本地缩放"
+
+#: ../vnc.html:216
+msgid "Remote Resizing"
+msgstr "远程调整大小"
+
+#: ../vnc.html:221
+msgid "Advanced"
+msgstr "高级"
+
+#: ../vnc.html:224
+msgid "Repeater ID:"
+msgstr "中继站 ID"
+
+#: ../vnc.html:228
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:231
+msgid "Encrypt"
+msgstr "加密"
+
+#: ../vnc.html:234
+msgid "Host:"
+msgstr "主机："
+
+#: ../vnc.html:238
+msgid "Port:"
+msgstr "端口："
+
+#: ../vnc.html:242
+msgid "Path:"
+msgstr "路径："
+
+#: ../vnc.html:249
+msgid "Automatic Reconnect"
+msgstr "自动重新连接"
+
+#: ../vnc.html:252
+msgid "Reconnect Delay (ms):"
+msgstr "重新连接间隔 (ms)："
+
+#: ../vnc.html:258
+msgid "Logging:"
+msgstr "日志级别："
+
+#: ../vnc.html:270
+msgid "Disconnect"
+msgstr "中断连接"
+
+#: ../vnc.html:289
+msgid "Connect"
+msgstr "连接"
+
+#: ../vnc.html:299
+msgid "Password:"
+msgstr "密码："
+
+#: ../vnc.html:313
+msgid "Cancel"
+msgstr "取消"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/po/zh_TW.po
@@ -0,0 +1,285 @@
+# Traditional Chinese translations for noVNC package.
+# Copyright (C) 2018 The noVNC Authors
+# This file is distributed under the same license as the noVNC package.
+# Peter Dave Hello <hsu@peterdavehello.org>, 2018.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: noVNC 1.0.0-testing.2\n"
+"Report-Msgid-Bugs-To: novnc@googlegroups.com\n"
+"POT-Creation-Date: 2018-01-10 00:53+0800\n"
+"PO-Revision-Date: 2018-01-10 01:33+0800\n"
+"Last-Translator: Peter Dave Hello <hsu@peterdavehello.org>\n"
+"Language-Team: Peter Dave Hello <hsu@peterdavehello.org>\n"
+"Language: zh\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: ../app/ui.js:395
+msgid "Connecting..."
+msgstr "連線中..."
+
+#: ../app/ui.js:402
+msgid "Disconnecting..."
+msgstr "正在中斷連線..."
+
+#: ../app/ui.js:408
+msgid "Reconnecting..."
+msgstr "重新連線中..."
+
+#: ../app/ui.js:413
+msgid "Internal error"
+msgstr "內部錯誤"
+
+#: ../app/ui.js:1015
+msgid "Must set host"
+msgstr "請提供主機資訊"
+
+#: ../app/ui.js:1097
+msgid "Connected (encrypted) to "
+msgstr "已加密連線到"
+
+#: ../app/ui.js:1099
+msgid "Connected (unencrypted) to "
+msgstr "未加密連線到"
+
+#: ../app/ui.js:1120
+msgid "Something went wrong, connection is closed"
+msgstr "發生錯誤，連線已關閉"
+
+#: ../app/ui.js:1123
+msgid "Failed to connect to server"
+msgstr "無法連線到伺服器"
+
+#: ../app/ui.js:1133
+msgid "Disconnected"
+msgstr "連線已中斷"
+
+#: ../app/ui.js:1146
+msgid "New connection has been rejected with reason: "
+msgstr "連線被拒絕，原因："
+
+#: ../app/ui.js:1149
+msgid "New connection has been rejected"
+msgstr "連線被拒絕"
+
+#: ../app/ui.js:1170
+msgid "Password is required"
+msgstr "請提供密碼"
+
+#: ../vnc.html:89
+msgid "noVNC encountered an error:"
+msgstr "noVNC 遇到一個錯誤："
+
+#: ../vnc.html:99
+msgid "Hide/Show the control bar"
+msgstr "顯示/隱藏控制列"
+
+#: ../vnc.html:106
+msgid "Move/Drag Viewport"
+msgstr "拖放顯示範圍"
+
+#: ../vnc.html:106
+msgid "viewport drag"
+msgstr "顯示範圍拖放"
+
+#: ../vnc.html:112 ../vnc.html:115 ../vnc.html:118 ../vnc.html:121
+msgid "Active Mouse Button"
+msgstr "啟用滑鼠按鍵"
+
+#: ../vnc.html:112
+msgid "No mousebutton"
+msgstr "無滑鼠按鍵"
+
+#: ../vnc.html:115
+msgid "Left mousebutton"
+msgstr "滑鼠左鍵"
+
+#: ../vnc.html:118
+msgid "Middle mousebutton"
+msgstr "滑鼠中鍵"
+
+#: ../vnc.html:121
+msgid "Right mousebutton"
+msgstr "滑鼠右鍵"
+
+#: ../vnc.html:124
+msgid "Keyboard"
+msgstr "鍵盤"
+
+#: ../vnc.html:124
+msgid "Show Keyboard"
+msgstr "顯示鍵盤"
+
+#: ../vnc.html:131
+msgid "Extra keys"
+msgstr "額外按鍵"
+
+#: ../vnc.html:131
+msgid "Show Extra Keys"
+msgstr "顯示額外按鍵"
+
+#: ../vnc.html:136
+msgid "Ctrl"
+msgstr "Ctrl"
+
+#: ../vnc.html:136
+msgid "Toggle Ctrl"
+msgstr "切換 Ctrl"
+
+#: ../vnc.html:139
+msgid "Alt"
+msgstr "Alt"
+
+#: ../vnc.html:139
+msgid "Toggle Alt"
+msgstr "切換 Alt"
+
+#: ../vnc.html:142
+msgid "Send Tab"
+msgstr "送出 Tab 鍵"
+
+#: ../vnc.html:142
+msgid "Tab"
+msgstr "Tab"
+
+#: ../vnc.html:145
+msgid "Esc"
+msgstr "Esc"
+
+#: ../vnc.html:145
+msgid "Send Escape"
+msgstr "送出 Escape 鍵"
+
+#: ../vnc.html:148
+msgid "Ctrl+Alt+Del"
+msgstr "Ctrl-Alt-Del"
+
+#: ../vnc.html:148
+msgid "Send Ctrl-Alt-Del"
+msgstr "送出 Ctrl-Alt-Del 快捷鍵"
+
+#: ../vnc.html:156
+msgid "Shutdown/Reboot"
+msgstr "關機/重新啟動"
+
+#: ../vnc.html:156
+msgid "Shutdown/Reboot..."
+msgstr "關機/重新啟動..."
+
+#: ../vnc.html:162
+msgid "Power"
+msgstr "電源"
+
+#: ../vnc.html:164
+msgid "Shutdown"
+msgstr "關機"
+
+#: ../vnc.html:165
+msgid "Reboot"
+msgstr "重新啟動"
+
+#: ../vnc.html:166
+msgid "Reset"
+msgstr "重設"
+
+#: ../vnc.html:171 ../vnc.html:177
+msgid "Clipboard"
+msgstr "剪貼簿"
+
+#: ../vnc.html:181
+msgid "Clear"
+msgstr "清除"
+
+#: ../vnc.html:187
+msgid "Fullscreen"
+msgstr "全螢幕"
+
+#: ../vnc.html:192 ../vnc.html:199
+msgid "Settings"
+msgstr "設定"
+
+#: ../vnc.html:202
+msgid "Shared Mode"
+msgstr "分享模式"
+
+#: ../vnc.html:205
+msgid "View Only"
+msgstr "僅檢視"
+
+#: ../vnc.html:209
+msgid "Clip to Window"
+msgstr "限制/裁切視窗大小"
+
+#: ../vnc.html:212
+msgid "Scaling Mode:"
+msgstr "縮放模式："
+
+#: ../vnc.html:214
+msgid "None"
+msgstr "無"
+
+#: ../vnc.html:215
+msgid "Local Scaling"
+msgstr "本機縮放"
+
+#: ../vnc.html:216
+msgid "Remote Resizing"
+msgstr "遠端調整大小"
+
+#: ../vnc.html:221
+msgid "Advanced"
+msgstr "進階"
+
+#: ../vnc.html:224
+msgid "Repeater ID:"
+msgstr "中繼站 ID"
+
+#: ../vnc.html:228
+msgid "WebSocket"
+msgstr "WebSocket"
+
+#: ../vnc.html:231
+msgid "Encrypt"
+msgstr "加密"
+
+#: ../vnc.html:234
+msgid "Host:"
+msgstr "主機："
+
+#: ../vnc.html:238
+msgid "Port:"
+msgstr "連接埠："
+
+#: ../vnc.html:242
+msgid "Path:"
+msgstr "路徑："
+
+#: ../vnc.html:249
+msgid "Automatic Reconnect"
+msgstr "自動重新連線"
+
+#: ../vnc.html:252
+msgid "Reconnect Delay (ms):"
+msgstr "重新連線間隔 (ms)："
+
+#: ../vnc.html:258
+msgid "Logging:"
+msgstr "日誌級別："
+
+#: ../vnc.html:270
+msgid "Disconnect"
+msgstr "中斷連線"
+
+#: ../vnc.html:289
+msgid "Connect"
+msgstr "連線"
+
+#: ../vnc.html:299
+msgid "Password:"
+msgstr "密碼："
+
+#: ../vnc.html:313
+msgid "Cancel"
+msgstr "取消"
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/snap/hooks/configure
@@ -0,0 +1,3 @@
+#!/bin/sh -e
+
+snapctl restart novnc.novncsvc
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/snap/local/svc_wrapper.sh
@@ -0,0 +1,29 @@
+#!/bin/bash
+
+# `snapctl get services` returns a JSON array, example:
+#{
+#"n6801": {
+#   "listen": 6801,
+#   "vnc": "localhost:5901"
+#},
+#"n6802": {
+#    "listen": 6802,
+#   "vnc": "localhost:5902"
+#}
+#}
+snapctl get services | jq -c '.[]' | while read service; do # for each service the user sepcified..
+    # get the important data for the service (listen port, VNC host:port)
+    listen_port="$(echo $service | jq --raw-output '.listen')"
+    vnc_host_port="$(echo $service | jq --raw-output '.vnc')" # --raw-output removes any quotation marks from the output
+    
+    # check whether those values are valid
+    expr "$listen_port" : '^[0-9]\+$' > /dev/null
+    listen_port_valid=$?
+    if [ ! $listen_port_valid ] || [ -z "$vnc_host_port" ]; then
+        # invalid values mean the service is disabled, do nothing except for printing a message (logged in /var/log/system or systemd journal)
+        echo "novnc: not starting service ${service} with listen_port ${listen_port} and vnc_host_port ${vnc_host_port}"
+    else
+        # start (and fork with '&') the service using the specified listen port and VNC host:port
+        $SNAP/novnc_proxy --listen $listen_port --vnc $vnc_host_port &
+    fi
+done
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/snap/snapcraft.yaml
@@ -0,0 +1,61 @@
+name: novnc
+base: core18 # the base snap is the execution environment for this snap
+version: git
+summary: Open Source VNC client using HTML5 (WebSockets, Canvas)
+description: |
+  Open Source VNC client using HTML5 (WebSockets, Canvas).
+  noVNC is both a VNC client JavaScript library as well as an
+  application built on top of that library. noVNC runs well in any
+  modern browser including mobile browsers (iOS and Android).
+
+grade: stable
+confinement: strict
+
+parts:
+    novnc:
+        source: .
+        plugin: dump
+        organize:
+            utils/novnc_proxy: /
+        stage:
+            - vnc.html
+            - app
+            - core/**/*.js
+            - vendor/**/*.js
+            - novnc_proxy
+
+    novnc-deps:
+        plugin: nil
+        stage-packages:
+            - bash
+
+    svc-script:
+        source: snap/local
+        plugin: dump
+        stage:
+            - svc_wrapper.sh
+
+    svc-script-deps:
+        plugin: nil
+        stage-packages:
+            - bash
+            - jq
+
+    websockify:
+        source: https://github.com/novnc/websockify/archive/v0.9.0.tar.gz
+        plugin: python
+        stage-packages:
+            - python3-numpy
+
+hooks:
+    configure:
+        plugs: [network, network-bind]
+
+apps:
+    novnc:
+        command: ./novnc_proxy
+        plugs: [network, network-bind]
+    novncsvc:
+        command: ./svc_wrapper.sh
+        daemon: forking
+        plugs: [network, network-bind]
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/.eslintrc
@@ -0,0 +1,15 @@
+{
+    "env": {
+        "node": true,
+        "mocha": true
+    },
+    "globals": {
+        "chai": false,
+        "sinon": false
+    },
+    "rules": {
+        "prefer-arrow-callback": 0,
+        // Too many anonymous callbacks
+        "func-names": "off",
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/assertions.js
@@ -0,0 +1,102 @@
+// noVNC specific assertions
+chai.use(function (_chai, utils) {
+    function _equal(a, b) {
+        return a === b;
+    }
+    _chai.Assertion.addMethod('displayed', function (targetData, cmp=_equal) {
+        const obj = this._obj;
+        const ctx = obj._target.getContext('2d');
+        const data = ctx.getImageData(0, 0, obj._target.width, obj._target.height).data;
+        const len = data.length;
+        new chai.Assertion(len).to.be.equal(targetData.length, "unexpected display size");
+        let same = true;
+        for (let i = 0; i < len; i++) {
+            if (!cmp(data[i], targetData[i])) {
+                same = false;
+                break;
+            }
+        }
+        if (!same) {
+            // eslint-disable-next-line no-console
+            console.log("expected data: %o, actual data: %o", targetData, data);
+        }
+        this.assert(same,
+                    "expected #{this} to have displayed the image #{exp}, but instead it displayed #{act}",
+                    "expected #{this} not to have displayed the image #{act}",
+                    targetData,
+                    data);
+    });
+
+    _chai.Assertion.addMethod('sent', function (targetData) {
+        const obj = this._obj;
+        obj.inspect = () => {
+            const res = { _websocket: obj._websocket, rQi: obj._rQi, _rQ: new Uint8Array(obj._rQ.buffer, 0, obj._rQlen),
+                          _sQ: new Uint8Array(obj._sQ.buffer, 0, obj._sQlen) };
+            res.prototype = obj;
+            return res;
+        };
+        const data = obj._websocket._getSentData();
+        let same = true;
+        if (data.length != targetData.length) {
+            same = false;
+        } else {
+            for (let i = 0; i < data.length; i++) {
+                if (data[i] != targetData[i]) {
+                    same = false;
+                    break;
+                }
+            }
+        }
+        if (!same) {
+            // eslint-disable-next-line no-console
+            console.log("expected data: %o, actual data: %o", targetData, data);
+        }
+        this.assert(same,
+                    "expected #{this} to have sent the data #{exp}, but it actually sent #{act}",
+                    "expected #{this} not to have sent the data #{act}",
+                    Array.prototype.slice.call(targetData),
+                    Array.prototype.slice.call(data));
+    });
+
+    _chai.Assertion.addProperty('array', function () {
+        utils.flag(this, 'array', true);
+    });
+
+    _chai.Assertion.overwriteMethod('equal', function (_super) {
+        return function assertArrayEqual(target) {
+            if (utils.flag(this, 'array')) {
+                const obj = this._obj;
+
+                let same = true;
+
+                if (utils.flag(this, 'deep')) {
+                    for (let i = 0; i < obj.length; i++) {
+                        if (!utils.eql(obj[i], target[i])) {
+                            same = false;
+                            break;
+                        }
+                    }
+
+                    this.assert(same,
+                                "expected #{this} to have elements deeply equal to #{exp}",
+                                "expected #{this} not to have elements deeply equal to #{exp}",
+                                Array.prototype.slice.call(target));
+                } else {
+                    for (let i = 0; i < obj.length; i++) {
+                        if (obj[i] != target[i]) {
+                            same = false;
+                            break;
+                        }
+                    }
+
+                    this.assert(same,
+                                "expected #{this} to have elements equal to #{exp}",
+                                "expected #{this} not to have elements equal to #{exp}",
+                                Array.prototype.slice.call(target));
+                }
+            } else {
+                _super.apply(this, arguments);
+            }
+        };
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/fake.websocket.js
@@ -0,0 +1,88 @@
+import Base64 from '../core/base64.js';
+
+export default class FakeWebSocket {
+    constructor(uri, protocols) {
+        this.url = uri;
+        this.binaryType = "arraybuffer";
+        this.extensions = "";
+
+        this.onerror = null;
+        this.onmessage = null;
+        this.onopen = null;
+
+        if (!protocols || typeof protocols === 'string') {
+            this.protocol = protocols;
+        } else {
+            this.protocol = protocols[0];
+        }
+
+        this._sendQueue = new Uint8Array(20000);
+
+        this.readyState = FakeWebSocket.CONNECTING;
+        this.bufferedAmount = 0;
+
+        this._isFake = true;
+    }
+
+    close(code, reason) {
+        this.readyState = FakeWebSocket.CLOSED;
+        if (this.onclose) {
+            this.onclose(new CloseEvent("close", { 'code': code, 'reason': reason, 'wasClean': true }));
+        }
+    }
+
+    send(data) {
+        if (this.protocol == 'base64') {
+            data = Base64.decode(data);
+        } else {
+            data = new Uint8Array(data);
+        }
+        this._sendQueue.set(data, this.bufferedAmount);
+        this.bufferedAmount += data.length;
+    }
+
+    _getSentData() {
+        const res = new Uint8Array(this._sendQueue.buffer, 0, this.bufferedAmount);
+        this.bufferedAmount = 0;
+        return res;
+    }
+
+    _open() {
+        this.readyState = FakeWebSocket.OPEN;
+        if (this.onopen) {
+            this.onopen(new Event('open'));
+        }
+    }
+
+    _receiveData(data) {
+        // Break apart the data to expose bugs where we assume data is
+        // neatly packaged
+        for (let i = 0;i < data.length;i++) {
+            let buf = data.subarray(i, i+1);
+            this.onmessage(new MessageEvent("message", { 'data': buf }));
+        }
+    }
+}
+
+FakeWebSocket.OPEN = WebSocket.OPEN;
+FakeWebSocket.CONNECTING = WebSocket.CONNECTING;
+FakeWebSocket.CLOSING = WebSocket.CLOSING;
+FakeWebSocket.CLOSED = WebSocket.CLOSED;
+
+FakeWebSocket._isFake = true;
+
+FakeWebSocket.replace = () => {
+    if (!WebSocket._isFake) {
+        const realVersion = WebSocket;
+        // eslint-disable-next-line no-global-assign
+        WebSocket = FakeWebSocket;
+        FakeWebSocket._realVersion = realVersion;
+    }
+};
+
+FakeWebSocket.restore = () => {
+    if (WebSocket._isFake) {
+        // eslint-disable-next-line no-global-assign
+        WebSocket = WebSocket._realVersion;
+    }
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/playback-ui.js
@@ -0,0 +1,215 @@
+/* global VNC_frame_data, VNC_frame_encoding */
+
+import * as WebUtil from '../app/webutil.js';
+import RecordingPlayer from './playback.js';
+import Base64 from '../core/base64.js';
+
+let frames = null;
+
+function message(str) {
+    const cell = document.getElementById('messages');
+    cell.textContent += str + "\n";
+    cell.scrollTop = cell.scrollHeight;
+}
+
+function loadFile() {
+    const fname = WebUtil.getQueryVar('data', null);
+
+    if (!fname) {
+        return Promise.reject("Must specify data=FOO in query string.");
+    }
+
+    message("Loading " + fname + "...");
+
+    return new Promise((resolve, reject) => {
+        const script = document.createElement("script");
+        script.onload = resolve;
+        script.onerror = reject;
+        document.body.appendChild(script);
+        script.src = "../recordings/" + fname;
+    });
+}
+
+function enableUI() {
+    const iterations = WebUtil.getQueryVar('iterations', 3);
+    document.getElementById('iterations').value = iterations;
+
+    const mode = WebUtil.getQueryVar('mode', 3);
+    if (mode === 'realtime') {
+        document.getElementById('mode2').checked = true;
+    } else {
+        document.getElementById('mode1').checked = true;
+    }
+
+    /* eslint-disable-next-line camelcase */
+    message("Loaded " + VNC_frame_data.length + " frames");
+
+    const startButton = document.getElementById('startButton');
+    startButton.disabled = false;
+    startButton.addEventListener('click', start);
+
+    message("Converting...");
+
+    /* eslint-disable-next-line camelcase */
+    frames = VNC_frame_data;
+
+    let encoding;
+
+    /* eslint-disable camelcase */
+    if (window.VNC_frame_encoding) {
+        // Only present in older recordings
+        encoding = VNC_frame_encoding;
+    /* eslint-enable camelcase */
+    } else {
+        let frame = frames[0];
+        let start = frame.indexOf('{', 1) + 1;
+        if (frame.slice(start, start+4) === 'UkZC') {
+            encoding = 'base64';
+        } else {
+            encoding = 'binary';
+        }
+    }
+
+    for (let i = 0;i < frames.length;i++) {
+        let frame = frames[i];
+
+        if (frame === "EOF") {
+            frames.splice(i);
+            break;
+        }
+
+        let dataIdx = frame.indexOf('{', 1) + 1;
+
+        let time = parseInt(frame.slice(1, dataIdx - 1));
+
+        let u8;
+        if (encoding === 'base64') {
+            u8 = Base64.decode(frame.slice(dataIdx));
+        } else {
+            u8 = new Uint8Array(frame.length - dataIdx);
+            for (let j = 0; j < frame.length - dataIdx; j++) {
+                u8[j] = frame.charCodeAt(dataIdx + j);
+            }
+        }
+
+        frames[i] = { fromClient: frame[0] === '}',
+                      timestamp: time,
+                      data: u8 };
+    }
+
+    message("Ready");
+}
+
+class IterationPlayer {
+    constructor(iterations, frames) {
+        this._iterations = iterations;
+
+        this._iteration = undefined;
+        this._player = undefined;
+
+        this._startTime = undefined;
+
+        this._frames = frames;
+
+        this._state = 'running';
+
+        this.onfinish = () => {};
+        this.oniterationfinish = () => {};
+        this.rfbdisconnected = () => {};
+    }
+
+    start(realtime) {
+        this._iteration = 0;
+        this._startTime = (new Date()).getTime();
+
+        this._realtime = realtime;
+
+        this._nextIteration();
+    }
+
+    _nextIteration() {
+        const player = new RecordingPlayer(this._frames, this._disconnected.bind(this));
+        player.onfinish = this._iterationFinish.bind(this);
+
+        if (this._state !== 'running') { return; }
+
+        this._iteration++;
+        if (this._iteration > this._iterations) {
+            this._finish();
+            return;
+        }
+
+        player.run(this._realtime, false);
+    }
+
+    _finish() {
+        const endTime = (new Date()).getTime();
+        const totalDuration = endTime - this._startTime;
+
+        const evt = new CustomEvent('finish',
+                                    { detail:
+                                      { duration: totalDuration,
+                                        iterations: this._iterations } } );
+        this.onfinish(evt);
+    }
+
+    _iterationFinish(duration) {
+        const evt = new CustomEvent('iterationfinish',
+                                    { detail:
+                                      { duration: duration,
+                                        number: this._iteration } } );
+        this.oniterationfinish(evt);
+
+        this._nextIteration();
+    }
+
+    _disconnected(clean, frame) {
+        if (!clean) {
+            this._state = 'failed';
+        }
+
+        const evt = new CustomEvent('rfbdisconnected',
+                                    { detail:
+                                      { clean: clean,
+                                        frame: frame,
+                                        iteration: this._iteration } } );
+        this.onrfbdisconnected(evt);
+    }
+}
+
+function start() {
+    document.getElementById('startButton').value = "Running";
+    document.getElementById('startButton').disabled = true;
+
+    const iterations = document.getElementById('iterations').value;
+
+    let realtime;
+
+    if (document.getElementById('mode1').checked) {
+        message(`Starting performance playback (fullspeed) [${iterations} iteration(s)]`);
+        realtime = false;
+    } else {
+        message(`Starting realtime playback [${iterations} iteration(s)]`);
+        realtime = true;
+    }
+
+    const player = new IterationPlayer(iterations, frames);
+    player.oniterationfinish = (evt) => {
+        message(`Iteration ${evt.detail.number} took ${evt.detail.duration}ms`);
+    };
+    player.onrfbdisconnected = (evt) => {
+        if (!evt.detail.clean) {
+            message(`noVNC sent disconnected during iteration ${evt.detail.iteration} frame ${evt.detail.frame}`);
+        }
+    };
+    player.onfinish = (evt) => {
+        const iterTime = parseInt(evt.detail.duration / evt.detail.iterations, 10);
+        message(`${evt.detail.iterations} iterations took ${evt.detail.duration}ms (average ${iterTime}ms / iteration)`);
+
+        document.getElementById('startButton').disabled = false;
+        document.getElementById('startButton').value = "Start";
+    };
+    player.start(realtime);
+}
+
+loadFile().then(enableUI).catch(e => message("Error loading recording: " + e));
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/playback.js
@@ -0,0 +1,178 @@
+/*
+ * noVNC: HTML5 VNC client
+ * Copyright (C) 2018 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ */
+
+import RFB from '../core/rfb.js';
+import * as Log from '../core/util/logging.js';
+
+// Immediate polyfill
+if (window.setImmediate === undefined) {
+    let _immediateIdCounter = 1;
+    const _immediateFuncs = {};
+
+    window.setImmediate = (func) => {
+        const index = _immediateIdCounter++;
+        _immediateFuncs[index] = func;
+        window.postMessage("noVNC immediate trigger:" + index, "*");
+        return index;
+    };
+
+    window.clearImmediate = (id) => {
+        _immediateFuncs[id];
+    };
+
+    window.addEventListener("message", (event) => {
+        if ((typeof event.data !== "string") ||
+            (event.data.indexOf("noVNC immediate trigger:") !== 0)) {
+            return;
+        }
+
+        const index = event.data.slice("noVNC immediate trigger:".length);
+
+        const callback = _immediateFuncs[index];
+        if (callback === undefined) {
+            return;
+        }
+
+        delete _immediateFuncs[index];
+
+        callback();
+    });
+}
+
+class FakeWebSocket {
+    constructor() {
+        this.binaryType = "arraybuffer";
+        this.protocol = "";
+        this.readyState = "open";
+
+        this.onerror = () => {};
+        this.onmessage = () => {};
+        this.onopen = () => {};
+    }
+
+    send() {
+    }
+
+    close() {
+    }
+}
+
+export default class RecordingPlayer {
+    constructor(frames, disconnected) {
+        this._frames = frames;
+
+        this._disconnected = disconnected;
+
+        this._rfb = undefined;
+        this._frameLength = this._frames.length;
+
+        this._frameIndex = 0;
+        this._startTime = undefined;
+        this._realtime = true;
+        this._trafficManagement = true;
+
+        this._running = false;
+
+        this.onfinish = () => {};
+    }
+
+    run(realtime, trafficManagement) {
+        // initialize a new RFB
+        this._ws = new FakeWebSocket();
+        this._rfb = new RFB(document.getElementById('VNC_screen'), this._ws);
+        this._rfb.viewOnly = true;
+        this._rfb.addEventListener("disconnect",
+                                   this._handleDisconnect.bind(this));
+        this._rfb.addEventListener("credentialsrequired",
+                                   this._handleCredentials.bind(this));
+
+        // reset the frame index and timer
+        this._frameIndex = 0;
+        this._startTime = (new Date()).getTime();
+
+        this._realtime = realtime;
+        this._trafficManagement = (trafficManagement === undefined) ? !realtime : trafficManagement;
+
+        this._running = true;
+        this._queueNextPacket();
+    }
+
+    _queueNextPacket() {
+        if (!this._running) { return; }
+
+        let frame = this._frames[this._frameIndex];
+
+        // skip send frames
+        while (this._frameIndex < this._frameLength && frame.fromClient) {
+            this._frameIndex++;
+            frame = this._frames[this._frameIndex];
+        }
+
+        if (this._frameIndex >= this._frameLength) {
+            Log.Debug('Finished, no more frames');
+            this._finish();
+            return;
+        }
+
+        if (this._realtime) {
+            const toffset = (new Date()).getTime() - this._startTime;
+            let delay = frame.timestamp - toffset;
+            if (delay < 1) delay = 1;
+
+            setTimeout(this._doPacket.bind(this), delay);
+        } else {
+            setImmediate(this._doPacket.bind(this));
+        }
+    }
+
+    _doPacket() {
+        // Avoid having excessive queue buildup in non-realtime mode
+        if (this._trafficManagement && this._rfb._flushing) {
+            const orig = this._rfb._display.onflush;
+            this._rfb._display.onflush = () => {
+                this._rfb._display.onflush = orig;
+                this._rfb._onFlush();
+                this._doPacket();
+            };
+            return;
+        }
+
+        const frame = this._frames[this._frameIndex];
+
+        this._ws.onmessage({'data': frame.data});
+        this._frameIndex++;
+
+        this._queueNextPacket();
+    }
+
+    _finish() {
+        if (this._rfb._display.pending()) {
+            this._rfb._display.onflush = () => {
+                if (this._rfb._flushing) {
+                    this._rfb._onFlush();
+                }
+                this._finish();
+            };
+            this._rfb._display.flush();
+        } else {
+            this._running = false;
+            this._ws.onclose({code: 1000, reason: ""});
+            delete this._rfb;
+            this.onfinish((new Date()).getTime() - this._startTime);
+        }
+    }
+
+    _handleDisconnect(evt) {
+        this._running = false;
+        this._disconnected(evt.detail.clean, this._frameIndex);
+    }
+
+    _handleCredentials(evt) {
+        this._rfb.sendCredentials({"username": "Foo",
+                                   "password": "Bar",
+                                   "target": "Baz"});
+    }
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.base64.js
@@ -0,0 +1,33 @@
+const expect = chai.expect;
+
+import Base64 from '../core/base64.js';
+
+describe('Base64 Tools', function () {
+    "use strict";
+
+    const BIN_ARR = new Array(256);
+    for (let i = 0; i < 256; i++) {
+        BIN_ARR[i] = i;
+    }
+
+    const B64_STR = "AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/w==";
+
+
+    describe('encode', function () {
+        it('should encode a binary string into Base64', function () {
+            const encoded = Base64.encode(BIN_ARR);
+            expect(encoded).to.equal(B64_STR);
+        });
+    });
+
+    describe('decode', function () {
+        it('should decode a Base64 string into a normal string', function () {
+            const decoded = Base64.decode(B64_STR);
+            expect(decoded).to.deep.equal(BIN_ARR);
+        });
+
+        it('should throw an error if we have extra characters at the end of the string', function () {
+            expect(() => Base64.decode(B64_STR+'abcdef')).to.throw(Error);
+        });
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.copyrect.js
@@ -0,0 +1,83 @@
+const expect = chai.expect;
+
+import Websock from '../core/websock.js';
+import Display from '../core/display.js';
+
+import CopyRectDecoder from '../core/decoders/copyrect.js';
+
+import FakeWebSocket from './fake.websocket.js';
+
+function testDecodeRect(decoder, x, y, width, height, data, display, depth) {
+    let sock;
+
+    sock = new Websock;
+    sock.open("ws://example.com");
+
+    sock.on('message', () => {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    });
+
+    // Empty messages are filtered at multiple layers, so we need to
+    // do a direct call
+    if (data.length === 0) {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    } else {
+        sock._websocket._receiveData(new Uint8Array(data));
+    }
+
+    display.flip();
+}
+
+describe('CopyRect Decoder', function () {
+    let decoder;
+    let display;
+
+    before(FakeWebSocket.replace);
+    after(FakeWebSocket.restore);
+
+    beforeEach(function () {
+        decoder = new CopyRectDecoder();
+        display = new Display(document.createElement('canvas'));
+        display.resize(4, 4);
+    });
+
+    it('should handle the CopyRect encoding', function () {
+        // seed some initial data to copy
+        display.fillRect(0, 0, 4, 4, [ 0x11, 0x22, 0x33 ]);
+        display.fillRect(0, 0, 2, 2, [ 0x00, 0x00, 0xff ]);
+        display.fillRect(2, 0, 2, 2, [ 0x00, 0xff, 0x00 ]);
+
+        testDecodeRect(decoder, 0, 2, 2, 2,
+                       [0x00, 0x02, 0x00, 0x00],
+                       display, 24);
+        testDecodeRect(decoder, 2, 2, 2, 2,
+                       [0x00, 0x00, 0x00, 0x00],
+                       display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle empty rects', function () {
+        display.fillRect(0, 0, 4, 4, [ 0x00, 0x00, 0xff ]);
+        display.fillRect(2, 0, 2, 2, [ 0x00, 0xff, 0x00 ]);
+        display.fillRect(0, 2, 2, 2, [ 0x00, 0xff, 0x00 ]);
+
+        testDecodeRect(decoder, 1, 2, 0, 0, [0x00, 0x00, 0x00, 0x00], display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.deflator.js
@@ -0,0 +1,82 @@
+/* eslint-disable no-console */
+const expect = chai.expect;
+
+import { inflateInit, inflate } from "../vendor/pako/lib/zlib/inflate.js";
+import ZStream from "../vendor/pako/lib/zlib/zstream.js";
+import Deflator from "../core/deflator.js";
+
+function _inflator(compText, expected) {
+    let strm = new ZStream();
+    let chunkSize = 1024 * 10 * 10;
+    strm.output = new Uint8Array(chunkSize);
+
+    inflateInit(strm, 5);
+
+    if (expected > chunkSize) {
+        chunkSize = expected;
+        strm.output = new Uint8Array(chunkSize);
+    }
+
+    /* eslint-disable camelcase */
+    strm.input = compText;
+    strm.avail_in = strm.input.length;
+    strm.next_in = 0;
+
+    strm.next_out = 0;
+    strm.avail_out = expected.length;
+    /* eslint-enable camelcase */
+
+    let ret = inflate(strm, 0);
+
+    // Check that return code is not an error
+    expect(ret).to.be.greaterThan(-1);
+
+    return new Uint8Array(strm.output.buffer, 0, strm.next_out);
+}
+
+describe('Deflate data', function () {
+
+    it('should be able to deflate messages', function () {
+        let deflator = new Deflator();
+
+        let text = "123asdf";
+        let preText = new Uint8Array(text.length);
+        for (let i = 0; i < preText.length; i++) {
+            preText[i] = text.charCodeAt(i);
+        }
+
+        let compText = deflator.deflate(preText);
+
+        let inflatedText = _inflator(compText, text.length);
+        expect(inflatedText).to.array.equal(preText);
+
+    });
+
+    it('should be able to deflate large messages', function () {
+        let deflator = new Deflator();
+
+        /* Generate a big string with random characters. Used because
+           repetition of letters might be deflated more effectively than
+           random ones. */
+        let text = "";
+        let characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
+        for (let i = 0; i < 300000; i++) {
+            text += characters.charAt(Math.floor(Math.random() * characters.length));
+        }
+
+        let preText = new Uint8Array(text.length);
+        for (let i = 0; i < preText.length; i++) {
+            preText[i] = text.charCodeAt(i);
+        }
+
+        let compText = deflator.deflate(preText);
+
+        //Check that the compressed size is expected size
+        expect(compText.length).to.be.greaterThan((1024 * 10 * 10) * 2);
+
+        let inflatedText = _inflator(compText, text.length);
+
+        expect(inflatedText).to.array.equal(preText);
+
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.display.js
@@ -0,0 +1,399 @@
+const expect = chai.expect;
+
+import Base64 from '../core/base64.js';
+import Display from '../core/display.js';
+
+describe('Display/Canvas Helper', function () {
+    const checkedData = new Uint8ClampedArray([
+        0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+        0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+        0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+        0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+    ]);
+
+    const basicData = new Uint8ClampedArray([0xff, 0x00, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0xff, 0xff, 0xff, 255]);
+
+    function makeImageCanvas(inputData, width, height) {
+        const canvas = document.createElement('canvas');
+        canvas.width = width;
+        canvas.height = height;
+        const ctx = canvas.getContext('2d');
+        const data = new ImageData(inputData, width, height);
+        ctx.putImageData(data, 0, 0);
+        return canvas;
+    }
+
+    function makeImagePng(inputData, width, height) {
+        const canvas = makeImageCanvas(inputData, width, height);
+        const url = canvas.toDataURL();
+        const data = url.split(",")[1];
+        return Base64.decode(data);
+    }
+
+    describe('viewport handling', function () {
+        let display;
+        beforeEach(function () {
+            display = new Display(document.createElement('canvas'));
+            display.clipViewport = true;
+            display.resize(5, 5);
+            display.viewportChangeSize(3, 3);
+            display.viewportChangePos(1, 1);
+        });
+
+        it('should take viewport location into consideration when drawing images', function () {
+            display.resize(4, 4);
+            display.viewportChangeSize(2, 2);
+            display.drawImage(makeImageCanvas(basicData, 4, 1), 1, 1);
+            display.flip();
+
+            const expected = new Uint8Array(16);
+            for (let i = 0; i < 8; i++) { expected[i] = basicData[i]; }
+            for (let i = 8; i < 16; i++) { expected[i] = 0; }
+            expect(display).to.have.displayed(expected);
+        });
+
+        it('should resize the target canvas when resizing the viewport', function () {
+            display.viewportChangeSize(2, 2);
+            expect(display._target.width).to.equal(2);
+            expect(display._target.height).to.equal(2);
+        });
+
+        it('should move the viewport if necessary', function () {
+            display.viewportChangeSize(5, 5);
+            expect(display.absX(0)).to.equal(0);
+            expect(display.absY(0)).to.equal(0);
+            expect(display._target.width).to.equal(5);
+            expect(display._target.height).to.equal(5);
+        });
+
+        it('should limit the viewport to the framebuffer size', function () {
+            display.viewportChangeSize(6, 6);
+            expect(display._target.width).to.equal(5);
+            expect(display._target.height).to.equal(5);
+        });
+
+        it('should redraw when moving the viewport', function () {
+            display.flip = sinon.spy();
+            display.viewportChangePos(-1, 1);
+            expect(display.flip).to.have.been.calledOnce;
+        });
+
+        it('should redraw when resizing the viewport', function () {
+            display.flip = sinon.spy();
+            display.viewportChangeSize(2, 2);
+            expect(display.flip).to.have.been.calledOnce;
+        });
+
+        it('should show the entire framebuffer when disabling the viewport', function () {
+            display.clipViewport = false;
+            expect(display.absX(0)).to.equal(0);
+            expect(display.absY(0)).to.equal(0);
+            expect(display._target.width).to.equal(5);
+            expect(display._target.height).to.equal(5);
+        });
+
+        it('should ignore viewport changes when the viewport is disabled', function () {
+            display.clipViewport = false;
+            display.viewportChangeSize(2, 2);
+            display.viewportChangePos(1, 1);
+            expect(display.absX(0)).to.equal(0);
+            expect(display.absY(0)).to.equal(0);
+            expect(display._target.width).to.equal(5);
+            expect(display._target.height).to.equal(5);
+        });
+
+        it('should show the entire framebuffer just after enabling the viewport', function () {
+            display.clipViewport = false;
+            display.clipViewport = true;
+            expect(display.absX(0)).to.equal(0);
+            expect(display.absY(0)).to.equal(0);
+            expect(display._target.width).to.equal(5);
+            expect(display._target.height).to.equal(5);
+        });
+    });
+
+    describe('resizing', function () {
+        let display;
+        beforeEach(function () {
+            display = new Display(document.createElement('canvas'));
+            display.clipViewport = false;
+            display.resize(4, 4);
+        });
+
+        it('should change the size of the logical canvas', function () {
+            display.resize(5, 7);
+            expect(display._fbWidth).to.equal(5);
+            expect(display._fbHeight).to.equal(7);
+        });
+
+        it('should keep the framebuffer data', function () {
+            display.fillRect(0, 0, 4, 4, [0xff, 0, 0]);
+            display.resize(2, 2);
+            display.flip();
+            const expected = [];
+            for (let i = 0; i < 4 * 2*2; i += 4) {
+                expected[i] = 0xff;
+                expected[i+1] = expected[i+2] = 0;
+                expected[i+3] = 0xff;
+            }
+            expect(display).to.have.displayed(new Uint8Array(expected));
+        });
+
+        describe('viewport', function () {
+            beforeEach(function () {
+                display.clipViewport = true;
+                display.viewportChangeSize(3, 3);
+                display.viewportChangePos(1, 1);
+            });
+
+            it('should keep the viewport position and size if possible', function () {
+                display.resize(6, 6);
+                expect(display.absX(0)).to.equal(1);
+                expect(display.absY(0)).to.equal(1);
+                expect(display._target.width).to.equal(3);
+                expect(display._target.height).to.equal(3);
+            });
+
+            it('should move the viewport if necessary', function () {
+                display.resize(3, 3);
+                expect(display.absX(0)).to.equal(0);
+                expect(display.absY(0)).to.equal(0);
+                expect(display._target.width).to.equal(3);
+                expect(display._target.height).to.equal(3);
+            });
+
+            it('should shrink the viewport if necessary', function () {
+                display.resize(2, 2);
+                expect(display.absX(0)).to.equal(0);
+                expect(display.absY(0)).to.equal(0);
+                expect(display._target.width).to.equal(2);
+                expect(display._target.height).to.equal(2);
+            });
+        });
+    });
+
+    describe('rescaling', function () {
+        let display;
+        let canvas;
+
+        beforeEach(function () {
+            canvas = document.createElement('canvas');
+            display = new Display(canvas);
+            display.clipViewport = true;
+            display.resize(4, 4);
+            display.viewportChangeSize(3, 3);
+            display.viewportChangePos(1, 1);
+            document.body.appendChild(canvas);
+        });
+
+        afterEach(function () {
+            document.body.removeChild(canvas);
+        });
+
+        it('should not change the bitmap size of the canvas', function () {
+            display.scale = 2.0;
+            expect(canvas.width).to.equal(3);
+            expect(canvas.height).to.equal(3);
+        });
+
+        it('should change the effective rendered size of the canvas', function () {
+            display.scale = 2.0;
+            expect(canvas.clientWidth).to.equal(6);
+            expect(canvas.clientHeight).to.equal(6);
+        });
+
+        it('should not change when resizing', function () {
+            display.scale = 2.0;
+            display.resize(5, 5);
+            expect(display.scale).to.equal(2.0);
+            expect(canvas.width).to.equal(3);
+            expect(canvas.height).to.equal(3);
+            expect(canvas.clientWidth).to.equal(6);
+            expect(canvas.clientHeight).to.equal(6);
+        });
+    });
+
+    describe('autoscaling', function () {
+        let display;
+        let canvas;
+
+        beforeEach(function () {
+            canvas = document.createElement('canvas');
+            display = new Display(canvas);
+            display.clipViewport = true;
+            display.resize(4, 3);
+            display.viewportChangeSize(4, 3);
+            document.body.appendChild(canvas);
+        });
+
+        afterEach(function () {
+            document.body.removeChild(canvas);
+        });
+
+        it('should preserve aspect ratio while autoscaling', function () {
+            display.autoscale(16, 9);
+            expect(canvas.clientWidth / canvas.clientHeight).to.equal(4 / 3);
+        });
+
+        it('should use width to determine scale when the current aspect ratio is wider than the target', function () {
+            display.autoscale(9, 16);
+            expect(display.absX(9)).to.equal(4);
+            expect(display.absY(18)).to.equal(8);
+            expect(canvas.clientWidth).to.equal(9);
+            expect(canvas.clientHeight).to.equal(7); // round 9 / (4 / 3)
+        });
+
+        it('should use height to determine scale when the current aspect ratio is taller than the target', function () {
+            display.autoscale(16, 9);
+            expect(display.absX(9)).to.equal(3);
+            expect(display.absY(18)).to.equal(6);
+            expect(canvas.clientWidth).to.equal(12);  // 16 * (4 / 3)
+            expect(canvas.clientHeight).to.equal(9);
+
+        });
+
+        it('should not change the bitmap size of the canvas', function () {
+            display.autoscale(16, 9);
+            expect(canvas.width).to.equal(4);
+            expect(canvas.height).to.equal(3);
+        });
+    });
+
+    describe('drawing', function () {
+
+        // TODO(directxman12): improve the tests for each of the drawing functions to cover more than just the
+        //                     basic cases
+        let display;
+        beforeEach(function () {
+            display = new Display(document.createElement('canvas'));
+            display.resize(4, 4);
+        });
+
+        it('should not draw directly on the target canvas', function () {
+            display.fillRect(0, 0, 4, 4, [0xff, 0, 0]);
+            display.flip();
+            display.fillRect(0, 0, 4, 4, [0, 0xff, 0]);
+            const expected = [];
+            for (let i = 0; i < 4 * display._fbWidth * display._fbHeight; i += 4) {
+                expected[i] = 0xff;
+                expected[i+1] = expected[i+2] = 0;
+                expected[i+3] = 0xff;
+            }
+            expect(display).to.have.displayed(new Uint8Array(expected));
+        });
+
+        it('should support filling a rectangle with particular color via #fillRect', function () {
+            display.fillRect(0, 0, 4, 4, [0, 0xff, 0]);
+            display.fillRect(0, 0, 2, 2, [0, 0, 0xff]);
+            display.fillRect(2, 2, 2, 2, [0, 0, 0xff]);
+            display.flip();
+            expect(display).to.have.displayed(checkedData);
+        });
+
+        it('should support copying an portion of the canvas via #copyImage', function () {
+            display.fillRect(0, 0, 4, 4, [0, 0xff, 0]);
+            display.fillRect(0, 0, 2, 2, [0, 0, 0xff]);
+            display.copyImage(0, 0, 2, 2, 2, 2);
+            display.flip();
+            expect(display).to.have.displayed(checkedData);
+        });
+
+        it('should support drawing images via #imageRect', function (done) {
+            display.imageRect(0, 0, 4, 4, "image/png", makeImagePng(checkedData, 4, 4));
+            display.flip();
+            display.onflush = () => {
+                expect(display).to.have.displayed(checkedData);
+                done();
+            };
+            display.flush();
+        });
+
+        it('should support blit images with true color via #blitImage', function () {
+            display.blitImage(0, 0, 4, 4, checkedData, 0);
+            display.flip();
+            expect(display).to.have.displayed(checkedData);
+        });
+
+        it('should support drawing an image object via #drawImage', function () {
+            const img = makeImageCanvas(checkedData, 4, 4);
+            display.drawImage(img, 0, 0);
+            display.flip();
+            expect(display).to.have.displayed(checkedData);
+        });
+    });
+
+    describe('the render queue processor', function () {
+        let display;
+        beforeEach(function () {
+            display = new Display(document.createElement('canvas'));
+            display.resize(4, 4);
+            sinon.spy(display, '_scanRenderQ');
+        });
+
+        it('should try to process an item when it is pushed on, if nothing else is on the queue', function () {
+            display._renderQPush({ type: 'noop' });  // does nothing
+            expect(display._scanRenderQ).to.have.been.calledOnce;
+        });
+
+        it('should not try to process an item when it is pushed on if we are waiting for other items', function () {
+            display._renderQ.length = 2;
+            display._renderQPush({ type: 'noop' });
+            expect(display._scanRenderQ).to.not.have.been.called;
+        });
+
+        it('should wait until an image is loaded to attempt to draw it and the rest of the queue', function () {
+            const img = { complete: false, width: 4, height: 4, addEventListener: sinon.spy() };
+            display._renderQ = [{ type: 'img', x: 3, y: 4, width: 4, height: 4, img: img },
+                                { type: 'fill', x: 1, y: 2, width: 3, height: 4, color: 5 }];
+            display.drawImage = sinon.spy();
+            display.fillRect = sinon.spy();
+
+            display._scanRenderQ();
+            expect(display.drawImage).to.not.have.been.called;
+            expect(display.fillRect).to.not.have.been.called;
+            expect(img.addEventListener).to.have.been.calledOnce;
+
+            display._renderQ[0].img.complete = true;
+            display._scanRenderQ();
+            expect(display.drawImage).to.have.been.calledOnce;
+            expect(display.fillRect).to.have.been.calledOnce;
+            expect(img.addEventListener).to.have.been.calledOnce;
+        });
+
+        it('should call callback when queue is flushed', function () {
+            display.onflush = sinon.spy();
+            display.fillRect(0, 0, 4, 4, [0, 0xff, 0]);
+            expect(display.onflush).to.not.have.been.called;
+            display.flush();
+            expect(display.onflush).to.have.been.calledOnce;
+        });
+
+        it('should draw a blit image on type "blit"', function () {
+            display.blitImage = sinon.spy();
+            display._renderQPush({ type: 'blit', x: 3, y: 4, width: 5, height: 6, data: [7, 8, 9] });
+            expect(display.blitImage).to.have.been.calledOnce;
+            expect(display.blitImage).to.have.been.calledWith(3, 4, 5, 6, [7, 8, 9], 0);
+        });
+
+        it('should copy a region on type "copy"', function () {
+            display.copyImage = sinon.spy();
+            display._renderQPush({ type: 'copy', x: 3, y: 4, width: 5, height: 6, oldX: 7, oldY: 8 });
+            expect(display.copyImage).to.have.been.calledOnce;
+            expect(display.copyImage).to.have.been.calledWith(7, 8, 3, 4, 5, 6);
+        });
+
+        it('should fill a rect with a given color on type "fill"', function () {
+            display.fillRect = sinon.spy();
+            display._renderQPush({ type: 'fill', x: 3, y: 4, width: 5, height: 6, color: [7, 8, 9]});
+            expect(display.fillRect).to.have.been.calledOnce;
+            expect(display.fillRect).to.have.been.calledWith(3, 4, 5, 6, [7, 8, 9]);
+        });
+
+        it('should draw an image from an image object on type "img" (if complete)', function () {
+            display.drawImage = sinon.spy();
+            display._renderQPush({ type: 'img', x: 3, y: 4, img: { complete: true } });
+            expect(display.drawImage).to.have.been.calledOnce;
+            expect(display.drawImage).to.have.been.calledWith({ complete: true }, 3, 4);
+        });
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.gesturehandler.js
@@ -0,0 +1,1026 @@
+const expect = chai.expect;
+
+import EventTargetMixin from '../core/util/eventtarget.js';
+
+import GestureHandler from '../core/input/gesturehandler.js';
+
+class DummyTarget extends EventTargetMixin {
+}
+
+describe('Gesture handler', function () {
+    let target, handler;
+    let gestures;
+    let clock;
+    let touches;
+
+    before(function () {
+        clock = sinon.useFakeTimers();
+    });
+
+    after(function () {
+        clock.restore();
+    });
+
+    beforeEach(function () {
+        target = new DummyTarget();
+        gestures = sinon.spy();
+        target.addEventListener('gesturestart', gestures);
+        target.addEventListener('gesturemove', gestures);
+        target.addEventListener('gestureend', gestures);
+        touches = [];
+        handler = new GestureHandler();
+        handler.attach(target);
+    });
+
+    afterEach(function () {
+        if (handler) {
+            handler.detach();
+        }
+        target = null;
+        gestures = null;
+    });
+
+    function touchStart(id, x, y) {
+        let touch = { identifier: id,
+                      clientX: x, clientY: y };
+        touches.push(touch);
+        let ev = { type: 'touchstart',
+                   touches: touches,
+                   targetTouches: touches,
+                   changedTouches: [ touch ],
+                   stopPropagation: sinon.spy(),
+                   preventDefault: sinon.spy() };
+        target.dispatchEvent(ev);
+    }
+
+    function touchMove(id, x, y) {
+        let touch = touches.find(t => t.identifier === id);
+        touch.clientX = x;
+        touch.clientY = y;
+        let ev = { type: 'touchmove',
+                   touches: touches,
+                   targetTouches: touches,
+                   changedTouches: [ touch ],
+                   stopPropagation: sinon.spy(),
+                   preventDefault: sinon.spy() };
+        target.dispatchEvent(ev);
+    }
+
+    function touchEnd(id) {
+        let idx = touches.findIndex(t => t.identifier === id);
+        let touch = touches.splice(idx, 1)[0];
+        let ev = { type: 'touchend',
+                   touches: touches,
+                   targetTouches: touches,
+                   changedTouches: [ touch ],
+                   stopPropagation: sinon.spy(),
+                   preventDefault: sinon.spy() };
+        target.dispatchEvent(ev);
+    }
+
+    describe('Single finger tap', function () {
+        it('should handle single finger tap', function () {
+            touchStart(1, 20.0, 30.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'onetap',
+                                        clientX: 20.0,
+                                        clientY: 30.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'onetap',
+                                        clientX: 20.0,
+                                        clientY: 30.0 } }));
+        });
+    });
+
+    describe('Two finger tap', function () {
+        it('should handle two finger tap', function () {
+            touchStart(1, 20.0, 30.0);
+            touchStart(2, 30.0, 50.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchEnd(1);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchEnd(2);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'twotap',
+                                        clientX: 25.0,
+                                        clientY: 40.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'twotap',
+                                        clientX: 25.0,
+                                        clientY: 40.0 } }));
+        });
+
+        it('should ignore slow starting two finger tap', function () {
+            touchStart(1, 20.0, 30.0);
+
+            clock.tick(500);
+
+            touchStart(2, 30.0, 50.0);
+            touchEnd(1);
+            touchEnd(2);
+
+            expect(gestures).to.not.have.been.called;
+        });
+
+        it('should ignore slow ending two finger tap', function () {
+            touchStart(1, 20.0, 30.0);
+            touchStart(2, 30.0, 50.0);
+            touchEnd(1);
+
+            clock.tick(500);
+
+            touchEnd(2);
+
+            expect(gestures).to.not.have.been.called;
+        });
+
+        it('should ignore slow two finger tap', function () {
+            touchStart(1, 20.0, 30.0);
+            touchStart(2, 30.0, 50.0);
+
+            clock.tick(1500);
+
+            touchEnd(1);
+            touchEnd(2);
+
+            expect(gestures).to.not.have.been.called;
+        });
+    });
+
+    describe('Three finger tap', function () {
+        it('should handle three finger tap', function () {
+            touchStart(1, 20.0, 30.0);
+            touchStart(2, 30.0, 50.0);
+            touchStart(3, 40.0, 40.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchEnd(1);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchEnd(2);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchEnd(3);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'threetap',
+                                        clientX: 30.0,
+                                        clientY: 40.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'threetap',
+                                        clientX: 30.0,
+                                        clientY: 40.0 } }));
+        });
+
+        it('should ignore slow starting three finger tap', function () {
+            touchStart(1, 20.0, 30.0);
+            touchStart(2, 30.0, 50.0);
+
+            clock.tick(500);
+
+            touchStart(3, 40.0, 40.0);
+            touchEnd(1);
+            touchEnd(2);
+            touchEnd(3);
+
+            expect(gestures).to.not.have.been.called;
+        });
+
+        it('should ignore slow ending three finger tap', function () {
+            touchStart(1, 20.0, 30.0);
+            touchStart(2, 30.0, 50.0);
+            touchStart(3, 40.0, 40.0);
+            touchEnd(1);
+            touchEnd(2);
+
+            clock.tick(500);
+
+            touchEnd(3);
+
+            expect(gestures).to.not.have.been.called;
+        });
+
+        it('should ignore three finger drag', function () {
+            touchStart(1, 20.0, 30.0);
+            touchStart(2, 30.0, 50.0);
+            touchStart(3, 40.0, 40.0);
+
+            touchMove(1, 120.0, 130.0);
+            touchMove(2, 130.0, 150.0);
+            touchMove(3, 140.0, 140.0);
+
+            touchEnd(1);
+            touchEnd(2);
+            touchEnd(3);
+
+            expect(gestures).to.not.have.been.called;
+        });
+
+        it('should ignore slow three finger tap', function () {
+            touchStart(1, 20.0, 30.0);
+            touchStart(2, 30.0, 50.0);
+            touchStart(3, 40.0, 40.0);
+
+            clock.tick(1500);
+
+            touchEnd(1);
+            touchEnd(2);
+            touchEnd(3);
+
+            expect(gestures).to.not.have.been.called;
+        });
+    });
+
+    describe('Single finger drag', function () {
+        it('should handle horizontal single finger drag', function () {
+            touchStart(1, 20.0, 30.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(1, 40.0, 30.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(1, 80.0, 30.0);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'drag',
+                                        clientX: 20.0,
+                                        clientY: 30.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'drag',
+                                        clientX: 80.0,
+                                        clientY: 30.0 } }));
+
+            gestures.resetHistory();
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'drag',
+                                        clientX: 80.0,
+                                        clientY: 30.0 } }));
+        });
+
+        it('should handle vertical single finger drag', function () {
+            touchStart(1, 20.0, 30.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(1, 20.0, 50.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(1, 20.0, 90.0);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'drag',
+                                        clientX: 20.0,
+                                        clientY: 30.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'drag',
+                                        clientX: 20.0,
+                                        clientY: 90.0 } }));
+
+            gestures.resetHistory();
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'drag',
+                                        clientX: 20.0,
+                                        clientY: 90.0 } }));
+        });
+
+        it('should handle diagonal single finger drag', function () {
+            touchStart(1, 120.0, 130.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(1, 90.0, 100.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(1, 60.0, 70.0);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'drag',
+                                        clientX: 120.0,
+                                        clientY: 130.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'drag',
+                                        clientX: 60.0,
+                                        clientY: 70.0 } }));
+
+            gestures.resetHistory();
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'drag',
+                                        clientX: 60.0,
+                                        clientY: 70.0 } }));
+        });
+    });
+
+    describe('Long press', function () {
+        it('should handle long press', function () {
+            touchStart(1, 20.0, 30.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            clock.tick(1500);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'longpress',
+                                        clientX: 20.0,
+                                        clientY: 30.0 } }));
+
+            gestures.resetHistory();
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'longpress',
+                                        clientX: 20.0,
+                                        clientY: 30.0 } }));
+        });
+
+        it('should handle long press drag', function () {
+            touchStart(1, 20.0, 30.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            clock.tick(1500);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'longpress',
+                                        clientX: 20.0,
+                                        clientY: 30.0 } }));
+
+            gestures.resetHistory();
+
+            touchMove(1, 120.0, 50.0);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'longpress',
+                                        clientX: 120.0,
+                                        clientY: 50.0 } }));
+
+            gestures.resetHistory();
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'longpress',
+                                        clientX: 120.0,
+                                        clientY: 50.0 } }));
+        });
+    });
+
+    describe('Two finger drag', function () {
+        it('should handle fast and distinct horizontal two finger drag', function () {
+            touchStart(1, 20.0, 30.0);
+            touchStart(2, 30.0, 30.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(1, 40.0, 30.0);
+            touchMove(2, 50.0, 30.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(2, 90.0, 30.0);
+            touchMove(1, 80.0, 30.0);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'twodrag',
+                                        clientX: 25.0,
+                                        clientY: 30.0,
+                                        magnitudeX: 0.0,
+                                        magnitudeY: 0.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'twodrag',
+                                        clientX: 25.0,
+                                        clientY: 30.0,
+                                        magnitudeX: 60.0,
+                                        magnitudeY: 0.0 } }));
+
+            gestures.resetHistory();
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'twodrag',
+                                        clientX: 25.0,
+                                        clientY: 30.0,
+                                        magnitudeX: 60.0,
+                                        magnitudeY: 0.0 } }));
+        });
+
+        it('should handle fast and distinct vertical two finger drag', function () {
+            touchStart(1, 20.0, 30.0);
+            touchStart(2, 30.0, 30.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(1, 20.0, 100.0);
+            touchMove(2, 30.0, 40.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(2, 30.0, 90.0);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'twodrag',
+                                        clientX: 25.0,
+                                        clientY: 30.0,
+                                        magnitudeX: 0.0,
+                                        magnitudeY: 0.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'twodrag',
+                                        clientX: 25.0,
+                                        clientY: 30.0,
+                                        magnitudeX: 0.0,
+                                        magnitudeY: 65.0 } }));
+
+            gestures.resetHistory();
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'twodrag',
+                                        clientX: 25.0,
+                                        clientY: 30.0,
+                                        magnitudeX: 0.0,
+                                        magnitudeY: 65.0 } }));
+        });
+
+        it('should handle fast and distinct diagonal two finger drag', function () {
+            touchStart(1, 120.0, 130.0);
+            touchStart(2, 130.0, 130.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(1, 80.0, 90.0);
+            touchMove(2, 100.0, 130.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(2, 60.0, 70.0);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'twodrag',
+                                        clientX: 125.0,
+                                        clientY: 130.0,
+                                        magnitudeX: 0.0,
+                                        magnitudeY: 0.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'twodrag',
+                                        clientX: 125.0,
+                                        clientY: 130.0,
+                                        magnitudeX: -55.0,
+                                        magnitudeY: -50.0 } }));
+
+            gestures.resetHistory();
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'twodrag',
+                                        clientX: 125.0,
+                                        clientY: 130.0,
+                                        magnitudeX: -55.0,
+                                        magnitudeY: -50.0 } }));
+        });
+
+        it('should ignore fast almost two finger dragging', function () {
+            touchStart(1, 20.0, 30.0);
+            touchStart(2, 30.0, 30.0);
+            touchMove(1, 80.0, 30.0);
+            touchMove(2, 70.0, 30.0);
+            touchEnd(1);
+            touchEnd(2);
+
+            expect(gestures).to.not.have.been.called;
+
+            clock.tick(1500);
+
+            expect(gestures).to.not.have.been.called;
+        });
+
+        it('should handle slow horizontal two finger drag', function () {
+            touchStart(1, 50.0, 40.0);
+            touchStart(2, 60.0, 40.0);
+            touchMove(1, 80.0, 40.0);
+            touchMove(2, 110.0, 40.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            clock.tick(60);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'twodrag',
+                                        clientX: 55.0,
+                                        clientY: 40.0,
+                                        magnitudeX: 0.0,
+                                        magnitudeY: 0.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'twodrag',
+                                        clientX: 55.0,
+                                        clientY: 40.0,
+                                        magnitudeX: 40.0,
+                                        magnitudeY: 0.0 } }));
+        });
+
+        it('should handle slow vertical two finger drag', function () {
+            touchStart(1, 40.0, 40.0);
+            touchStart(2, 40.0, 60.0);
+            touchMove(2, 40.0, 80.0);
+            touchMove(1, 40.0, 100.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            clock.tick(60);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'twodrag',
+                                        clientX: 40.0,
+                                        clientY: 50.0,
+                                        magnitudeX: 0.0,
+                                        magnitudeY: 0.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'twodrag',
+                                        clientX: 40.0,
+                                        clientY: 50.0,
+                                        magnitudeX: 0.0,
+                                        magnitudeY: 40.0 } }));
+        });
+
+        it('should handle slow diagonal two finger drag', function () {
+            touchStart(1, 50.0, 40.0);
+            touchStart(2, 40.0, 60.0);
+            touchMove(1, 70.0, 60.0);
+            touchMove(2, 90.0, 110.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            clock.tick(60);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'twodrag',
+                                        clientX: 45.0,
+                                        clientY: 50.0,
+                                        magnitudeX: 0.0,
+                                        magnitudeY: 0.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'twodrag',
+                                        clientX: 45.0,
+                                        clientY: 50.0,
+                                        magnitudeX: 35.0,
+                                        magnitudeY: 35.0 } }));
+        });
+
+        it('should ignore too slow two finger drag', function () {
+            touchStart(1, 20.0, 30.0);
+
+            clock.tick(500);
+
+            touchStart(2, 30.0, 30.0);
+            touchMove(1, 40.0, 30.0);
+            touchMove(2, 50.0, 30.0);
+            touchMove(1, 80.0, 30.0);
+
+            expect(gestures).to.not.have.been.called;
+        });
+    });
+
+    describe('Pinch', function () {
+        it('should handle pinching distinctly and fast inwards', function () {
+            touchStart(1, 0.0, 0.0);
+            touchStart(2, 130.0, 130.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(1, 50.0, 40.0);
+            touchMove(2, 100.0, 130.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(2, 60.0, 70.0);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'pinch',
+                                        clientX: 65.0,
+                                        clientY: 65.0,
+                                        magnitudeX: 130.0,
+                                        magnitudeY: 130.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'pinch',
+                                        clientX: 65.0,
+                                        clientY: 65.0,
+                                        magnitudeX: 10.0,
+                                        magnitudeY: 30.0 } }));
+
+            gestures.resetHistory();
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'pinch',
+                                        clientX: 65.0,
+                                        clientY: 65.0,
+                                        magnitudeX: 10.0,
+                                        magnitudeY: 30.0 } }));
+        });
+
+        it('should handle pinching fast and distinctly outwards', function () {
+            touchStart(1, 100.0, 100.0);
+            touchStart(2, 110.0, 100.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(1, 130.0, 70.0);
+            touchMove(2, 0.0, 200.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(1, 180.0, 20.0);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'pinch',
+                                        clientX: 105.0,
+                                        clientY: 100.0,
+                                        magnitudeX: 10.0,
+                                        magnitudeY: 0.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'pinch',
+                                        clientX: 105.0,
+                                        clientY: 100.0,
+                                        magnitudeX: 180.0,
+                                        magnitudeY: 180.0 } }));
+
+            gestures.resetHistory();
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'pinch',
+                                        clientX: 105.0,
+                                        clientY: 100.0,
+                                        magnitudeX: 180.0,
+                                        magnitudeY: 180.0 } }));
+        });
+
+        it('should ignore fast almost pinching', function () {
+            touchStart(1, 20.0, 30.0);
+            touchStart(2, 130.0, 130.0);
+            touchMove(1, 80.0, 70.0);
+            touchEnd(1);
+            touchEnd(2);
+
+            expect(gestures).to.not.have.been.called;
+
+            clock.tick(1500);
+
+            expect(gestures).to.not.have.been.called;
+        });
+
+        it('should handle pinching inwards slowly', function () {
+            touchStart(1, 0.0, 0.0);
+            touchStart(2, 130.0, 130.0);
+            touchMove(1, 50.0, 40.0);
+            touchMove(2, 100.0, 130.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            clock.tick(60);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'pinch',
+                                        clientX: 65.0,
+                                        clientY: 65.0,
+                                        magnitudeX: 130.0,
+                                        magnitudeY: 130.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'pinch',
+                                        clientX: 65.0,
+                                        clientY: 65.0,
+                                        magnitudeX: 50.0,
+                                        magnitudeY: 90.0 } }));
+        });
+
+        it('should handle pinching outwards slowly', function () {
+            touchStart(1, 100.0, 130.0);
+            touchStart(2, 110.0, 130.0);
+            touchMove(2, 200.0, 130.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            clock.tick(60);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'pinch',
+                                        clientX: 105.0,
+                                        clientY: 130.0,
+                                        magnitudeX: 10.0,
+                                        magnitudeY: 0.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'pinch',
+                                        clientX: 105.0,
+                                        clientY: 130.0,
+                                        magnitudeX: 100.0,
+                                        magnitudeY: 0.0 } }));
+        });
+
+        it('should ignore pinching too slowly', function () {
+            touchStart(1, 0.0, 0.0);
+
+            clock.tick(500);
+
+            touchStart(2, 130.0, 130.0);
+            touchMove(2, 100.0, 130.0);
+            touchMove(1, 50.0, 40.0);
+
+            expect(gestures).to.not.have.been.called;
+        });
+    });
+
+    describe('Ignoring', function () {
+        it('should ignore extra touches during gesture', function () {
+            touchStart(1, 20.0, 30.0);
+            touchMove(1, 40.0, 30.0);
+            touchMove(1, 80.0, 30.0);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'drag' } }));
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'drag' } }));
+
+            gestures.resetHistory();
+
+            touchStart(2, 10.0, 10.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(1, 100.0, 50.0);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'drag',
+                                        clientX: 100.0,
+                                        clientY: 50.0 } }));
+
+            gestures.resetHistory();
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'drag',
+                                        clientX: 100.0,
+                                        clientY: 50.0 } }));
+        });
+
+        it('should ignore extra touches when waiting for gesture to end', function () {
+            touchStart(1, 20.0, 30.0);
+            touchStart(2, 30.0, 30.0);
+            touchMove(1, 40.0, 30.0);
+            touchMove(2, 90.0, 30.0);
+            touchMove(1, 80.0, 30.0);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'twodrag' } }));
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'twodrag' } }));
+
+            gestures.resetHistory();
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'twodrag' } }));
+
+            gestures.resetHistory();
+
+            touchStart(3, 10.0, 10.0);
+            touchEnd(3);
+
+            expect(gestures).to.not.have.been.called;
+        });
+
+        it('should ignore extra touches after gesture', function () {
+            touchStart(1, 20.0, 30.0);
+            touchMove(1, 40.0, 30.0);
+            touchMove(1, 80.0, 30.0);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'drag' } }));
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'drag' } }));
+
+            gestures.resetHistory();
+
+            touchStart(2, 10.0, 10.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchMove(1, 100.0, 50.0);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gesturemove',
+                              detail: { type: 'drag' } }));
+
+            gestures.resetHistory();
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledOnceWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'drag' } }));
+
+            gestures.resetHistory();
+
+            touchEnd(2);
+
+            expect(gestures).to.not.have.been.called;
+
+            // Check that everything is reseted after trailing ignores are released
+
+            touchStart(3, 20.0, 30.0);
+            touchEnd(3);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'onetap' } }));
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'onetap' } }));
+        });
+
+        it('should properly reset after a gesture', function () {
+            touchStart(1, 20.0, 30.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchEnd(1);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'onetap',
+                                        clientX: 20.0,
+                                        clientY: 30.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'onetap',
+                                        clientX: 20.0,
+                                        clientY: 30.0 } }));
+
+            gestures.resetHistory();
+
+            touchStart(2, 70.0, 80.0);
+
+            expect(gestures).to.not.have.been.called;
+
+            touchEnd(2);
+
+            expect(gestures).to.have.been.calledTwice;
+
+            expect(gestures.firstCall).to.have.been.calledWith(
+                sinon.match({ type: 'gesturestart',
+                              detail: { type: 'onetap',
+                                        clientX: 70.0,
+                                        clientY: 80.0 } }));
+
+            expect(gestures.secondCall).to.have.been.calledWith(
+                sinon.match({ type: 'gestureend',
+                              detail: { type: 'onetap',
+                                        clientX: 70.0,
+                                        clientY: 80.0 } }));
+        });
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.helper.js
@@ -0,0 +1,223 @@
+﻿const expect = chai.expect;
+
+import keysyms from '../core/input/keysymdef.js';
+import * as KeyboardUtil from "../core/input/util.js";
+
+describe('Helpers', function () {
+    "use strict";
+
+    describe('keysyms.lookup', function () {
+        it('should map ASCII characters to keysyms', function () {
+            expect(keysyms.lookup('a'.charCodeAt())).to.be.equal(0x61);
+            expect(keysyms.lookup('A'.charCodeAt())).to.be.equal(0x41);
+        });
+        it('should map Latin-1 characters to keysyms', function () {
+            expect(keysyms.lookup('ø'.charCodeAt())).to.be.equal(0xf8);
+
+            expect(keysyms.lookup('é'.charCodeAt())).to.be.equal(0xe9);
+        });
+        it('should map characters that are in Windows-1252 but not in Latin-1 to keysyms', function () {
+            expect(keysyms.lookup('Š'.charCodeAt())).to.be.equal(0x01a9);
+        });
+        it('should map characters which aren\'t in Latin1 *or* Windows-1252 to keysyms', function () {
+            expect(keysyms.lookup('ũ'.charCodeAt())).to.be.equal(0x03fd);
+        });
+        it('should map unknown codepoints to the Unicode range', function () {
+            expect(keysyms.lookup('\n'.charCodeAt())).to.be.equal(0x100000a);
+            expect(keysyms.lookup('\u262D'.charCodeAt())).to.be.equal(0x100262d);
+        });
+        // This requires very recent versions of most browsers... skipping for now
+        it.skip('should map UCS-4 codepoints to the Unicode range', function () {
+            //expect(keysyms.lookup('\u{1F686}'.codePointAt())).to.be.equal(0x101f686);
+        });
+    });
+
+    describe('getKeycode', function () {
+        it('should pass through proper code', function () {
+            expect(KeyboardUtil.getKeycode({code: 'Semicolon'})).to.be.equal('Semicolon');
+        });
+        it('should map legacy values', function () {
+            expect(KeyboardUtil.getKeycode({code: ''})).to.be.equal('Unidentified');
+            expect(KeyboardUtil.getKeycode({code: 'OSLeft'})).to.be.equal('MetaLeft');
+        });
+        it('should map keyCode to code when possible', function () {
+            expect(KeyboardUtil.getKeycode({keyCode: 0x14})).to.be.equal('CapsLock');
+            expect(KeyboardUtil.getKeycode({keyCode: 0x5b})).to.be.equal('MetaLeft');
+            expect(KeyboardUtil.getKeycode({keyCode: 0x35})).to.be.equal('Digit5');
+            expect(KeyboardUtil.getKeycode({keyCode: 0x65})).to.be.equal('Numpad5');
+        });
+        it('should map keyCode left/right side', function () {
+            expect(KeyboardUtil.getKeycode({keyCode: 0x10, location: 1})).to.be.equal('ShiftLeft');
+            expect(KeyboardUtil.getKeycode({keyCode: 0x10, location: 2})).to.be.equal('ShiftRight');
+            expect(KeyboardUtil.getKeycode({keyCode: 0x11, location: 1})).to.be.equal('ControlLeft');
+            expect(KeyboardUtil.getKeycode({keyCode: 0x11, location: 2})).to.be.equal('ControlRight');
+        });
+        it('should map keyCode on numpad', function () {
+            expect(KeyboardUtil.getKeycode({keyCode: 0x0d, location: 0})).to.be.equal('Enter');
+            expect(KeyboardUtil.getKeycode({keyCode: 0x0d, location: 3})).to.be.equal('NumpadEnter');
+            expect(KeyboardUtil.getKeycode({keyCode: 0x23, location: 0})).to.be.equal('End');
+            expect(KeyboardUtil.getKeycode({keyCode: 0x23, location: 3})).to.be.equal('Numpad1');
+        });
+        it('should return Unidentified when it cannot map the keyCode', function () {
+            expect(KeyboardUtil.getKeycode({keycode: 0x42})).to.be.equal('Unidentified');
+        });
+
+        describe('Fix Meta on macOS', function () {
+            let origNavigator;
+            beforeEach(function () {
+                // window.navigator is a protected read-only property in many
+                // environments, so we need to redefine it whilst running these
+                // tests.
+                origNavigator = Object.getOwnPropertyDescriptor(window, "navigator");
+
+                Object.defineProperty(window, "navigator", {value: {}});
+                if (window.navigator.platform !== undefined) {
+                    // Object.defineProperty() doesn't work properly in old
+                    // versions of Chrome
+                    this.skip();
+                }
+
+                window.navigator.platform = "Mac x86_64";
+            });
+            afterEach(function () {
+                if (origNavigator !== undefined) {
+                    Object.defineProperty(window, "navigator", origNavigator);
+                }
+            });
+
+            it('should respect ContextMenu on modern browser', function () {
+                expect(KeyboardUtil.getKeycode({code: 'ContextMenu', keyCode: 0x5d})).to.be.equal('ContextMenu');
+            });
+            it('should translate legacy ContextMenu to MetaRight', function () {
+                expect(KeyboardUtil.getKeycode({keyCode: 0x5d})).to.be.equal('MetaRight');
+            });
+        });
+    });
+
+    describe('getKey', function () {
+        it('should prefer key', function () {
+            expect(KeyboardUtil.getKey({key: 'a', charCode: 'Š'.charCodeAt(), keyCode: 0x42, which: 0x43})).to.be.equal('a');
+        });
+        it('should map legacy values', function () {
+            expect(KeyboardUtil.getKey({key: 'OS'})).to.be.equal('Meta');
+            expect(KeyboardUtil.getKey({key: 'UIKeyInputLeftArrow'})).to.be.equal('ArrowLeft');
+        });
+        it('should handle broken Delete', function () {
+            expect(KeyboardUtil.getKey({key: '\x00', code: 'NumpadDecimal'})).to.be.equal('Delete');
+        });
+        it('should use code if no key', function () {
+            expect(KeyboardUtil.getKey({code: 'NumpadBackspace'})).to.be.equal('Backspace');
+        });
+        it('should not use code fallback for character keys', function () {
+            expect(KeyboardUtil.getKey({code: 'KeyA'})).to.be.equal('Unidentified');
+            expect(KeyboardUtil.getKey({code: 'Digit1'})).to.be.equal('Unidentified');
+            expect(KeyboardUtil.getKey({code: 'Period'})).to.be.equal('Unidentified');
+            expect(KeyboardUtil.getKey({code: 'Numpad1'})).to.be.equal('Unidentified');
+        });
+        it('should use charCode if no key', function () {
+            expect(KeyboardUtil.getKey({charCode: 'Š'.charCodeAt(), keyCode: 0x42, which: 0x43})).to.be.equal('Š');
+        });
+        it('should return Unidentified when it cannot map the key', function () {
+            expect(KeyboardUtil.getKey({keycode: 0x42})).to.be.equal('Unidentified');
+        });
+    });
+
+    describe('getKeysym', function () {
+        describe('Non-character keys', function () {
+            it('should recognize the right keys', function () {
+                expect(KeyboardUtil.getKeysym({key: 'Enter'})).to.be.equal(0xFF0D);
+                expect(KeyboardUtil.getKeysym({key: 'Backspace'})).to.be.equal(0xFF08);
+                expect(KeyboardUtil.getKeysym({key: 'Tab'})).to.be.equal(0xFF09);
+                expect(KeyboardUtil.getKeysym({key: 'Shift'})).to.be.equal(0xFFE1);
+                expect(KeyboardUtil.getKeysym({key: 'Control'})).to.be.equal(0xFFE3);
+                expect(KeyboardUtil.getKeysym({key: 'Alt'})).to.be.equal(0xFFE9);
+                expect(KeyboardUtil.getKeysym({key: 'Meta'})).to.be.equal(0xFFEB);
+                expect(KeyboardUtil.getKeysym({key: 'Escape'})).to.be.equal(0xFF1B);
+                expect(KeyboardUtil.getKeysym({key: 'ArrowUp'})).to.be.equal(0xFF52);
+            });
+            it('should map left/right side', function () {
+                expect(KeyboardUtil.getKeysym({key: 'Shift', location: 1})).to.be.equal(0xFFE1);
+                expect(KeyboardUtil.getKeysym({key: 'Shift', location: 2})).to.be.equal(0xFFE2);
+                expect(KeyboardUtil.getKeysym({key: 'Control', location: 1})).to.be.equal(0xFFE3);
+                expect(KeyboardUtil.getKeysym({key: 'Control', location: 2})).to.be.equal(0xFFE4);
+            });
+            it('should handle AltGraph', function () {
+                expect(KeyboardUtil.getKeysym({code: 'AltRight', key: 'Alt', location: 2})).to.be.equal(0xFFEA);
+                expect(KeyboardUtil.getKeysym({code: 'AltRight', key: 'AltGraph', location: 2})).to.be.equal(0xFE03);
+            });
+            it('should handle Windows key with incorrect location', function () {
+                expect(KeyboardUtil.getKeysym({key: 'Meta', location: 0})).to.be.equal(0xFFEC);
+            });
+            it('should handle Clear/NumLock key with incorrect location', function () {
+                this.skip(); // Broken because of Clear/NumLock override
+                expect(KeyboardUtil.getKeysym({key: 'Clear', code: 'NumLock', location: 3})).to.be.equal(0xFF0B);
+            });
+            it('should handle Meta/Windows distinction', function () {
+                expect(KeyboardUtil.getKeysym({code: 'AltLeft', key: 'Meta', location: 1})).to.be.equal(0xFFE7);
+                expect(KeyboardUtil.getKeysym({code: 'AltRight', key: 'Meta', location: 2})).to.be.equal(0xFFE8);
+                expect(KeyboardUtil.getKeysym({code: 'MetaLeft', key: 'Meta', location: 1})).to.be.equal(0xFFEB);
+                expect(KeyboardUtil.getKeysym({code: 'MetaRight', key: 'Meta', location: 2})).to.be.equal(0xFFEC);
+            });
+            it('should send NumLock even if key is Clear', function () {
+                expect(KeyboardUtil.getKeysym({key: 'Clear', code: 'NumLock'})).to.be.equal(0xFF7F);
+            });
+            it('should return null for unknown keys', function () {
+                expect(KeyboardUtil.getKeysym({key: 'Semicolon'})).to.be.null;
+                expect(KeyboardUtil.getKeysym({key: 'BracketRight'})).to.be.null;
+            });
+            it('should handle remappings', function () {
+                expect(KeyboardUtil.getKeysym({code: 'ControlLeft', key: 'Tab'})).to.be.equal(0xFF09);
+            });
+        });
+
+        describe('Numpad', function () {
+            it('should handle Numpad numbers', function () {
+                expect(KeyboardUtil.getKeysym({code: 'Digit5', key: '5', location: 0})).to.be.equal(0x0035);
+                expect(KeyboardUtil.getKeysym({code: 'Numpad5', key: '5', location: 3})).to.be.equal(0xFFB5);
+            });
+            it('should handle Numpad non-character keys', function () {
+                expect(KeyboardUtil.getKeysym({code: 'Home', key: 'Home', location: 0})).to.be.equal(0xFF50);
+                expect(KeyboardUtil.getKeysym({code: 'Numpad5', key: 'Home', location: 3})).to.be.equal(0xFF95);
+                expect(KeyboardUtil.getKeysym({code: 'Delete', key: 'Delete', location: 0})).to.be.equal(0xFFFF);
+                expect(KeyboardUtil.getKeysym({code: 'NumpadDecimal', key: 'Delete', location: 3})).to.be.equal(0xFF9F);
+            });
+            it('should handle Numpad Decimal key', function () {
+                expect(KeyboardUtil.getKeysym({code: 'NumpadDecimal', key: '.', location: 3})).to.be.equal(0xFFAE);
+                expect(KeyboardUtil.getKeysym({code: 'NumpadDecimal', key: ',', location: 3})).to.be.equal(0xFFAC);
+            });
+        });
+
+        describe('Japanese IM keys on Windows', function () {
+            let origNavigator;
+            beforeEach(function () {
+                // window.navigator is a protected read-only property in many
+                // environments, so we need to redefine it whilst running these
+                // tests.
+                origNavigator = Object.getOwnPropertyDescriptor(window, "navigator");
+
+                Object.defineProperty(window, "navigator", {value: {}});
+                if (window.navigator.platform !== undefined) {
+                    // Object.defineProperty() doesn't work properly in old
+                    // versions of Chrome
+                    this.skip();
+                }
+
+                window.navigator.platform = "Windows";
+            });
+
+            afterEach(function () {
+                if (origNavigator !== undefined) {
+                    Object.defineProperty(window, "navigator", origNavigator);
+                }
+            });
+
+            const keys = { 'Zenkaku': 0xff2a, 'Hankaku': 0xff2a,
+                           'Romaji': 0xff24, 'KanaMode': 0xff24 };
+            for (let [key, keysym] of Object.entries(keys)) {
+                it(`should fake combined key for ${key} on Windows`, function () {
+                    expect(KeyboardUtil.getKeysym({code: 'FakeIM', key: key})).to.be.equal(keysym);
+                });
+            }
+        });
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.hextile.js
@@ -0,0 +1,232 @@
+const expect = chai.expect;
+
+import Websock from '../core/websock.js';
+import Display from '../core/display.js';
+
+import HextileDecoder from '../core/decoders/hextile.js';
+
+import FakeWebSocket from './fake.websocket.js';
+
+function testDecodeRect(decoder, x, y, width, height, data, display, depth) {
+    let sock;
+
+    sock = new Websock;
+    sock.open("ws://example.com");
+
+    sock.on('message', () => {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    });
+
+    // Empty messages are filtered at multiple layers, so we need to
+    // do a direct call
+    if (data.length === 0) {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    } else {
+        sock._websocket._receiveData(new Uint8Array(data));
+    }
+
+    display.flip();
+}
+
+function push32(arr, num) {
+    arr.push((num >> 24) & 0xFF,
+             (num >> 16) & 0xFF,
+             (num >>  8) & 0xFF,
+             num & 0xFF);
+}
+
+describe('Hextile Decoder', function () {
+    let decoder;
+    let display;
+
+    before(FakeWebSocket.replace);
+    after(FakeWebSocket.restore);
+
+    beforeEach(function () {
+        decoder = new HextileDecoder();
+        display = new Display(document.createElement('canvas'));
+        display.resize(4, 4);
+    });
+
+    it('should handle a tile with fg, bg specified, normal subrects', function () {
+        let data = [];
+        data.push(0x02 | 0x04 | 0x08); // bg spec, fg spec, anysubrects
+        push32(data, 0x00ff0000); // becomes 00ff0000 --> #00FF00 bg color
+        data.push(0x00); // becomes 0000ff00 --> #0000FF fg color
+        data.push(0x00);
+        data.push(0xff);
+        data.push(0x00);
+        data.push(2); // 2 subrects
+        data.push(0); // x: 0, y: 0
+        data.push(1 | (1 << 4)); // width: 2, height: 2
+        data.push(2 | (2 << 4)); // x: 2, y: 2
+        data.push(1 | (1 << 4)); // width: 2, height: 2
+
+        testDecodeRect(decoder, 0, 0, 4, 4, data, display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle a raw tile', function () {
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        let data = [];
+        data.push(0x01); // raw
+        for (let i = 0; i < targetData.length; i += 4) {
+            data.push(targetData[i]);
+            data.push(targetData[i + 1]);
+            data.push(targetData[i + 2]);
+            // Last byte zero to test correct alpha handling
+            data.push(0);
+        }
+
+        testDecodeRect(decoder, 0, 0, 4, 4, data, display, 24);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle a tile with only bg specified (solid bg)', function () {
+        let data = [];
+        data.push(0x02);
+        push32(data, 0x00ff0000); // becomes 00ff0000 --> #00FF00 bg color
+
+        testDecodeRect(decoder, 0, 0, 4, 4, data, display, 24);
+
+        let expected = [];
+        for (let i = 0; i < 16; i++) {
+            push32(expected, 0x00ff00ff);
+        }
+
+        expect(display).to.have.displayed(new Uint8Array(expected));
+    });
+
+    it('should handle a tile with only bg specified and an empty frame afterwards', function () {
+        // set the width so we can have two tiles
+        display.resize(8, 4);
+
+        let data = [];
+
+        // send a bg frame
+        data.push(0x02);
+        push32(data, 0x00ff0000); // becomes 00ff0000 --> #00FF00 bg color
+
+        // send an empty frame
+        data.push(0x00);
+
+        testDecodeRect(decoder, 0, 0, 32, 4, data, display, 24);
+
+        let expected = [];
+        for (let i = 0; i < 16; i++) {
+            push32(expected, 0x00ff00ff);     // rect 1: solid
+        }
+        for (let i = 0; i < 16; i++) {
+            push32(expected, 0x00ff00ff);    // rect 2: same bkground color
+        }
+
+        expect(display).to.have.displayed(new Uint8Array(expected));
+    });
+
+    it('should handle a tile with bg and coloured subrects', function () {
+        let data = [];
+        data.push(0x02 | 0x08 | 0x10); // bg spec, anysubrects, colouredsubrects
+        push32(data, 0x00ff0000); // becomes 00ff0000 --> #00FF00 bg color
+        data.push(2); // 2 subrects
+        data.push(0x00); // becomes 0000ff00 --> #0000FF fg color
+        data.push(0x00);
+        data.push(0xff);
+        data.push(0x00);
+        data.push(0); // x: 0, y: 0
+        data.push(1 | (1 << 4)); // width: 2, height: 2
+        data.push(0x00); // becomes 0000ff00 --> #0000FF fg color
+        data.push(0x00);
+        data.push(0xff);
+        data.push(0x00);
+        data.push(2 | (2 << 4)); // x: 2, y: 2
+        data.push(1 | (1 << 4)); // width: 2, height: 2
+
+        testDecodeRect(decoder, 0, 0, 4, 4, data, display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should carry over fg and bg colors from the previous tile if not specified', function () {
+        display.resize(4, 17);
+
+        let data = [];
+        data.push(0x02 | 0x04 | 0x08); // bg spec, fg spec, anysubrects
+        push32(data, 0xff00ff); // becomes 00ff00ff --> #00FF00 bg color
+        data.push(0x00); // becomes 0000ffff --> #0000FF fg color
+        data.push(0x00);
+        data.push(0xff);
+        data.push(0xff);
+        data.push(8); // 8 subrects
+        for (let i = 0; i < 4; i++) {
+            data.push((0 << 4) | (i * 4)); // x: 0, y: i*4
+            data.push(1 | (1 << 4)); // width: 2, height: 2
+            data.push((2 << 4) | (i * 4 + 2)); // x: 2, y: i * 4 + 2
+            data.push(1 | (1 << 4)); // width: 2, height: 2
+        }
+        data.push(0x08); // anysubrects
+        data.push(1); // 1 subrect
+        data.push(0); // x: 0, y: 0
+        data.push(1 | (1 << 4)); // width: 2, height: 2
+
+        testDecodeRect(decoder, 0, 0, 4, 17, data, display, 24);
+
+        let targetData = [
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ];
+
+        let expected = [];
+        for (let i = 0; i < 4; i++) {
+            expected = expected.concat(targetData);
+        }
+        expected = expected.concat(targetData.slice(0, 16));
+
+        expect(display).to.have.displayed(new Uint8Array(expected));
+    });
+
+    it('should fail on an invalid subencoding', function () {
+        let data = [45];  // an invalid subencoding
+        expect(() => testDecodeRect(decoder, 0, 0, 4, 4, data, display, 24)).to.throw();
+    });
+
+    it('should handle empty rects', function () {
+        display.fillRect(0, 0, 4, 4, [ 0x00, 0x00, 0xff ]);
+        display.fillRect(2, 0, 2, 2, [ 0x00, 0xff, 0x00 ]);
+        display.fillRect(0, 2, 2, 2, [ 0x00, 0xff, 0x00 ]);
+
+        testDecodeRect(decoder, 1, 2, 0, 0, [], display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.inflator.js
@@ -0,0 +1,113 @@
+/* eslint-disable no-console */
+const expect = chai.expect;
+
+import { deflateInit, deflate, Z_FULL_FLUSH } from "../vendor/pako/lib/zlib/deflate.js";
+import ZStream from "../vendor/pako/lib/zlib/zstream.js";
+import Inflator from "../core/inflator.js";
+
+function _deflator(data) {
+    let strm = new ZStream();
+
+    deflateInit(strm, 5);
+
+    /* eslint-disable camelcase */
+    strm.input = data;
+    strm.avail_in = strm.input.length;
+    strm.next_in = 0;
+    /* eslint-enable camelcase */
+
+    let chunks = [];
+    let totalLen = 0;
+    while (strm.avail_in > 0) {
+        /* eslint-disable camelcase */
+        strm.output = new Uint8Array(1024 * 10 * 10);
+        strm.avail_out = strm.output.length;
+        strm.next_out = 0;
+        /* eslint-enable camelcase */
+
+        let ret = deflate(strm, Z_FULL_FLUSH);
+
+        // Check that return code is not an error
+        expect(ret).to.be.greaterThan(-1);
+
+        let chunk = new Uint8Array(strm.output.buffer, 0, strm.next_out);
+        totalLen += chunk.length;
+        chunks.push(chunk);
+    }
+
+    // Combine chunks into a single data
+
+    let outData = new Uint8Array(totalLen);
+    let offset = 0;
+
+    for (let i = 0; i < chunks.length; i++) {
+        outData.set(chunks[i], offset);
+        offset += chunks[i].length;
+    }
+
+    return outData;
+}
+
+describe('Inflate data', function () {
+
+    it('should be able to inflate messages', function () {
+        let inflator = new Inflator();
+
+        let text = "123asdf";
+        let preText = new Uint8Array(text.length);
+        for (let i = 0; i < preText.length; i++) {
+            preText[i] = text.charCodeAt(i);
+        }
+
+        let compText = _deflator(preText);
+
+        inflator.setInput(compText);
+        let inflatedText = inflator.inflate(preText.length);
+
+        expect(inflatedText).to.array.equal(preText);
+
+    });
+
+    it('should be able to inflate large messages', function () {
+        let inflator = new Inflator();
+
+        /* Generate a big string with random characters. Used because
+           repetition of letters might be deflated more effectively than
+           random ones. */
+        let text = "";
+        let characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
+        for (let i = 0; i < 300000; i++) {
+            text += characters.charAt(Math.floor(Math.random() * characters.length));
+        }
+
+        let preText = new Uint8Array(text.length);
+        for (let i = 0; i < preText.length; i++) {
+            preText[i] = text.charCodeAt(i);
+        }
+
+        let compText = _deflator(preText);
+
+        //Check that the compressed size is expected size
+        expect(compText.length).to.be.greaterThan((1024 * 10 * 10) * 2);
+
+        inflator.setInput(compText);
+        let inflatedText = inflator.inflate(preText.length);
+
+        expect(inflatedText).to.array.equal(preText);
+    });
+
+    it('should throw an error on insufficient data', function () {
+        let inflator = new Inflator();
+
+        let text = "123asdf";
+        let preText = new Uint8Array(text.length);
+        for (let i = 0; i < preText.length; i++) {
+            preText[i] = text.charCodeAt(i);
+        }
+
+        let compText = _deflator(preText);
+
+        inflator.setInput(compText);
+        expect(() => inflator.inflate(preText.length * 2)).to.throw();
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.int.js
@@ -0,0 +1,16 @@
+/* eslint-disable no-console */
+const expect = chai.expect;
+
+import { toUnsigned32bit, toSigned32bit } from '../core/util/int.js';
+
+describe('Integer casting', function () {
+    it('should cast unsigned to signed', function () {
+        let expected = 4294967286;
+        expect(toUnsigned32bit(-10)).to.equal(expected);
+    });
+
+    it('should cast signed to unsigned', function () {
+        let expected = -10;
+        expect(toSigned32bit(4294967286)).to.equal(expected);
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.jpeg.js
@@ -0,0 +1,288 @@
+const expect = chai.expect;
+
+import Websock from '../core/websock.js';
+import Display from '../core/display.js';
+
+import JPEGDecoder from '../core/decoders/jpeg.js';
+
+import FakeWebSocket from './fake.websocket.js';
+
+function testDecodeRect(decoder, x, y, width, height, data, display, depth) {
+    let sock;
+
+    sock = new Websock;
+    sock.open("ws://example.com");
+
+    sock.on('message', () => {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    });
+
+    // Empty messages are filtered at multiple layers, so we need to
+    // do a direct call
+    if (data.length === 0) {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    } else {
+        sock._websocket._receiveData(new Uint8Array(data));
+    }
+
+    display.flip();
+}
+
+describe('JPEG Decoder', function () {
+    let decoder;
+    let display;
+
+    before(FakeWebSocket.replace);
+    after(FakeWebSocket.restore);
+
+    beforeEach(function () {
+        decoder = new JPEGDecoder();
+        display = new Display(document.createElement('canvas'));
+        display.resize(4, 4);
+    });
+
+    it('should handle JPEG rects', function (done) {
+        let data = [
+            // JPEG data
+            0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46,
+            0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x01, 0x2c,
+            0x01, 0x2c, 0x00, 0x42, 0xff, 0xdb, 0x00, 0x43,
+            0x00, 0x03, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03,
+            0x03, 0x03, 0x03, 0x04, 0x03, 0x03, 0x04, 0x05,
+            0x08, 0x05, 0x05, 0x04, 0x04, 0x05, 0x0a, 0x07,
+            0x07, 0x06, 0x08, 0x0c, 0x0a, 0x0c, 0x0c, 0x0b,
+            0x0a, 0x0b, 0x0b, 0x0d, 0x0e, 0x12, 0x10, 0x0d,
+            0x0e, 0x11, 0x0e, 0x0b, 0x0b, 0x10, 0x16, 0x10,
+            0x11, 0x13, 0x14, 0x15, 0x15, 0x15, 0x0c, 0x0f,
+            0x17, 0x18, 0x16, 0x14, 0x18, 0x12, 0x14, 0x15,
+            0x14, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x03, 0x04,
+            0x04, 0x05, 0x04, 0x05, 0x09, 0x05, 0x05, 0x09,
+            0x14, 0x0d, 0x0b, 0x0d, 0x14, 0x14, 0x14, 0x14,
+            0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+            0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+            0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+            0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+            0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+            0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0xff, 0xc0,
+            0x00, 0x11, 0x08, 0x00, 0x04, 0x00, 0x04, 0x03,
+            0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11,
+            0x01, 0xff, 0xc4, 0x00, 0x1f, 0x00, 0x00, 0x01,
+            0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+            0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
+            0x0a, 0x0b, 0xff, 0xc4, 0x00, 0xb5, 0x10, 0x00,
+            0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05,
+            0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7d, 0x01,
+            0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,
+            0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22,
+            0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23,
+            0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24,
+            0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17,
+            0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29,
+            0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a,
+            0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,
+            0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a,
+            0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a,
+            0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,
+            0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a,
+            0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
+            0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8,
+            0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
+            0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6,
+            0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5,
+            0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3,
+            0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1,
+            0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9,
+            0xfa, 0xff, 0xc4, 0x00, 0x1f, 0x01, 0x00, 0x03,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+            0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
+            0x0a, 0x0b, 0xff, 0xc4, 0x00, 0xb5, 0x11, 0x00,
+            0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07,
+            0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00,
+            0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31,
+            0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13,
+            0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1,
+            0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15,
+            0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1,
+            0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27,
+            0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39,
+            0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
+            0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
+            0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
+            0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
+            0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88,
+            0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
+            0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6,
+            0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5,
+            0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4,
+            0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3,
+            0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2,
+            0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
+            0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9,
+            0xfa, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00,
+            0x02, 0x11, 0x03, 0x11, 0x00, 0x3f, 0x00, 0xf9,
+            0xf7, 0xfb, 0x67, 0x56, 0xff, 0x00, 0x9f, 0xf8,
+            0x3f, 0xf0, 0x51, 0xa7, 0xff, 0x00, 0xf2, 0x3d,
+            0x7e, 0x6f, 0xfd, 0xab, 0x94, 0x7f, 0xd0, 0x9a,
+            0x8f, 0xfe, 0x0d, 0xc7, 0x7f, 0xf3, 0x61, 0xfd,
+            0xa7, 0xff, 0x00, 0x10, 0x77, 0x0d, 0xff, 0x00,
+            0x43, 0xec, 0xcf, 0xff, 0x00, 0x0b, 0xab, 0x1f,
+            0xff, 0xd9,
+        ];
+
+        testDecodeRect(decoder, 0, 0, 4, 4, data, display, 24);
+
+        let targetData = new Uint8Array([
+            0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255
+        ]);
+
+        // Browsers have rounding errors, so we need an approximate
+        // comparing function
+        function almost(a, b) {
+            let diff = Math.abs(a - b);
+            return diff < 5;
+        }
+
+        display.onflush = () => {
+            expect(display).to.have.displayed(targetData, almost);
+            done();
+        };
+        display.flush();
+    });
+
+    it('should handle JPEG rects without Huffman and quantification tables', function (done) {
+        let data1 = [
+            // JPEG data
+            0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46,
+            0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x01, 0x2c,
+            0x01, 0x2c, 0x00, 0x42, 0xff, 0xdb, 0x00, 0x43,
+            0x00, 0x03, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03,
+            0x03, 0x03, 0x03, 0x04, 0x03, 0x03, 0x04, 0x05,
+            0x08, 0x05, 0x05, 0x04, 0x04, 0x05, 0x0a, 0x07,
+            0x07, 0x06, 0x08, 0x0c, 0x0a, 0x0c, 0x0c, 0x0b,
+            0x0a, 0x0b, 0x0b, 0x0d, 0x0e, 0x12, 0x10, 0x0d,
+            0x0e, 0x11, 0x0e, 0x0b, 0x0b, 0x10, 0x16, 0x10,
+            0x11, 0x13, 0x14, 0x15, 0x15, 0x15, 0x0c, 0x0f,
+            0x17, 0x18, 0x16, 0x14, 0x18, 0x12, 0x14, 0x15,
+            0x14, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x03, 0x04,
+            0x04, 0x05, 0x04, 0x05, 0x09, 0x05, 0x05, 0x09,
+            0x14, 0x0d, 0x0b, 0x0d, 0x14, 0x14, 0x14, 0x14,
+            0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+            0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+            0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+            0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+            0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+            0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0xff, 0xc0,
+            0x00, 0x11, 0x08, 0x00, 0x04, 0x00, 0x04, 0x03,
+            0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11,
+            0x01, 0xff, 0xc4, 0x00, 0x1f, 0x00, 0x00, 0x01,
+            0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+            0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
+            0x0a, 0x0b, 0xff, 0xc4, 0x00, 0xb5, 0x10, 0x00,
+            0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05,
+            0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7d, 0x01,
+            0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,
+            0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22,
+            0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23,
+            0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24,
+            0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17,
+            0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29,
+            0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a,
+            0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,
+            0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a,
+            0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a,
+            0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,
+            0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a,
+            0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
+            0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8,
+            0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
+            0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6,
+            0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5,
+            0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3,
+            0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1,
+            0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9,
+            0xfa, 0xff, 0xc4, 0x00, 0x1f, 0x01, 0x00, 0x03,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+            0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
+            0x0a, 0x0b, 0xff, 0xc4, 0x00, 0xb5, 0x11, 0x00,
+            0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07,
+            0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00,
+            0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31,
+            0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13,
+            0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1,
+            0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15,
+            0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1,
+            0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27,
+            0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39,
+            0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
+            0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
+            0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
+            0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
+            0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88,
+            0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
+            0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6,
+            0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5,
+            0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4,
+            0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3,
+            0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2,
+            0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
+            0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9,
+            0xfa, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00,
+            0x02, 0x11, 0x03, 0x11, 0x00, 0x3f, 0x00, 0xf9,
+            0xf7, 0xfb, 0x67, 0x56, 0xff, 0x00, 0x9f, 0xf8,
+            0x3f, 0xf0, 0x51, 0xa7, 0xff, 0x00, 0xf2, 0x3d,
+            0x7e, 0x6f, 0xfd, 0xab, 0x94, 0x7f, 0xd0, 0x9a,
+            0x8f, 0xfe, 0x0d, 0xc7, 0x7f, 0xf3, 0x61, 0xfd,
+            0xa7, 0xff, 0x00, 0x10, 0x77, 0x0d, 0xff, 0x00,
+            0x43, 0xec, 0xcf, 0xff, 0x00, 0x0b, 0xab, 0x1f,
+            0xff, 0xd9,
+        ];
+
+        testDecodeRect(decoder, 0, 0, 4, 4, data1, display, 24);
+
+        let data2 = [
+            // JPEG data
+            0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46,
+            0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x01, 0x2c,
+            0x01, 0x2c, 0x00, 0x73, 0xff, 0xc0, 0x00, 0x11,
+            0x08, 0x00, 0x04, 0x00, 0x04, 0x03, 0x01, 0x11,
+            0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xff,
+            0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11,
+            0x03, 0x11, 0x00, 0x3f, 0x00, 0xf9, 0xf7, 0xfb,
+            0x67, 0x56, 0xff, 0x00, 0x9f, 0xf8, 0x3f, 0xf0,
+            0x51, 0xa7, 0xff, 0x00, 0xf2, 0x3d, 0x7e, 0x6f,
+            0xfd, 0xab, 0x94, 0x7f, 0xd0, 0x9a, 0x8f, 0xfe,
+            0x0d, 0xc7, 0x7f, 0xf3, 0x61, 0xfd, 0xa7, 0xff,
+            0x00, 0x10, 0x77, 0x0d, 0xff, 0x00, 0x43, 0xec,
+            0xcf, 0xff, 0x00, 0x0b, 0xab, 0x1f, 0xff, 0xd9,
+        ];
+
+        testDecodeRect(decoder, 0, 0, 4, 4, data2, display, 24);
+
+        let targetData = new Uint8Array([
+            0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255
+        ]);
+
+        // Browsers have rounding errors, so we need an approximate
+        // comparing function
+        function almost(a, b) {
+            let diff = Math.abs(a - b);
+            return diff < 5;
+        }
+
+        display.onflush = () => {
+            expect(display).to.have.displayed(targetData, almost);
+            done();
+        };
+        display.flush();
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.keyboard.js
@@ -0,0 +1,582 @@
+const expect = chai.expect;
+
+import Keyboard from '../core/input/keyboard.js';
+
+describe('Key Event Handling', function () {
+    "use strict";
+
+    // The real KeyboardEvent constructor might not work everywhere we
+    // want to run these tests
+    function keyevent(typeArg, KeyboardEventInit) {
+        const e = { type: typeArg };
+        for (let key in KeyboardEventInit) {
+            e[key] = KeyboardEventInit[key];
+        }
+        e.stopPropagation = sinon.spy();
+        e.preventDefault = sinon.spy();
+        return e;
+    }
+
+    describe('Decode Keyboard Events', function () {
+        it('should decode keydown events', function (done) {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = (keysym, code, down) => {
+                expect(keysym).to.be.equal(0x61);
+                expect(code).to.be.equal('KeyA');
+                expect(down).to.be.equal(true);
+                done();
+            };
+            kbd._handleKeyDown(keyevent('keydown', {code: 'KeyA', key: 'a'}));
+        });
+        it('should decode keyup events', function (done) {
+            let calls = 0;
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = (keysym, code, down) => {
+                expect(keysym).to.be.equal(0x61);
+                expect(code).to.be.equal('KeyA');
+                if (calls++ === 1) {
+                    expect(down).to.be.equal(false);
+                    done();
+                }
+            };
+            kbd._handleKeyDown(keyevent('keydown', {code: 'KeyA', key: 'a'}));
+            kbd._handleKeyUp(keyevent('keyup', {code: 'KeyA', key: 'a'}));
+        });
+    });
+
+    describe('Fake keyup', function () {
+        it('should fake keyup events for virtual keyboards', function (done) {
+            let count = 0;
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = (keysym, code, down) => {
+                switch (count++) {
+                    case 0:
+                        expect(keysym).to.be.equal(0x61);
+                        expect(code).to.be.equal('Unidentified');
+                        expect(down).to.be.equal(true);
+                        break;
+                    case 1:
+                        expect(keysym).to.be.equal(0x61);
+                        expect(code).to.be.equal('Unidentified');
+                        expect(down).to.be.equal(false);
+                        done();
+                }
+            };
+            kbd._handleKeyDown(keyevent('keydown', {code: 'Unidentified', key: 'a'}));
+        });
+    });
+
+    describe('Track Key State', function () {
+        it('should send release using the same keysym as the press', function (done) {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = (keysym, code, down) => {
+                expect(keysym).to.be.equal(0x61);
+                expect(code).to.be.equal('KeyA');
+                if (!down) {
+                    done();
+                }
+            };
+            kbd._handleKeyDown(keyevent('keydown', {code: 'KeyA', key: 'a'}));
+            kbd._handleKeyUp(keyevent('keyup', {code: 'KeyA', key: 'b'}));
+        });
+        it('should send the same keysym for multiple presses', function () {
+            let count = 0;
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = (keysym, code, down) => {
+                expect(keysym).to.be.equal(0x61);
+                expect(code).to.be.equal('KeyA');
+                expect(down).to.be.equal(true);
+                count++;
+            };
+            kbd._handleKeyDown(keyevent('keydown', {code: 'KeyA', key: 'a'}));
+            kbd._handleKeyDown(keyevent('keydown', {code: 'KeyA', key: 'b'}));
+            expect(count).to.be.equal(2);
+        });
+        it('should do nothing on keyup events if no keys are down', function () {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyUp(keyevent('keyup', {code: 'KeyA', key: 'a'}));
+            expect(kbd.onkeyevent).to.not.have.been.called;
+        });
+
+        describe('Legacy Events', function () {
+            it('should track keys using keyCode if no code', function (done) {
+                const kbd = new Keyboard(document);
+                kbd.onkeyevent = (keysym, code, down) => {
+                    expect(keysym).to.be.equal(0x61);
+                    expect(code).to.be.equal('Platform65');
+                    if (!down) {
+                        done();
+                    }
+                };
+                kbd._handleKeyDown(keyevent('keydown', {keyCode: 65, key: 'a'}));
+                kbd._handleKeyUp(keyevent('keyup', {keyCode: 65, key: 'b'}));
+            });
+            it('should ignore compositing code', function () {
+                const kbd = new Keyboard(document);
+                kbd.onkeyevent = (keysym, code, down) => {
+                    expect(keysym).to.be.equal(0x61);
+                    expect(code).to.be.equal('Unidentified');
+                };
+                kbd._handleKeyDown(keyevent('keydown', {keyCode: 229, key: 'a'}));
+            });
+            it('should track keys using keyIdentifier if no code', function (done) {
+                const kbd = new Keyboard(document);
+                kbd.onkeyevent = (keysym, code, down) => {
+                    expect(keysym).to.be.equal(0x61);
+                    expect(code).to.be.equal('Platform65');
+                    if (!down) {
+                        done();
+                    }
+                };
+                kbd._handleKeyDown(keyevent('keydown', {keyIdentifier: 'U+0041', key: 'a'}));
+                kbd._handleKeyUp(keyevent('keyup', {keyIdentifier: 'U+0041', key: 'b'}));
+            });
+        });
+    });
+
+    describe('Shuffle modifiers on macOS', function () {
+        let origNavigator;
+        beforeEach(function () {
+            // window.navigator is a protected read-only property in many
+            // environments, so we need to redefine it whilst running these
+            // tests.
+            origNavigator = Object.getOwnPropertyDescriptor(window, "navigator");
+
+            Object.defineProperty(window, "navigator", {value: {}});
+            if (window.navigator.platform !== undefined) {
+                // Object.defineProperty() doesn't work properly in old
+                // versions of Chrome
+                this.skip();
+            }
+
+            window.navigator.platform = "Mac x86_64";
+        });
+        afterEach(function () {
+            if (origNavigator !== undefined) {
+                Object.defineProperty(window, "navigator", origNavigator);
+            }
+        });
+
+        it('should change Alt to AltGraph', function () {
+            let count = 0;
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = (keysym, code, down) => {
+                switch (count++) {
+                    case 0:
+                        expect(keysym).to.be.equal(0xFF7E);
+                        expect(code).to.be.equal('AltLeft');
+                        break;
+                    case 1:
+                        expect(keysym).to.be.equal(0xFE03);
+                        expect(code).to.be.equal('AltRight');
+                        break;
+                }
+            };
+            kbd._handleKeyDown(keyevent('keydown', {code: 'AltLeft', key: 'Alt', location: 1}));
+            kbd._handleKeyDown(keyevent('keydown', {code: 'AltRight', key: 'Alt', location: 2}));
+            expect(count).to.be.equal(2);
+        });
+        it('should change left Super to Alt', function (done) {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = (keysym, code, down) => {
+                expect(keysym).to.be.equal(0xFFE9);
+                expect(code).to.be.equal('MetaLeft');
+                done();
+            };
+            kbd._handleKeyDown(keyevent('keydown', {code: 'MetaLeft', key: 'Meta', location: 1}));
+        });
+        it('should change right Super to left Super', function (done) {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = (keysym, code, down) => {
+                expect(keysym).to.be.equal(0xFFEB);
+                expect(code).to.be.equal('MetaRight');
+                done();
+            };
+            kbd._handleKeyDown(keyevent('keydown', {code: 'MetaRight', key: 'Meta', location: 2}));
+        });
+    });
+
+    describe('Meta key combination on iOS and macOS', function () {
+        let origNavigator;
+        beforeEach(function () {
+            // window.navigator is a protected read-only property in many
+            // environments, so we need to redefine it whilst running these
+            // tests.
+            origNavigator = Object.getOwnPropertyDescriptor(window, "navigator");
+
+            Object.defineProperty(window, "navigator", {value: {}});
+            if (window.navigator.platform !== undefined) {
+                // Object.defineProperty() doesn't work properly in old
+                // versions of Chrome
+                this.skip();
+            }
+        });
+
+        afterEach(function () {
+            if (origNavigator !== undefined) {
+                Object.defineProperty(window, "navigator", origNavigator);
+            }
+        });
+
+        it('should send keyup when meta key is pressed on iOS', function () {
+            window.navigator.platform = "iPad";
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+
+            kbd._handleKeyDown(keyevent('keydown', {code: 'MetaRight', key: 'Meta', location: 2, metaKey: true}));
+            expect(kbd.onkeyevent).to.have.been.calledOnce;
+            kbd.onkeyevent.resetHistory();
+
+            kbd._handleKeyDown(keyevent('keydown', {code: 'KeyA', key: 'a', metaKey: true}));
+            expect(kbd.onkeyevent).to.have.been.calledTwice;
+            expect(kbd.onkeyevent).to.have.been.calledWith(0x61, "KeyA", true);
+            expect(kbd.onkeyevent).to.have.been.calledWith(0x61, "KeyA", false);
+            kbd.onkeyevent.resetHistory();
+
+            kbd._handleKeyUp(keyevent('keyup', {code: 'MetaRight', key: 'Meta', location: 2, metaKey: true}));
+            expect(kbd.onkeyevent).to.have.been.calledOnce;
+        });
+
+        it('should send keyup when meta key is pressed on macOS', function () {
+            window.navigator.platform = "Mac";
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+
+            kbd._handleKeyDown(keyevent('keydown', {code: 'MetaRight', key: 'Meta', location: 2, metaKey: true}));
+            expect(kbd.onkeyevent).to.have.been.calledOnce;
+            kbd.onkeyevent.resetHistory();
+
+            kbd._handleKeyDown(keyevent('keydown', {code: 'KeyA', key: 'a', metaKey: true}));
+            expect(kbd.onkeyevent).to.have.been.calledTwice;
+            expect(kbd.onkeyevent).to.have.been.calledWith(0x61, "KeyA", true);
+            expect(kbd.onkeyevent).to.have.been.calledWith(0x61, "KeyA", false);
+            kbd.onkeyevent.resetHistory();
+
+            kbd._handleKeyUp(keyevent('keyup', {code: 'MetaRight', key: 'Meta', location: 2, metaKey: true}));
+            expect(kbd.onkeyevent).to.have.been.calledOnce;
+        });
+    });
+
+    describe('Caps Lock on iOS and macOS', function () {
+        let origNavigator;
+        beforeEach(function () {
+            // window.navigator is a protected read-only property in many
+            // environments, so we need to redefine it whilst running these
+            // tests.
+            origNavigator = Object.getOwnPropertyDescriptor(window, "navigator");
+
+            Object.defineProperty(window, "navigator", {value: {}});
+            if (window.navigator.platform !== undefined) {
+                // Object.defineProperty() doesn't work properly in old
+                // versions of Chrome
+                this.skip();
+            }
+        });
+
+        afterEach(function () {
+            if (origNavigator !== undefined) {
+                Object.defineProperty(window, "navigator", origNavigator);
+            }
+        });
+
+        it('should toggle caps lock on key press on iOS', function () {
+            window.navigator.platform = "iPad";
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyDown(keyevent('keydown', {code: 'CapsLock', key: 'CapsLock'}));
+
+            expect(kbd.onkeyevent).to.have.been.calledTwice;
+            expect(kbd.onkeyevent.firstCall).to.have.been.calledWith(0xFFE5, "CapsLock", true);
+            expect(kbd.onkeyevent.secondCall).to.have.been.calledWith(0xFFE5, "CapsLock", false);
+        });
+
+        it('should toggle caps lock on key press on mac', function () {
+            window.navigator.platform = "Mac";
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyDown(keyevent('keydown', {code: 'CapsLock', key: 'CapsLock'}));
+
+            expect(kbd.onkeyevent).to.have.been.calledTwice;
+            expect(kbd.onkeyevent.firstCall).to.have.been.calledWith(0xFFE5, "CapsLock", true);
+            expect(kbd.onkeyevent.secondCall).to.have.been.calledWith(0xFFE5, "CapsLock", false);
+        });
+
+        it('should toggle caps lock on key release on iOS', function () {
+            window.navigator.platform = "iPad";
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyUp(keyevent('keyup', {code: 'CapsLock', key: 'CapsLock'}));
+
+            expect(kbd.onkeyevent).to.have.been.calledTwice;
+            expect(kbd.onkeyevent.firstCall).to.have.been.calledWith(0xFFE5, "CapsLock", true);
+            expect(kbd.onkeyevent.secondCall).to.have.been.calledWith(0xFFE5, "CapsLock", false);
+        });
+
+        it('should toggle caps lock on key release on mac', function () {
+            window.navigator.platform = "Mac";
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyUp(keyevent('keyup', {code: 'CapsLock', key: 'CapsLock'}));
+
+            expect(kbd.onkeyevent).to.have.been.calledTwice;
+            expect(kbd.onkeyevent.firstCall).to.have.been.calledWith(0xFFE5, "CapsLock", true);
+            expect(kbd.onkeyevent.secondCall).to.have.been.calledWith(0xFFE5, "CapsLock", false);
+        });
+    });
+
+    describe('Japanese IM keys on Windows', function () {
+        let origNavigator;
+        beforeEach(function () {
+            // window.navigator is a protected read-only property in many
+            // environments, so we need to redefine it whilst running these
+            // tests.
+            origNavigator = Object.getOwnPropertyDescriptor(window, "navigator");
+
+            Object.defineProperty(window, "navigator", {value: {}});
+            if (window.navigator.platform !== undefined) {
+                // Object.defineProperty() doesn't work properly in old
+                // versions of Chrome
+                this.skip();
+            }
+
+            window.navigator.platform = "Windows";
+        });
+
+        afterEach(function () {
+            if (origNavigator !== undefined) {
+                Object.defineProperty(window, "navigator", origNavigator);
+            }
+        });
+
+        const keys = { 'Zenkaku': 0xff2a, 'Hankaku': 0xff2a,
+                       'Alphanumeric': 0xff30, 'Katakana': 0xff26,
+                       'Hiragana': 0xff25, 'Romaji': 0xff24,
+                       'KanaMode': 0xff24 };
+        for (let [key, keysym] of Object.entries(keys)) {
+            it(`should fake key release for ${key} on Windows`, function () {
+                let kbd = new Keyboard(document);
+                kbd.onkeyevent = sinon.spy();
+                kbd._handleKeyDown(keyevent('keydown', {code: 'FakeIM', key: key}));
+
+                expect(kbd.onkeyevent).to.have.been.calledTwice;
+                expect(kbd.onkeyevent.firstCall).to.have.been.calledWith(keysym, "FakeIM", true);
+                expect(kbd.onkeyevent.secondCall).to.have.been.calledWith(keysym, "FakeIM", false);
+            });
+        }
+    });
+
+    describe('Escape AltGraph on Windows', function () {
+        let origNavigator;
+        beforeEach(function () {
+            // window.navigator is a protected read-only property in many
+            // environments, so we need to redefine it whilst running these
+            // tests.
+            origNavigator = Object.getOwnPropertyDescriptor(window, "navigator");
+
+            Object.defineProperty(window, "navigator", {value: {}});
+            if (window.navigator.platform !== undefined) {
+                // Object.defineProperty() doesn't work properly in old
+                // versions of Chrome
+                this.skip();
+            }
+
+            window.navigator.platform = "Windows x86_64";
+
+            this.clock = sinon.useFakeTimers();
+        });
+        afterEach(function () {
+            if (origNavigator !== undefined) {
+                Object.defineProperty(window, "navigator", origNavigator);
+            }
+            if (this.clock !== undefined) {
+                this.clock.restore();
+            }
+        });
+
+        it('should supress ControlLeft until it knows if it is AltGr', function () {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyDown(keyevent('keydown', {code: 'ControlLeft', key: 'Control', location: 1}));
+            expect(kbd.onkeyevent).to.not.have.been.called;
+        });
+
+        it('should not trigger on repeating ControlLeft', function () {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyDown(keyevent('keydown', {code: 'ControlLeft', key: 'Control', location: 1}));
+            kbd._handleKeyDown(keyevent('keydown', {code: 'ControlLeft', key: 'Control', location: 1}));
+            expect(kbd.onkeyevent).to.have.been.calledTwice;
+            expect(kbd.onkeyevent.firstCall).to.have.been.calledWith(0xffe3, "ControlLeft", true);
+            expect(kbd.onkeyevent.secondCall).to.have.been.calledWith(0xffe3, "ControlLeft", true);
+        });
+
+        it('should not supress ControlRight', function () {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyDown(keyevent('keydown', {code: 'ControlRight', key: 'Control', location: 2}));
+            expect(kbd.onkeyevent).to.have.been.calledOnce;
+            expect(kbd.onkeyevent).to.have.been.calledWith(0xffe4, "ControlRight", true);
+        });
+
+        it('should release ControlLeft after 100 ms', function () {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyDown(keyevent('keydown', {code: 'ControlLeft', key: 'Control', location: 1}));
+            expect(kbd.onkeyevent).to.not.have.been.called;
+            this.clock.tick(100);
+            expect(kbd.onkeyevent).to.have.been.calledOnce;
+            expect(kbd.onkeyevent).to.have.been.calledWith(0xffe3, "ControlLeft", true);
+        });
+
+        it('should release ControlLeft on other key press', function () {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyDown(keyevent('keydown', {code: 'ControlLeft', key: 'Control', location: 1}));
+            expect(kbd.onkeyevent).to.not.have.been.called;
+            kbd._handleKeyDown(keyevent('keydown', {code: 'KeyA', key: 'a'}));
+            expect(kbd.onkeyevent).to.have.been.calledTwice;
+            expect(kbd.onkeyevent.firstCall).to.have.been.calledWith(0xffe3, "ControlLeft", true);
+            expect(kbd.onkeyevent.secondCall).to.have.been.calledWith(0x61, "KeyA", true);
+
+            // Check that the timer is properly dead
+            kbd.onkeyevent.resetHistory();
+            this.clock.tick(100);
+            expect(kbd.onkeyevent).to.not.have.been.called;
+        });
+
+        it('should release ControlLeft on other key release', function () {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyDown(keyevent('keydown', {code: 'KeyA', key: 'a'}));
+            kbd._handleKeyDown(keyevent('keydown', {code: 'ControlLeft', key: 'Control', location: 1}));
+            expect(kbd.onkeyevent).to.have.been.calledOnce;
+            expect(kbd.onkeyevent.firstCall).to.have.been.calledWith(0x61, "KeyA", true);
+            kbd._handleKeyUp(keyevent('keyup', {code: 'KeyA', key: 'a'}));
+            expect(kbd.onkeyevent).to.have.been.calledThrice;
+            expect(kbd.onkeyevent.secondCall).to.have.been.calledWith(0xffe3, "ControlLeft", true);
+            expect(kbd.onkeyevent.thirdCall).to.have.been.calledWith(0x61, "KeyA", false);
+
+            // Check that the timer is properly dead
+            kbd.onkeyevent.resetHistory();
+            this.clock.tick(100);
+            expect(kbd.onkeyevent).to.not.have.been.called;
+        });
+
+        it('should generate AltGraph for quick Ctrl+Alt sequence', function () {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyDown(keyevent('keydown', {code: 'ControlLeft', key: 'Control', location: 1, timeStamp: Date.now()}));
+            this.clock.tick(20);
+            kbd._handleKeyDown(keyevent('keydown', {code: 'AltRight', key: 'Alt', location: 2, timeStamp: Date.now()}));
+            expect(kbd.onkeyevent).to.have.been.calledOnce;
+            expect(kbd.onkeyevent).to.have.been.calledWith(0xfe03, 'AltRight', true);
+
+            // Check that the timer is properly dead
+            kbd.onkeyevent.resetHistory();
+            this.clock.tick(100);
+            expect(kbd.onkeyevent).to.not.have.been.called;
+        });
+
+        it('should generate Ctrl, Alt for slow Ctrl+Alt sequence', function () {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyDown(keyevent('keydown', {code: 'ControlLeft', key: 'Control', location: 1, timeStamp: Date.now()}));
+            this.clock.tick(60);
+            kbd._handleKeyDown(keyevent('keydown', {code: 'AltRight', key: 'Alt', location: 2, timeStamp: Date.now()}));
+            expect(kbd.onkeyevent).to.have.been.calledTwice;
+            expect(kbd.onkeyevent.firstCall).to.have.been.calledWith(0xffe3, "ControlLeft", true);
+            expect(kbd.onkeyevent.secondCall).to.have.been.calledWith(0xffea, "AltRight", true);
+
+            // Check that the timer is properly dead
+            kbd.onkeyevent.resetHistory();
+            this.clock.tick(100);
+            expect(kbd.onkeyevent).to.not.have.been.called;
+        });
+
+        it('should pass through single Alt', function () {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyDown(keyevent('keydown', {code: 'AltRight', key: 'Alt', location: 2}));
+            expect(kbd.onkeyevent).to.have.been.calledOnce;
+            expect(kbd.onkeyevent).to.have.been.calledWith(0xffea, 'AltRight', true);
+        });
+
+        it('should pass through single AltGr', function () {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+            kbd._handleKeyDown(keyevent('keydown', {code: 'AltRight', key: 'AltGraph', location: 2}));
+            expect(kbd.onkeyevent).to.have.been.calledOnce;
+            expect(kbd.onkeyevent).to.have.been.calledWith(0xfe03, 'AltRight', true);
+        });
+    });
+
+    describe('Missing Shift keyup on Windows', function () {
+        let origNavigator;
+        beforeEach(function () {
+            // window.navigator is a protected read-only property in many
+            // environments, so we need to redefine it whilst running these
+            // tests.
+            origNavigator = Object.getOwnPropertyDescriptor(window, "navigator");
+
+            Object.defineProperty(window, "navigator", {value: {}});
+            if (window.navigator.platform !== undefined) {
+                // Object.defineProperty() doesn't work properly in old
+                // versions of Chrome
+                this.skip();
+            }
+
+            window.navigator.platform = "Windows x86_64";
+
+            this.clock = sinon.useFakeTimers();
+        });
+        afterEach(function () {
+            if (origNavigator !== undefined) {
+                Object.defineProperty(window, "navigator", origNavigator);
+            }
+            if (this.clock !== undefined) {
+                this.clock.restore();
+            }
+        });
+
+        it('should fake a left Shift keyup', function () {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+
+            kbd._handleKeyDown(keyevent('keydown', {code: 'ShiftLeft', key: 'Shift', location: 1}));
+            expect(kbd.onkeyevent).to.have.been.calledOnce;
+            expect(kbd.onkeyevent).to.have.been.calledWith(0xffe1, 'ShiftLeft', true);
+            kbd.onkeyevent.resetHistory();
+
+            kbd._handleKeyDown(keyevent('keydown', {code: 'ShiftRight', key: 'Shift', location: 2}));
+            expect(kbd.onkeyevent).to.have.been.calledOnce;
+            expect(kbd.onkeyevent).to.have.been.calledWith(0xffe2, 'ShiftRight', true);
+            kbd.onkeyevent.resetHistory();
+
+            kbd._handleKeyUp(keyevent('keyup', {code: 'ShiftLeft', key: 'Shift', location: 1}));
+            expect(kbd.onkeyevent).to.have.been.calledTwice;
+            expect(kbd.onkeyevent).to.have.been.calledWith(0xffe2, 'ShiftRight', false);
+            expect(kbd.onkeyevent).to.have.been.calledWith(0xffe1, 'ShiftLeft', false);
+        });
+
+        it('should fake a right Shift keyup', function () {
+            const kbd = new Keyboard(document);
+            kbd.onkeyevent = sinon.spy();
+
+            kbd._handleKeyDown(keyevent('keydown', {code: 'ShiftLeft', key: 'Shift', location: 1}));
+            expect(kbd.onkeyevent).to.have.been.calledOnce;
+            expect(kbd.onkeyevent).to.have.been.calledWith(0xffe1, 'ShiftLeft', true);
+            kbd.onkeyevent.resetHistory();
+
+            kbd._handleKeyDown(keyevent('keydown', {code: 'ShiftRight', key: 'Shift', location: 2}));
+            expect(kbd.onkeyevent).to.have.been.calledOnce;
+            expect(kbd.onkeyevent).to.have.been.calledWith(0xffe2, 'ShiftRight', true);
+            kbd.onkeyevent.resetHistory();
+
+            kbd._handleKeyUp(keyevent('keyup', {code: 'ShiftRight', key: 'Shift', location: 2}));
+            expect(kbd.onkeyevent).to.have.been.calledTwice;
+            expect(kbd.onkeyevent).to.have.been.calledWith(0xffe2, 'ShiftRight', false);
+            expect(kbd.onkeyevent).to.have.been.calledWith(0xffe1, 'ShiftLeft', false);
+        });
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.localization.js
@@ -0,0 +1,69 @@
+const expect = chai.expect;
+import { l10n } from '../app/localization.js';
+
+describe('Localization', function () {
+    "use strict";
+
+    describe('language selection', function () {
+        let origNavigator;
+        beforeEach(function () {
+            // window.navigator is a protected read-only property in many
+            // environments, so we need to redefine it whilst running these
+            // tests.
+            origNavigator = Object.getOwnPropertyDescriptor(window, "navigator");
+
+            Object.defineProperty(window, "navigator", {value: {}});
+            if (window.navigator.languages !== undefined) {
+                // Object.defineProperty() doesn't work properly in old
+                // versions of Chrome
+                this.skip();
+            }
+
+            window.navigator.languages = [];
+        });
+        afterEach(function () {
+            if (origNavigator !== undefined) {
+                Object.defineProperty(window, "navigator", origNavigator);
+            }
+        });
+
+        it('should use English by default', function () {
+            expect(l10n.language).to.equal('en');
+        });
+        it('should use English if no user language matches', function () {
+            window.navigator.languages = ["nl", "de"];
+            l10n.setup(["es", "fr"]);
+            expect(l10n.language).to.equal('en');
+        });
+        it('should use the most preferred user language', function () {
+            window.navigator.languages = ["nl", "de", "fr"];
+            l10n.setup(["es", "fr", "de"]);
+            expect(l10n.language).to.equal('de');
+        });
+        it('should prefer sub-languages languages', function () {
+            window.navigator.languages = ["pt-BR"];
+            l10n.setup(["pt", "pt-BR"]);
+            expect(l10n.language).to.equal('pt-BR');
+        });
+        it('should fall back to language "parents"', function () {
+            window.navigator.languages = ["pt-BR"];
+            l10n.setup(["fr", "pt", "de"]);
+            expect(l10n.language).to.equal('pt');
+        });
+        it('should not use specific language when user asks for a generic language', function () {
+            window.navigator.languages = ["pt", "de"];
+            l10n.setup(["fr", "pt-BR", "de"]);
+            expect(l10n.language).to.equal('de');
+        });
+        it('should handle underscore as a separator', function () {
+            window.navigator.languages = ["pt-BR"];
+            l10n.setup(["pt_BR"]);
+            expect(l10n.language).to.equal('pt_BR');
+        });
+        it('should handle difference in case', function () {
+            window.navigator.languages = ["pt-br"];
+            l10n.setup(["pt-BR"]);
+            expect(l10n.language).to.equal('pt-BR');
+        });
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.ra2.js
@@ -0,0 +1,357 @@
+const expect = chai.expect;
+
+import RFB from '../core/rfb.js';
+
+import FakeWebSocket from './fake.websocket.js';
+
+function fakeGetRandomValues(arr) {
+    if (arr.length === 16) {
+        arr.set(new Uint8Array([
+            0x1c, 0x08, 0xfe, 0x21, 0x78, 0xef, 0x4e, 0xf9,
+            0x3f, 0x05, 0xec, 0xea, 0xd4, 0x6b, 0xa5, 0xd5,
+        ]));
+    } else {
+        arr.set(new Uint8Array([
+            0xee, 0xe2, 0xf1, 0x5a, 0x3c, 0xa7, 0xbe, 0x95,
+            0x6f, 0x2a, 0x75, 0xfd, 0x62, 0x01, 0xcb, 0xbf,
+            0x43, 0x74, 0xca, 0x47, 0x4d, 0xfb, 0x0f, 0xcf,
+            0x3a, 0x6d, 0x55, 0x6b, 0x59, 0x3a, 0xf6, 0x87,
+            0xcb, 0x03, 0xb7, 0x28, 0x35, 0x7b, 0x15, 0x8e,
+            0xb6, 0xc8, 0x8f, 0x2d, 0x5e, 0x7b, 0x1c, 0x9a,
+            0x32, 0x55, 0xe7, 0x64, 0x36, 0x25, 0x7b, 0xa3,
+            0xe9, 0x4f, 0x6f, 0x97, 0xdc, 0xa4, 0xd4, 0x62,
+            0x6d, 0x7f, 0xab, 0x02, 0x6b, 0x13, 0x56, 0x69,
+            0xfb, 0xd0, 0xd4, 0x13, 0x76, 0xcd, 0x0d, 0xd0,
+            0x1f, 0xd1, 0x0c, 0x63, 0x3a, 0x34, 0x20, 0x6c,
+            0xbb, 0x60, 0x45, 0x82, 0x23, 0xfd, 0x7c, 0x77,
+            0x6d, 0xcc, 0x5e, 0xaa, 0xc3, 0x0c, 0x43, 0xb7,
+            0x8d, 0xc0, 0x27, 0x6e, 0xeb, 0x1d, 0x6c, 0x5f,
+            0xd8, 0x1c, 0x3c, 0x1c, 0x60, 0x2e, 0x82, 0x15,
+            0xfd, 0x2e, 0x5f, 0x3a, 0x15, 0x53, 0x14, 0x70,
+            0x4f, 0xe1, 0x65, 0x68, 0x35, 0x6d, 0xc7, 0x64,
+            0xdb, 0xdd, 0x09, 0x31, 0x4f, 0x7b, 0x6d, 0x6c,
+            0x77, 0x59, 0x5e, 0x1e, 0xfa, 0x4b, 0x06, 0x14,
+            0xbe, 0xdc, 0x9c, 0x3d, 0x7b, 0xed, 0xf3, 0x2b,
+            0x19, 0x26, 0x11, 0x8e, 0x3f, 0xab, 0x73, 0x9a,
+            0x0a, 0x3a, 0xaa, 0x85, 0x06, 0xd5, 0xca, 0x3f,
+            0xc3, 0xe2, 0x33, 0x7f, 0x97, 0x74, 0x98, 0x8f,
+            0x2f, 0xa5, 0xfc, 0x7e, 0xb1, 0x77, 0x71, 0x58,
+            0xf0, 0xbc, 0x04, 0x59, 0xbb, 0xb4, 0xc6, 0xcc,
+            0x0f, 0x06, 0xcd, 0xa2, 0xd5, 0x01, 0x2f, 0xb2,
+            0x22, 0x0b, 0xfc, 0x1e, 0x59, 0x9f, 0xd3, 0x4f,
+            0x30, 0x95, 0xc6, 0x80, 0x0f, 0x69, 0xf3, 0x4a,
+            0xd4, 0x36, 0xb6, 0x5a, 0x0b, 0x16, 0x0d, 0x81,
+            0x31, 0xb0, 0x69, 0xd4, 0x4e,
+        ]));
+    }
+}
+
+async function fakeGeneratekey() {
+    let key = JSON.parse('{"alg":"RSA-OAEP-256","d":"B7QR2yI8sXjo8vQhJpX9odqqR\
+6wIuPrTM1B1JJEKVeSrr7OYcc1FRJ52Vap9LIAU-ezigs9QDvWMxknB8motLnG69Wck37nt9_z4s8l\
+FQp0nROA-oaR92HW34KNL1b2fEVWGI0N86h730MvTJC5O2cmKeMezIG-oNqbbfFyP8AW-WLdDlgZm1\
+1-FjzhbVpb0Bc7nRSgBPSV-EY6Sl-LuglxDx4LaTdQW7QE_WXoRUt-GYGfTseuFQQK5WeoyX3yBtQy\
+dpauW6rrgyWdtP4hDFIoZsX6w1i-UMWMMwlIB5FdnUSi26igVGADGpV_vGMP36bv-EHp0bY-Qp0gpI\
+fLfgQ","dp":"Z1v5UceFfV2bhmbG19eGYb30jFxqoRBq36PKNY7IunMs1keYy0FpLbyGhtgMZ1Ymm\
+c8wEzGYsCPEP-ykcun_rlyu7YxmcnyC9YQqTqLyqvO-7rUqDvk9TMfdqWFP6heADRhKZmEbmcau6_m\
+2MwwK9kOkMKWvpqp8_TpJMnAH7zE","dq":"OBacRE15aY3NtCR4cvP5os3sT70JbDdDLHT3IHZM6r\
+E35CYNpLDia2chm_wnMcYvKFW9zC2ajRZ15i9c_VXQzS7ZlTaQYBFyMt7kVhxMEMFsPv1crD6t3uEI\
+j0LNuNYyy0jkon_LPZKQFK654CiL-L2YaNXOH4HbHP02dWeVQIE","e":"AQAB","ext":true,"ke\
+y_ops":["decrypt"],"kty":"RSA","n":"m1c92ZFk9ZI6l_O4YFiNxbv0Ng94SB3yThy1P_mcqr\
+GDQkRiGVdcTxAk38T9PgLztmspF-6U5TAHO-gSmmW88AC9m6f1Mspps6r7zl-M_OG-TwvGzf3BDz8z\
+Eg1FPbZV7whO1M4TCAZ0PqwG7qCc6nK1WiAhaKrSpzuPdL1igfNBsX7qu5wgw4ZTTGSLbVC_LfULQ5\
+FADgFTRXUSaxm1F8C_Lwy6a2e4nTcXilmtN2IHUjHegzm-Tq2HizmR3ARdWJpESYIW5-AXoiqj29tD\
+rqCmu2WPkB2psVp83IzZfaQNQzjNfvA8GpimkcDCkP5VMRrtKCcG4ZAFnO-A3NBX_Q","p":"2Q_lN\
+L7vCOBzAppYzCZo3WSh0hX-MOZyPUznks5U2TjmfdNZoL6_FJRiGyyLvwSiZFdEAAvpAyESFfFigng\
+AqMLSf448nPg15VUGj533CotsEM0WpoEr1JCgqdUbgDAfJQIBcwOmegBqd7lWm7uzEnRCvouB70ybk\
+JfpdprhkVE","q":"tzTt-F3g2u_3Ctj26Ho9iN_wC_W0lXGzslLt5nLmss8JqdLoDDrijjU-gjeRh\
+7lgiuHdUc3dorfFKbaMNOjoW3QKqt9oZ1JM0HKeRw0X2PnWW_0WK6DK5ASWDTXbMq2sUZqJvYEyL74\
+H2Zrt0RPAux7XQLEVgND6ROdXnMJ70O0","qi":"qfl4cXQkz4BNqa2De0-PfdU-8d1w3onnaGqx1D\
+s2fHzD_SJ4cNghn2TksoT9Qo64b3pUjH9igi2pyEjomk6D12N6FG0e10u7vFKv3W5YqUOgTpYdbcWH\
+dZ2qZWJU0XQZIrF8jLGTOO4GYP6_9sJ5R7Wk_0MdqQy8qvixWD4zLcY"}');
+    key = await window.crypto.subtle.importKey("jwk", key, {
+        name: "RSA-OAEP",
+        hash: {name: "SHA-256"}
+    }, true, ["decrypt"]);
+    return {privateKey: key};
+}
+
+const receiveData = new Uint8Array([
+    // server public key
+    0x00, 0x00, 0x08, 0x00, 0xac, 0x1a, 0xbc, 0x42,
+    0x8a, 0x2a, 0x69, 0x65, 0x54, 0xf8, 0x9a, 0xe6,
+    0x43, 0xaa, 0xf7, 0x27, 0xf6, 0x2a, 0xf8, 0x8f,
+    0x36, 0xd4, 0xae, 0x54, 0x0f, 0x16, 0x28, 0x08,
+    0xc2, 0x5b, 0xca, 0x23, 0xdc, 0x27, 0x88, 0x1a,
+    0x12, 0x82, 0xa8, 0x54, 0xea, 0x00, 0x99, 0x8d,
+    0x02, 0x1d, 0x77, 0x4a, 0xeb, 0xd0, 0x93, 0x40,
+    0x79, 0x86, 0xcb, 0x37, 0xd4, 0xb2, 0xc7, 0xcd,
+    0x93, 0xe1, 0x00, 0x4d, 0x86, 0xff, 0x97, 0x33,
+    0x0c, 0xad, 0x51, 0x47, 0x45, 0x85, 0x56, 0x07,
+    0x65, 0x21, 0x7c, 0x57, 0x6d, 0x68, 0x7d, 0xd7,
+    0x00, 0x43, 0x0c, 0x9d, 0x3b, 0xa1, 0x5a, 0x11,
+    0xed, 0x51, 0x77, 0xf9, 0xd1, 0x5b, 0x33, 0xd7,
+    0x1a, 0xeb, 0x65, 0x57, 0xc0, 0x01, 0x51, 0xff,
+    0x9b, 0x82, 0xb3, 0xeb, 0x82, 0xc2, 0x1f, 0xca,
+    0x47, 0xc0, 0x6a, 0x09, 0xe0, 0xf7, 0xda, 0x39,
+    0x85, 0x12, 0xe7, 0x45, 0x8d, 0xb4, 0x1a, 0xda,
+    0xcb, 0x86, 0x58, 0x52, 0x37, 0x66, 0x9d, 0x8a,
+    0xce, 0xf2, 0x18, 0x78, 0x7d, 0x7f, 0xf0, 0x07,
+    0x94, 0x8e, 0x6b, 0x17, 0xd9, 0x00, 0x2a, 0x3a,
+    0xb9, 0xd4, 0x77, 0xde, 0x70, 0x85, 0xc4, 0x3a,
+    0x62, 0x10, 0x02, 0xee, 0xba, 0xd8, 0xc0, 0x62,
+    0xd0, 0x8e, 0xc1, 0x98, 0x19, 0x8e, 0x39, 0x0f,
+    0x3e, 0x1d, 0x61, 0xb1, 0x93, 0x13, 0x59, 0x39,
+    0xcb, 0x96, 0xf2, 0x17, 0xc9, 0xe1, 0x41, 0xd3,
+    0x20, 0xdd, 0x62, 0x5e, 0x7d, 0x53, 0xd6, 0xb7,
+    0x1d, 0xfe, 0x02, 0x18, 0x1f, 0xe0, 0xef, 0x3d,
+    0x94, 0xe3, 0x0a, 0x9c, 0x59, 0x54, 0xd8, 0x98,
+    0x16, 0x9c, 0x31, 0xda, 0x41, 0x0f, 0x2e, 0x71,
+    0x68, 0xe0, 0xa2, 0x62, 0x3e, 0xe5, 0x25, 0x31,
+    0xcf, 0xfc, 0x67, 0x63, 0xc3, 0xb0, 0xda, 0x3f,
+    0x7b, 0x59, 0xbe, 0x7e, 0x9e, 0xa8, 0xd0, 0x01,
+    0x4f, 0x43, 0x7f, 0x8d, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x01, 0x00, 0x01,
+    // server random
+    0x01, 0x00, 0x5b, 0x58, 0x2a, 0x96, 0x2d, 0xbb,
+    0x88, 0xec, 0xc3, 0x54, 0x00, 0xf3, 0xbb, 0xbe,
+    0x17, 0xa3, 0x84, 0xd3, 0xef, 0xd8, 0x4a, 0x31,
+    0x09, 0x20, 0xdd, 0xbc, 0x16, 0x9d, 0xc9, 0x5b,
+    0x99, 0x62, 0x86, 0xfe, 0x0b, 0x28, 0x4b, 0xfe,
+    0x5b, 0x56, 0x2d, 0xcb, 0x6e, 0x6f, 0xec, 0xf0,
+    0x53, 0x0c, 0x33, 0x84, 0x93, 0xc9, 0xbf, 0x79,
+    0xde, 0xb3, 0xb9, 0x29, 0x60, 0x78, 0xde, 0xe6,
+    0x1d, 0xa7, 0x89, 0x48, 0x3f, 0xd1, 0x58, 0x66,
+    0x27, 0x9c, 0xd4, 0x6e, 0x72, 0x9c, 0x6e, 0x4a,
+    0xc0, 0x69, 0x79, 0x6f, 0x79, 0x0f, 0x13, 0xc4,
+    0x20, 0xcf, 0xa6, 0xbb, 0xce, 0x18, 0x6d, 0xd5,
+    0x9e, 0xd9, 0x67, 0xbe, 0x61, 0x43, 0x67, 0x11,
+    0x76, 0x2f, 0xfd, 0x78, 0x75, 0x2b, 0x89, 0x35,
+    0xdd, 0x0f, 0x13, 0x7f, 0xee, 0x78, 0xad, 0x32,
+    0x56, 0x21, 0x81, 0x08, 0x1f, 0xcf, 0x4c, 0x29,
+    0xa3, 0xeb, 0x89, 0x2d, 0xbe, 0xba, 0x8d, 0xe4,
+    0x69, 0x28, 0xba, 0x53, 0x82, 0xce, 0x5c, 0xf6,
+    0x5e, 0x5e, 0xa5, 0xb3, 0x88, 0xd8, 0x3d, 0xab,
+    0xf4, 0x24, 0x9e, 0x3f, 0x04, 0xaf, 0xdc, 0x48,
+    0x90, 0x53, 0x37, 0xe6, 0x82, 0x1d, 0xe0, 0x15,
+    0x91, 0xa1, 0xc6, 0xa9, 0x54, 0xe5, 0x2a, 0xb5,
+    0x64, 0x2d, 0x93, 0xc0, 0xc0, 0xe1, 0x0f, 0x6a,
+    0x4b, 0xdb, 0x77, 0xf8, 0x4a, 0x0f, 0x83, 0x36,
+    0xdd, 0x5e, 0x1e, 0xdd, 0x39, 0x65, 0xa2, 0x11,
+    0xc2, 0xcf, 0x56, 0x1e, 0xa1, 0x29, 0xae, 0x11,
+    0x9f, 0x3a, 0x82, 0xc7, 0xbd, 0x89, 0x6e, 0x59,
+    0xb8, 0x59, 0x17, 0xcb, 0x65, 0xa0, 0x4b, 0x4d,
+    0xbe, 0x33, 0x32, 0x85, 0x9c, 0xca, 0x5e, 0x95,
+    0xc2, 0x5a, 0xd0, 0xc9, 0x8b, 0xf1, 0xf5, 0x14,
+    0xcf, 0x76, 0x80, 0xc2, 0x24, 0x0a, 0x39, 0x7e,
+    0x60, 0x64, 0xce, 0xd9, 0xb8, 0xad, 0x24, 0xa8,
+    0xdf, 0xcb,
+    // server hash
+    0x00, 0x14, 0x39, 0x30, 0x66, 0xb5, 0x66, 0x8a,
+    0xcd, 0xb9, 0xda, 0xe0, 0xde, 0xcb, 0xf6, 0x47,
+    0x5f, 0x54, 0x66, 0xe0, 0xbc, 0x49, 0x37, 0x01,
+    0xf2, 0x9e, 0xef, 0xcc, 0xcd, 0x4d, 0x6c, 0x0e,
+    0xc6, 0xab, 0x28, 0xd4, 0x7b, 0x13,
+    // subtype
+    0x00, 0x01, 0x30, 0x2a, 0xc3, 0x0b, 0xc2, 0x1c,
+    0xeb, 0x02, 0x44, 0x92, 0x5d, 0xfd, 0xf9, 0xa7,
+    0x94, 0xd0, 0x19,
+]);
+
+const sendData = new Uint8Array([
+    // client public key
+    0x00, 0x00, 0x08, 0x00, 0x9b, 0x57, 0x3d, 0xd9,
+    0x91, 0x64, 0xf5, 0x92, 0x3a, 0x97, 0xf3, 0xb8,
+    0x60, 0x58, 0x8d, 0xc5, 0xbb, 0xf4, 0x36, 0x0f,
+    0x78, 0x48, 0x1d, 0xf2, 0x4e, 0x1c, 0xb5, 0x3f,
+    0xf9, 0x9c, 0xaa, 0xb1, 0x83, 0x42, 0x44, 0x62,
+    0x19, 0x57, 0x5c, 0x4f, 0x10, 0x24, 0xdf, 0xc4,
+    0xfd, 0x3e, 0x02, 0xf3, 0xb6, 0x6b, 0x29, 0x17,
+    0xee, 0x94, 0xe5, 0x30, 0x07, 0x3b, 0xe8, 0x12,
+    0x9a, 0x65, 0xbc, 0xf0, 0x00, 0xbd, 0x9b, 0xa7,
+    0xf5, 0x32, 0xca, 0x69, 0xb3, 0xaa, 0xfb, 0xce,
+    0x5f, 0x8c, 0xfc, 0xe1, 0xbe, 0x4f, 0x0b, 0xc6,
+    0xcd, 0xfd, 0xc1, 0x0f, 0x3f, 0x33, 0x12, 0x0d,
+    0x45, 0x3d, 0xb6, 0x55, 0xef, 0x08, 0x4e, 0xd4,
+    0xce, 0x13, 0x08, 0x06, 0x74, 0x3e, 0xac, 0x06,
+    0xee, 0xa0, 0x9c, 0xea, 0x72, 0xb5, 0x5a, 0x20,
+    0x21, 0x68, 0xaa, 0xd2, 0xa7, 0x3b, 0x8f, 0x74,
+    0xbd, 0x62, 0x81, 0xf3, 0x41, 0xb1, 0x7e, 0xea,
+    0xbb, 0x9c, 0x20, 0xc3, 0x86, 0x53, 0x4c, 0x64,
+    0x8b, 0x6d, 0x50, 0xbf, 0x2d, 0xf5, 0x0b, 0x43,
+    0x91, 0x40, 0x0e, 0x01, 0x53, 0x45, 0x75, 0x12,
+    0x6b, 0x19, 0xb5, 0x17, 0xc0, 0xbf, 0x2f, 0x0c,
+    0xba, 0x6b, 0x67, 0xb8, 0x9d, 0x37, 0x17, 0x8a,
+    0x59, 0xad, 0x37, 0x62, 0x07, 0x52, 0x31, 0xde,
+    0x83, 0x39, 0xbe, 0x4e, 0xad, 0x87, 0x8b, 0x39,
+    0x91, 0xdc, 0x04, 0x5d, 0x58, 0x9a, 0x44, 0x49,
+    0x82, 0x16, 0xe7, 0xe0, 0x17, 0xa2, 0x2a, 0xa3,
+    0xdb, 0xdb, 0x43, 0xae, 0xa0, 0xa6, 0xbb, 0x65,
+    0x8f, 0x90, 0x1d, 0xa9, 0xb1, 0x5a, 0x7c, 0xdc,
+    0x8c, 0xd9, 0x7d, 0xa4, 0x0d, 0x43, 0x38, 0xcd,
+    0x7e, 0xf0, 0x3c, 0x1a, 0x98, 0xa6, 0x91, 0xc0,
+    0xc2, 0x90, 0xfe, 0x55, 0x31, 0x1a, 0xed, 0x28,
+    0x27, 0x06, 0xe1, 0x90, 0x05, 0x9c, 0xef, 0x80,
+    0xdc, 0xd0, 0x57, 0xfd, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x01, 0x00, 0x01,
+    // client random
+    0x01, 0x00, 0x84, 0x7f, 0x26, 0x54, 0x74, 0xf6,
+    0x47, 0xaf, 0x33, 0x64, 0x0d, 0xa6, 0xe5, 0x30,
+    0xba, 0xe6, 0xe4, 0x8e, 0x50, 0x40, 0x71, 0x1c,
+    0x0e, 0x06, 0x63, 0xf5, 0x07, 0x2a, 0x26, 0x68,
+    0xd6, 0xcf, 0xa6, 0x80, 0x84, 0x5e, 0x64, 0xd4,
+    0x5e, 0x62, 0x31, 0xfe, 0x44, 0x51, 0x0b, 0x7c,
+    0x4d, 0x55, 0xc5, 0x4a, 0x7e, 0x0d, 0x4d, 0x9b,
+    0x84, 0xb4, 0x32, 0x2b, 0x4d, 0x8a, 0x34, 0x8d,
+    0xc8, 0xcf, 0x19, 0x3b, 0x64, 0x82, 0x27, 0x9e,
+    0xa7, 0x70, 0x2a, 0xc1, 0xb8, 0xf3, 0x6a, 0x3a,
+    0xf2, 0x75, 0x6e, 0x1d, 0xeb, 0xb6, 0x70, 0x7a,
+    0x15, 0x18, 0x38, 0x00, 0xb4, 0x4f, 0x55, 0xb5,
+    0xd8, 0x03, 0x4e, 0xb8, 0x53, 0xff, 0x80, 0x62,
+    0xf1, 0x9d, 0x27, 0xe8, 0x2a, 0x3d, 0x98, 0x19,
+    0x32, 0x09, 0x7e, 0x9a, 0xb0, 0xc7, 0x46, 0x23,
+    0x10, 0x85, 0x35, 0x00, 0x96, 0xce, 0xb3, 0x2c,
+    0x84, 0x8d, 0xf4, 0x9e, 0xa8, 0x42, 0x67, 0xed,
+    0x09, 0xa6, 0x09, 0x97, 0xb3, 0x64, 0x26, 0xfb,
+    0x71, 0x11, 0x9b, 0x3f, 0xbb, 0x57, 0xb8, 0x5b,
+    0x2e, 0xc5, 0x2d, 0x8c, 0x5c, 0xf7, 0xef, 0x27,
+    0x25, 0x88, 0x42, 0x45, 0x43, 0xa4, 0xe7, 0xde,
+    0xea, 0xf9, 0x15, 0x7b, 0x5d, 0x66, 0x24, 0xce,
+    0xf7, 0xc8, 0x2f, 0xc5, 0xc0, 0x3d, 0xcd, 0xf2,
+    0x62, 0xfc, 0x1a, 0x5e, 0xec, 0xff, 0xf1, 0x1b,
+    0xc8, 0xdb, 0xc1, 0x0f, 0x54, 0x66, 0x9e, 0xfd,
+    0x99, 0x9b, 0x23, 0x70, 0x62, 0x37, 0x80, 0xad,
+    0x91, 0x6b, 0x84, 0x85, 0x6a, 0x4c, 0x80, 0x9e,
+    0x60, 0x8a, 0x93, 0xa3, 0xc8, 0x8e, 0xc4, 0x4b,
+    0x4d, 0xb4, 0x8e, 0x3e, 0xaf, 0xce, 0xcd, 0x83,
+    0xe5, 0x21, 0x90, 0x95, 0x20, 0x3c, 0x82, 0xb4,
+    0x7c, 0xab, 0x63, 0x9c, 0xae, 0xc3, 0xc9, 0x71,
+    0x1a, 0xec, 0x34, 0x18, 0x47, 0xec, 0x5c, 0x4d,
+    0xed, 0x84,
+    // client hash
+    0x00, 0x14, 0x9c, 0x91, 0x9e, 0x76, 0xcf, 0x1e,
+    0x66, 0x87, 0x5e, 0x29, 0xf1, 0x13, 0x80, 0xea,
+    0x7d, 0xec, 0xae, 0xf9, 0x60, 0x01, 0xd3, 0x6f,
+    0xb7, 0x9e, 0xb2, 0xcd, 0x2d, 0xc8, 0xf8, 0x84,
+    0xb2, 0x9f, 0xc3, 0x7e, 0xb4, 0xbe,
+    // credentials
+    0x00, 0x08, 0x9d, 0xc8, 0x3a, 0xb8, 0x80, 0x4f,
+    0xe3, 0x52, 0xdb, 0x62, 0x9e, 0x97, 0x64, 0x82,
+    0xa8, 0xa1, 0x6b, 0x7e, 0x4d, 0x68, 0x8c, 0x29,
+    0x91, 0x38,
+]);
+
+describe('RA2 handshake', function () {
+    let sock;
+    let rfb;
+    let sentData;
+
+    before(() => {
+        FakeWebSocket.replace();
+        sinon.stub(window.crypto, "getRandomValues").callsFake(fakeGetRandomValues);
+        sinon.stub(window.crypto.subtle, "generateKey").callsFake(fakeGeneratekey);
+    });
+    after(() => {
+        FakeWebSocket.restore();
+        window.crypto.getRandomValues.restore();
+        window.crypto.subtle.generateKey.restore();
+    });
+
+    it('should fire the serververification event', function (done) {
+        sentData = new Uint8Array();
+        rfb = new RFB(document.createElement('div'), "ws://example.com");
+        sock = rfb._sock;
+        sock.send = (data) => {
+            let res = new Uint8Array(sentData.length + data.length);
+            res.set(sentData);
+            res.set(data, sentData.length);
+            sentData = res;
+        };
+        rfb._rfbInitState = "Security";
+        rfb._rfbVersion = 3.8;
+        sock._websocket._receiveData(new Uint8Array([1, 6]));
+        rfb.addEventListener("serververification", (e) => {
+            expect(e.detail.publickey).to.eql(receiveData.slice(0, 516));
+            done();
+        });
+        sock._websocket._receiveData(receiveData);
+    });
+
+    it('should handle approveServer and fire the credentialsrequired event', function (done) {
+        rfb.addEventListener("credentialsrequired", (e) => {
+            expect(e.detail.types).to.eql(["password"]);
+            done();
+        });
+        rfb.approveServer();
+    });
+
+    it('should match sendData after sending credentials', function (done) {
+        rfb.addEventListener("securityresult", (event) => {
+            expect(sentData.slice(1)).to.eql(sendData);
+            done();
+        });
+        rfb.sendCredentials({ "password": "123456" });
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.raw.js
@@ -0,0 +1,129 @@
+const expect = chai.expect;
+
+import Websock from '../core/websock.js';
+import Display from '../core/display.js';
+
+import RawDecoder from '../core/decoders/raw.js';
+
+import FakeWebSocket from './fake.websocket.js';
+
+function testDecodeRect(decoder, x, y, width, height, data, display, depth) {
+    let sock;
+
+    sock = new Websock;
+    sock.open("ws://example.com");
+
+    sock.on('message', () => {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    });
+
+    // Empty messages are filtered at multiple layers, so we need to
+    // do a direct call
+    if (data.length === 0) {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    } else {
+        sock._websocket._receiveData(new Uint8Array(data));
+    }
+
+    display.flip();
+}
+
+describe('Raw Decoder', function () {
+    let decoder;
+    let display;
+
+    before(FakeWebSocket.replace);
+    after(FakeWebSocket.restore);
+
+    beforeEach(function () {
+        decoder = new RawDecoder();
+        display = new Display(document.createElement('canvas'));
+        display.resize(4, 4);
+    });
+
+    it('should handle the Raw encoding', function () {
+        testDecodeRect(decoder, 0, 0, 2, 2,
+                       [0xff, 0x00, 0x00, 0, 0x00, 0xff, 0x00, 0,
+                        0x00, 0xff, 0x00, 0, 0xff, 0x00, 0x00, 0],
+                       display, 24);
+        testDecodeRect(decoder, 2, 0, 2, 2,
+                       [0x00, 0x00, 0xff, 0, 0x00, 0x00, 0xff, 0,
+                        0x00, 0x00, 0xff, 0, 0x00, 0x00, 0xff, 0],
+                       display, 24);
+        testDecodeRect(decoder, 0, 2, 4, 1,
+                       [0xee, 0x00, 0xff, 0, 0x00, 0xee, 0xff, 0,
+                        0xaa, 0xee, 0xff, 0, 0xab, 0xee, 0xff, 0],
+                       display, 24);
+        testDecodeRect(decoder, 0, 3, 4, 1,
+                       [0xee, 0x00, 0xff, 0, 0x00, 0xee, 0xff, 0,
+                        0xaa, 0xee, 0xff, 0, 0xab, 0xee, 0xff, 0],
+                       display, 24);
+
+        let targetData = new Uint8Array([
+            0xff, 0x00, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0xff, 0x00, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0xee, 0x00, 0xff, 255, 0x00, 0xee, 0xff, 255, 0xaa, 0xee, 0xff, 255, 0xab, 0xee, 0xff, 255,
+            0xee, 0x00, 0xff, 255, 0x00, 0xee, 0xff, 255, 0xaa, 0xee, 0xff, 255, 0xab, 0xee, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle the Raw encoding in low colour mode', function () {
+        testDecodeRect(decoder, 0, 0, 2, 2,
+                       [0x30, 0x30, 0x30, 0x30],
+                       display, 8);
+        testDecodeRect(decoder, 2, 0, 2, 2,
+                       [0x0c, 0x0c, 0x0c, 0x0c],
+                       display, 8);
+        testDecodeRect(decoder, 0, 2, 4, 1,
+                       [0x0c, 0x0c, 0x30, 0x30],
+                       display, 8);
+        testDecodeRect(decoder, 0, 3, 4, 1,
+                       [0x0c, 0x0c, 0x30, 0x30],
+                       display, 8);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle empty rects', function () {
+        display.fillRect(0, 0, 4, 4, [ 0x00, 0x00, 0xff ]);
+        display.fillRect(2, 0, 2, 2, [ 0x00, 0xff, 0x00 ]);
+        display.fillRect(0, 2, 2, 2, [ 0x00, 0xff, 0x00 ]);
+
+        testDecodeRect(decoder, 1, 2, 0, 0, [], display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle empty rects in low colour mode', function () {
+        display.fillRect(0, 0, 4, 4, [ 0x00, 0x00, 0xff ]);
+        display.fillRect(2, 0, 2, 2, [ 0x00, 0xff, 0x00 ]);
+        display.fillRect(0, 2, 2, 2, [ 0x00, 0xff, 0x00 ]);
+
+        testDecodeRect(decoder, 1, 2, 0, 0, [], display, 8);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.rfb.js
@@ -0,0 +1,4224 @@
+const expect = chai.expect;
+
+import RFB from '../core/rfb.js';
+import Websock from '../core/websock.js';
+import ZStream from "../vendor/pako/lib/zlib/zstream.js";
+import { deflateInit, deflate } from "../vendor/pako/lib/zlib/deflate.js";
+import { encodings } from '../core/encodings.js';
+import { toUnsigned32bit } from '../core/util/int.js';
+import { encodeUTF8 } from '../core/util/strings.js';
+import KeyTable from '../core/input/keysym.js';
+
+import FakeWebSocket from './fake.websocket.js';
+
+function push8(arr, num) {
+    "use strict";
+    arr.push(num & 0xFF);
+}
+
+function push16(arr, num) {
+    "use strict";
+    arr.push((num >> 8) & 0xFF,
+             num & 0xFF);
+}
+
+function push32(arr, num) {
+    "use strict";
+    arr.push((num >> 24) & 0xFF,
+             (num >> 16) & 0xFF,
+             (num >>  8) & 0xFF,
+             num & 0xFF);
+}
+
+function pushString(arr, string) {
+    let utf8 = unescape(encodeURIComponent(string));
+    for (let i = 0; i < utf8.length; i++) {
+        arr.push(utf8.charCodeAt(i));
+    }
+}
+
+function deflateWithSize(data) {
+    // Adds the size of the string in front before deflating
+
+    let unCompData = [];
+    unCompData.push((data.length >> 24) & 0xFF,
+                    (data.length >> 16) & 0xFF,
+                    (data.length >>  8) & 0xFF,
+                    (data.length & 0xFF));
+
+    for (let i = 0; i < data.length; i++) {
+        unCompData.push(data.charCodeAt(i));
+    }
+
+    let strm = new ZStream();
+    let chunkSize = 1024 * 10 * 10;
+    strm.output = new Uint8Array(chunkSize);
+    deflateInit(strm, 5);
+
+    /* eslint-disable camelcase */
+    strm.input = unCompData;
+    strm.avail_in = strm.input.length;
+    strm.next_in = 0;
+    strm.next_out = 0;
+    strm.avail_out = chunkSize;
+    /* eslint-enable camelcase */
+
+    deflate(strm, 3);
+
+    return new Uint8Array(strm.output.buffer, 0, strm.next_out);
+}
+
+describe('Remote Frame Buffer Protocol Client', function () {
+    let clock;
+    let raf;
+    let fakeResizeObserver = null;
+    const realObserver = window.ResizeObserver;
+
+    // Since we are using fake timers we don't actually want
+    // to wait for the browser to observe the size change,
+    // that's why we use a fake ResizeObserver
+    class FakeResizeObserver {
+        constructor(handler) {
+            this.fire = handler;
+            fakeResizeObserver = this;
+        }
+        disconnect() {}
+        observe(target, options) {}
+        unobserve(target) {}
+    }
+
+    before(FakeWebSocket.replace);
+    after(FakeWebSocket.restore);
+
+    before(function () {
+        this.clock = clock = sinon.useFakeTimers(Date.now());
+        // sinon doesn't support this yet
+        raf = window.requestAnimationFrame;
+        window.requestAnimationFrame = setTimeout;
+        // We must do this in a 'before' since it needs to be set before
+        // the RFB constructor, which runs in beforeEach further down
+        window.ResizeObserver = FakeResizeObserver;
+        // Use a single set of buffers instead of reallocating to
+        // speed up tests
+        const sock = new Websock();
+        const _sQ = new Uint8Array(sock._sQbufferSize);
+        const rQ = new Uint8Array(sock._rQbufferSize);
+
+        Websock.prototype._oldAllocateBuffers = Websock.prototype._allocateBuffers;
+        Websock.prototype._allocateBuffers = function () {
+            this._sQ = _sQ;
+            this._rQ = rQ;
+        };
+
+        // Avoiding printing the entire Websock buffer on errors
+        Websock.prototype.toString = function () { return "[object Websock]"; };
+    });
+
+    after(function () {
+        delete Websock.prototype.toString;
+        this.clock.restore();
+        window.requestAnimationFrame = raf;
+        window.ResizeObserver = realObserver;
+    });
+
+    let container;
+    let rfbs;
+
+    beforeEach(function () {
+        // Create a container element for all RFB objects to attach to
+        container = document.createElement('div');
+        container.style.width = "100%";
+        container.style.height = "100%";
+        document.body.appendChild(container);
+
+        // And track all created RFB objects
+        rfbs = [];
+    });
+    afterEach(function () {
+        // Make sure every created RFB object is properly cleaned up
+        // or they might affect subsequent tests
+        rfbs.forEach(function (rfb) {
+            rfb.disconnect();
+            expect(rfb._disconnect).to.have.been.called;
+        });
+        rfbs = [];
+
+        document.body.removeChild(container);
+        container = null;
+    });
+
+    function makeRFB(url, options) {
+        url = url || 'wss://host:8675';
+        const rfb = new RFB(container, url, options);
+        clock.tick();
+        rfb._sock._websocket._open();
+        rfb._rfbConnectionState = 'connected';
+        sinon.spy(rfb, "_disconnect");
+        rfbs.push(rfb);
+        return rfb;
+    }
+
+    describe('Connecting/Disconnecting', function () {
+        describe('#RFB (constructor)', function () {
+            let open, attach;
+            beforeEach(function () {
+                open = sinon.spy(Websock.prototype, 'open');
+                attach = sinon.spy(Websock.prototype, 'attach');
+            });
+            afterEach(function () {
+                open.restore();
+                attach.restore();
+            });
+
+            it('should actually connect to the websocket', function () {
+                new RFB(document.createElement('div'), 'ws://HOST:8675/PATH');
+                expect(open).to.have.been.calledOnceWithExactly('ws://HOST:8675/PATH', []);
+            });
+
+            it('should pass on connection problems', function () {
+                open.restore();
+                open = sinon.stub(Websock.prototype, 'open');
+                open.throws(new Error('Failure'));
+                expect(() => new RFB(document.createElement('div'), 'ws://HOST:8675/PATH')).to.throw('Failure');
+            });
+
+            it('should handle WebSocket/RTCDataChannel objects', function () {
+                let sock = new FakeWebSocket('ws://HOST:8675/PATH', []);
+                new RFB(document.createElement('div'), sock);
+                expect(open).to.not.have.been.called;
+                expect(attach).to.have.been.calledOnceWithExactly(sock);
+            });
+
+            it('should handle already open WebSocket/RTCDataChannel objects', function () {
+                let sock = new FakeWebSocket('ws://HOST:8675/PATH', []);
+                sock._open();
+                const client = new RFB(document.createElement('div'), sock);
+                let callback = sinon.spy();
+                client.addEventListener('disconnect', callback);
+                expect(open).to.not.have.been.called;
+                expect(attach).to.have.been.calledOnceWithExactly(sock);
+                // Check if it is ready for some data
+                sock._receiveData(new Uint8Array(['R', 'F', 'B', '0', '0', '3', '0', '0', '8']));
+                expect(callback).to.not.have.been.called;
+            });
+
+            it('should refuse closed WebSocket/RTCDataChannel objects', function () {
+                let sock = new FakeWebSocket('ws://HOST:8675/PATH', []);
+                sock.readyState = WebSocket.CLOSED;
+                expect(() => new RFB(document.createElement('div'), sock)).to.throw();
+            });
+
+            it('should pass on attach problems', function () {
+                attach.restore();
+                attach = sinon.stub(Websock.prototype, 'attach');
+                attach.throws(new Error('Failure'));
+                let sock = new FakeWebSocket('ws://HOST:8675/PATH', []);
+                expect(() => new RFB(document.createElement('div'), sock)).to.throw('Failure');
+            });
+        });
+
+        describe('#disconnect', function () {
+            let client;
+            let close;
+
+            beforeEach(function () {
+                client = makeRFB();
+                close = sinon.stub(Websock.prototype, "close");
+            });
+            afterEach(function () {
+                close.restore();
+            });
+
+            it('should start closing WebSocket', function () {
+                let callback = sinon.spy();
+                client.addEventListener('disconnect', callback);
+                client.disconnect();
+                expect(close).to.have.been.calledOnceWithExactly();
+                expect(callback).to.not.have.been.called;
+            });
+
+            it('should send disconnect event', function () {
+                let callback = sinon.spy();
+                client.addEventListener('disconnect', callback);
+                client.disconnect();
+                close.thisValues[0]._eventHandlers.close(new CloseEvent("close", { 'code': 1000, 'reason': "", 'wasClean': true }));
+                expect(callback).to.have.been.calledOnce;
+                expect(callback.args[0][0].detail.clean).to.be.true;
+            });
+
+            it('should force disconnect if disconnecting takes too long', function () {
+                let callback = sinon.spy();
+                client.addEventListener('disconnect', callback);
+                client.disconnect();
+                this.clock.tick(3 * 1000);
+                expect(callback).to.have.been.calledOnce;
+                expect(callback.args[0][0].detail.clean).to.be.true;
+            });
+
+            it('should not fail if disconnect completes before timeout', function () {
+                let callback = sinon.spy();
+                client.addEventListener('disconnect', callback);
+                client.disconnect();
+                client._updateConnectionState('disconnecting');
+                this.clock.tick(3 * 1000 / 2);
+                close.thisValues[0]._eventHandlers.close(new CloseEvent("close", { 'code': 1000, 'reason': "", 'wasClean': true }));
+                this.clock.tick(3 * 1000 / 2 + 1);
+                expect(callback).to.have.been.calledOnce;
+                expect(callback.args[0][0].detail.clean).to.be.true;
+            });
+
+            it('should unregister error event handler', function () {
+                sinon.spy(client._sock, 'off');
+                client.disconnect();
+                expect(client._sock.off).to.have.been.calledWith('error');
+            });
+
+            it('should unregister message event handler', function () {
+                sinon.spy(client._sock, 'off');
+                client.disconnect();
+                expect(client._sock.off).to.have.been.calledWith('message');
+            });
+
+            it('should unregister open event handler', function () {
+                sinon.spy(client._sock, 'off');
+                client.disconnect();
+                expect(client._sock.off).to.have.been.calledWith('open');
+            });
+        });
+
+        describe('#sendCredentials', function () {
+            let client;
+            beforeEach(function () {
+                client = makeRFB();
+                client._rfbConnectionState = 'connecting';
+            });
+
+            it('should set the rfb credentials properly"', function () {
+                client.sendCredentials({ password: 'pass' });
+                expect(client._rfbCredentials).to.deep.equal({ password: 'pass' });
+            });
+
+            it('should call initMsg "soon"', function () {
+                client._initMsg = sinon.spy();
+                client.sendCredentials({ password: 'pass' });
+                this.clock.tick(5);
+                expect(client._initMsg).to.have.been.calledOnce;
+            });
+        });
+    });
+
+    describe('Public API Basic Behavior', function () {
+        let client;
+        beforeEach(function () {
+            client = makeRFB();
+        });
+
+        describe('#sendCtrlAlDel', function () {
+            it('should sent ctrl[down]-alt[down]-del[down] then del[up]-alt[up]-ctrl[up]', function () {
+                const expected = {_sQ: new Uint8Array(48), _sQlen: 0, flush: () => {}};
+                RFB.messages.keyEvent(expected, 0xFFE3, 1);
+                RFB.messages.keyEvent(expected, 0xFFE9, 1);
+                RFB.messages.keyEvent(expected, 0xFFFF, 1);
+                RFB.messages.keyEvent(expected, 0xFFFF, 0);
+                RFB.messages.keyEvent(expected, 0xFFE9, 0);
+                RFB.messages.keyEvent(expected, 0xFFE3, 0);
+
+                client.sendCtrlAltDel();
+                expect(client._sock).to.have.sent(expected._sQ);
+            });
+
+            it('should not send the keys if we are not in a normal state', function () {
+                sinon.spy(client._sock, 'flush');
+                client._rfbConnectionState = "connecting";
+                client.sendCtrlAltDel();
+                expect(client._sock.flush).to.not.have.been.called;
+            });
+
+            it('should not send the keys if we are set as view_only', function () {
+                sinon.spy(client._sock, 'flush');
+                client._viewOnly = true;
+                client.sendCtrlAltDel();
+                expect(client._sock.flush).to.not.have.been.called;
+            });
+        });
+
+        describe('#sendKey', function () {
+            it('should send a single key with the given code and state (down = true)', function () {
+                const expected = {_sQ: new Uint8Array(8), _sQlen: 0, flush: () => {}};
+                RFB.messages.keyEvent(expected, 123, 1);
+                client.sendKey(123, 'Key123', true);
+                expect(client._sock).to.have.sent(expected._sQ);
+            });
+
+            it('should send both a down and up event if the state is not specified', function () {
+                const expected = {_sQ: new Uint8Array(16), _sQlen: 0, flush: () => {}};
+                RFB.messages.keyEvent(expected, 123, 1);
+                RFB.messages.keyEvent(expected, 123, 0);
+                client.sendKey(123, 'Key123');
+                expect(client._sock).to.have.sent(expected._sQ);
+            });
+
+            it('should not send the key if we are not in a normal state', function () {
+                sinon.spy(client._sock, 'flush');
+                client._rfbConnectionState = "connecting";
+                client.sendKey(123, 'Key123');
+                expect(client._sock.flush).to.not.have.been.called;
+            });
+
+            it('should not send the key if we are set as view_only', function () {
+                sinon.spy(client._sock, 'flush');
+                client._viewOnly = true;
+                client.sendKey(123, 'Key123');
+                expect(client._sock.flush).to.not.have.been.called;
+            });
+
+            it('should send QEMU extended events if supported', function () {
+                client._qemuExtKeyEventSupported = true;
+                const expected = {_sQ: new Uint8Array(12), _sQlen: 0, flush: () => {}};
+                RFB.messages.QEMUExtendedKeyEvent(expected, 0x20, true, 0x0039);
+                client.sendKey(0x20, 'Space', true);
+                expect(client._sock).to.have.sent(expected._sQ);
+            });
+
+            it('should not send QEMU extended events if unknown key code', function () {
+                client._qemuExtKeyEventSupported = true;
+                const expected = {_sQ: new Uint8Array(8), _sQlen: 0, flush: () => {}};
+                RFB.messages.keyEvent(expected, 123, 1);
+                client.sendKey(123, 'FooBar', true);
+                expect(client._sock).to.have.sent(expected._sQ);
+            });
+        });
+
+        describe('#focus', function () {
+            it('should move focus to canvas object', function () {
+                client._canvas.focus = sinon.spy();
+                client.focus();
+                expect(client._canvas.focus).to.have.been.calledOnce;
+            });
+
+            it('should include focus options', function () {
+                client._canvas.focus = sinon.spy();
+                client.focus({ foobar: 12, gazonk: true });
+                expect(client._canvas.focus).to.have.been.calledOnce;
+                expect(client._canvas.focus).to.have.been.calledWith({ foobar: 12, gazonk: true});
+            });
+        });
+
+        describe('#blur', function () {
+            it('should remove focus from canvas object', function () {
+                client._canvas.blur = sinon.spy();
+                client.blur();
+                expect(client._canvas.blur).to.have.been.calledOnce;
+            });
+        });
+
+        describe('#clipboardPasteFrom', function () {
+            describe('Clipboard update handling', function () {
+                beforeEach(function () {
+                    sinon.spy(RFB.messages, 'clientCutText');
+                    sinon.spy(RFB.messages, 'extendedClipboardNotify');
+                });
+
+                afterEach(function () {
+                    RFB.messages.clientCutText.restore();
+                    RFB.messages.extendedClipboardNotify.restore();
+                });
+
+                it('should send the given text in an clipboard update', function () {
+                    client.clipboardPasteFrom('abc');
+
+                    expect(RFB.messages.clientCutText).to.have.been.calledOnce;
+                    expect(RFB.messages.clientCutText).to.have.been.calledWith(client._sock,
+                                                                               new Uint8Array([97, 98, 99]));
+                });
+
+                it('should send an notify if extended clipboard is supported by server', function () {
+                    // Send our capabilities
+                    let data = [3, 0, 0, 0];
+                    const flags = [0x1F, 0x00, 0x00, 0x01];
+                    let fileSizes = [0x00, 0x00, 0x00, 0x1E];
+
+                    push32(data, toUnsigned32bit(-8));
+                    data = data.concat(flags);
+                    data = data.concat(fileSizes);
+                    client._sock._websocket._receiveData(new Uint8Array(data));
+
+                    client.clipboardPasteFrom('extended test');
+                    expect(RFB.messages.extendedClipboardNotify).to.have.been.calledOnce;
+                });
+            });
+
+            it('should flush multiple times for large clipboards', function () {
+                sinon.spy(client._sock, 'flush');
+                let longText = "";
+                for (let i = 0; i < client._sock._sQbufferSize + 100; i++) {
+                    longText += 'a';
+                }
+                client.clipboardPasteFrom(longText);
+                expect(client._sock.flush).to.have.been.calledTwice;
+            });
+
+            it('should not send the text if we are not in a normal state', function () {
+                sinon.spy(client._sock, 'flush');
+                client._rfbConnectionState = "connecting";
+                client.clipboardPasteFrom('abc');
+                expect(client._sock.flush).to.not.have.been.called;
+            });
+        });
+
+        describe("XVP operations", function () {
+            beforeEach(function () {
+                client._rfbXvpVer = 1;
+            });
+
+            it('should send the shutdown signal on #machineShutdown', function () {
+                client.machineShutdown();
+                expect(client._sock).to.have.sent(new Uint8Array([0xFA, 0x00, 0x01, 0x02]));
+            });
+
+            it('should send the reboot signal on #machineReboot', function () {
+                client.machineReboot();
+                expect(client._sock).to.have.sent(new Uint8Array([0xFA, 0x00, 0x01, 0x03]));
+            });
+
+            it('should send the reset signal on #machineReset', function () {
+                client.machineReset();
+                expect(client._sock).to.have.sent(new Uint8Array([0xFA, 0x00, 0x01, 0x04]));
+            });
+
+            it('should not send XVP operations with higher versions than we support', function () {
+                sinon.spy(client._sock, 'flush');
+                client._xvpOp(2, 7);
+                expect(client._sock.flush).to.not.have.been.called;
+            });
+        });
+    });
+
+    describe('Clipping', function () {
+        let client;
+
+        beforeEach(function () {
+            client = makeRFB();
+            container.style.width = '70px';
+            container.style.height = '80px';
+            client.clipViewport = true;
+        });
+
+        it('should update display clip state when changing the property', function () {
+            const spy = sinon.spy(client._display, "clipViewport", ["set"]);
+
+            client.clipViewport = false;
+            expect(spy.set).to.have.been.calledOnce;
+            expect(spy.set).to.have.been.calledWith(false);
+            spy.set.resetHistory();
+
+            client.clipViewport = true;
+            expect(spy.set).to.have.been.calledOnce;
+            expect(spy.set).to.have.been.calledWith(true);
+        });
+
+        it('should update the viewport when the container size changes', function () {
+            sinon.spy(client._display, "viewportChangeSize");
+
+            container.style.width = '40px';
+            container.style.height = '50px';
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            expect(client._display.viewportChangeSize).to.have.been.calledOnce;
+            expect(client._display.viewportChangeSize).to.have.been.calledWith(40, 50);
+        });
+
+        it('should update the viewport when the remote session resizes', function () {
+            // Simple ExtendedDesktopSize FBU message
+            const incoming = [ 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+                               0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0xfe, 0xcc,
+                               0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                               0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff,
+                               0x00, 0x00, 0x00, 0x00 ];
+
+            sinon.spy(client._display, "viewportChangeSize");
+
+            client._sock._websocket._receiveData(new Uint8Array(incoming));
+            // The resize will cause scrollbars on the container, this causes a
+            // resize observation in the browsers
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            // FIXME: Display implicitly calls viewportChangeSize() when
+            //        resizing the framebuffer, hence calledTwice.
+            expect(client._display.viewportChangeSize).to.have.been.calledTwice;
+            expect(client._display.viewportChangeSize).to.have.been.calledWith(70, 80);
+        });
+
+        it('should not update the viewport if not clipping', function () {
+            client.clipViewport = false;
+            sinon.spy(client._display, "viewportChangeSize");
+
+            container.style.width = '40px';
+            container.style.height = '50px';
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            expect(client._display.viewportChangeSize).to.not.have.been.called;
+        });
+
+        it('should not update the viewport if scaling', function () {
+            client.scaleViewport = true;
+            sinon.spy(client._display, "viewportChangeSize");
+
+            container.style.width = '40px';
+            container.style.height = '50px';
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            expect(client._display.viewportChangeSize).to.not.have.been.called;
+        });
+
+        describe('Clipping and remote resize', function () {
+            beforeEach(function () {
+                // Given a remote (100, 100) larger than the container (70x80),
+                client._resize(100, 100);
+                client._supportsSetDesktopSize = true;
+                client.resizeSession = true;
+                sinon.spy(RFB.messages, "setDesktopSize");
+            });
+            afterEach(function () {
+                RFB.messages.setDesktopSize.restore();
+            });
+            it('should not change remote size when changing clipping', function () {
+                // When changing clipping the scrollbars of the container
+                // will appear and disappear and thus trigger resize observations
+                client.clipViewport = false;
+                fakeResizeObserver.fire();
+                clock.tick(1000);
+                client.clipViewport = true;
+                fakeResizeObserver.fire();
+                clock.tick(1000);
+
+                // Then no resize requests should be sent
+                expect(RFB.messages.setDesktopSize).to.not.have.been.called;
+            });
+        });
+
+        describe('Dragging', function () {
+            beforeEach(function () {
+                client.dragViewport = true;
+                sinon.spy(RFB.messages, "pointerEvent");
+            });
+
+            afterEach(function () {
+                RFB.messages.pointerEvent.restore();
+            });
+
+            it('should not send button messages when initiating viewport dragging', function () {
+                client._handleMouseButton(13, 9, 0x001);
+                expect(RFB.messages.pointerEvent).to.not.have.been.called;
+            });
+
+            it('should send button messages when release without movement', function () {
+                // Just up and down
+                client._handleMouseButton(13, 9, 0x001);
+                client._handleMouseButton(13, 9, 0x000);
+                expect(RFB.messages.pointerEvent).to.have.been.calledTwice;
+
+                RFB.messages.pointerEvent.resetHistory();
+
+                // Small movement
+                client._handleMouseButton(13, 9, 0x001);
+                client._handleMouseMove(15, 14);
+                client._handleMouseButton(15, 14, 0x000);
+                expect(RFB.messages.pointerEvent).to.have.been.calledTwice;
+            });
+
+            it('should not send button messages when in view only', function () {
+                client._viewOnly = true;
+                client._handleMouseButton(13, 9, 0x001);
+                client._handleMouseButton(13, 9, 0x000);
+                expect(RFB.messages.pointerEvent).to.not.have.been.called;
+            });
+
+            it('should send button message directly when drag is disabled', function () {
+                client.dragViewport = false;
+                client._handleMouseButton(13, 9, 0x001);
+                expect(RFB.messages.pointerEvent).to.have.been.calledOnce;
+            });
+
+            it('should be initiate viewport dragging on sufficient movement', function () {
+                sinon.spy(client._display, "viewportChangePos");
+
+                // Too small movement
+
+                client._handleMouseButton(13, 9, 0x001);
+                client._handleMouseMove(18, 9);
+
+                expect(RFB.messages.pointerEvent).to.not.have.been.called;
+                expect(client._display.viewportChangePos).to.not.have.been.called;
+
+                // Sufficient movement
+
+                client._handleMouseMove(43, 9);
+
+                expect(RFB.messages.pointerEvent).to.not.have.been.called;
+                expect(client._display.viewportChangePos).to.have.been.calledOnce;
+                expect(client._display.viewportChangePos).to.have.been.calledWith(-30, 0);
+
+                client._display.viewportChangePos.resetHistory();
+
+                // Now a small movement should move right away
+
+                client._handleMouseMove(43, 14);
+
+                expect(RFB.messages.pointerEvent).to.not.have.been.called;
+                expect(client._display.viewportChangePos).to.have.been.calledOnce;
+                expect(client._display.viewportChangePos).to.have.been.calledWith(0, -5);
+            });
+
+            it('should not send button messages when dragging ends', function () {
+                // First the movement
+
+                client._handleMouseButton(13, 9, 0x001);
+                client._handleMouseMove(43, 9);
+                client._handleMouseButton(43, 9, 0x000);
+
+                expect(RFB.messages.pointerEvent).to.not.have.been.called;
+            });
+
+            it('should terminate viewport dragging on a button up event', function () {
+                // First the dragging movement
+
+                client._handleMouseButton(13, 9, 0x001);
+                client._handleMouseMove(43, 9);
+                client._handleMouseButton(43, 9, 0x000);
+
+                // Another movement now should not move the viewport
+
+                sinon.spy(client._display, "viewportChangePos");
+
+                client._handleMouseMove(43, 59);
+
+                expect(client._display.viewportChangePos).to.not.have.been.called;
+            });
+        });
+    });
+
+    describe('Scaling', function () {
+        let client;
+        beforeEach(function () {
+            client = makeRFB();
+            container.style.width = '70px';
+            container.style.height = '80px';
+            client.scaleViewport = true;
+        });
+
+        it('should update display scale factor when changing the property', function () {
+            const spy = sinon.spy(client._display, "scale", ["set"]);
+            sinon.spy(client._display, "autoscale");
+
+            client.scaleViewport = false;
+            expect(spy.set).to.have.been.calledOnce;
+            expect(spy.set).to.have.been.calledWith(1.0);
+            expect(client._display.autoscale).to.not.have.been.called;
+
+            client.scaleViewport = true;
+            expect(client._display.autoscale).to.have.been.calledOnce;
+            expect(client._display.autoscale).to.have.been.calledWith(70, 80);
+        });
+
+        it('should update the clipping setting when changing the property', function () {
+            client.clipViewport = true;
+
+            const spy = sinon.spy(client._display, "clipViewport", ["set"]);
+
+            client.scaleViewport = false;
+            expect(spy.set).to.have.been.calledOnce;
+            expect(spy.set).to.have.been.calledWith(true);
+
+            spy.set.resetHistory();
+
+            client.scaleViewport = true;
+            expect(spy.set).to.have.been.calledOnce;
+            expect(spy.set).to.have.been.calledWith(false);
+        });
+
+        it('should update the scaling when the container size changes', function () {
+            sinon.spy(client._display, "autoscale");
+
+            container.style.width = '40px';
+            container.style.height = '50px';
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            expect(client._display.autoscale).to.have.been.calledOnce;
+            expect(client._display.autoscale).to.have.been.calledWith(40, 50);
+        });
+
+        it('should update the scaling when the remote session resizes', function () {
+            // Simple ExtendedDesktopSize FBU message
+            const incoming = [ 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+                               0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0xfe, 0xcc,
+                               0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                               0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff,
+                               0x00, 0x00, 0x00, 0x00 ];
+
+            sinon.spy(client._display, "autoscale");
+
+            client._sock._websocket._receiveData(new Uint8Array(incoming));
+            // The resize will cause scrollbars on the container, this causes a
+            // resize observation in the browsers
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            expect(client._display.autoscale).to.have.been.calledOnce;
+            expect(client._display.autoscale).to.have.been.calledWith(70, 80);
+        });
+
+        it('should not update the display scale factor if not scaling', function () {
+            client.scaleViewport = false;
+
+            sinon.spy(client._display, "autoscale");
+
+            container.style.width = '40px';
+            container.style.height = '50px';
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            expect(client._display.autoscale).to.not.have.been.called;
+        });
+    });
+
+    describe('Remote resize', function () {
+        let client;
+        beforeEach(function () {
+            client = makeRFB();
+            client._supportsSetDesktopSize = true;
+            client.resizeSession = true;
+            container.style.width = '70px';
+            container.style.height = '80px';
+            sinon.spy(RFB.messages, "setDesktopSize");
+        });
+
+        afterEach(function () {
+            RFB.messages.setDesktopSize.restore();
+        });
+
+        it('should only request a resize when turned on', function () {
+            client.resizeSession = false;
+            expect(RFB.messages.setDesktopSize).to.not.have.been.called;
+            client.resizeSession = true;
+            expect(RFB.messages.setDesktopSize).to.have.been.calledOnce;
+        });
+
+        it('should request a resize when initially connecting', function () {
+            // Simple ExtendedDesktopSize FBU message
+            const incoming = [ 0x00,        // msg-type=FBU
+                               0x00,        // padding
+                               0x00, 0x01,  // number of rects = 1
+                               0x00, 0x00,  // reason = server initialized
+                               0x00, 0x00,  // status = no error
+                               0x00, 0x04,  // new width = 4
+                               0x00, 0x04,  // new height = 4
+                               0xff, 0xff,
+                               0xfe, 0xcc,  // enc = (-308) ExtendedDesktopSize
+                               0x01,        // number of screens = 1
+                               0x00, 0x00,
+                               0x00,        // padding
+                               0x00, 0x00,
+                               0x00, 0x00,  // screen id = 0
+                               0x00, 0x00,  // screen x = 0
+                               0x00, 0x00,  // screen y = 0
+                               0x00, 0x04,  // screen width = 4
+                               0x00, 0x04,  // screen height = 4
+                               0x00, 0x00,
+                               0x00, 0x00]; // screen flags
+
+            // This property is indirectly used as a marker for the first update
+            client._supportsSetDesktopSize = false;
+
+            // First message should trigger a resize
+
+            client._sock._websocket._receiveData(new Uint8Array(incoming));
+
+            // It should match the current size of the container,
+            // not the reported size from the server
+            expect(RFB.messages.setDesktopSize).to.have.been.calledOnce;
+            expect(RFB.messages.setDesktopSize).to.have.been.calledWith(
+                sinon.match.object, 70, 80, 0, 0);
+
+            RFB.messages.setDesktopSize.resetHistory();
+
+            // Second message should not trigger a resize
+
+            client._sock._websocket._receiveData(new Uint8Array(incoming));
+
+            expect(RFB.messages.setDesktopSize).to.not.have.been.called;
+        });
+
+        it('should request a resize when the container resizes', function () {
+            container.style.width = '40px';
+            container.style.height = '50px';
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            expect(RFB.messages.setDesktopSize).to.have.been.calledOnce;
+            expect(RFB.messages.setDesktopSize).to.have.been.calledWith(sinon.match.object, 40, 50, 0, 0);
+        });
+
+        it('should not request the same size twice', function () {
+            container.style.width = '40px';
+            container.style.height = '50px';
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            expect(RFB.messages.setDesktopSize).to.have.been.calledOnce;
+            expect(RFB.messages.setDesktopSize).to.have.been.calledWith(
+                sinon.match.object, 40, 50, 0, 0);
+
+            // Server responds with the requested size 40x50
+            const incoming = [ 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
+                               0x00, 0x28, 0x00, 0x32, 0xff, 0xff, 0xfe, 0xcc,
+                               0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                               0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x32,
+                               0x00, 0x00, 0x00, 0x00];
+
+            client._sock._websocket._receiveData(new Uint8Array(incoming));
+            clock.tick(1000);
+
+            RFB.messages.setDesktopSize.resetHistory();
+
+            // size is still 40x50
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            expect(RFB.messages.setDesktopSize).to.not.have.been.called;
+        });
+
+        it('should not resize until the container size is stable', function () {
+            container.style.width = '20px';
+            container.style.height = '30px';
+            fakeResizeObserver.fire();
+            clock.tick(400);
+
+            expect(RFB.messages.setDesktopSize).to.not.have.been.called;
+
+            container.style.width = '40px';
+            container.style.height = '50px';
+            fakeResizeObserver.fire();
+            clock.tick(400);
+
+            expect(RFB.messages.setDesktopSize).to.not.have.been.called;
+
+            clock.tick(200);
+
+            expect(RFB.messages.setDesktopSize).to.have.been.calledOnce;
+            expect(RFB.messages.setDesktopSize).to.have.been.calledWith(sinon.match.object, 40, 50, 0, 0);
+        });
+
+        it('should not resize when resize is disabled', function () {
+            client._resizeSession = false;
+
+            container.style.width = '40px';
+            container.style.height = '50px';
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            expect(RFB.messages.setDesktopSize).to.not.have.been.called;
+        });
+
+        it('should not resize when resize is not supported', function () {
+            client._supportsSetDesktopSize = false;
+
+            container.style.width = '40px';
+            container.style.height = '50px';
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            expect(RFB.messages.setDesktopSize).to.not.have.been.called;
+        });
+
+        it('should not resize when in view only mode', function () {
+            client._viewOnly = true;
+
+            container.style.width = '40px';
+            container.style.height = '50px';
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            expect(RFB.messages.setDesktopSize).to.not.have.been.called;
+        });
+
+        it('should not try to override a server resize', function () {
+            // Simple ExtendedDesktopSize FBU message, new size: 100x100
+            const incoming = [ 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+                               0x00, 0x64, 0x00, 0x64, 0xff, 0xff, 0xfe, 0xcc,
+                               0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                               0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04,
+                               0x00, 0x00, 0x00, 0x00 ];
+
+            // Note that this will cause the browser to display scrollbars
+            // since the framebuffer is 100x100 and the container is 70x80.
+            // The usable space (clientWidth/clientHeight) will be even smaller
+            // due to the scrollbars taking up space.
+            client._sock._websocket._receiveData(new Uint8Array(incoming));
+            // The scrollbars cause the ResizeObserver to fire
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            expect(RFB.messages.setDesktopSize).to.not.have.been.called;
+
+            // An actual size change must not be ignored afterwards
+            container.style.width = '120px';
+            container.style.height = '130px';
+            fakeResizeObserver.fire();
+            clock.tick(1000);
+
+            expect(RFB.messages.setDesktopSize).to.have.been.calledOnce;
+            expect(RFB.messages.setDesktopSize.firstCall.args[1]).to.equal(120);
+            expect(RFB.messages.setDesktopSize.firstCall.args[2]).to.equal(130);
+        });
+    });
+
+    describe('Misc Internals', function () {
+        describe('#_fail', function () {
+            let client;
+            beforeEach(function () {
+                client = makeRFB();
+            });
+
+            it('should close the WebSocket connection', function () {
+                sinon.spy(client._sock, 'close');
+                client._fail();
+                expect(client._sock.close).to.have.been.calledOnce;
+            });
+
+            it('should transition to disconnected', function () {
+                sinon.spy(client, '_updateConnectionState');
+                client._fail();
+                this.clock.tick(2000);
+                expect(client._updateConnectionState).to.have.been.called;
+                expect(client._rfbConnectionState).to.equal('disconnected');
+            });
+
+            it('should set clean_disconnect variable', function () {
+                client._rfbCleanDisconnect = true;
+                client._rfbConnectionState = 'connected';
+                client._fail();
+                expect(client._rfbCleanDisconnect).to.be.false;
+            });
+
+            it('should result in disconnect event with clean set to false', function () {
+                client._rfbConnectionState = 'connected';
+                const spy = sinon.spy();
+                client.addEventListener("disconnect", spy);
+                client._fail();
+                this.clock.tick(2000);
+                expect(spy).to.have.been.calledOnce;
+                expect(spy.args[0][0].detail.clean).to.be.false;
+            });
+
+        });
+    });
+
+    describe('Protocol Initialization States', function () {
+        let client;
+        beforeEach(function () {
+            client = makeRFB();
+            client._rfbConnectionState = 'connecting';
+        });
+
+        function sendVer(ver, client) {
+            const arr = new Uint8Array(12);
+            for (let i = 0; i < ver.length; i++) {
+                arr[i+4] = ver.charCodeAt(i);
+            }
+            arr[0] = 'R'; arr[1] = 'F'; arr[2] = 'B'; arr[3] = ' ';
+            arr[11] = '\n';
+            client._sock._websocket._receiveData(arr);
+        }
+
+        function sendSecurity(type, cl) {
+            cl._sock._websocket._receiveData(new Uint8Array([1, type]));
+        }
+
+        describe('ProtocolVersion', function () {
+            describe('version parsing', function () {
+                it('should interpret version 003.003 as version 3.3', function () {
+                    sendVer('003.003', client);
+                    expect(client._rfbVersion).to.equal(3.3);
+                });
+
+                it('should interpret version 003.006 as version 3.3', function () {
+                    sendVer('003.006', client);
+                    expect(client._rfbVersion).to.equal(3.3);
+                });
+
+                it('should interpret version 003.889 as version 3.8', function () {
+                    sendVer('003.889', client);
+                    expect(client._rfbVersion).to.equal(3.8);
+                });
+
+                it('should interpret version 003.007 as version 3.7', function () {
+                    sendVer('003.007', client);
+                    expect(client._rfbVersion).to.equal(3.7);
+                });
+
+                it('should interpret version 003.008 as version 3.8', function () {
+                    sendVer('003.008', client);
+                    expect(client._rfbVersion).to.equal(3.8);
+                });
+
+                it('should interpret version 004.000 as version 3.8', function () {
+                    sendVer('004.000', client);
+                    expect(client._rfbVersion).to.equal(3.8);
+                });
+
+                it('should interpret version 004.001 as version 3.8', function () {
+                    sendVer('004.001', client);
+                    expect(client._rfbVersion).to.equal(3.8);
+                });
+
+                it('should interpret version 005.000 as version 3.8', function () {
+                    sendVer('005.000', client);
+                    expect(client._rfbVersion).to.equal(3.8);
+                });
+
+                it('should fail on an invalid version', function () {
+                    sinon.spy(client, "_fail");
+                    sendVer('002.000', client);
+                    expect(client._fail).to.have.been.calledOnce;
+                });
+            });
+
+            it('should send back the interpreted version', function () {
+                sendVer('004.000', client);
+
+                const expectedStr = 'RFB 003.008\n';
+                const expected = [];
+                for (let i = 0; i < expectedStr.length; i++) {
+                    expected[i] = expectedStr.charCodeAt(i);
+                }
+
+                expect(client._sock).to.have.sent(new Uint8Array(expected));
+            });
+
+            it('should transition to the Security state on successful negotiation', function () {
+                sendVer('003.008', client);
+                expect(client._rfbInitState).to.equal('Security');
+            });
+
+            describe('Repeater', function () {
+                beforeEach(function () {
+                    client = makeRFB('wss://host:8675', { repeaterID: "12345" });
+                    client._rfbConnectionState = 'connecting';
+                });
+
+                it('should interpret version 000.000 as a repeater', function () {
+                    sendVer('000.000', client);
+                    expect(client._rfbVersion).to.equal(0);
+
+                    const sentData = client._sock._websocket._getSentData();
+                    expect(new Uint8Array(sentData.buffer, 0, 9)).to.array.equal(new Uint8Array([73, 68, 58, 49, 50, 51, 52, 53, 0]));
+                    expect(sentData).to.have.length(250);
+                });
+
+                it('should handle two step repeater negotiation', function () {
+                    sendVer('000.000', client);
+                    sendVer('003.008', client);
+                    expect(client._rfbVersion).to.equal(3.8);
+                });
+            });
+        });
+
+        describe('Security', function () {
+            beforeEach(function () {
+                sendVer('003.008\n', client);
+                client._sock._websocket._getSentData();
+            });
+
+            it('should respect server preference order', function () {
+                const authSchemes = [ 6, 79, 30, 188, 16, 6, 1 ];
+                client._sock._websocket._receiveData(new Uint8Array(authSchemes));
+                expect(client._sock).to.have.sent(new Uint8Array([30]));
+            });
+
+            it('should fail if there are no supported schemes', function () {
+                sinon.spy(client, "_fail");
+                const authSchemes = [1, 32];
+                client._sock._websocket._receiveData(new Uint8Array(authSchemes));
+                expect(client._fail).to.have.been.calledOnce;
+            });
+
+            it('should fail with the appropriate message if no types are sent', function () {
+                const failureData = [0, 0, 0, 0, 6, 119, 104, 111, 111, 112, 115];
+                sinon.spy(client, '_fail');
+                client._sock._websocket._receiveData(new Uint8Array(failureData));
+
+                expect(client._fail).to.have.been.calledOnce;
+                expect(client._fail).to.have.been.calledWith(
+                    'Security negotiation failed on no security types (reason: whoops)');
+            });
+
+            it('should transition to the Authentication state and continue on successful negotiation', function () {
+                const authSchemes = [1, 1];
+                client._negotiateAuthentication = sinon.spy();
+                client._sock._websocket._receiveData(new Uint8Array(authSchemes));
+                expect(client._rfbInitState).to.equal('Authentication');
+                expect(client._negotiateAuthentication).to.have.been.calledOnce;
+            });
+        });
+
+        describe('Legacy Authentication', function () {
+            it('should fail on auth scheme 0 (pre 3.7) with the given message', function () {
+                const errMsg = "Whoopsies";
+                const data = [0, 0, 0, 0];
+                const errLen = errMsg.length;
+                push32(data, errLen);
+                for (let i = 0; i < errLen; i++) {
+                    data.push(errMsg.charCodeAt(i));
+                }
+
+                sendVer('003.006\n', client);
+                client._sock._websocket._getSentData();
+
+                sinon.spy(client, '_fail');
+                client._sock._websocket._receiveData(new Uint8Array(data));
+                expect(client._fail).to.have.been.calledWith(
+                    'Security negotiation failed on authentication scheme (reason: Whoopsies)');
+            });
+
+            it('should transition straight to ServerInitialisation on "no auth" for versions < 3.7', function () {
+                sendVer('003.006\n', client);
+                client._sock._websocket._getSentData();
+
+                client._sock._websocket._receiveData(new Uint8Array([0, 0, 0, 1]));
+                expect(client._rfbInitState).to.equal('ServerInitialisation');
+            });
+        });
+
+        describe('Authentication', function () {
+            beforeEach(function () {
+                sendVer('003.008\n', client);
+                client._sock._websocket._getSentData();
+            });
+
+            it('should transition straight to SecurityResult on "no auth" (1)', function () {
+                sendSecurity(1, client);
+                expect(client._rfbInitState).to.equal('SecurityResult');
+            });
+
+            it('should fail on an unknown auth scheme', function () {
+                sinon.spy(client, "_fail");
+                sendSecurity(57, client);
+                expect(client._fail).to.have.been.calledOnce;
+            });
+
+            describe('VNC Authentication (type 2) Handler', function () {
+                it('should fire the credentialsrequired event if missing a password', function () {
+                    const spy = sinon.spy();
+                    client.addEventListener("credentialsrequired", spy);
+                    sendSecurity(2, client);
+
+                    const challenge = [];
+                    for (let i = 0; i < 16; i++) { challenge[i] = i; }
+                    client._sock._websocket._receiveData(new Uint8Array(challenge));
+
+                    expect(client._rfbCredentials).to.be.empty;
+                    expect(spy).to.have.been.calledOnce;
+                    expect(spy.args[0][0].detail.types).to.have.members(["password"]);
+                });
+
+                it('should encrypt the password with DES and then send it back', function () {
+                    client._rfbCredentials = { password: 'passwd' };
+                    sendSecurity(2, client);
+                    client._sock._websocket._getSentData(); // skip the choice of auth reply
+
+                    const challenge = [];
+                    for (let i = 0; i < 16; i++) { challenge[i] = i; }
+                    client._sock._websocket._receiveData(new Uint8Array(challenge));
+
+                    const desPass = RFB.genDES('passwd', challenge);
+                    expect(client._sock).to.have.sent(new Uint8Array(desPass));
+                });
+
+                it('should transition to SecurityResult immediately after sending the password', function () {
+                    client._rfbCredentials = { password: 'passwd' };
+                    sendSecurity(2, client);
+
+                    const challenge = [];
+                    for (let i = 0; i < 16; i++) { challenge[i] = i; }
+                    client._sock._websocket._receiveData(new Uint8Array(challenge));
+
+                    expect(client._rfbInitState).to.equal('SecurityResult');
+                });
+            });
+
+            describe('ARD Authentication (type 30) Handler', function () {
+                it('should fire the credentialsrequired event if all credentials are missing', function () {
+                    const spy = sinon.spy();
+                    client.addEventListener("credentialsrequired", spy);
+                    client._rfbCredentials = {};
+                    sendSecurity(30, client);
+
+                    expect(client._rfbCredentials).to.be.empty;
+                    expect(spy).to.have.been.calledOnce;
+                    expect(spy.args[0][0].detail.types).to.have.members(["username", "password"]);
+                });
+
+                it('should fire the credentialsrequired event if some credentials are missing', function () {
+                    const spy = sinon.spy();
+                    client.addEventListener("credentialsrequired", spy);
+                    client._rfbCredentials = { password: 'password'};
+                    sendSecurity(30, client);
+
+                    expect(spy).to.have.been.calledOnce;
+                    expect(spy.args[0][0].detail.types).to.have.members(["username", "password"]);
+                });
+
+                it('should return properly encrypted credentials and public key', async function () {
+                    client._rfbCredentials = { username: 'user',
+                                               password: 'password' };
+                    sendSecurity(30, client);
+
+                    expect(client._sock).to.have.sent([30]);
+
+                    function byteArray(length) {
+                        return Array.from(new Uint8Array(length).keys());
+                    }
+
+                    let generator = [127, 255];
+                    let prime = byteArray(128);
+                    let serverPrivateKey = byteArray(128);
+                    let serverPublicKey = client._modPow(generator, serverPrivateKey, prime);
+
+                    let clientPrivateKey = byteArray(128);
+                    let clientPublicKey = client._modPow(generator, clientPrivateKey, prime);
+
+                    let padding = Array.from(byteArray(64), byte => String.fromCharCode(65+byte%26)).join('');
+
+                    await client._negotiateARDAuthAsync(generator, 128, prime, serverPublicKey, clientPrivateKey, padding);
+
+                    client._negotiateARDAuth();
+
+                    expect(client._rfbInitState).to.equal('SecurityResult');
+
+                    let expectEncrypted = new Uint8Array([
+                        232, 234, 159, 162, 170, 180, 138, 104, 164, 49, 53, 96, 20, 36, 21, 15,
+                        217, 219, 107, 173, 196, 60, 96, 142, 215, 71, 13, 185, 185, 47, 5, 175,
+                        151, 30, 194, 55, 173, 214, 141, 161, 36, 138, 146, 3, 178, 89, 43, 248,
+                        131, 134, 205, 174, 9, 150, 171, 74, 222, 201, 20, 2, 30, 168, 162, 123,
+                        46, 86, 81, 221, 44, 211, 180, 247, 221, 61, 95, 155, 157, 241, 76, 76,
+                        49, 217, 234, 75, 147, 237, 199, 159, 93, 140, 191, 174, 52, 90, 133, 58,
+                        243, 81, 112, 182, 64, 62, 149, 7, 151, 28, 36, 161, 247, 247, 36, 96,
+                        230, 95, 58, 207, 46, 183, 100, 139, 143, 155, 224, 43, 219, 3, 71, 139]);
+
+                    let output = new Uint8Array(256);
+                    output.set(expectEncrypted, 0);
+                    output.set(clientPublicKey, 128);
+
+                    expect(client._sock).to.have.sent(output);
+                });
+            });
+
+            describe('XVP Authentication (type 22) Handler', function () {
+                it('should fall through to standard VNC authentication upon completion', function () {
+                    client._rfbCredentials = { username: 'user',
+                                               target: 'target',
+                                               password: 'password' };
+                    client._negotiateStdVNCAuth = sinon.spy();
+                    sendSecurity(22, client);
+                    expect(client._negotiateStdVNCAuth).to.have.been.calledOnce;
+                });
+
+                it('should fire the credentialsrequired event if all credentials are missing', function () {
+                    const spy = sinon.spy();
+                    client.addEventListener("credentialsrequired", spy);
+                    client._rfbCredentials = {};
+                    sendSecurity(22, client);
+
+                    expect(client._rfbCredentials).to.be.empty;
+                    expect(spy).to.have.been.calledOnce;
+                    expect(spy.args[0][0].detail.types).to.have.members(["username", "password", "target"]);
+                });
+
+                it('should fire the credentialsrequired event if some credentials are missing', function () {
+                    const spy = sinon.spy();
+                    client.addEventListener("credentialsrequired", spy);
+                    client._rfbCredentials = { username: 'user',
+                                               target: 'target' };
+                    sendSecurity(22, client);
+
+                    expect(spy).to.have.been.calledOnce;
+                    expect(spy.args[0][0].detail.types).to.have.members(["username", "password", "target"]);
+                });
+
+                it('should send user and target separately', function () {
+                    client._rfbCredentials = { username: 'user',
+                                               target: 'target',
+                                               password: 'password' };
+                    client._negotiateStdVNCAuth = sinon.spy();
+
+                    sendSecurity(22, client);
+
+                    const expected = [22, 4, 6]; // auth selection, len user, len target
+                    for (let i = 0; i < 10; i++) { expected[i+3] = 'usertarget'.charCodeAt(i); }
+
+                    expect(client._sock).to.have.sent(new Uint8Array(expected));
+                });
+            });
+
+            describe('TightVNC Authentication (type 16) Handler', function () {
+                beforeEach(function () {
+                    sendSecurity(16, client);
+                    client._sock._websocket._getSentData();  // skip the security reply
+                });
+
+                function sendNumStrPairs(pairs, client) {
+                    const data = [];
+                    push32(data, pairs.length);
+
+                    for (let i = 0; i < pairs.length; i++) {
+                        push32(data, pairs[i][0]);
+                        for (let j = 0; j < 4; j++) {
+                            data.push(pairs[i][1].charCodeAt(j));
+                        }
+                        for (let j = 0; j < 8; j++) {
+                            data.push(pairs[i][2].charCodeAt(j));
+                        }
+                    }
+
+                    client._sock._websocket._receiveData(new Uint8Array(data));
+                }
+
+                it('should skip tunnel negotiation if no tunnels are requested', function () {
+                    client._sock._websocket._receiveData(new Uint8Array([0, 0, 0, 0]));
+                    expect(client._rfbTightVNC).to.be.true;
+                });
+
+                it('should fail if no supported tunnels are listed', function () {
+                    sinon.spy(client, "_fail");
+                    sendNumStrPairs([[123, 'OTHR', 'SOMETHNG']], client);
+                    expect(client._fail).to.have.been.calledOnce;
+                });
+
+                it('should choose the notunnel tunnel type', function () {
+                    sendNumStrPairs([[0, 'TGHT', 'NOTUNNEL'], [123, 'OTHR', 'SOMETHNG']], client);
+                    expect(client._sock).to.have.sent(new Uint8Array([0, 0, 0, 0]));
+                });
+
+                it('should choose the notunnel tunnel type for Siemens devices', function () {
+                    sendNumStrPairs([[1, 'SICR', 'SCHANNEL'], [2, 'SICR', 'SCHANLPW']], client);
+                    expect(client._sock).to.have.sent(new Uint8Array([0, 0, 0, 0]));
+                });
+
+                it('should continue to sub-auth negotiation after tunnel negotiation', function () {
+                    sendNumStrPairs([[0, 'TGHT', 'NOTUNNEL']], client);
+                    client._sock._websocket._getSentData();  // skip the tunnel choice here
+                    sendNumStrPairs([[1, 'STDV', 'NOAUTH__']], client);
+                    expect(client._sock).to.have.sent(new Uint8Array([0, 0, 0, 1]));
+                    expect(client._rfbInitState).to.equal('SecurityResult');
+                });
+
+                /*it('should attempt to use VNC auth over no auth when possible', function () {
+                    client._rfbTightVNC = true;
+                    client._negotiateStdVNCAuth = sinon.spy();
+                    sendNumStrPairs([[1, 'STDV', 'NOAUTH__'], [2, 'STDV', 'VNCAUTH_']], client);
+                    expect(client._sock).to.have.sent([0, 0, 0, 1]);
+                    expect(client._negotiateStdVNCAuth).to.have.been.calledOnce;
+                    expect(client._rfbAuthScheme).to.equal(2);
+                });*/ // while this would make sense, the original code doesn't actually do this
+
+                it('should accept the "no auth" auth type and transition to SecurityResult', function () {
+                    client._rfbTightVNC = true;
+                    sendNumStrPairs([[1, 'STDV', 'NOAUTH__']], client);
+                    expect(client._sock).to.have.sent(new Uint8Array([0, 0, 0, 1]));
+                    expect(client._rfbInitState).to.equal('SecurityResult');
+                });
+
+                it('should accept VNC authentication and transition to that', function () {
+                    client._rfbTightVNC = true;
+                    client._negotiateStdVNCAuth = sinon.spy();
+                    sendNumStrPairs([[2, 'STDV', 'VNCAUTH__']], client);
+                    expect(client._sock).to.have.sent(new Uint8Array([0, 0, 0, 2]));
+                    expect(client._negotiateStdVNCAuth).to.have.been.calledOnce;
+                    expect(client._rfbAuthScheme).to.equal(2);
+                });
+
+                it('should fail if there are no supported auth types', function () {
+                    sinon.spy(client, "_fail");
+                    client._rfbTightVNC = true;
+                    sendNumStrPairs([[23, 'stdv', 'badval__']], client);
+                    expect(client._fail).to.have.been.calledOnce;
+                });
+            });
+
+            describe('VeNCrypt Authentication (type 19) Handler', function () {
+                beforeEach(function () {
+                    sendSecurity(19, client);
+                    expect(client._sock).to.have.sent(new Uint8Array([19]));
+                });
+
+                it('should fail with non-0.2 versions', function () {
+                    sinon.spy(client, "_fail");
+                    client._sock._websocket._receiveData(new Uint8Array([0, 1]));
+                    expect(client._fail).to.have.been.calledOnce;
+                });
+
+                it('should fail if there are no supported subtypes', function () {
+                    // VeNCrypt version
+                    client._sock._websocket._receiveData(new Uint8Array([0, 2]));
+                    expect(client._sock).to.have.sent(new Uint8Array([0, 2]));
+                    // Server ACK.
+                    client._sock._websocket._receiveData(new Uint8Array([0]));
+                    // Subtype list
+                    sinon.spy(client, "_fail");
+                    client._sock._websocket._receiveData(new Uint8Array([2, 0, 0, 0, 9, 0, 0, 1, 4]));
+                    expect(client._fail).to.have.been.calledOnce;
+                });
+
+                it('should support standard types', function () {
+                    // VeNCrypt version
+                    client._sock._websocket._receiveData(new Uint8Array([0, 2]));
+                    expect(client._sock).to.have.sent(new Uint8Array([0, 2]));
+                    // Server ACK.
+                    client._sock._websocket._receiveData(new Uint8Array([0]));
+                    // Subtype list
+                    client._sock._websocket._receiveData(new Uint8Array([2, 0, 0, 0, 2, 0, 0, 1, 4]));
+
+                    let expectedResponse = [];
+                    push32(expectedResponse, 2); // Chosen subtype.
+
+                    expect(client._sock).to.have.sent(new Uint8Array(expectedResponse));
+                });
+
+                it('should respect server preference order', function () {
+                    // VeNCrypt version
+                    client._sock._websocket._receiveData(new Uint8Array([0, 2]));
+                    expect(client._sock).to.have.sent(new Uint8Array([0, 2]));
+                    // Server ACK.
+                    client._sock._websocket._receiveData(new Uint8Array([0]));
+                    // Subtype list
+                    let subtypes = [ 6 ];
+                    push32(subtypes, 79);
+                    push32(subtypes, 30);
+                    push32(subtypes, 188);
+                    push32(subtypes, 256);
+                    push32(subtypes, 6);
+                    push32(subtypes, 1);
+                    client._sock._websocket._receiveData(new Uint8Array(subtypes));
+
+                    let expectedResponse = [];
+                    push32(expectedResponse, 30); // Chosen subtype.
+
+                    expect(client._sock).to.have.sent(new Uint8Array(expectedResponse));
+                });
+
+                it('should ignore redundant VeNCrypt subtype', function () {
+                    // VeNCrypt version
+                    client._sock._websocket._receiveData(new Uint8Array([0, 2]));
+                    expect(client._sock).to.have.sent(new Uint8Array([0, 2]));
+                    // Server ACK.
+                    client._sock._websocket._receiveData(new Uint8Array([0]));
+                    // Subtype list
+                    client._sock._websocket._receiveData(new Uint8Array([2, 0, 0, 0, 19, 0, 0, 0, 2]));
+
+                    let expectedResponse = [];
+                    push32(expectedResponse, 2); // Chosen subtype.
+
+                    expect(client._sock).to.have.sent(new Uint8Array(expectedResponse));
+                });
+
+                it('should support Plain authentication', function () {
+                    client._rfbCredentials = { username: 'username', password: 'password' };
+                    // VeNCrypt version
+                    client._sock._websocket._receiveData(new Uint8Array([0, 2]));
+                    expect(client._sock).to.have.sent(new Uint8Array([0, 2]));
+                    // Server ACK.
+                    client._sock._websocket._receiveData(new Uint8Array([0]));
+                    // Subtype list.
+                    client._sock._websocket._receiveData(new Uint8Array([1, 0, 0, 1, 0]));
+
+                    const expectedResponse = [];
+                    push32(expectedResponse, 256); // Chosen subtype.
+                    push32(expectedResponse, client._rfbCredentials.username.length);
+                    push32(expectedResponse, client._rfbCredentials.password.length);
+                    pushString(expectedResponse, client._rfbCredentials.username);
+                    pushString(expectedResponse, client._rfbCredentials.password);
+                    expect(client._sock).to.have.sent(new Uint8Array(expectedResponse));
+
+                    client._initMsg = sinon.spy();
+                    client._sock._websocket._receiveData(new Uint8Array([0, 0, 0, 0]));
+                    expect(client._initMsg).to.have.been.called;
+                });
+
+                it('should support Plain authentication with an empty password', function () {
+                    client._rfbCredentials = { username: 'username', password: '' };
+                    // VeNCrypt version
+                    client._sock._websocket._receiveData(new Uint8Array([0, 2]));
+                    expect(client._sock).to.have.sent(new Uint8Array([0, 2]));
+                    // Server ACK.
+                    client._sock._websocket._receiveData(new Uint8Array([0]));
+                    // Subtype list.
+                    client._sock._websocket._receiveData(new Uint8Array([1, 0, 0, 1, 0]));
+
+                    const expectedResponse = [];
+                    push32(expectedResponse, 256); // Chosen subtype.
+                    push32(expectedResponse, client._rfbCredentials.username.length);
+                    push32(expectedResponse, client._rfbCredentials.password.length);
+                    pushString(expectedResponse, client._rfbCredentials.username);
+                    pushString(expectedResponse, client._rfbCredentials.password);
+                    expect(client._sock).to.have.sent(new Uint8Array(expectedResponse));
+
+                    client._initMsg = sinon.spy();
+                    client._sock._websocket._receiveData(new Uint8Array([0, 0, 0, 0]));
+                    expect(client._initMsg).to.have.been.called;
+                });
+
+                it('should support Plain authentication with a very long username and password', function () {
+                    client._rfbCredentials = { username: 'a'.repeat(300), password: 'a'.repeat(300) };
+                    // VeNCrypt version
+                    client._sock._websocket._receiveData(new Uint8Array([0, 2]));
+                    expect(client._sock).to.have.sent(new Uint8Array([0, 2]));
+                    // Server ACK.
+                    client._sock._websocket._receiveData(new Uint8Array([0]));
+                    // Subtype list.
+                    client._sock._websocket._receiveData(new Uint8Array([1, 0, 0, 1, 0]));
+
+                    const expectedResponse = [];
+                    push32(expectedResponse, 256); // Chosen subtype.
+                    push32(expectedResponse, client._rfbCredentials.username.length);
+                    push32(expectedResponse, client._rfbCredentials.password.length);
+                    pushString(expectedResponse, client._rfbCredentials.username);
+                    pushString(expectedResponse, client._rfbCredentials.password);
+                    expect(client._sock).to.have.sent(new Uint8Array(expectedResponse));
+
+                    client._initMsg = sinon.spy();
+                    client._sock._websocket._receiveData(new Uint8Array([0, 0, 0, 0]));
+                    expect(client._initMsg).to.have.been.called;
+                });
+            });
+        });
+
+        describe('Legacy SecurityResult', function () {
+            beforeEach(function () {
+                sendVer('003.007\n', client);
+                client._sock._websocket._getSentData();
+                sendSecurity(1, client);
+                client._sock._websocket._getSentData();
+            });
+
+            it('should not include reason in securityfailure event', function () {
+                const spy = sinon.spy();
+                client.addEventListener("securityfailure", spy);
+                client._sock._websocket._receiveData(new Uint8Array([0, 0, 0, 2]));
+                expect(spy).to.have.been.calledOnce;
+                expect(spy.args[0][0].detail.status).to.equal(2);
+                expect('reason' in spy.args[0][0].detail).to.be.false;
+            });
+        });
+
+        describe('SecurityResult', function () {
+            beforeEach(function () {
+                sendVer('003.008\n', client);
+                client._sock._websocket._getSentData();
+                sendSecurity(1, client);
+                client._sock._websocket._getSentData();
+            });
+
+            it('should fall through to ServerInitialisation on a response code of 0', function () {
+                client._sock._websocket._receiveData(new Uint8Array([0, 0, 0, 0]));
+                expect(client._rfbInitState).to.equal('ServerInitialisation');
+            });
+
+            it('should include reason when provided in securityfailure event', function () {
+                const spy = sinon.spy();
+                client.addEventListener("securityfailure", spy);
+                const failureData = [0, 0, 0, 1, 0, 0, 0, 12, 115, 117, 99, 104,
+                                     32, 102, 97, 105, 108, 117, 114, 101];
+                client._sock._websocket._receiveData(new Uint8Array(failureData));
+                expect(spy).to.have.been.calledOnce;
+                expect(spy.args[0][0].detail.status).to.equal(1);
+                expect(spy.args[0][0].detail.reason).to.equal('such failure');
+            });
+
+            it('should not include reason when length is zero in securityfailure event', function () {
+                const spy = sinon.spy();
+                client.addEventListener("securityfailure", spy);
+                const failureData = [0, 0, 0, 1, 0, 0, 0, 0];
+                client._sock._websocket._receiveData(new Uint8Array(failureData));
+                expect(spy).to.have.been.calledOnce;
+                expect(spy.args[0][0].detail.status).to.equal(1);
+                expect('reason' in spy.args[0][0].detail).to.be.false;
+            });
+        });
+
+        describe('ClientInitialisation', function () {
+            it('should transition to the ServerInitialisation state', function () {
+                const client = makeRFB();
+                client._rfbConnectionState = 'connecting';
+                client._rfbInitState = 'SecurityResult';
+                client._sock._websocket._receiveData(new Uint8Array([0, 0, 0, 0]));
+                expect(client._rfbInitState).to.equal('ServerInitialisation');
+            });
+
+            it('should send 1 if we are in shared mode', function () {
+                const client = makeRFB('wss://host:8675', { shared: true });
+                client._rfbConnectionState = 'connecting';
+                client._rfbInitState = 'SecurityResult';
+                client._sock._websocket._receiveData(new Uint8Array([0, 0, 0, 0]));
+                expect(client._sock).to.have.sent(new Uint8Array([1]));
+            });
+
+            it('should send 0 if we are not in shared mode', function () {
+                const client = makeRFB('wss://host:8675', { shared: false });
+                client._rfbConnectionState = 'connecting';
+                client._rfbInitState = 'SecurityResult';
+                client._sock._websocket._receiveData(new Uint8Array([0, 0, 0, 0]));
+                expect(client._sock).to.have.sent(new Uint8Array([0]));
+            });
+        });
+
+        describe('ServerInitialisation', function () {
+            beforeEach(function () {
+                client._rfbInitState = 'ServerInitialisation';
+            });
+
+            function sendServerInit(opts, client) {
+                const fullOpts = { width: 10, height: 12, bpp: 24, depth: 24, bigEndian: 0,
+                                   trueColor: 1, redMax: 255, greenMax: 255, blueMax: 255,
+                                   redShift: 16, greenShift: 8, blueShift: 0, name: 'a name' };
+                for (let opt in opts) {
+                    fullOpts[opt] = opts[opt];
+                }
+                const data = [];
+
+                push16(data, fullOpts.width);
+                push16(data, fullOpts.height);
+
+                data.push(fullOpts.bpp);
+                data.push(fullOpts.depth);
+                data.push(fullOpts.bigEndian);
+                data.push(fullOpts.trueColor);
+
+                push16(data, fullOpts.redMax);
+                push16(data, fullOpts.greenMax);
+                push16(data, fullOpts.blueMax);
+                push8(data, fullOpts.redShift);
+                push8(data, fullOpts.greenShift);
+                push8(data, fullOpts.blueShift);
+
+                // padding
+                push8(data, 0);
+                push8(data, 0);
+                push8(data, 0);
+
+                client._sock._websocket._receiveData(new Uint8Array(data));
+
+                const nameData = [];
+                let nameLen = [];
+                pushString(nameData, fullOpts.name);
+                push32(nameLen, nameData.length);
+
+                client._sock._websocket._receiveData(new Uint8Array(nameLen));
+                client._sock._websocket._receiveData(new Uint8Array(nameData));
+            }
+
+            it('should set the framebuffer width and height', function () {
+                sendServerInit({ width: 32, height: 84 }, client);
+                expect(client._fbWidth).to.equal(32);
+                expect(client._fbHeight).to.equal(84);
+            });
+
+            // NB(sross): we just warn, not fail, for endian-ness and shifts, so we don't test them
+
+            it('should set the framebuffer name and call the callback', function () {
+                const spy = sinon.spy();
+                client.addEventListener("desktopname", spy);
+                sendServerInit({ name: 'som€ nam€' }, client);
+
+                expect(client._fbName).to.equal('som€ nam€');
+                expect(spy).to.have.been.calledOnce;
+                expect(spy.args[0][0].detail.name).to.equal('som€ nam€');
+            });
+
+            it('should handle the extended init message of the tight encoding', function () {
+                // NB(sross): we don't actually do anything with it, so just test that we can
+                //            read it w/o throwing an error
+                client._rfbTightVNC = true;
+                sendServerInit({}, client);
+
+                const tightData = [];
+                push16(tightData, 1);
+                push16(tightData, 2);
+                push16(tightData, 3);
+                push16(tightData, 0);
+                for (let i = 0; i < 16 + 32 + 48; i++) {
+                    tightData.push(i);
+                }
+                client._sock._websocket._receiveData(new Uint8Array(tightData));
+
+                expect(client._rfbConnectionState).to.equal('connected');
+            });
+
+            it('should resize the display', function () {
+                sinon.spy(client._display, 'resize');
+                sendServerInit({ width: 27, height: 32 }, client);
+
+                expect(client._display.resize).to.have.been.calledOnce;
+                expect(client._display.resize).to.have.been.calledWith(27, 32);
+            });
+
+            it('should grab the keyboard', function () {
+                sinon.spy(client._keyboard, 'grab');
+                sendServerInit({}, client);
+                expect(client._keyboard.grab).to.have.been.calledOnce;
+            });
+
+            describe('Initial Update Request', function () {
+                beforeEach(function () {
+                    sinon.spy(RFB.messages, "pixelFormat");
+                    sinon.spy(RFB.messages, "clientEncodings");
+                    sinon.spy(RFB.messages, "fbUpdateRequest");
+                });
+
+                afterEach(function () {
+                    RFB.messages.pixelFormat.restore();
+                    RFB.messages.clientEncodings.restore();
+                    RFB.messages.fbUpdateRequest.restore();
+                });
+
+                // TODO(directxman12): test the various options in this configuration matrix
+                it('should reply with the pixel format, client encodings, and initial update request', function () {
+                    sendServerInit({ width: 27, height: 32 }, client);
+
+                    expect(RFB.messages.pixelFormat).to.have.been.calledOnce;
+                    expect(RFB.messages.pixelFormat).to.have.been.calledWith(client._sock, 24, true);
+                    expect(RFB.messages.pixelFormat).to.have.been.calledBefore(RFB.messages.clientEncodings);
+                    expect(RFB.messages.clientEncodings).to.have.been.calledOnce;
+                    expect(RFB.messages.clientEncodings.getCall(0).args[1]).to.include(encodings.encodingTight);
+                    RFB.messages.clientEncodings.getCall(0).args[1].forEach((enc) => {
+                        expect(enc).to.be.a('number');
+                        expect(Number.isInteger(enc)).to.be.true;
+                    });
+                    expect(RFB.messages.clientEncodings).to.have.been.calledBefore(RFB.messages.fbUpdateRequest);
+                    expect(RFB.messages.fbUpdateRequest).to.have.been.calledOnce;
+                    expect(RFB.messages.fbUpdateRequest).to.have.been.calledWith(client._sock, false, 0, 0, 27, 32);
+                });
+
+                it('should reply with restricted settings for Intel AMT servers', function () {
+                    sendServerInit({ width: 27, height: 32, name: "Intel(r) AMT KVM"}, client);
+
+                    expect(RFB.messages.pixelFormat).to.have.been.calledOnce;
+                    expect(RFB.messages.pixelFormat).to.have.been.calledWith(client._sock, 8, true);
+                    expect(RFB.messages.pixelFormat).to.have.been.calledBefore(RFB.messages.clientEncodings);
+                    expect(RFB.messages.clientEncodings).to.have.been.calledOnce;
+                    expect(RFB.messages.clientEncodings.getCall(0).args[1]).to.not.include(encodings.encodingTight);
+                    expect(RFB.messages.clientEncodings.getCall(0).args[1]).to.not.include(encodings.encodingHextile);
+                    expect(RFB.messages.clientEncodings).to.have.been.calledBefore(RFB.messages.fbUpdateRequest);
+                    expect(RFB.messages.fbUpdateRequest).to.have.been.calledOnce;
+                    expect(RFB.messages.fbUpdateRequest).to.have.been.calledWith(client._sock, false, 0, 0, 27, 32);
+                });
+            });
+
+            it('should send the "connect" event', function () {
+                let spy = sinon.spy();
+                client.addEventListener('connect', spy);
+                sendServerInit({}, client);
+                expect(spy).to.have.been.calledOnce;
+            });
+        });
+    });
+
+    describe('Protocol Message Processing After Completing Initialization', function () {
+        let client;
+
+        beforeEach(function () {
+            client = makeRFB();
+            client._fbName = 'some device';
+            client._fbWidth = 640;
+            client._fbHeight = 20;
+        });
+
+        describe('Framebuffer Update Handling', function () {
+            function sendFbuMsg(rectInfo, rectData, client, rectCnt) {
+                let data = [];
+
+                if (!rectCnt || rectCnt > -1) {
+                    // header
+                    data.push(0);  // msg type
+                    data.push(0);  // padding
+                    push16(data, rectCnt || rectData.length);
+                }
+
+                for (let i = 0; i < rectData.length; i++) {
+                    if (rectInfo[i]) {
+                        push16(data, rectInfo[i].x);
+                        push16(data, rectInfo[i].y);
+                        push16(data, rectInfo[i].width);
+                        push16(data, rectInfo[i].height);
+                        push32(data, rectInfo[i].encoding);
+                    }
+                    data = data.concat(rectData[i]);
+                }
+
+                client._sock._websocket._receiveData(new Uint8Array(data));
+            }
+
+            it('should send an update request if there is sufficient data', function () {
+                const expectedMsg = {_sQ: new Uint8Array(10), _sQlen: 0, flush: () => {}};
+                RFB.messages.fbUpdateRequest(expectedMsg, true, 0, 0, 640, 20);
+
+                client._framebufferUpdate = () => true;
+                client._sock._websocket._receiveData(new Uint8Array([0]));
+
+                expect(client._sock).to.have.sent(expectedMsg._sQ);
+            });
+
+            it('should not send an update request if we need more data', function () {
+                client._sock._websocket._receiveData(new Uint8Array([0]));
+                expect(client._sock._websocket._getSentData()).to.have.length(0);
+            });
+
+            it('should resume receiving an update if we previously did not have enough data', function () {
+                const expectedMsg = {_sQ: new Uint8Array(10), _sQlen: 0, flush: () => {}};
+                RFB.messages.fbUpdateRequest(expectedMsg, true, 0, 0, 640, 20);
+
+                // just enough to set FBU.rects
+                client._sock._websocket._receiveData(new Uint8Array([0, 0, 0, 3]));
+                expect(client._sock._websocket._getSentData()).to.have.length(0);
+
+                client._framebufferUpdate = function () { this._sock.rQskipBytes(1); return true; };  // we magically have enough data
+                // 247 should *not* be used as the message type here
+                client._sock._websocket._receiveData(new Uint8Array([247]));
+                expect(client._sock).to.have.sent(expectedMsg._sQ);
+            });
+
+            it('should not send a request in continuous updates mode', function () {
+                client._enabledContinuousUpdates = true;
+                client._framebufferUpdate = () => true;
+                client._sock._websocket._receiveData(new Uint8Array([0]));
+
+                expect(client._sock._websocket._getSentData()).to.have.length(0);
+            });
+
+            it('should fail on an unsupported encoding', function () {
+                sinon.spy(client, "_fail");
+                const rectInfo = { x: 8, y: 11, width: 27, height: 32, encoding: 234 };
+                sendFbuMsg([rectInfo], [[]], client);
+                expect(client._fail).to.have.been.calledOnce;
+            });
+
+            describe('Message Encoding Handlers', function () {
+                beforeEach(function () {
+                    // a really small frame
+                    client._fbWidth = 4;
+                    client._fbHeight = 4;
+                    client._fbDepth = 24;
+                    client._display.resize(4, 4);
+                });
+
+                it('should handle the DesktopSize pseduo-encoding', function () {
+                    sinon.spy(client._display, 'resize');
+                    sendFbuMsg([{ x: 0, y: 0, width: 20, height: 50, encoding: -223 }], [[]], client);
+
+                    expect(client._fbWidth).to.equal(20);
+                    expect(client._fbHeight).to.equal(50);
+
+                    expect(client._display.resize).to.have.been.calledOnce;
+                    expect(client._display.resize).to.have.been.calledWith(20, 50);
+                });
+
+                describe('the ExtendedDesktopSize pseudo-encoding handler', function () {
+                    beforeEach(function () {
+                        // a really small frame
+                        client._fbWidth = 4;
+                        client._fbHeight = 4;
+                        client._display.resize(4, 4);
+                        sinon.spy(client._display, 'resize');
+                    });
+
+                    function makeScreenData(nrOfScreens) {
+                        const data = [];
+                        push8(data, nrOfScreens);   // number-of-screens
+                        push8(data, 0);               // padding
+                        push16(data, 0);              // padding
+                        for (let i=0; i<nrOfScreens; i += 1) {
+                            push32(data, 0);  // id
+                            push16(data, 0);  // x-position
+                            push16(data, 0);  // y-position
+                            push16(data, 20); // width
+                            push16(data, 50); // height
+                            push32(data, 0);  // flags
+                        }
+                        return data;
+                    }
+
+                    it('should handle a resize requested by this client', function () {
+                        const reasonForChange = 1; // requested by this client
+                        const statusCode      = 0; // No error
+
+                        sendFbuMsg([{ x: reasonForChange, y: statusCode,
+                                      width: 20, height: 50, encoding: -308 }],
+                                   makeScreenData(1), client);
+
+                        expect(client._fbWidth).to.equal(20);
+                        expect(client._fbHeight).to.equal(50);
+
+                        expect(client._display.resize).to.have.been.calledOnce;
+                        expect(client._display.resize).to.have.been.calledWith(20, 50);
+                    });
+
+                    it('should handle a resize requested by another client', function () {
+                        const reasonForChange = 2; // requested by another client
+                        const statusCode      = 0; // No error
+
+                        sendFbuMsg([{ x: reasonForChange, y: statusCode,
+                                      width: 20, height: 50, encoding: -308 }],
+                                   makeScreenData(1), client);
+
+                        expect(client._fbWidth).to.equal(20);
+                        expect(client._fbHeight).to.equal(50);
+
+                        expect(client._display.resize).to.have.been.calledOnce;
+                        expect(client._display.resize).to.have.been.calledWith(20, 50);
+                    });
+
+                    it('should be able to recieve requests which contain data for multiple screens', function () {
+                        const reasonForChange = 2; // requested by another client
+                        const statusCode      = 0; // No error
+
+                        sendFbuMsg([{ x: reasonForChange, y: statusCode,
+                                      width: 60, height: 50, encoding: -308 }],
+                                   makeScreenData(3), client);
+
+                        expect(client._fbWidth).to.equal(60);
+                        expect(client._fbHeight).to.equal(50);
+
+                        expect(client._display.resize).to.have.been.calledOnce;
+                        expect(client._display.resize).to.have.been.calledWith(60, 50);
+                    });
+
+                    it('should not handle a failed request', function () {
+                        const reasonForChange = 1; // requested by this client
+                        const statusCode      = 1; // Resize is administratively prohibited
+
+                        sendFbuMsg([{ x: reasonForChange, y: statusCode,
+                                      width: 20, height: 50, encoding: -308 }],
+                                   makeScreenData(1), client);
+
+                        expect(client._fbWidth).to.equal(4);
+                        expect(client._fbHeight).to.equal(4);
+
+                        expect(client._display.resize).to.not.have.been.called;
+                    });
+                });
+
+                describe('the Cursor pseudo-encoding handler', function () {
+                    beforeEach(function () {
+                        sinon.spy(client._cursor, 'change');
+                    });
+
+                    it('should handle a standard cursor', function () {
+                        const info = { x: 5, y: 7,
+                                       width: 4, height: 4,
+                                       encoding: -239};
+                        let rect = [];
+                        let expected = [];
+
+                        for (let i = 0;i < info.width*info.height;i++) {
+                            push32(rect, 0x11223300);
+                        }
+                        push32(rect, 0xa0a0a0a0);
+
+                        for (let i = 0;i < info.width*info.height/2;i++) {
+                            push32(expected, 0x332211ff);
+                            push32(expected, 0x33221100);
+                        }
+                        expected = new Uint8Array(expected);
+
+                        sendFbuMsg([info], [rect], client);
+
+                        expect(client._cursor.change).to.have.been.calledOnce;
+                        expect(client._cursor.change).to.have.been.calledWith(expected, 5, 7, 4, 4);
+                    });
+
+                    it('should handle an empty cursor', function () {
+                        const info = { x: 0, y: 0,
+                                       width: 0, height: 0,
+                                       encoding: -239};
+                        const rect = [];
+
+                        sendFbuMsg([info], [rect], client);
+
+                        expect(client._cursor.change).to.have.been.calledOnce;
+                        expect(client._cursor.change).to.have.been.calledWith(new Uint8Array, 0, 0, 0, 0);
+                    });
+
+                    it('should handle a transparent cursor', function () {
+                        const info = { x: 5, y: 7,
+                                       width: 4, height: 4,
+                                       encoding: -239};
+                        let rect = [];
+                        let expected = [];
+
+                        for (let i = 0;i < info.width*info.height;i++) {
+                            push32(rect, 0x11223300);
+                        }
+                        push32(rect, 0x00000000);
+
+                        for (let i = 0;i < info.width*info.height;i++) {
+                            push32(expected, 0x33221100);
+                        }
+                        expected = new Uint8Array(expected);
+
+                        sendFbuMsg([info], [rect], client);
+
+                        expect(client._cursor.change).to.have.been.calledOnce;
+                        expect(client._cursor.change).to.have.been.calledWith(expected, 5, 7, 4, 4);
+                    });
+
+                    describe('dot for empty cursor', function () {
+                        beforeEach(function () {
+                            client.showDotCursor = true;
+                            // Was called when we enabled dot cursor
+                            client._cursor.change.resetHistory();
+                        });
+
+                        it('should show a standard cursor', function () {
+                            const info = { x: 5, y: 7,
+                                           width: 4, height: 4,
+                                           encoding: -239};
+                            let rect = [];
+                            let expected = [];
+
+                            for (let i = 0;i < info.width*info.height;i++) {
+                                push32(rect, 0x11223300);
+                            }
+                            push32(rect, 0xa0a0a0a0);
+
+                            for (let i = 0;i < info.width*info.height/2;i++) {
+                                push32(expected, 0x332211ff);
+                                push32(expected, 0x33221100);
+                            }
+                            expected = new Uint8Array(expected);
+
+                            sendFbuMsg([info], [rect], client);
+
+                            expect(client._cursor.change).to.have.been.calledOnce;
+                            expect(client._cursor.change).to.have.been.calledWith(expected, 5, 7, 4, 4);
+                        });
+
+                        it('should handle an empty cursor', function () {
+                            const info = { x: 0, y: 0,
+                                           width: 0, height: 0,
+                                           encoding: -239};
+                            const rect = [];
+                            const dot = RFB.cursors.dot;
+
+                            sendFbuMsg([info], [rect], client);
+
+                            expect(client._cursor.change).to.have.been.calledOnce;
+                            expect(client._cursor.change).to.have.been.calledWith(dot.rgbaPixels,
+                                                                                  dot.hotx,
+                                                                                  dot.hoty,
+                                                                                  dot.w,
+                                                                                  dot.h);
+                        });
+
+                        it('should handle a transparent cursor', function () {
+                            const info = { x: 5, y: 7,
+                                           width: 4, height: 4,
+                                           encoding: -239};
+                            let rect = [];
+                            const dot = RFB.cursors.dot;
+
+                            for (let i = 0;i < info.width*info.height;i++) {
+                                push32(rect, 0x11223300);
+                            }
+                            push32(rect, 0x00000000);
+
+                            sendFbuMsg([info], [rect], client);
+
+                            expect(client._cursor.change).to.have.been.calledOnce;
+                            expect(client._cursor.change).to.have.been.calledWith(dot.rgbaPixels,
+                                                                                  dot.hotx,
+                                                                                  dot.hoty,
+                                                                                  dot.w,
+                                                                                  dot.h);
+                        });
+                    });
+                });
+
+                describe('the VMware Cursor pseudo-encoding handler', function () {
+                    beforeEach(function () {
+                        sinon.spy(client._cursor, 'change');
+                    });
+                    afterEach(function () {
+                        client._cursor.change.resetHistory();
+                    });
+
+                    it('should handle the VMware cursor pseudo-encoding', function () {
+                        let data = [0x00, 0x00, 0xff, 0,
+                                    0x00, 0xff, 0x00, 0,
+                                    0x00, 0xff, 0x00, 0,
+                                    0x00, 0x00, 0xff, 0];
+                        let rect = [];
+                        push8(rect, 0);
+                        push8(rect, 0);
+
+                        //AND-mask
+                        for (let i = 0; i < data.length; i++) {
+                            push8(rect, data[i]);
+                        }
+                        //XOR-mask
+                        for (let i = 0; i < data.length; i++) {
+                            push8(rect, data[i]);
+                        }
+
+                        sendFbuMsg([{ x: 0, y: 0, width: 2, height: 2,
+                                      encoding: 0x574d5664}],
+                                   [rect], client);
+                        expect(client._FBU.rects).to.equal(0);
+                    });
+
+                    it('should handle insufficient cursor pixel data', function () {
+
+                        // Specified 14x23 pixels for the cursor,
+                        // but only send 2x2 pixels worth of data
+                        let w = 14;
+                        let h = 23;
+                        let data = [0x00, 0x00, 0xff, 0,
+                                    0x00, 0xff, 0x00, 0];
+                        let rect = [];
+
+                        push8(rect, 0);
+                        push8(rect, 0);
+
+                        //AND-mask
+                        for (let i = 0; i < data.length; i++) {
+                            push8(rect, data[i]);
+                        }
+                        //XOR-mask
+                        for (let i = 0; i < data.length; i++) {
+                            push8(rect, data[i]);
+                        }
+
+                        sendFbuMsg([{ x: 0, y: 0, width: w, height: h,
+                                      encoding: 0x574d5664}],
+                                   [rect], client);
+
+                        // expect one FBU to remain unhandled
+                        expect(client._FBU.rects).to.equal(1);
+                    });
+
+                    it('should update the cursor when type is classic', function () {
+                        let andMask =
+                            [0xff, 0xff, 0xff, 0xff,  //Transparent
+                             0xff, 0xff, 0xff, 0xff,  //Transparent
+                             0x00, 0x00, 0x00, 0x00,  //Opaque
+                             0xff, 0xff, 0xff, 0xff]; //Inverted
+
+                        let xorMask =
+                            [0x00, 0x00, 0x00, 0x00,  //Transparent
+                             0x00, 0x00, 0x00, 0x00,  //Transparent
+                             0x11, 0x22, 0x33, 0x44,  //Opaque
+                             0xff, 0xff, 0xff, 0x44]; //Inverted
+
+                        let rect = [];
+                        push8(rect, 0); //cursor_type
+                        push8(rect, 0); //padding
+                        let hotx = 0;
+                        let hoty = 0;
+                        let w = 2;
+                        let h = 2;
+
+                        //AND-mask
+                        for (let i = 0; i < andMask.length; i++) {
+                            push8(rect, andMask[i]);
+                        }
+                        //XOR-mask
+                        for (let i = 0; i < xorMask.length; i++) {
+                            push8(rect, xorMask[i]);
+                        }
+
+                        let expectedRgba = [0x00, 0x00, 0x00, 0x00,
+                                            0x00, 0x00, 0x00, 0x00,
+                                            0x33, 0x22, 0x11, 0xff,
+                                            0x00, 0x00, 0x00, 0xff];
+
+                        sendFbuMsg([{ x: hotx, y: hoty,
+                                      width: w, height: h,
+                                      encoding: 0x574d5664}],
+                                   [rect], client);
+
+                        expect(client._cursor.change)
+                            .to.have.been.calledOnce;
+                        expect(client._cursor.change)
+                            .to.have.been.calledWith(expectedRgba,
+                                                     hotx, hoty,
+                                                     w, h);
+                    });
+
+                    it('should update the cursor when type is alpha', function () {
+                        let data = [0xee, 0x55, 0xff, 0x00, // rgba
+                                    0x00, 0xff, 0x00, 0xff,
+                                    0x00, 0xff, 0x00, 0x22,
+                                    0x00, 0xff, 0x00, 0x22,
+                                    0x00, 0xff, 0x00, 0x22,
+                                    0x00, 0x00, 0xff, 0xee];
+                        let rect = [];
+                        push8(rect, 1); //cursor_type
+                        push8(rect, 0); //padding
+                        let hotx = 0;
+                        let hoty = 0;
+                        let w = 3;
+                        let h = 2;
+
+                        for (let i = 0; i < data.length; i++) {
+                            push8(rect, data[i]);
+                        }
+
+                        let expectedRgba = [0xee, 0x55, 0xff, 0x00,
+                                            0x00, 0xff, 0x00, 0xff,
+                                            0x00, 0xff, 0x00, 0x22,
+                                            0x00, 0xff, 0x00, 0x22,
+                                            0x00, 0xff, 0x00, 0x22,
+                                            0x00, 0x00, 0xff, 0xee];
+
+                        sendFbuMsg([{ x: hotx, y: hoty,
+                                      width: w, height: h,
+                                      encoding: 0x574d5664}],
+                                   [rect], client);
+
+                        expect(client._cursor.change)
+                            .to.have.been.calledOnce;
+                        expect(client._cursor.change)
+                            .to.have.been.calledWith(expectedRgba,
+                                                     hotx, hoty,
+                                                     w, h);
+                    });
+
+                    it('should not update cursor when incorrect cursor type given', function () {
+                        let rect = [];
+                        push8(rect, 3); // invalid cursor type
+                        push8(rect, 0); // padding
+
+                        client._cursor.change.resetHistory();
+                        sendFbuMsg([{ x: 0, y: 0, width: 2, height: 2,
+                                      encoding: 0x574d5664}],
+                                   [rect], client);
+
+                        expect(client._cursor.change)
+                            .to.not.have.been.called;
+                    });
+                });
+
+                it('should handle the last_rect pseudo-encoding', function () {
+                    sendFbuMsg([{ x: 0, y: 0, width: 0, height: 0, encoding: -224}], [[]], client, 100);
+                    expect(client._FBU.rects).to.equal(0);
+                });
+
+                it('should handle the DesktopName pseudo-encoding', function () {
+                    let data = [];
+                    push32(data, 13);
+                    pushString(data, "som€ nam€");
+
+                    const spy = sinon.spy();
+                    client.addEventListener("desktopname", spy);
+
+                    sendFbuMsg([{ x: 0, y: 0, width: 0, height: 0, encoding: -307 }], [data], client);
+
+                    expect(client._fbName).to.equal('som€ nam€');
+                    expect(spy).to.have.been.calledOnce;
+                    expect(spy.args[0][0].detail.name).to.equal('som€ nam€');
+                });
+            });
+        });
+
+        describe('XVP Message Handling', function () {
+            it('should set the XVP version and fire the callback with the version on XVP_INIT', function () {
+                const spy = sinon.spy();
+                client.addEventListener("capabilities", spy);
+                client._sock._websocket._receiveData(new Uint8Array([250, 0, 10, 1]));
+                expect(client._rfbXvpVer).to.equal(10);
+                expect(spy).to.have.been.calledOnce;
+                expect(spy.args[0][0].detail.capabilities.power).to.be.true;
+                expect(client.capabilities.power).to.be.true;
+            });
+
+            it('should fail on unknown XVP message types', function () {
+                sinon.spy(client, "_fail");
+                client._sock._websocket._receiveData(new Uint8Array([250, 0, 10, 237]));
+                expect(client._fail).to.have.been.calledOnce;
+            });
+        });
+
+        describe('Normal Clipboard Handling Receive', function () {
+            it('should fire the clipboard callback with the retrieved text on ServerCutText', function () {
+                const expectedStr = 'cheese!';
+                const data = [3, 0, 0, 0];
+                push32(data, expectedStr.length);
+                for (let i = 0; i < expectedStr.length; i++) { data.push(expectedStr.charCodeAt(i)); }
+                const spy = sinon.spy();
+                client.addEventListener("clipboard", spy);
+
+                client._sock._websocket._receiveData(new Uint8Array(data));
+                expect(spy).to.have.been.calledOnce;
+                expect(spy.args[0][0].detail.text).to.equal(expectedStr);
+            });
+        });
+
+        describe('Extended clipboard Handling', function () {
+
+            describe('Extended clipboard initialization', function () {
+                beforeEach(function () {
+                    sinon.spy(RFB.messages, 'extendedClipboardCaps');
+                });
+
+                afterEach(function () {
+                    RFB.messages.extendedClipboardCaps.restore();
+                });
+
+                it('should update capabilities when receiving a Caps message', function () {
+                    let data = [3, 0, 0, 0];
+                    const flags = [0x1F, 0x00, 0x00, 0x03];
+                    let fileSizes = [0x00, 0x00, 0x00, 0x1E,
+                                     0x00, 0x00, 0x00, 0x3C];
+
+                    push32(data, toUnsigned32bit(-12));
+                    data = data.concat(flags);
+                    data = data.concat(fileSizes);
+                    client._sock._websocket._receiveData(new Uint8Array(data));
+
+                    // Check that we give an response caps when we receive one
+                    expect(RFB.messages.extendedClipboardCaps).to.have.been.calledOnce;
+
+                    // FIXME: Can we avoid checking internal variables?
+                    expect(client._clipboardServerCapabilitiesFormats[0]).to.not.equal(true);
+                    expect(client._clipboardServerCapabilitiesFormats[1]).to.equal(true);
+                    expect(client._clipboardServerCapabilitiesFormats[2]).to.equal(true);
+                    expect(client._clipboardServerCapabilitiesActions[(1 << 24)]).to.equal(true);
+                });
+
+
+            });
+
+            describe('Extended Clipboard Handling Receive', function () {
+
+                beforeEach(function () {
+                    // Send our capabilities
+                    let data = [3, 0, 0, 0];
+                    const flags = [0x1F, 0x00, 0x00, 0x01];
+                    let fileSizes = [0x00, 0x00, 0x00, 0x1E];
+
+                    push32(data, toUnsigned32bit(-8));
+                    data = data.concat(flags);
+                    data = data.concat(fileSizes);
+                    client._sock._websocket._receiveData(new Uint8Array(data));
+                });
+
+                describe('Handle Provide', function () {
+                    it('should update clipboard with correct Unicode data from a Provide message', function () {
+                        let expectedData = "Aå漢字!";
+                        let data = [3, 0, 0, 0];
+                        const flags = [0x10, 0x00, 0x00, 0x01];
+
+                        /* The size 10 (utf8 encoded string size) and the
+                        string "Aå漢字!" utf8 encoded and deflated. */
+                        let deflatedData = [120, 94, 99, 96, 96, 224, 114, 60,
+                                            188, 244, 217, 158, 69, 79, 215,
+                                            78, 87, 4, 0, 35, 207, 6, 66];
+
+                        // How much data we are sending.
+                        push32(data, toUnsigned32bit(-(4 + deflatedData.length)));
+
+                        data = data.concat(flags);
+                        data = data.concat(deflatedData);
+
+                        const spy = sinon.spy();
+                        client.addEventListener("clipboard", spy);
+
+                        client._sock._websocket._receiveData(new Uint8Array(data));
+                        expect(spy).to.have.been.calledOnce;
+                        expect(spy.args[0][0].detail.text).to.equal(expectedData);
+                        client.removeEventListener("clipboard", spy);
+                    });
+
+                    it('should update clipboard with correct escape characters from a Provide message ', function () {
+                        let expectedData = "Oh\nmy!";
+                        let data = [3, 0, 0, 0];
+                        const flags = [0x10, 0x00, 0x00, 0x01];
+
+                        let text = encodeUTF8("Oh\r\nmy!\0");
+
+                        let deflatedText = deflateWithSize(text);
+
+                        // How much data we are sending.
+                        push32(data, toUnsigned32bit(-(4 + deflatedText.length)));
+
+                        data = data.concat(flags);
+
+                        let sendData = new Uint8Array(data.length + deflatedText.length);
+                        sendData.set(data);
+                        sendData.set(deflatedText, data.length);
+
+                        const spy = sinon.spy();
+                        client.addEventListener("clipboard", spy);
+
+                        client._sock._websocket._receiveData(sendData);
+                        expect(spy).to.have.been.calledOnce;
+                        expect(spy.args[0][0].detail.text).to.equal(expectedData);
+                        client.removeEventListener("clipboard", spy);
+                    });
+
+                    it('should be able to handle large Provide messages', function () {
+                        let expectedData = "hello".repeat(100000);
+                        let data = [3, 0, 0, 0];
+                        const flags = [0x10, 0x00, 0x00, 0x01];
+
+                        let text = encodeUTF8(expectedData + "\0");
+
+                        let deflatedText = deflateWithSize(text);
+
+                        // How much data we are sending.
+                        push32(data, toUnsigned32bit(-(4 + deflatedText.length)));
+
+                        data = data.concat(flags);
+
+                        let sendData = new Uint8Array(data.length + deflatedText.length);
+                        sendData.set(data);
+                        sendData.set(deflatedText, data.length);
+
+                        const spy = sinon.spy();
+                        client.addEventListener("clipboard", spy);
+
+                        client._sock._websocket._receiveData(sendData);
+                        expect(spy).to.have.been.calledOnce;
+                        expect(spy.args[0][0].detail.text).to.equal(expectedData);
+                        client.removeEventListener("clipboard", spy);
+                    });
+
+                });
+
+                describe('Handle Notify', function () {
+                    beforeEach(function () {
+                        sinon.spy(RFB.messages, 'extendedClipboardRequest');
+                    });
+
+                    afterEach(function () {
+                        RFB.messages.extendedClipboardRequest.restore();
+                    });
+
+                    it('should make a request with supported formats when receiving a notify message', function () {
+                        let data = [3, 0, 0, 0];
+                        const flags = [0x08, 0x00, 0x00, 0x07];
+                        push32(data, toUnsigned32bit(-4));
+                        data = data.concat(flags);
+                        let expectedData = [0x01];
+
+                        client._sock._websocket._receiveData(new Uint8Array(data));
+
+                        expect(RFB.messages.extendedClipboardRequest).to.have.been.calledOnce;
+                        expect(RFB.messages.extendedClipboardRequest).to.have.been.calledWith(client._sock, expectedData);
+                    });
+                });
+
+                describe('Handle Peek', function () {
+                    beforeEach(function () {
+                        sinon.spy(RFB.messages, 'extendedClipboardNotify');
+                    });
+
+                    afterEach(function () {
+                        RFB.messages.extendedClipboardNotify.restore();
+                    });
+
+                    it('should send an empty Notify when receiving a Peek and no excisting clipboard data', function () {
+                        let data = [3, 0, 0, 0];
+                        const flags = [0x04, 0x00, 0x00, 0x00];
+                        push32(data, toUnsigned32bit(-4));
+                        data = data.concat(flags);
+                        let expectedData = [];
+
+                        client._sock._websocket._receiveData(new Uint8Array(data));
+
+                        expect(RFB.messages.extendedClipboardNotify).to.have.been.calledOnce;
+                        expect(RFB.messages.extendedClipboardNotify).to.have.been.calledWith(client._sock, expectedData);
+                    });
+
+                    it('should send a Notify message with supported formats when receiving a Peek', function () {
+                        let data = [3, 0, 0, 0];
+                        const flags = [0x04, 0x00, 0x00, 0x00];
+                        push32(data, toUnsigned32bit(-4));
+                        data = data.concat(flags);
+                        let expectedData = [0x01];
+
+                        // Needed to have clipboard data to read.
+                        // This will trigger a call to Notify, reset history
+                        client.clipboardPasteFrom("HejHej");
+                        RFB.messages.extendedClipboardNotify.resetHistory();
+
+                        client._sock._websocket._receiveData(new Uint8Array(data));
+
+                        expect(RFB.messages.extendedClipboardNotify).to.have.been.calledOnce;
+                        expect(RFB.messages.extendedClipboardNotify).to.have.been.calledWith(client._sock, expectedData);
+                    });
+                });
+
+                describe('Handle Request', function () {
+                    beforeEach(function () {
+                        sinon.spy(RFB.messages, 'extendedClipboardProvide');
+                    });
+
+                    afterEach(function () {
+                        RFB.messages.extendedClipboardProvide.restore();
+                    });
+
+                    it('should send a Provide message with supported formats when receiving a Request', function () {
+                        let data = [3, 0, 0, 0];
+                        const flags = [0x02, 0x00, 0x00, 0x01];
+                        push32(data, toUnsigned32bit(-4));
+                        data = data.concat(flags);
+                        let expectedData = [0x01];
+
+                        client.clipboardPasteFrom("HejHej");
+                        expect(RFB.messages.extendedClipboardProvide).to.not.have.been.called;
+
+                        client._sock._websocket._receiveData(new Uint8Array(data));
+
+                        expect(RFB.messages.extendedClipboardProvide).to.have.been.calledOnce;
+                        expect(RFB.messages.extendedClipboardProvide).to.have.been.calledWith(client._sock, expectedData, ["HejHej"]);
+                    });
+                });
+            });
+
+        });
+
+        it('should fire the bell callback on Bell', function () {
+            const spy = sinon.spy();
+            client.addEventListener("bell", spy);
+            client._sock._websocket._receiveData(new Uint8Array([2]));
+            expect(spy).to.have.been.calledOnce;
+        });
+
+        it('should respond correctly to ServerFence', function () {
+            const expectedMsg = {_sQ: new Uint8Array(16), _sQlen: 0, flush: () => {}};
+            const incomingMsg = {_sQ: new Uint8Array(16), _sQlen: 0, flush: () => {}};
+
+            const payload = "foo\x00ab9";
+
+            // ClientFence and ServerFence are identical in structure
+            RFB.messages.clientFence(expectedMsg, (1<<0) | (1<<1), payload);
+            RFB.messages.clientFence(incomingMsg, 0xffffffff, payload);
+
+            client._sock._websocket._receiveData(incomingMsg._sQ);
+
+            expect(client._sock).to.have.sent(expectedMsg._sQ);
+
+            expectedMsg._sQlen = 0;
+            incomingMsg._sQlen = 0;
+
+            RFB.messages.clientFence(expectedMsg, (1<<0), payload);
+            RFB.messages.clientFence(incomingMsg, (1<<0) | (1<<31), payload);
+
+            client._sock._websocket._receiveData(incomingMsg._sQ);
+
+            expect(client._sock).to.have.sent(expectedMsg._sQ);
+        });
+
+        it('should enable continuous updates on first EndOfContinousUpdates', function () {
+            const expectedMsg = {_sQ: new Uint8Array(10), _sQlen: 0, flush: () => {}};
+
+            RFB.messages.enableContinuousUpdates(expectedMsg, true, 0, 0, 640, 20);
+
+            expect(client._enabledContinuousUpdates).to.be.false;
+
+            client._sock._websocket._receiveData(new Uint8Array([150]));
+
+            expect(client._enabledContinuousUpdates).to.be.true;
+            expect(client._sock).to.have.sent(expectedMsg._sQ);
+        });
+
+        it('should disable continuous updates on subsequent EndOfContinousUpdates', function () {
+            client._enabledContinuousUpdates = true;
+            client._supportsContinuousUpdates = true;
+
+            client._sock._websocket._receiveData(new Uint8Array([150]));
+
+            expect(client._enabledContinuousUpdates).to.be.false;
+        });
+
+        it('should update continuous updates on resize', function () {
+            const expectedMsg = {_sQ: new Uint8Array(10), _sQlen: 0, flush: () => {}};
+            RFB.messages.enableContinuousUpdates(expectedMsg, true, 0, 0, 90, 700);
+
+            client._resize(450, 160);
+
+            expect(client._sock._websocket._getSentData()).to.have.length(0);
+
+            client._enabledContinuousUpdates = true;
+
+            client._resize(90, 700);
+
+            expect(client._sock).to.have.sent(expectedMsg._sQ);
+        });
+
+        it('should fail on an unknown message type', function () {
+            sinon.spy(client, "_fail");
+            client._sock._websocket._receiveData(new Uint8Array([87]));
+            expect(client._fail).to.have.been.calledOnce;
+        });
+    });
+
+    describe('Asynchronous Events', function () {
+        let client;
+        let pointerEvent;
+        let keyEvent;
+        let qemuKeyEvent;
+
+        beforeEach(function () {
+            client = makeRFB();
+            client._display.resize(100, 100);
+
+            // We need to disable this as focusing the canvas will
+            // cause the browser to scoll to it, messing up our
+            // client coordinate calculations
+            client.focusOnClick = false;
+
+            pointerEvent = sinon.spy(RFB.messages, 'pointerEvent');
+            keyEvent = sinon.spy(RFB.messages, 'keyEvent');
+            qemuKeyEvent = sinon.spy(RFB.messages, 'QEMUExtendedKeyEvent');
+        });
+
+        afterEach(function () {
+            pointerEvent.restore();
+            keyEvent.restore();
+            qemuKeyEvent.restore();
+        });
+
+        function elementToClient(x, y) {
+            let res = { x: 0, y: 0 };
+
+            let bounds = client._canvas.getBoundingClientRect();
+
+            /*
+             * If the canvas is on a fractional position we will calculate
+             * a fractional mouse position. But that gets truncated when we
+             * send the event, AND the same thing happens in RFB when it
+             * generates the PointerEvent message. To compensate for that
+             * fact we round the value upwards here.
+             */
+            res.x = Math.ceil(bounds.left + x);
+            res.y = Math.ceil(bounds.top + y);
+
+            return res;
+        }
+
+        describe('Mouse Events', function () {
+            function sendMouseMoveEvent(x, y) {
+                let pos = elementToClient(x, y);
+                let ev;
+
+                ev = new MouseEvent('mousemove',
+                                    { 'screenX': pos.x + window.screenX,
+                                      'screenY': pos.y + window.screenY,
+                                      'clientX': pos.x,
+                                      'clientY': pos.y });
+                client._canvas.dispatchEvent(ev);
+            }
+
+            function sendMouseButtonEvent(x, y, down, button) {
+                let pos = elementToClient(x, y);
+                let ev;
+
+                ev = new MouseEvent(down ? 'mousedown' : 'mouseup',
+                                    { 'screenX': pos.x + window.screenX,
+                                      'screenY': pos.y + window.screenY,
+                                      'clientX': pos.x,
+                                      'clientY': pos.y,
+                                      'button': button,
+                                      'buttons': 1 << button });
+                client._canvas.dispatchEvent(ev);
+            }
+
+            it('should not send button messages in view-only mode', function () {
+                client._viewOnly = true;
+                sendMouseButtonEvent(10, 10, true, 0);
+                clock.tick(50);
+                expect(pointerEvent).to.not.have.been.called;
+            });
+
+            it('should not send movement messages in view-only mode', function () {
+                client._viewOnly = true;
+                sendMouseMoveEvent(10, 10);
+                clock.tick(50);
+                expect(pointerEvent).to.not.have.been.called;
+            });
+
+            it('should handle left mouse button', function () {
+                sendMouseButtonEvent(10, 10, true, 0);
+
+                expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                 10, 10, 0x1);
+                pointerEvent.resetHistory();
+
+                sendMouseButtonEvent(10, 10, false, 0);
+
+                expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                 10, 10, 0x0);
+            });
+
+            it('should handle middle mouse button', function () {
+                sendMouseButtonEvent(10, 10, true, 1);
+
+                expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                 10, 10, 0x2);
+                pointerEvent.resetHistory();
+
+                sendMouseButtonEvent(10, 10, false, 1);
+
+                expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                 10, 10, 0x0);
+            });
+
+            it('should handle right mouse button', function () {
+                sendMouseButtonEvent(10, 10, true, 2);
+
+                expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                 10, 10, 0x4);
+                pointerEvent.resetHistory();
+
+                sendMouseButtonEvent(10, 10, false, 2);
+
+                expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                 10, 10, 0x0);
+            });
+
+            it('should handle multiple mouse buttons', function () {
+                sendMouseButtonEvent(10, 10, true, 0);
+                sendMouseButtonEvent(10, 10, true, 2);
+
+                expect(pointerEvent).to.have.been.calledTwice;
+                expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       10, 10, 0x1);
+                expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        10, 10, 0x5);
+
+                pointerEvent.resetHistory();
+
+                sendMouseButtonEvent(10, 10, false, 0);
+                sendMouseButtonEvent(10, 10, false, 2);
+
+                expect(pointerEvent).to.have.been.calledTwice;
+                expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       10, 10, 0x4);
+                expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        10, 10, 0x0);
+            });
+
+            it('should handle mouse movement', function () {
+                sendMouseMoveEvent(50, 70);
+                expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                 50, 70, 0x0);
+            });
+
+            it('should handle click and drag', function () {
+                sendMouseButtonEvent(10, 10, true, 0);
+                sendMouseMoveEvent(50, 70);
+
+                expect(pointerEvent).to.have.been.calledTwice;
+                expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       10, 10, 0x1);
+                expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        50, 70, 0x1);
+
+                pointerEvent.resetHistory();
+
+                sendMouseButtonEvent(50, 70, false, 0);
+
+                expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                 50, 70, 0x0);
+            });
+
+            describe('Event Aggregation', function () {
+                it('should send a single pointer event on mouse movement', function () {
+                    sendMouseMoveEvent(50, 70);
+                    clock.tick(100);
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     50, 70, 0x0);
+                });
+
+                it('should delay one move if two events are too close', function () {
+                    sendMouseMoveEvent(18, 30);
+                    sendMouseMoveEvent(20, 50);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     18, 30, 0x0);
+                    pointerEvent.resetHistory();
+
+                    clock.tick(100);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     20, 50, 0x0);
+                });
+
+                it('should only send first and last move of many close events', function () {
+                    sendMouseMoveEvent(18, 30);
+                    sendMouseMoveEvent(20, 50);
+                    sendMouseMoveEvent(21, 55);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     18, 30, 0x0);
+                    pointerEvent.resetHistory();
+
+                    clock.tick(100);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     21, 55, 0x0);
+                });
+
+                // We selected the 17ms since that is ~60 FPS
+                it('should send move events every 17 ms', function () {
+                    sendMouseMoveEvent(1, 10);  // instant send
+                    clock.tick(10);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     1, 10, 0x0);
+                    pointerEvent.resetHistory();
+
+                    sendMouseMoveEvent(2, 20);  // delayed
+                    clock.tick(10);        // timeout send
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     2, 20, 0x0);
+                    pointerEvent.resetHistory();
+
+                    sendMouseMoveEvent(3, 30);  // delayed
+                    clock.tick(10);
+                    sendMouseMoveEvent(4, 40);  // delayed
+                    clock.tick(10);        // timeout send
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     4, 40, 0x0);
+                    pointerEvent.resetHistory();
+
+                    sendMouseMoveEvent(5, 50);  // delayed
+
+                    expect(pointerEvent).to.not.have.been.called;
+                });
+
+                it('should send waiting move events before a button press', function () {
+                    sendMouseMoveEvent(13, 9);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     13, 9, 0x0);
+                    pointerEvent.resetHistory();
+
+                    sendMouseMoveEvent(20, 70);
+
+                    expect(pointerEvent).to.not.have.been.called;
+
+                    sendMouseButtonEvent(20, 70, true, 0);
+
+                    expect(pointerEvent).to.have.been.calledTwice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 70, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 70, 0x1);
+                });
+
+                it('should send move events with enough time apart normally', function () {
+                    sendMouseMoveEvent(58, 60);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     58, 60, 0x0);
+                    pointerEvent.resetHistory();
+
+                    clock.tick(20);
+
+                    sendMouseMoveEvent(25, 60);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     25, 60, 0x0);
+                    pointerEvent.resetHistory();
+                });
+
+                it('should not send waiting move events if disconnected', function () {
+                    sendMouseMoveEvent(88, 99);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     88, 99, 0x0);
+                    pointerEvent.resetHistory();
+
+                    sendMouseMoveEvent(66, 77);
+                    client.disconnect();
+                    clock.tick(20);
+
+                    expect(pointerEvent).to.not.have.been.called;
+                });
+            });
+
+            it.skip('should block click events', function () {
+                /* FIXME */
+            });
+
+            it.skip('should block contextmenu events', function () {
+                /* FIXME */
+            });
+        });
+
+        describe('Wheel Events', function () {
+            function sendWheelEvent(x, y, dx, dy, mode=0) {
+                let pos = elementToClient(x, y);
+                let ev;
+
+                ev = new WheelEvent('wheel',
+                                    { 'screenX': pos.x + window.screenX,
+                                      'screenY': pos.y + window.screenY,
+                                      'clientX': pos.x,
+                                      'clientY': pos.y,
+                                      'deltaX': dx,
+                                      'deltaY': dy,
+                                      'deltaMode': mode });
+                client._canvas.dispatchEvent(ev);
+            }
+
+            it('should handle wheel up event', function () {
+                sendWheelEvent(10, 10, 0, -50);
+
+                expect(pointerEvent).to.have.been.calledTwice;
+                expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       10, 10, 1<<3);
+                expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        10, 10, 0);
+            });
+
+            it('should handle wheel down event', function () {
+                sendWheelEvent(10, 10, 0, 50);
+
+                expect(pointerEvent).to.have.been.calledTwice;
+                expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       10, 10, 1<<4);
+                expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        10, 10, 0);
+            });
+
+            it('should handle wheel left event', function () {
+                sendWheelEvent(10, 10, -50, 0);
+
+                expect(pointerEvent).to.have.been.calledTwice;
+                expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       10, 10, 1<<5);
+                expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        10, 10, 0);
+            });
+
+            it('should handle wheel right event', function () {
+                sendWheelEvent(10, 10, 50, 0);
+
+                expect(pointerEvent).to.have.been.calledTwice;
+                expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       10, 10, 1<<6);
+                expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        10, 10, 0);
+            });
+
+            it('should ignore wheel when in view only', function () {
+                client._viewOnly = true;
+
+                sendWheelEvent(10, 10, 50, 0);
+
+                expect(pointerEvent).to.not.have.been.called;
+            });
+
+            it('should accumulate wheel events if small enough', function () {
+                sendWheelEvent(10, 10, 0, 20);
+                sendWheelEvent(10, 10, 0, 20);
+
+                expect(pointerEvent).to.not.have.been.called;
+
+                sendWheelEvent(10, 10, 0, 20);
+
+                expect(pointerEvent).to.have.been.calledTwice;
+                expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       10, 10, 1<<4);
+                expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        10, 10, 0);
+            });
+
+            it('should not accumulate large wheel events', function () {
+                sendWheelEvent(10, 10, 0, 400);
+
+                expect(pointerEvent).to.have.been.calledTwice;
+                expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       10, 10, 1<<4);
+                expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        10, 10, 0);
+            });
+
+            it('should handle line based wheel event', function () {
+                sendWheelEvent(10, 10, 0, 3, 1);
+
+                expect(pointerEvent).to.have.been.calledTwice;
+                expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       10, 10, 1<<4);
+                expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        10, 10, 0);
+            });
+
+            it('should handle page based wheel event', function () {
+                sendWheelEvent(10, 10, 0, 3, 2);
+
+                expect(pointerEvent).to.have.been.calledTwice;
+                expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       10, 10, 1<<4);
+                expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        10, 10, 0);
+            });
+        });
+
+        describe('Keyboard Events', function () {
+            it('should send a key message on a key press', function () {
+                client._handleKeyEvent(0x41, 'KeyA', true);
+                const keyMsg = {_sQ: new Uint8Array(8), _sQlen: 0, flush: () => {}};
+                RFB.messages.keyEvent(keyMsg, 0x41, 1);
+                expect(client._sock).to.have.sent(keyMsg._sQ);
+            });
+
+            it('should not send messages in view-only mode', function () {
+                client._viewOnly = true;
+                sinon.spy(client._sock, 'flush');
+                client._handleKeyEvent('a', 'KeyA', true);
+                expect(client._sock.flush).to.not.have.been.called;
+            });
+        });
+
+        describe('Gesture event handlers', function () {
+            function gestureStart(gestureType, x, y,
+                                  magnitudeX = 0, magnitudeY = 0) {
+                let pos = elementToClient(x, y);
+                let detail = {type: gestureType, clientX: pos.x, clientY: pos.y};
+
+                detail.magnitudeX = magnitudeX;
+                detail.magnitudeY = magnitudeY;
+
+                let ev = new CustomEvent('gesturestart', { detail: detail });
+                client._canvas.dispatchEvent(ev);
+            }
+
+            function gestureMove(gestureType, x, y,
+                                 magnitudeX = 0, magnitudeY = 0) {
+                let pos = elementToClient(x, y);
+                let detail = {type: gestureType, clientX: pos.x, clientY: pos.y};
+
+                detail.magnitudeX = magnitudeX;
+                detail.magnitudeY = magnitudeY;
+
+                let ev = new CustomEvent('gesturemove', { detail: detail });
+                client._canvas.dispatchEvent(ev);
+            }
+
+            function gestureEnd(gestureType, x, y) {
+                let pos = elementToClient(x, y);
+                let detail = {type: gestureType, clientX: pos.x, clientY: pos.y};
+                let ev = new CustomEvent('gestureend', { detail: detail });
+                client._canvas.dispatchEvent(ev);
+            }
+
+            describe('Gesture onetap', function () {
+                it('should handle onetap events', function () {
+                    let bmask = 0x1;
+
+                    gestureStart('onetap', 20, 40);
+                    gestureEnd('onetap', 20, 40);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                });
+
+                it('should keep same position for multiple onetap events', function () {
+                    let bmask = 0x1;
+
+                    gestureStart('onetap', 20, 40);
+                    gestureEnd('onetap', 20, 40);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+
+                    pointerEvent.resetHistory();
+
+                    gestureStart('onetap', 20, 50);
+                    gestureEnd('onetap', 20, 50);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+
+                    pointerEvent.resetHistory();
+
+                    gestureStart('onetap', 30, 50);
+                    gestureEnd('onetap', 30, 50);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                });
+
+                it('should not keep same position for onetap events when too far apart', function () {
+                    let bmask = 0x1;
+
+                    gestureStart('onetap', 20, 40);
+                    gestureEnd('onetap', 20, 40);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+
+                    pointerEvent.resetHistory();
+
+                    gestureStart('onetap', 80, 95);
+                    gestureEnd('onetap', 80, 95);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           80, 95, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            80, 95, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           80, 95, 0x0);
+                });
+
+                it('should not keep same position for onetap events when enough time inbetween', function () {
+                    let bmask = 0x1;
+
+                    gestureStart('onetap', 10, 20);
+                    gestureEnd('onetap', 10, 20);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           10, 20, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            10, 20, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           10, 20, 0x0);
+
+                    pointerEvent.resetHistory();
+                    this.clock.tick(1500);
+
+                    gestureStart('onetap', 15, 20);
+                    gestureEnd('onetap', 15, 20);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           15, 20, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            15, 20, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           15, 20, 0x0);
+
+                    pointerEvent.resetHistory();
+                });
+            });
+
+            describe('Gesture twotap', function () {
+                it('should handle gesture twotap events', function () {
+                    let bmask = 0x4;
+
+                    gestureStart("twotap", 20, 40);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                });
+
+                it('should keep same position for multiple twotap events', function () {
+                    let bmask = 0x4;
+
+                    for (let offset = 0;offset < 30;offset += 10) {
+                        pointerEvent.resetHistory();
+
+                        gestureStart('twotap', 20, 40 + offset);
+                        gestureEnd('twotap', 20, 40 + offset);
+
+                        expect(pointerEvent).to.have.been.calledThrice;
+                        expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                               20, 40, 0x0);
+                        expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                                20, 40, bmask);
+                        expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                               20, 40, 0x0);
+                    }
+                });
+            });
+
+            describe('Gesture threetap', function () {
+                it('should handle gesture start for threetap events', function () {
+                    let bmask = 0x2;
+
+                    gestureStart("threetap", 20, 40);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                });
+
+                it('should keep same position for multiple threetap events', function () {
+                    let bmask = 0x2;
+
+                    for (let offset = 0;offset < 30;offset += 10) {
+                        pointerEvent.resetHistory();
+
+                        gestureStart('threetap', 20, 40 + offset);
+                        gestureEnd('threetap', 20, 40 + offset);
+
+                        expect(pointerEvent).to.have.been.calledThrice;
+                        expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                               20, 40, 0x0);
+                        expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                                20, 40, bmask);
+                        expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                               20, 40, 0x0);
+                    }
+                });
+            });
+
+            describe('Gesture drag', function () {
+                it('should handle gesture drag events', function () {
+                    let bmask = 0x1;
+
+                    gestureStart('drag', 20, 40);
+
+                    expect(pointerEvent).to.have.been.calledTwice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('drag', 30, 50);
+                    clock.tick(50);
+
+                    expect(pointerEvent).to.have.been.calledOnce;
+                    expect(pointerEvent).to.have.been.calledWith(client._sock,
+                                                                 30, 50, bmask);
+
+                    pointerEvent.resetHistory();
+
+                    gestureEnd('drag', 30, 50);
+
+                    expect(pointerEvent).to.have.been.calledTwice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           30, 50, bmask);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            30, 50, 0x0);
+                });
+            });
+
+            describe('Gesture long press', function () {
+                it('should handle long press events', function () {
+                    let bmask = 0x4;
+
+                    gestureStart('longpress', 20, 40);
+
+                    expect(pointerEvent).to.have.been.calledTwice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    pointerEvent.resetHistory();
+
+                    gestureMove('longpress', 40, 60);
+                    clock.tick(50);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     40, 60, bmask);
+
+                    pointerEvent.resetHistory();
+
+                    gestureEnd('longpress', 40, 60);
+
+                    expect(pointerEvent).to.have.been.calledTwice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           40, 60, bmask);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            40, 60, 0x0);
+                });
+            });
+
+            describe('Gesture twodrag', function () {
+                it('should handle gesture twodrag up events', function () {
+                    let bmask = 0x10; // Button mask for scroll down
+
+                    gestureStart('twodrag', 20, 40, 0, 0);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     20, 40, 0x0);
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('twodrag', 20, 40, 0, -60);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                });
+
+                it('should handle gesture twodrag down events', function () {
+                    let bmask = 0x8; // Button mask for scroll up
+
+                    gestureStart('twodrag', 20, 40, 0, 0);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     20, 40, 0x0);
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('twodrag', 20, 40, 0, 60);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                });
+
+                it('should handle gesture twodrag right events', function () {
+                    let bmask = 0x20; // Button mask for scroll right
+
+                    gestureStart('twodrag', 20, 40, 0, 0);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     20, 40, 0x0);
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('twodrag', 20, 40, 60, 0);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                });
+
+                it('should handle gesture twodrag left events', function () {
+                    let bmask = 0x40; // Button mask for scroll left
+
+                    gestureStart('twodrag', 20, 40, 0, 0);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     20, 40, 0x0);
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('twodrag', 20, 40, -60, 0);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                });
+
+                it('should handle gesture twodrag diag events', function () {
+                    let scrlUp = 0x8; // Button mask for scroll up
+                    let scrlRight = 0x20; // Button mask for scroll right
+
+                    gestureStart('twodrag', 20, 40, 0, 0);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     20, 40, 0x0);
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('twodrag', 20, 40, 60, 60);
+
+                    expect(pointerEvent).to.have.been.callCount(5);
+                    expect(pointerEvent.getCall(0)).to.have.been.calledWith(client._sock,
+                                                                            20, 40, 0x0);
+                    expect(pointerEvent.getCall(1)).to.have.been.calledWith(client._sock,
+                                                                            20, 40, scrlUp);
+                    expect(pointerEvent.getCall(2)).to.have.been.calledWith(client._sock,
+                                                                            20, 40, 0x0);
+                    expect(pointerEvent.getCall(3)).to.have.been.calledWith(client._sock,
+                                                                            20, 40, scrlRight);
+                    expect(pointerEvent.getCall(4)).to.have.been.calledWith(client._sock,
+                                                                            20, 40, 0x0);
+                });
+
+                it('should handle multiple small gesture twodrag events', function () {
+                    let bmask = 0x8; // Button mask for scroll up
+
+                    gestureStart('twodrag', 20, 40, 0, 0);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     20, 40, 0x0);
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('twodrag', 20, 40, 0, 10);
+                    clock.tick(50);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     20, 40, 0x0);
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('twodrag', 20, 40, 0, 20);
+                    clock.tick(50);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     20, 40, 0x0);
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('twodrag', 20, 40, 0, 60);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                });
+
+                it('should handle large gesture twodrag events', function () {
+                    let bmask = 0x8; // Button mask for scroll up
+
+                    gestureStart('twodrag', 30, 50, 0, 0);
+
+                    expect(pointerEvent).
+                        to.have.been.calledOnceWith(client._sock, 30, 50, 0x0);
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('twodrag', 30, 50, 0, 200);
+
+                    expect(pointerEvent).to.have.callCount(7);
+                    expect(pointerEvent.getCall(0)).to.have.been.calledWith(client._sock,
+                                                                            30, 50, 0x0);
+                    expect(pointerEvent.getCall(1)).to.have.been.calledWith(client._sock,
+                                                                            30, 50, bmask);
+                    expect(pointerEvent.getCall(2)).to.have.been.calledWith(client._sock,
+                                                                            30, 50, 0x0);
+                    expect(pointerEvent.getCall(3)).to.have.been.calledWith(client._sock,
+                                                                            30, 50, bmask);
+                    expect(pointerEvent.getCall(4)).to.have.been.calledWith(client._sock,
+                                                                            30, 50, 0x0);
+                    expect(pointerEvent.getCall(5)).to.have.been.calledWith(client._sock,
+                                                                            30, 50, bmask);
+                    expect(pointerEvent.getCall(6)).to.have.been.calledWith(client._sock,
+                                                                            30, 50, 0x0);
+                });
+            });
+
+            describe('Gesture pinch', function () {
+                it('should handle gesture pinch in events', function () {
+                    let keysym = KeyTable.XK_Control_L;
+                    let bmask = 0x10; // Button mask for scroll down
+
+                    gestureStart('pinch', 20, 40, 90, 90);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     20, 40, 0x0);
+                    expect(keyEvent).to.not.have.been.called;
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('pinch', 20, 40, 30, 30);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+
+                    expect(keyEvent).to.have.been.calledTwice;
+                    expect(keyEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       keysym, 1);
+                    expect(keyEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        keysym, 0);
+
+                    expect(keyEvent.firstCall).to.have.been.calledBefore(pointerEvent.secondCall);
+                    expect(keyEvent.lastCall).to.have.been.calledAfter(pointerEvent.lastCall);
+
+                    pointerEvent.resetHistory();
+                    keyEvent.resetHistory();
+
+                    gestureEnd('pinch', 20, 40);
+
+                    expect(pointerEvent).to.not.have.been.called;
+                    expect(keyEvent).to.not.have.been.called;
+                });
+
+                it('should handle gesture pinch out events', function () {
+                    let keysym = KeyTable.XK_Control_L;
+                    let bmask = 0x8; // Button mask for scroll up
+
+                    gestureStart('pinch', 10, 20, 10, 20);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     10, 20, 0x0);
+                    expect(keyEvent).to.not.have.been.called;
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('pinch', 10, 20, 70, 80);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           10, 20, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            10, 20, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           10, 20, 0x0);
+
+                    expect(keyEvent).to.have.been.calledTwice;
+                    expect(keyEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       keysym, 1);
+                    expect(keyEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        keysym, 0);
+
+                    expect(keyEvent.firstCall).to.have.been.calledBefore(pointerEvent.secondCall);
+                    expect(keyEvent.lastCall).to.have.been.calledAfter(pointerEvent.lastCall);
+
+                    pointerEvent.resetHistory();
+                    keyEvent.resetHistory();
+
+                    gestureEnd('pinch', 10, 20);
+
+                    expect(pointerEvent).to.not.have.been.called;
+                    expect(keyEvent).to.not.have.been.called;
+                });
+
+                it('should handle large gesture pinch', function () {
+                    let keysym = KeyTable.XK_Control_L;
+                    let bmask = 0x10; // Button mask for scroll down
+
+                    gestureStart('pinch', 20, 40, 150, 150);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     20, 40, 0x0);
+                    expect(keyEvent).to.not.have.been.called;
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('pinch', 20, 40, 30, 30);
+
+                    expect(pointerEvent).to.have.been.callCount(5);
+                    expect(pointerEvent.getCall(0)).to.have.been.calledWith(client._sock,
+                                                                            20, 40, 0x0);
+                    expect(pointerEvent.getCall(1)).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.getCall(2)).to.have.been.calledWith(client._sock,
+                                                                            20, 40, 0x0);
+                    expect(pointerEvent.getCall(3)).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.getCall(4)).to.have.been.calledWith(client._sock,
+                                                                            20, 40, 0x0);
+
+                    expect(keyEvent).to.have.been.calledTwice;
+                    expect(keyEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       keysym, 1);
+                    expect(keyEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        keysym, 0);
+
+                    expect(keyEvent.firstCall).to.have.been.calledBefore(pointerEvent.secondCall);
+                    expect(keyEvent.lastCall).to.have.been.calledAfter(pointerEvent.lastCall);
+
+                    pointerEvent.resetHistory();
+                    keyEvent.resetHistory();
+
+                    gestureEnd('pinch', 20, 40);
+
+                    expect(pointerEvent).to.not.have.been.called;
+                    expect(keyEvent).to.not.have.been.called;
+                });
+
+                it('should handle multiple small gesture pinch out events', function () {
+                    let keysym = KeyTable.XK_Control_L;
+                    let bmask = 0x8; // Button mask for scroll down
+
+                    gestureStart('pinch', 20, 40, 0, 10);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     20, 40, 0x0);
+                    expect(keyEvent).to.not.have.been.called;
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('pinch', 20, 40, 0, 30);
+                    clock.tick(50);
+
+                    expect(pointerEvent).to.have.been.calledWith(client._sock,
+                                                                 20, 40, 0x0);
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('pinch', 20, 40, 0, 60);
+                    clock.tick(50);
+
+                    expect(pointerEvent).to.have.been.calledWith(client._sock,
+                                                                 20, 40, 0x0);
+
+                    pointerEvent.resetHistory();
+                    keyEvent.resetHistory();
+
+                    gestureMove('pinch', 20, 40, 0, 90);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+
+                    expect(keyEvent).to.have.been.calledTwice;
+                    expect(keyEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                       keysym, 1);
+                    expect(keyEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                        keysym, 0);
+
+                    expect(keyEvent.firstCall).to.have.been.calledBefore(pointerEvent.secondCall);
+                    expect(keyEvent.lastCall).to.have.been.calledAfter(pointerEvent.lastCall);
+
+                    pointerEvent.resetHistory();
+                    keyEvent.resetHistory();
+
+                    gestureEnd('pinch', 20, 40);
+
+                    expect(keyEvent).to.not.have.been.called;
+                });
+
+                it('should send correct key control code', function () {
+                    let keysym = KeyTable.XK_Control_L;
+                    let code = 0x1d;
+                    let bmask = 0x10; // Button mask for scroll down
+
+                    client._qemuExtKeyEventSupported = true;
+
+                    gestureStart('pinch', 20, 40, 90, 90);
+
+                    expect(pointerEvent).to.have.been.calledOnceWith(client._sock,
+                                                                     20, 40, 0x0);
+                    expect(qemuKeyEvent).to.not.have.been.called;
+
+                    pointerEvent.resetHistory();
+
+                    gestureMove('pinch', 20, 40, 30, 30);
+
+                    expect(pointerEvent).to.have.been.calledThrice;
+                    expect(pointerEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+                    expect(pointerEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            20, 40, bmask);
+                    expect(pointerEvent.thirdCall).to.have.been.calledWith(client._sock,
+                                                                           20, 40, 0x0);
+
+                    expect(qemuKeyEvent).to.have.been.calledTwice;
+                    expect(qemuKeyEvent.firstCall).to.have.been.calledWith(client._sock,
+                                                                           keysym,
+                                                                           true,
+                                                                           code);
+                    expect(qemuKeyEvent.secondCall).to.have.been.calledWith(client._sock,
+                                                                            keysym,
+                                                                            false,
+                                                                            code);
+
+                    expect(qemuKeyEvent.firstCall).to.have.been.calledBefore(pointerEvent.secondCall);
+                    expect(qemuKeyEvent.lastCall).to.have.been.calledAfter(pointerEvent.lastCall);
+
+                    pointerEvent.resetHistory();
+                    qemuKeyEvent.resetHistory();
+
+                    gestureEnd('pinch', 20, 40);
+
+                    expect(pointerEvent).to.not.have.been.called;
+                    expect(qemuKeyEvent).to.not.have.been.called;
+                });
+            });
+        });
+
+        describe('WebSocket Events', function () {
+            // message events
+            it('should do nothing if we receive an empty message and have nothing in the queue', function () {
+                client._normalMsg = sinon.spy();
+                client._sock._websocket._receiveData(new Uint8Array([]));
+                expect(client._normalMsg).to.not.have.been.called;
+            });
+
+            it('should handle a message in the connected state as a normal message', function () {
+                client._normalMsg = sinon.spy();
+                client._sock._websocket._receiveData(new Uint8Array([1, 2, 3]));
+                expect(client._normalMsg).to.have.been.called;
+            });
+
+            it('should handle a message in any non-disconnected/failed state like an init message', function () {
+                client._rfbConnectionState = 'connecting';
+                client._rfbInitState = 'ProtocolVersion';
+                client._initMsg = sinon.spy();
+                client._sock._websocket._receiveData(new Uint8Array([1, 2, 3]));
+                expect(client._initMsg).to.have.been.called;
+            });
+
+            it('should process all normal messages directly', function () {
+                const spy = sinon.spy();
+                client.addEventListener("bell", spy);
+                client._sock._websocket._receiveData(new Uint8Array([0x02, 0x02]));
+                expect(spy).to.have.been.calledTwice;
+            });
+
+            // open events
+            it('should update the state to ProtocolVersion on open (if the state is "connecting")', function () {
+                client = new RFB(document.createElement('div'), 'wss://host:8675');
+                this.clock.tick();
+                client._sock._websocket._open();
+                expect(client._rfbInitState).to.equal('ProtocolVersion');
+            });
+
+            it('should fail if we are not currently ready to connect and we get an "open" event', function () {
+                sinon.spy(client, "_fail");
+                client._rfbConnectionState = 'connected';
+                client._sock._websocket._open();
+                expect(client._fail).to.have.been.calledOnce;
+            });
+
+            // close events
+            it('should transition to "disconnected" from "disconnecting" on a close event', function () {
+                const real = client._sock._websocket.close;
+                client._sock._websocket.close = () => {};
+                client.disconnect();
+                expect(client._rfbConnectionState).to.equal('disconnecting');
+                client._sock._websocket.close = real;
+                client._sock._websocket.close();
+                expect(client._rfbConnectionState).to.equal('disconnected');
+            });
+
+            it('should fail if we get a close event while connecting', function () {
+                sinon.spy(client, "_fail");
+                client._rfbConnectionState = 'connecting';
+                client._sock._websocket.close();
+                expect(client._fail).to.have.been.calledOnce;
+            });
+
+            it('should unregister close event handler', function () {
+                sinon.spy(client._sock, 'off');
+                client.disconnect();
+                client._sock._websocket.close();
+                expect(client._sock.off).to.have.been.calledWith('close');
+            });
+
+            // error events do nothing
+        });
+    });
+
+    describe('Quality level setting', function () {
+        const defaultQuality = 6;
+
+        let client;
+
+        beforeEach(function () {
+            client = makeRFB();
+            sinon.spy(RFB.messages, "clientEncodings");
+        });
+
+        afterEach(function () {
+            RFB.messages.clientEncodings.restore();
+        });
+
+        it(`should equal ${defaultQuality} by default`, function () {
+            expect(client._qualityLevel).to.equal(defaultQuality);
+        });
+
+        it('should ignore non-integers when set', function () {
+            client.qualityLevel = '1';
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client.qualityLevel = 1.5;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client.qualityLevel = null;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client.qualityLevel = undefined;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client.qualityLevel = {};
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+        });
+
+        it('should ignore integers out of range [0, 9]', function () {
+            client.qualityLevel = -1;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client.qualityLevel = 10;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+        });
+
+        it('should send clientEncodings with new quality value', function () {
+            let newQuality;
+
+            newQuality = 8;
+            client.qualityLevel = newQuality;
+            expect(client.qualityLevel).to.equal(newQuality);
+            expect(RFB.messages.clientEncodings).to.have.been.calledOnce;
+            expect(RFB.messages.clientEncodings.getCall(0).args[1]).to.include(encodings.pseudoEncodingQualityLevel0 + newQuality);
+        });
+
+        it('should not send clientEncodings if quality is the same', function () {
+            let newQuality;
+
+            newQuality = 2;
+            client.qualityLevel = newQuality;
+            expect(RFB.messages.clientEncodings).to.have.been.calledOnce;
+            expect(RFB.messages.clientEncodings.getCall(0).args[1]).to.include(encodings.pseudoEncodingQualityLevel0 + newQuality);
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client.qualityLevel = newQuality;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+        });
+
+        it('should not send clientEncodings if not in connected state', function () {
+            let newQuality;
+
+            client._rfbConnectionState = '';
+            newQuality = 2;
+            client.qualityLevel = newQuality;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client._rfbConnectionState = 'connnecting';
+            newQuality = 6;
+            client.qualityLevel = newQuality;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client._rfbConnectionState = 'connected';
+            newQuality = 5;
+            client.qualityLevel = newQuality;
+            expect(RFB.messages.clientEncodings).to.have.been.calledOnce;
+            expect(RFB.messages.clientEncodings.getCall(0).args[1]).to.include(encodings.pseudoEncodingQualityLevel0 + newQuality);
+        });
+    });
+
+    describe('Compression level setting', function () {
+        const defaultCompression = 2;
+
+        let client;
+
+        beforeEach(function () {
+            client = makeRFB();
+            sinon.spy(RFB.messages, "clientEncodings");
+        });
+
+        afterEach(function () {
+            RFB.messages.clientEncodings.restore();
+        });
+
+        it(`should equal ${defaultCompression} by default`, function () {
+            expect(client._compressionLevel).to.equal(defaultCompression);
+        });
+
+        it('should ignore non-integers when set', function () {
+            client.compressionLevel = '1';
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client.compressionLevel = 1.5;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client.compressionLevel = null;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client.compressionLevel = undefined;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client.compressionLevel = {};
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+        });
+
+        it('should ignore integers out of range [0, 9]', function () {
+            client.compressionLevel = -1;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client.compressionLevel = 10;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+        });
+
+        it('should send clientEncodings with new compression value', function () {
+            let newCompression;
+
+            newCompression = 5;
+            client.compressionLevel = newCompression;
+            expect(client.compressionLevel).to.equal(newCompression);
+            expect(RFB.messages.clientEncodings).to.have.been.calledOnce;
+            expect(RFB.messages.clientEncodings.getCall(0).args[1]).to.include(encodings.pseudoEncodingCompressLevel0 + newCompression);
+        });
+
+        it('should not send clientEncodings if compression is the same', function () {
+            let newCompression;
+
+            newCompression = 9;
+            client.compressionLevel = newCompression;
+            expect(RFB.messages.clientEncodings).to.have.been.calledOnce;
+            expect(RFB.messages.clientEncodings.getCall(0).args[1]).to.include(encodings.pseudoEncodingCompressLevel0 + newCompression);
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client.compressionLevel = newCompression;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+        });
+
+        it('should not send clientEncodings if not in connected state', function () {
+            let newCompression;
+
+            client._rfbConnectionState = '';
+            newCompression = 7;
+            client.compressionLevel = newCompression;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client._rfbConnectionState = 'connnecting';
+            newCompression = 6;
+            client.compressionLevel = newCompression;
+            expect(RFB.messages.clientEncodings).to.not.have.been.called;
+
+            RFB.messages.clientEncodings.resetHistory();
+
+            client._rfbConnectionState = 'connected';
+            newCompression = 5;
+            client.compressionLevel = newCompression;
+            expect(RFB.messages.clientEncodings).to.have.been.calledOnce;
+            expect(RFB.messages.clientEncodings.getCall(0).args[1]).to.include(encodings.pseudoEncodingCompressLevel0 + newCompression);
+        });
+    });
+});
+
+describe('RFB messages', function () {
+    let sock;
+
+    before(function () {
+        FakeWebSocket.replace();
+        sock = new Websock();
+        sock.open();
+    });
+
+    after(function () {
+        FakeWebSocket.restore();
+    });
+
+    describe('Extended Clipboard Handling Send', function () {
+        beforeEach(function () {
+            sinon.spy(RFB.messages, 'clientCutText');
+        });
+
+        afterEach(function () {
+            RFB.messages.clientCutText.restore();
+        });
+
+        it('should call clientCutText with correct Caps data', function () {
+            let formats = {
+                0: 2,
+                2: 4121
+            };
+            let expectedData = new Uint8Array([0x1F, 0x00, 0x00, 0x05,
+                                               0x00, 0x00, 0x00, 0x02,
+                                               0x00, 0x00, 0x10, 0x19]);
+            let actions = [
+                1 << 24,  // Caps
+                1 << 25,  // Request
+                1 << 26,  // Peek
+                1 << 27,  // Notify
+                1 << 28   // Provide
+            ];
+
+            RFB.messages.extendedClipboardCaps(sock, actions, formats);
+            expect(RFB.messages.clientCutText).to.have.been.calledOnce;
+            expect(RFB.messages.clientCutText).to.have.been.calledWith(sock, expectedData);
+        });
+
+        it('should call clientCutText with correct Request data', function () {
+            let formats = new Uint8Array([0x01]);
+            let expectedData = new Uint8Array([0x02, 0x00, 0x00, 0x01]);
+
+            RFB.messages.extendedClipboardRequest(sock, formats);
+            expect(RFB.messages.clientCutText).to.have.been.calledOnce;
+            expect(RFB.messages.clientCutText).to.have.been.calledWith(sock, expectedData);
+        });
+
+        it('should call clientCutText with correct Notify data', function () {
+            let formats = new Uint8Array([0x01]);
+            let expectedData = new Uint8Array([0x08, 0x00, 0x00, 0x01]);
+
+            RFB.messages.extendedClipboardNotify(sock, formats);
+            expect(RFB.messages.clientCutText).to.have.been.calledOnce;
+            expect(RFB.messages.clientCutText).to.have.been.calledWith(sock, expectedData);
+        });
+
+        it('should call clientCutText with correct Provide data', function () {
+            let testText = "Test string";
+            let expectedText = encodeUTF8(testText + "\0");
+
+            let deflatedData =  deflateWithSize(expectedText);
+
+            // Build Expected with flags and deflated data
+            let expectedData = new Uint8Array(4 + deflatedData.length);
+            expectedData[0] = 0x10; // The client capabilities
+            expectedData[1] = 0x00; // Reserved flags
+            expectedData[2] = 0x00; // Reserved flags
+            expectedData[3] = 0x01; // The formats client supports
+            expectedData.set(deflatedData, 4);
+
+            RFB.messages.extendedClipboardProvide(sock, [0x01], [testText]);
+            expect(RFB.messages.clientCutText).to.have.been.calledOnce;
+            expect(RFB.messages.clientCutText).to.have.been.calledWith(sock, expectedData, true);
+
+        });
+
+        describe('End of line characters', function () {
+            it('Carriage return', function () {
+
+                let testText = "Hello\rworld\r\r!";
+                let expectedText = encodeUTF8("Hello\r\nworld\r\n\r\n!\0");
+
+                let deflatedData =  deflateWithSize(expectedText);
+
+                // Build Expected with flags and deflated data
+                let expectedData = new Uint8Array(4 + deflatedData.length);
+                expectedData[0] = 0x10; // The client capabilities
+                expectedData[1] = 0x00; // Reserved flags
+                expectedData[2] = 0x00; // Reserved flags
+                expectedData[3] = 0x01; // The formats client supports
+                expectedData.set(deflatedData, 4);
+
+                RFB.messages.extendedClipboardProvide(sock, [0x01], [testText]);
+                expect(RFB.messages.clientCutText).to.have.been.calledOnce;
+                expect(RFB.messages.clientCutText).to.have.been.calledWith(sock, expectedData, true);
+            });
+
+            it('Carriage return Line feed', function () {
+
+                let testText = "Hello\r\n\r\nworld\r\n!";
+                let expectedText = encodeUTF8(testText + "\0");
+
+                let deflatedData =  deflateWithSize(expectedText);
+
+                // Build Expected with flags and deflated data
+                let expectedData = new Uint8Array(4 + deflatedData.length);
+                expectedData[0] = 0x10; // The client capabilities
+                expectedData[1] = 0x00; // Reserved flags
+                expectedData[2] = 0x00; // Reserved flags
+                expectedData[3] = 0x01; // The formats client supports
+                expectedData.set(deflatedData, 4);
+
+                RFB.messages.extendedClipboardProvide(sock, [0x01], [testText]);
+                expect(RFB.messages.clientCutText).to.have.been.calledOnce;
+                expect(RFB.messages.clientCutText).to.have.been.calledWith(sock, expectedData, true);
+            });
+
+            it('Line feed', function () {
+                let testText = "Hello\n\n\nworld\n!";
+                let expectedText = encodeUTF8("Hello\r\n\r\n\r\nworld\r\n!\0");
+
+                let deflatedData =  deflateWithSize(expectedText);
+
+                // Build Expected with flags and deflated data
+                let expectedData = new Uint8Array(4 + deflatedData.length);
+                expectedData[0] = 0x10; // The client capabilities
+                expectedData[1] = 0x00; // Reserved flags
+                expectedData[2] = 0x00; // Reserved flags
+                expectedData[3] = 0x01; // The formats client supports
+                expectedData.set(deflatedData, 4);
+
+                RFB.messages.extendedClipboardProvide(sock, [0x01], [testText]);
+                expect(RFB.messages.clientCutText).to.have.been.calledOnce;
+                expect(RFB.messages.clientCutText).to.have.been.calledWith(sock, expectedData, true);
+            });
+
+            it('Carriage return and Line feed mixed', function () {
+                let testText = "\rHello\r\n\rworld\n\n!";
+                let expectedText = encodeUTF8("\r\nHello\r\n\r\nworld\r\n\r\n!\0");
+
+                let deflatedData =  deflateWithSize(expectedText);
+
+                // Build Expected with flags and deflated data
+                let expectedData = new Uint8Array(4 + deflatedData.length);
+                expectedData[0] = 0x10; // The client capabilities
+                expectedData[1] = 0x00; // Reserved flags
+                expectedData[2] = 0x00; // Reserved flags
+                expectedData[3] = 0x01; // The formats client supports
+                expectedData.set(deflatedData, 4);
+
+                RFB.messages.extendedClipboardProvide(sock, [0x01], [testText]);
+                expect(RFB.messages.clientCutText).to.have.been.calledOnce;
+                expect(RFB.messages.clientCutText).to.have.been.calledWith(sock, expectedData, true);
+            });
+        });
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.rre.js
@@ -0,0 +1,107 @@
+const expect = chai.expect;
+
+import Websock from '../core/websock.js';
+import Display from '../core/display.js';
+
+import RREDecoder from '../core/decoders/rre.js';
+
+import FakeWebSocket from './fake.websocket.js';
+
+function testDecodeRect(decoder, x, y, width, height, data, display, depth) {
+    let sock;
+
+    sock = new Websock;
+    sock.open("ws://example.com");
+
+    sock.on('message', () => {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    });
+
+    // Empty messages are filtered at multiple layers, so we need to
+    // do a direct call
+    if (data.length === 0) {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    } else {
+        sock._websocket._receiveData(new Uint8Array(data));
+    }
+
+    display.flip();
+}
+
+function push16(arr, num) {
+    arr.push((num >> 8) & 0xFF,
+             num & 0xFF);
+}
+
+function push32(arr, num) {
+    arr.push((num >> 24) & 0xFF,
+             (num >> 16) & 0xFF,
+             (num >>  8) & 0xFF,
+             num & 0xFF);
+}
+
+describe('RRE Decoder', function () {
+    let decoder;
+    let display;
+
+    before(FakeWebSocket.replace);
+    after(FakeWebSocket.restore);
+
+    beforeEach(function () {
+        decoder = new RREDecoder();
+        display = new Display(document.createElement('canvas'));
+        display.resize(4, 4);
+    });
+
+    // TODO(directxman12): test rre_chunk_sz?
+
+    it('should handle the RRE encoding', function () {
+        let data = [];
+        push32(data, 2); // 2 subrects
+        push32(data, 0x00ff0000); // becomes 00ff0000 --> #00FF00 bg color
+        data.push(0x00); // becomes 0000ff00 --> #0000FF fg color
+        data.push(0x00);
+        data.push(0xff);
+        data.push(0x00);
+        push16(data, 0); // x: 0
+        push16(data, 0); // y: 0
+        push16(data, 2); // width: 2
+        push16(data, 2); // height: 2
+        data.push(0x00); // becomes 0000ff00 --> #0000FF fg color
+        data.push(0x00);
+        data.push(0xff);
+        data.push(0x00);
+        push16(data, 2); // x: 2
+        push16(data, 2); // y: 2
+        push16(data, 2); // width: 2
+        push16(data, 2); // height: 2
+
+        testDecodeRect(decoder, 0, 0, 4, 4, data, display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle empty rects', function () {
+        display.fillRect(0, 0, 4, 4, [ 0x00, 0x00, 0xff ]);
+        display.fillRect(2, 0, 2, 2, [ 0x00, 0xff, 0x00 ]);
+        display.fillRect(0, 2, 2, 2, [ 0x00, 0xff, 0x00 ]);
+
+        testDecodeRect(decoder, 1, 2, 0, 0, [ 0x00, 0xff, 0xff, 0xff, 0xff ], display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.tight.js
@@ -0,0 +1,394 @@
+const expect = chai.expect;
+
+import Websock from '../core/websock.js';
+import Display from '../core/display.js';
+
+import TightDecoder from '../core/decoders/tight.js';
+
+import FakeWebSocket from './fake.websocket.js';
+
+function testDecodeRect(decoder, x, y, width, height, data, display, depth) {
+    let sock;
+
+    sock = new Websock;
+    sock.open("ws://example.com");
+
+    sock.on('message', () => {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    });
+
+    // Empty messages are filtered at multiple layers, so we need to
+    // do a direct call
+    if (data.length === 0) {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    } else {
+        sock._websocket._receiveData(new Uint8Array(data));
+    }
+
+    display.flip();
+}
+
+describe('Tight Decoder', function () {
+    let decoder;
+    let display;
+
+    before(FakeWebSocket.replace);
+    after(FakeWebSocket.restore);
+
+    beforeEach(function () {
+        decoder = new TightDecoder();
+        display = new Display(document.createElement('canvas'));
+        display.resize(4, 4);
+    });
+
+    it('should handle fill rects', function () {
+        testDecodeRect(decoder, 0, 0, 4, 4,
+                       [0x80, 0xff, 0x88, 0x44],
+                       display, 24);
+
+        let targetData = new Uint8Array([
+            0xff, 0x88, 0x44, 255, 0xff, 0x88, 0x44, 255, 0xff, 0x88, 0x44, 255, 0xff, 0x88, 0x44, 255,
+            0xff, 0x88, 0x44, 255, 0xff, 0x88, 0x44, 255, 0xff, 0x88, 0x44, 255, 0xff, 0x88, 0x44, 255,
+            0xff, 0x88, 0x44, 255, 0xff, 0x88, 0x44, 255, 0xff, 0x88, 0x44, 255, 0xff, 0x88, 0x44, 255,
+            0xff, 0x88, 0x44, 255, 0xff, 0x88, 0x44, 255, 0xff, 0x88, 0x44, 255, 0xff, 0x88, 0x44, 255,
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle uncompressed copy rects', function () {
+        let blueData = [ 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff ];
+        let greenData = [ 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00 ];
+
+        testDecodeRect(decoder, 0, 0, 2, 1, blueData, display, 24);
+        testDecodeRect(decoder, 0, 1, 2, 1, blueData, display, 24);
+        testDecodeRect(decoder, 2, 0, 2, 1, greenData, display, 24);
+        testDecodeRect(decoder, 2, 1, 2, 1, greenData, display, 24);
+        testDecodeRect(decoder, 0, 2, 2, 1, greenData, display, 24);
+        testDecodeRect(decoder, 0, 3, 2, 1, greenData, display, 24);
+        testDecodeRect(decoder, 2, 2, 2, 1, blueData, display, 24);
+        testDecodeRect(decoder, 2, 3, 2, 1, blueData, display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle compressed copy rects', function () {
+        let data = [
+            // Control byte
+            0x00,
+            // Pixels (compressed)
+            0x15,
+            0x78, 0x9c, 0x63, 0x60, 0xf8, 0xcf, 0x00, 0x44,
+            0x60, 0x82, 0x01, 0x99, 0x8d, 0x29, 0x02, 0xa6,
+            0x00, 0x7e, 0xbf, 0x0f, 0xf1 ];
+
+        testDecodeRect(decoder, 0, 0, 4, 4, data, display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle uncompressed mono rects', function () {
+        let data = [
+            // Control bytes
+            0x40, 0x01,
+            // Palette
+            0x01, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00,
+            // Pixels
+            0x30, 0x30, 0xc0, 0xc0 ];
+
+        testDecodeRect(decoder, 0, 0, 4, 4, data, display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle compressed mono rects', function () {
+        display.resize(4, 12);
+
+        let data = [
+            // Control bytes
+            0x40, 0x01,
+            // Palette
+            0x01, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00,
+            // Pixels (compressed)
+            0x0e,
+            0x78, 0x9c, 0x33, 0x30, 0x38, 0x70, 0xc0, 0x00,
+            0x8a, 0x01, 0x21, 0x3c, 0x05, 0xa1 ];
+
+        testDecodeRect(decoder, 0, 0, 4, 12, data, display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle uncompressed palette rects', function () {
+        let data1 = [
+            // Control bytes
+            0x40, 0x01,
+            // Palette
+            0x02, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
+            // Pixels
+            0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01 ];
+        let data2 = [
+            // Control bytes
+            0x40, 0x01,
+            // Palette
+            0x02, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
+            // Pixels
+            0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00 ];
+
+        testDecodeRect(decoder, 0, 0, 4, 2, data1, display, 24);
+        testDecodeRect(decoder, 0, 2, 4, 2, data2, display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle compressed palette rects', function () {
+        let data = [
+            // Control bytes
+            0x40, 0x01,
+            // Palette
+            0x02, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
+            // Pixels (compressed)
+            0x12,
+            0x78, 0x9c, 0x63, 0x60, 0x60, 0x64, 0x64, 0x00,
+            0x62, 0x08, 0xc9, 0xc0, 0x00, 0x00, 0x00, 0x54,
+            0x00, 0x09 ];
+
+        testDecodeRect(decoder, 0, 0, 4, 4, data, display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it.skip('should handle uncompressed gradient rects', function () {
+        // Not implemented yet
+    });
+
+    it.skip('should handle compressed gradient rects', function () {
+        // Not implemented yet
+    });
+
+    it('should handle empty copy rects', function () {
+        display.fillRect(0, 0, 4, 4, [ 0x00, 0x00, 0xff ]);
+        display.fillRect(2, 0, 2, 2, [ 0x00, 0xff, 0x00 ]);
+        display.fillRect(0, 2, 2, 2, [ 0x00, 0xff, 0x00 ]);
+
+        testDecodeRect(decoder, 1, 2, 0, 0, [ 0x00 ], display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle empty palette rects', function () {
+        display.fillRect(0, 0, 4, 4, [ 0x00, 0x00, 0xff ]);
+        display.fillRect(2, 0, 2, 2, [ 0x00, 0xff, 0x00 ]);
+        display.fillRect(0, 2, 2, 2, [ 0x00, 0xff, 0x00 ]);
+
+        testDecodeRect(decoder, 1, 2, 0, 0,
+                       [ 0x40, 0x01, 0x01,
+                         0xff, 0xff, 0xff,
+                         0xff, 0xff, 0xff ], display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle empty fill rects', function () {
+        display.fillRect(0, 0, 4, 4, [ 0x00, 0x00, 0xff ]);
+        display.fillRect(2, 0, 2, 2, [ 0x00, 0xff, 0x00 ]);
+        display.fillRect(0, 2, 2, 2, [ 0x00, 0xff, 0x00 ]);
+
+        testDecodeRect(decoder, 1, 2, 0, 0,
+                       [ 0x80, 0xff, 0xff, 0xff ], display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0x00, 0xff, 255, 0x00, 0x00, 0xff, 255
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle JPEG rects', function (done) {
+        let data = [
+            // Control bytes
+            0x90, 0xd6, 0x05,
+            // JPEG data
+            0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46,
+            0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00, 0x48,
+            0x00, 0x48, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x13,
+            0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
+            0x77, 0x69, 0x74, 0x68, 0x20, 0x47, 0x49, 0x4d,
+            0x50, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xff, 0xdb,
+            0x00, 0x43, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0xff, 0xc2, 0x00, 0x11, 0x08,
+            0x00, 0x04, 0x00, 0x04, 0x03, 0x01, 0x11, 0x00,
+            0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xff, 0xc4,
+            0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x07, 0xff, 0xc4, 0x00, 0x14,
+            0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x08, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01,
+            0x00, 0x02, 0x10, 0x03, 0x10, 0x00, 0x00, 0x01,
+            0x1e, 0x0a, 0xa7, 0x7f, 0xff, 0xc4, 0x00, 0x14,
+            0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x05, 0xff, 0xda, 0x00, 0x08, 0x01, 0x01,
+            0x00, 0x01, 0x05, 0x02, 0x5d, 0x74, 0x41, 0x47,
+            0xff, 0xc4, 0x00, 0x1f, 0x11, 0x00, 0x01, 0x04,
+            0x02, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x04, 0x05,
+            0x07, 0x08, 0x14, 0x16, 0x03, 0x15, 0x17, 0x25,
+            0x26, 0xff, 0xda, 0x00, 0x08, 0x01, 0x03, 0x01,
+            0x01, 0x3f, 0x01, 0xad, 0x35, 0xa6, 0x13, 0xb8,
+            0x10, 0x98, 0x5d, 0x8a, 0xb1, 0x41, 0x7e, 0x43,
+            0x99, 0x24, 0x3d, 0x8f, 0x70, 0x30, 0xd8, 0xcb,
+            0x44, 0xbb, 0x7d, 0x48, 0xb5, 0xf8, 0x18, 0x7f,
+            0xe7, 0xc1, 0x9f, 0x86, 0x45, 0x9b, 0xfa, 0xf1,
+            0x61, 0x96, 0x46, 0xbf, 0x56, 0xc8, 0x8b, 0x2b,
+            0x0b, 0x35, 0x6e, 0x4b, 0x8a, 0x95, 0x6a, 0xf9,
+            0xff, 0x00, 0xff, 0xc4, 0x00, 0x1f, 0x11, 0x00,
+            0x01, 0x04, 0x02, 0x02, 0x03, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
+            0x02, 0x04, 0x05, 0x12, 0x13, 0x14, 0x01, 0x06,
+            0x11, 0x22, 0x23, 0xff, 0xda, 0x00, 0x08, 0x01,
+            0x02, 0x01, 0x01, 0x3f, 0x01, 0x85, 0x85, 0x8c,
+            0xec, 0x31, 0x8d, 0xa6, 0x26, 0x1b, 0x6e, 0x48,
+            0xbc, 0xcd, 0xb0, 0xe3, 0x33, 0x86, 0xf9, 0x35,
+            0xdc, 0x15, 0xa8, 0xbe, 0x4d, 0x4a, 0x10, 0x22,
+            0x80, 0x00, 0x91, 0xe8, 0x24, 0xda, 0xb6, 0x57,
+            0x95, 0xf2, 0xa5, 0x73, 0xff, 0xc4, 0x00, 0x1e,
+            0x10, 0x00, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x03, 0x01, 0x02, 0x04, 0x12, 0x05, 0x11,
+            0x13, 0x14, 0x22, 0x23, 0xff, 0xda, 0x00, 0x08,
+            0x01, 0x01, 0x00, 0x06, 0x3f, 0x02, 0x91, 0x89,
+            0xc4, 0xc8, 0xf1, 0x60, 0x45, 0xe5, 0xc0, 0x1c,
+            0x80, 0x7a, 0x77, 0x00, 0xe4, 0x97, 0xeb, 0x24,
+            0x66, 0x33, 0xac, 0x63, 0x11, 0xfe, 0xe4, 0x76,
+            0xad, 0x56, 0xe9, 0xa8, 0x88, 0x9f, 0xff, 0xc4,
+            0x00, 0x14, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0xff, 0xda, 0x00, 0x08,
+            0x01, 0x01, 0x00, 0x01, 0x3f, 0x21, 0x68, 0x3f,
+            0x92, 0x17, 0x81, 0x1f, 0x7f, 0xff, 0xda, 0x00,
+            0x0c, 0x03, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00,
+            0x00, 0x00, 0x10, 0x5f, 0xff, 0xc4, 0x00, 0x14,
+            0x11, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0xff, 0xda, 0x00, 0x08, 0x01, 0x03,
+            0x01, 0x01, 0x3f, 0x10, 0x03, 0xeb, 0x11, 0xe4,
+            0xa7, 0xe3, 0xff, 0x00, 0xff, 0xc4, 0x00, 0x14,
+            0x11, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0xff, 0xda, 0x00, 0x08, 0x01, 0x02,
+            0x01, 0x01, 0x3f, 0x10, 0x6b, 0xd3, 0x02, 0xdc,
+            0x9a, 0xf4, 0xff, 0x00, 0xff, 0xc4, 0x00, 0x14,
+            0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0xff, 0xda, 0x00, 0x08, 0x01, 0x01,
+            0x00, 0x01, 0x3f, 0x10, 0x62, 0x7b, 0x3a, 0xd0,
+            0x3f, 0xeb, 0xff, 0x00, 0xff, 0xd9,
+        ];
+
+        testDecodeRect(decoder, 0, 0, 4, 4, data, display, 24);
+
+        let targetData = new Uint8Array([
+            0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255
+        ]);
+
+        // Browsers have rounding errors, so we need an approximate
+        // comparing function
+        function almost(a, b) {
+            let diff = Math.abs(a - b);
+            return diff < 5;
+        }
+
+        display.onflush = () => {
+            expect(display).to.have.displayed(targetData, almost);
+            done();
+        };
+        display.flush();
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.tightpng.js
@@ -0,0 +1,144 @@
+const expect = chai.expect;
+
+import Websock from '../core/websock.js';
+import Display from '../core/display.js';
+
+import TightPngDecoder from '../core/decoders/tightpng.js';
+
+import FakeWebSocket from './fake.websocket.js';
+
+function testDecodeRect(decoder, x, y, width, height, data, display, depth) {
+    let sock;
+
+    sock = new Websock;
+    sock.open("ws://example.com");
+
+    sock.on('message', () => {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    });
+
+    // Empty messages are filtered at multiple layers, so we need to
+    // do a direct call
+    if (data.length === 0) {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    } else {
+        sock._websocket._receiveData(new Uint8Array(data));
+    }
+
+    display.flip();
+}
+
+describe('TightPng Decoder', function () {
+    let decoder;
+    let display;
+
+    before(FakeWebSocket.replace);
+    after(FakeWebSocket.restore);
+
+    beforeEach(function () {
+        decoder = new TightPngDecoder();
+        display = new Display(document.createElement('canvas'));
+        display.resize(4, 4);
+    });
+
+    it('should handle the TightPng encoding', function (done) {
+        let data = [
+            // Control bytes
+            0xa0, 0xb4, 0x04,
+            // PNG data
+            0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,
+            0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
+            0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
+            0x08, 0x02, 0x00, 0x00, 0x00, 0x26, 0x93, 0x09,
+            0x29, 0x00, 0x00, 0x01, 0x84, 0x69, 0x43, 0x43,
+            0x50, 0x49, 0x43, 0x43, 0x20, 0x70, 0x72, 0x6f,
+            0x66, 0x69, 0x6c, 0x65, 0x00, 0x00, 0x28, 0x91,
+            0x7d, 0x91, 0x3d, 0x48, 0xc3, 0x40, 0x18, 0x86,
+            0xdf, 0xa6, 0x6a, 0x45, 0x2a, 0x0e, 0x76, 0x10,
+            0x71, 0x08, 0x52, 0x9d, 0x2c, 0x88, 0x8a, 0x38,
+            0x6a, 0x15, 0x8a, 0x50, 0x21, 0xd4, 0x0a, 0xad,
+            0x3a, 0x98, 0x5c, 0xfa, 0x07, 0x4d, 0x1a, 0x92,
+            0x14, 0x17, 0x47, 0xc1, 0xb5, 0xe0, 0xe0, 0xcf,
+            0x62, 0xd5, 0xc1, 0xc5, 0x59, 0x57, 0x07, 0x57,
+            0x41, 0x10, 0xfc, 0x01, 0x71, 0x72, 0x74, 0x52,
+            0x74, 0x91, 0x12, 0xbf, 0x4b, 0x0a, 0x2d, 0x62,
+            0xbc, 0xe3, 0xb8, 0x87, 0xf7, 0xbe, 0xf7, 0xe5,
+            0xee, 0x3b, 0x40, 0xa8, 0x97, 0x99, 0x66, 0x75,
+            0x8c, 0x03, 0x9a, 0x6e, 0x9b, 0xa9, 0x44, 0x5c,
+            0xcc, 0x64, 0x57, 0xc5, 0xd0, 0x2b, 0xba, 0x68,
+            0x86, 0x31, 0x8c, 0x2e, 0x99, 0x59, 0xc6, 0x9c,
+            0x24, 0x25, 0xe1, 0x3b, 0xbe, 0xee, 0x11, 0xe0,
+            0xfb, 0x5d, 0x8c, 0x67, 0xf9, 0xd7, 0xfd, 0x39,
+            0x7a, 0xd5, 0x9c, 0xc5, 0x80, 0x80, 0x48, 0x3c,
+            0xcb, 0x0c, 0xd3, 0x26, 0xde, 0x20, 0x9e, 0xde,
+            0xb4, 0x0d, 0xce, 0xfb, 0xc4, 0x11, 0x56, 0x94,
+            0x55, 0xe2, 0x73, 0xe2, 0x31, 0x93, 0x2e, 0x48,
+            0xfc, 0xc8, 0x75, 0xc5, 0xe3, 0x37, 0xce, 0x05,
+            0x97, 0x05, 0x9e, 0x19, 0x31, 0xd3, 0xa9, 0x79,
+            0xe2, 0x08, 0xb1, 0x58, 0x68, 0x63, 0xa5, 0x8d,
+            0x59, 0xd1, 0xd4, 0x88, 0xa7, 0x88, 0xa3, 0xaa,
+            0xa6, 0x53, 0xbe, 0x90, 0xf1, 0x58, 0xe5, 0xbc,
+            0xc5, 0x59, 0x2b, 0x57, 0x59, 0xf3, 0x9e, 0xfc,
+            0x85, 0xe1, 0x9c, 0xbe, 0xb2, 0xcc, 0x75, 0x5a,
+            0x43, 0x48, 0x60, 0x11, 0x4b, 0x90, 0x20, 0x42,
+            0x41, 0x15, 0x25, 0x94, 0x61, 0x23, 0x46, 0xbb,
+            0x4e, 0x8a, 0x85, 0x14, 0x9d, 0xc7, 0x7d, 0xfc,
+            0x83, 0xae, 0x5f, 0x22, 0x97, 0x42, 0xae, 0x12,
+            0x18, 0x39, 0x16, 0x50, 0x81, 0x06, 0xd9, 0xf5,
+            0x83, 0xff, 0xc1, 0xef, 0xde, 0x5a, 0xf9, 0xc9,
+            0x09, 0x2f, 0x29, 0x1c, 0x07, 0x3a, 0x5f, 0x1c,
+            0xe7, 0x63, 0x04, 0x08, 0xed, 0x02, 0x8d, 0x9a,
+            0xe3, 0x7c, 0x1f, 0x3b, 0x4e, 0xe3, 0x04, 0x08,
+            0x3e, 0x03, 0x57, 0x7a, 0xcb, 0x5f, 0xa9, 0x03,
+            0x33, 0x9f, 0xa4, 0xd7, 0x5a, 0x5a, 0xf4, 0x08,
+            0xe8, 0xdb, 0x06, 0x2e, 0xae, 0x5b, 0x9a, 0xb2,
+            0x07, 0x5c, 0xee, 0x00, 0x03, 0x4f, 0x86, 0x6c,
+            0xca, 0xae, 0x14, 0xa4, 0x25, 0xe4, 0xf3, 0xc0,
+            0xfb, 0x19, 0x7d, 0x53, 0x16, 0xe8, 0xbf, 0x05,
+            0x7a, 0xd6, 0xbc, 0xbe, 0x35, 0xcf, 0x71, 0xfa,
+            0x00, 0xa4, 0xa9, 0x57, 0xc9, 0x1b, 0xe0, 0xe0,
+            0x10, 0x18, 0x2d, 0x50, 0xf6, 0xba, 0xcf, 0xbb,
+            0xbb, 0xdb, 0xfb, 0xf6, 0x6f, 0x4d, 0xb3, 0x7f,
+            0x3f, 0x0a, 0x27, 0x72, 0x7d, 0x49, 0x29, 0x8b,
+            0xbb, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59,
+            0x73, 0x00, 0x00, 0x2e, 0x23, 0x00, 0x00, 0x2e,
+            0x23, 0x01, 0x78, 0xa5, 0x3f, 0x76, 0x00, 0x00,
+            0x00, 0x07, 0x74, 0x49, 0x4d, 0x45, 0x07, 0xe4,
+            0x06, 0x06, 0x0c, 0x23, 0x1d, 0x3f, 0x9f, 0xbb,
+            0x94, 0x00, 0x00, 0x00, 0x19, 0x74, 0x45, 0x58,
+            0x74, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74,
+            0x00, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64,
+            0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x47, 0x49,
+            0x4d, 0x50, 0x57, 0x81, 0x0e, 0x17, 0x00, 0x00,
+            0x00, 0x1e, 0x49, 0x44, 0x41, 0x54, 0x08, 0xd7,
+            0x65, 0xc9, 0xb1, 0x0d, 0x00, 0x00, 0x08, 0x03,
+            0x20, 0xea, 0xff, 0x3f, 0xd7, 0xd5, 0x44, 0x56,
+            0x52, 0x90, 0xc2, 0x38, 0xa2, 0xd0, 0xbc, 0x59,
+            0x8a, 0x9f, 0x04, 0x05, 0x6b, 0x38, 0x7b, 0xb2,
+            0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44,
+            0xae, 0x42, 0x60, 0x82,
+        ];
+
+        testDecodeRect(decoder, 0, 0, 4, 4, data, display, 24);
+
+        let targetData = new Uint8Array([
+            0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255, 0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255,
+            0x00, 0xff, 0x00, 255, 0x00, 0xff, 0x00, 255, 0xff, 0x00, 0x00, 255, 0xff, 0x00, 0x00, 255
+        ]);
+
+        // Firefox currently has some very odd rounding bug:
+        // https://bugzilla.mozilla.org/show_bug.cgi?id=1667747
+        function almost(a, b) {
+            let diff = Math.abs(a - b);
+            return diff < 30;
+        }
+
+        display.onflush = () => {
+            expect(display).to.have.displayed(targetData, almost);
+            done();
+        };
+        display.flush();
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.util.js
@@ -0,0 +1,89 @@
+/* eslint-disable no-console */
+const expect = chai.expect;
+
+import * as Log from '../core/util/logging.js';
+import { encodeUTF8, decodeUTF8 } from '../core/util/strings.js';
+
+describe('Utils', function () {
+    "use strict";
+
+    describe('logging functions', function () {
+        beforeEach(function () {
+            sinon.spy(console, 'log');
+            sinon.spy(console, 'debug');
+            sinon.spy(console, 'warn');
+            sinon.spy(console, 'error');
+            sinon.spy(console, 'info');
+        });
+
+        afterEach(function () {
+            console.log.restore();
+            console.debug.restore();
+            console.warn.restore();
+            console.error.restore();
+            console.info.restore();
+            Log.initLogging();
+        });
+
+        it('should use noop for levels lower than the min level', function () {
+            Log.initLogging('warn');
+            Log.Debug('hi');
+            Log.Info('hello');
+            expect(console.log).to.not.have.been.called;
+        });
+
+        it('should use console.debug for Debug', function () {
+            Log.initLogging('debug');
+            Log.Debug('dbg');
+            expect(console.debug).to.have.been.calledWith('dbg');
+        });
+
+        it('should use console.info for Info', function () {
+            Log.initLogging('debug');
+            Log.Info('inf');
+            expect(console.info).to.have.been.calledWith('inf');
+        });
+
+        it('should use console.warn for Warn', function () {
+            Log.initLogging('warn');
+            Log.Warn('wrn');
+            expect(console.warn).to.have.been.called;
+            expect(console.warn).to.have.been.calledWith('wrn');
+        });
+
+        it('should use console.error for Error', function () {
+            Log.initLogging('error');
+            Log.Error('err');
+            expect(console.error).to.have.been.called;
+            expect(console.error).to.have.been.calledWith('err');
+        });
+    });
+
+    describe('string functions', function () {
+        it('should decode UTF-8 to DOMString correctly', function () {
+            const utf8string = '\xd0\x9f';
+            const domstring = decodeUTF8(utf8string);
+            expect(domstring).to.equal("П");
+        });
+
+        it('should encode DOMString to UTF-8 correctly', function () {
+            const domstring = "åäöa";
+            const utf8string = encodeUTF8(domstring);
+            expect(utf8string).to.equal('\xc3\xa5\xc3\xa4\xc3\xb6\x61');
+        });
+
+        it('should allow Latin-1 strings if allowLatin1 is set when decoding', function () {
+            const latin1string = '\xe5\xe4\xf6';
+            expect(() => decodeUTF8(latin1string)).to.throw(Error);
+            expect(decodeUTF8(latin1string, true)).to.equal('åäö');
+        });
+    });
+
+    // TODO(directxman12): test the conf_default and conf_defaults methods
+    // TODO(directxman12): test the event methods (addEvent, removeEvent, stopEvent)
+    // TODO(directxman12): figure out a good way to test getPosition and getEventPosition
+    // TODO(directxman12): figure out how to test the browser detection functions properly
+    //                     (we can't really test them against the browsers, except for Gecko
+    //                     via PhantomJS, the default test driver)
+});
+/* eslint-enable no-console */
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.websock.js
@@ -0,0 +1,552 @@
+const expect = chai.expect;
+
+import Websock from '../core/websock.js';
+import FakeWebSocket from './fake.websocket.js';
+
+describe('Websock', function () {
+    "use strict";
+
+    describe('Queue methods', function () {
+        let sock;
+        const RQ_TEMPLATE = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7]);
+
+        beforeEach(function () {
+            sock = new Websock();
+            // skip init
+            sock._allocateBuffers();
+            sock._rQ.set(RQ_TEMPLATE);
+            sock._rQlen = RQ_TEMPLATE.length;
+        });
+        describe('rQlen', function () {
+            it('should return the length of the receive queue', function () {
+                sock.rQi = 0;
+
+                expect(sock.rQlen).to.equal(RQ_TEMPLATE.length);
+            });
+
+            it("should return the proper length if we read some from the receive queue", function () {
+                sock.rQi = 1;
+
+                expect(sock.rQlen).to.equal(RQ_TEMPLATE.length - 1);
+            });
+        });
+
+        describe('rQpeek8', function () {
+            it('should peek at the next byte without poping it off the queue', function () {
+                const befLen = sock.rQlen;
+                const peek = sock.rQpeek8();
+                expect(sock.rQpeek8()).to.equal(peek);
+                expect(sock.rQlen).to.equal(befLen);
+            });
+        });
+
+        describe('rQshift8()', function () {
+            it('should pop a single byte from the receive queue', function () {
+                const peek = sock.rQpeek8();
+                const befLen = sock.rQlen;
+                expect(sock.rQshift8()).to.equal(peek);
+                expect(sock.rQlen).to.equal(befLen - 1);
+            });
+        });
+
+        describe('rQshift16()', function () {
+            it('should pop two bytes from the receive queue and return a single number', function () {
+                const befLen = sock.rQlen;
+                const expected = (RQ_TEMPLATE[0] << 8) + RQ_TEMPLATE[1];
+                expect(sock.rQshift16()).to.equal(expected);
+                expect(sock.rQlen).to.equal(befLen - 2);
+            });
+        });
+
+        describe('rQshift32()', function () {
+            it('should pop four bytes from the receive queue and return a single number', function () {
+                const befLen = sock.rQlen;
+                const expected = (RQ_TEMPLATE[0] << 24) +
+                               (RQ_TEMPLATE[1] << 16) +
+                               (RQ_TEMPLATE[2] << 8) +
+                               RQ_TEMPLATE[3];
+                expect(sock.rQshift32()).to.equal(expected);
+                expect(sock.rQlen).to.equal(befLen - 4);
+            });
+        });
+
+        describe('rQshiftStr', function () {
+            it('should shift the given number of bytes off of the receive queue and return a string', function () {
+                const befLen = sock.rQlen;
+                const befRQi = sock.rQi;
+                const shifted = sock.rQshiftStr(3);
+                expect(shifted).to.be.a('string');
+                expect(shifted).to.equal(String.fromCharCode.apply(null, Array.prototype.slice.call(new Uint8Array(RQ_TEMPLATE.buffer, befRQi, 3))));
+                expect(sock.rQlen).to.equal(befLen - 3);
+            });
+
+            it('should shift the entire rest of the queue off if no length is given', function () {
+                sock.rQshiftStr();
+                expect(sock.rQlen).to.equal(0);
+            });
+
+            it('should be able to handle very large strings', function () {
+                const BIG_LEN = 500000;
+                const RQ_BIG = new Uint8Array(BIG_LEN);
+                let expected = "";
+                let letterCode = 'a'.charCodeAt(0);
+                for (let i = 0; i < BIG_LEN; i++) {
+                    RQ_BIG[i] = letterCode;
+                    expected += String.fromCharCode(letterCode);
+
+                    if (letterCode < 'z'.charCodeAt(0)) {
+                        letterCode++;
+                    } else {
+                        letterCode = 'a'.charCodeAt(0);
+                    }
+                }
+                sock._rQ.set(RQ_BIG);
+                sock._rQlen = RQ_BIG.length;
+
+                const shifted = sock.rQshiftStr();
+
+                expect(shifted).to.be.equal(expected);
+                expect(sock.rQlen).to.equal(0);
+            });
+        });
+
+        describe('rQshiftBytes', function () {
+            it('should shift the given number of bytes of the receive queue and return an array', function () {
+                const befLen = sock.rQlen;
+                const befRQi = sock.rQi;
+                const shifted = sock.rQshiftBytes(3);
+                expect(shifted).to.be.an.instanceof(Uint8Array);
+                expect(shifted).to.array.equal(new Uint8Array(RQ_TEMPLATE.buffer, befRQi, 3));
+                expect(sock.rQlen).to.equal(befLen - 3);
+            });
+
+            it('should shift the entire rest of the queue off if no length is given', function () {
+                sock.rQshiftBytes();
+                expect(sock.rQlen).to.equal(0);
+            });
+        });
+
+        describe('rQslice', function () {
+            beforeEach(function () {
+                sock.rQi = 0;
+            });
+
+            it('should not modify the receive queue', function () {
+                const befLen = sock.rQlen;
+                sock.rQslice(0, 2);
+                expect(sock.rQlen).to.equal(befLen);
+            });
+
+            it('should return an array containing the given slice of the receive queue', function () {
+                const sl = sock.rQslice(0, 2);
+                expect(sl).to.be.an.instanceof(Uint8Array);
+                expect(sl).to.array.equal(new Uint8Array(RQ_TEMPLATE.buffer, 0, 2));
+            });
+
+            it('should use the rest of the receive queue if no end is given', function () {
+                const sl = sock.rQslice(1);
+                expect(sl).to.have.length(RQ_TEMPLATE.length - 1);
+                expect(sl).to.array.equal(new Uint8Array(RQ_TEMPLATE.buffer, 1));
+            });
+
+            it('should take the current rQi in to account', function () {
+                sock.rQi = 1;
+                expect(sock.rQslice(0, 2)).to.array.equal(new Uint8Array(RQ_TEMPLATE.buffer, 1, 2));
+            });
+        });
+
+        describe('rQwait', function () {
+            beforeEach(function () {
+                sock.rQi = 0;
+            });
+
+            it('should return true if there are not enough bytes in the receive queue', function () {
+                expect(sock.rQwait('hi', RQ_TEMPLATE.length + 1)).to.be.true;
+            });
+
+            it('should return false if there are enough bytes in the receive queue', function () {
+                expect(sock.rQwait('hi', RQ_TEMPLATE.length)).to.be.false;
+            });
+
+            it('should return true and reduce rQi by "goback" if there are not enough bytes', function () {
+                sock.rQi = 5;
+                expect(sock.rQwait('hi', RQ_TEMPLATE.length, 4)).to.be.true;
+                expect(sock.rQi).to.equal(1);
+            });
+
+            it('should raise an error if we try to go back more than possible', function () {
+                sock.rQi = 5;
+                expect(() => sock.rQwait('hi', RQ_TEMPLATE.length, 6)).to.throw(Error);
+            });
+
+            it('should not reduce rQi if there are enough bytes', function () {
+                sock.rQi = 5;
+                sock.rQwait('hi', 1, 6);
+                expect(sock.rQi).to.equal(5);
+            });
+        });
+
+        describe('flush', function () {
+            beforeEach(function () {
+                sock._websocket = {
+                    send: sinon.spy()
+                };
+            });
+
+            it('should actually send on the websocket', function () {
+                sock._websocket.bufferedAmount = 8;
+                sock._websocket.readyState = WebSocket.OPEN;
+                sock._sQ = new Uint8Array([1, 2, 3]);
+                sock._sQlen = 3;
+                const encoded = sock._encodeMessage();
+
+                sock.flush();
+                expect(sock._websocket.send).to.have.been.calledOnce;
+                expect(sock._websocket.send).to.have.been.calledWith(encoded);
+            });
+
+            it('should not call send if we do not have anything queued up', function () {
+                sock._sQlen = 0;
+                sock._websocket.bufferedAmount = 8;
+
+                sock.flush();
+
+                expect(sock._websocket.send).not.to.have.been.called;
+            });
+        });
+
+        describe('send', function () {
+            beforeEach(function () {
+                sock.flush = sinon.spy();
+            });
+
+            it('should add to the send queue', function () {
+                sock.send([1, 2, 3]);
+                const sq = sock.sQ;
+                expect(new Uint8Array(sq.buffer, sock._sQlen - 3, 3)).to.array.equal(new Uint8Array([1, 2, 3]));
+            });
+
+            it('should call flush', function () {
+                sock.send([1, 2, 3]);
+                expect(sock.flush).to.have.been.calledOnce;
+            });
+        });
+
+        describe('sendString', function () {
+            beforeEach(function () {
+                sock.send = sinon.spy();
+            });
+
+            it('should call send after converting the string to an array', function () {
+                sock.sendString("\x01\x02\x03");
+                expect(sock.send).to.have.been.calledWith([1, 2, 3]);
+            });
+        });
+    });
+
+    describe('lifecycle methods', function () {
+        let oldWS;
+        before(function () {
+            oldWS = WebSocket;
+        });
+
+        let sock;
+        beforeEach(function () {
+            sock = new Websock();
+            // eslint-disable-next-line no-global-assign
+            WebSocket = sinon.spy(FakeWebSocket);
+        });
+
+        describe('opening', function () {
+            it('should pick the correct protocols if none are given', function () {
+
+            });
+
+            it('should open the actual websocket', function () {
+                sock.open('ws://localhost:8675', 'binary');
+                expect(WebSocket).to.have.been.calledWith('ws://localhost:8675', 'binary');
+            });
+
+            // it('should initialize the event handlers')?
+        });
+
+        describe('attaching', function () {
+            it('should attach to an existing websocket', function () {
+                let ws = new FakeWebSocket('ws://localhost:8675');
+                sock.attach(ws);
+                expect(WebSocket).to.not.have.been.called;
+            });
+        });
+
+        describe('closing', function () {
+            beforeEach(function () {
+                sock.open('ws://localhost');
+                sock._websocket.close = sinon.spy();
+            });
+
+            it('should close the actual websocket if it is open', function () {
+                sock._websocket.readyState = WebSocket.OPEN;
+                sock.close();
+                expect(sock._websocket.close).to.have.been.calledOnce;
+            });
+
+            it('should close the actual websocket if it is connecting', function () {
+                sock._websocket.readyState = WebSocket.CONNECTING;
+                sock.close();
+                expect(sock._websocket.close).to.have.been.calledOnce;
+            });
+
+            it('should not try to close the actual websocket if closing', function () {
+                sock._websocket.readyState = WebSocket.CLOSING;
+                sock.close();
+                expect(sock._websocket.close).not.to.have.been.called;
+            });
+
+            it('should not try to close the actual websocket if closed', function () {
+                sock._websocket.readyState = WebSocket.CLOSED;
+                sock.close();
+                expect(sock._websocket.close).not.to.have.been.called;
+            });
+
+            it('should reset onmessage to not call _recvMessage', function () {
+                sinon.spy(sock, '_recvMessage');
+                sock.close();
+                sock._websocket.onmessage(null);
+                try {
+                    expect(sock._recvMessage).not.to.have.been.called;
+                } finally {
+                    sock._recvMessage.restore();
+                }
+            });
+        });
+
+        describe('event handlers', function () {
+            beforeEach(function () {
+                sock._recvMessage = sinon.spy();
+                sock.on('open', sinon.spy());
+                sock.on('close', sinon.spy());
+                sock.on('error', sinon.spy());
+                sock.open('ws://localhost');
+            });
+
+            it('should call _recvMessage on a message', function () {
+                sock._websocket.onmessage(null);
+                expect(sock._recvMessage).to.have.been.calledOnce;
+            });
+
+            it('should call the open event handler on opening', function () {
+                sock._websocket.onopen();
+                expect(sock._eventHandlers.open).to.have.been.calledOnce;
+            });
+
+            it('should call the close event handler on closing', function () {
+                sock._websocket.onclose();
+                expect(sock._eventHandlers.close).to.have.been.calledOnce;
+            });
+
+            it('should call the error event handler on error', function () {
+                sock._websocket.onerror();
+                expect(sock._eventHandlers.error).to.have.been.calledOnce;
+            });
+        });
+
+        describe('ready state', function () {
+            it('should be "unused" after construction', function () {
+                let sock = new Websock();
+                expect(sock.readyState).to.equal('unused');
+            });
+
+            it('should be "connecting" if WebSocket is connecting', function () {
+                let sock = new Websock();
+                let ws = new FakeWebSocket();
+                ws.readyState = WebSocket.CONNECTING;
+                sock.attach(ws);
+                expect(sock.readyState).to.equal('connecting');
+            });
+
+            it('should be "open" if WebSocket is open', function () {
+                let sock = new Websock();
+                let ws = new FakeWebSocket();
+                ws.readyState = WebSocket.OPEN;
+                sock.attach(ws);
+                expect(sock.readyState).to.equal('open');
+            });
+
+            it('should be "closing" if WebSocket is closing', function () {
+                let sock = new Websock();
+                let ws = new FakeWebSocket();
+                ws.readyState = WebSocket.CLOSING;
+                sock.attach(ws);
+                expect(sock.readyState).to.equal('closing');
+            });
+
+            it('should be "closed" if WebSocket is closed', function () {
+                let sock = new Websock();
+                let ws = new FakeWebSocket();
+                ws.readyState = WebSocket.CLOSED;
+                sock.attach(ws);
+                expect(sock.readyState).to.equal('closed');
+            });
+
+            it('should be "unknown" if WebSocket state is unknown', function () {
+                let sock = new Websock();
+                let ws = new FakeWebSocket();
+                ws.readyState = 666;
+                sock.attach(ws);
+                expect(sock.readyState).to.equal('unknown');
+            });
+
+            it('should be "connecting" if RTCDataChannel is connecting', function () {
+                let sock = new Websock();
+                let ws = new FakeWebSocket();
+                ws.readyState = 'connecting';
+                sock.attach(ws);
+                expect(sock.readyState).to.equal('connecting');
+            });
+
+            it('should be "open" if RTCDataChannel is open', function () {
+                let sock = new Websock();
+                let ws = new FakeWebSocket();
+                ws.readyState = 'open';
+                sock.attach(ws);
+                expect(sock.readyState).to.equal('open');
+            });
+
+            it('should be "closing" if RTCDataChannel is closing', function () {
+                let sock = new Websock();
+                let ws = new FakeWebSocket();
+                ws.readyState = 'closing';
+                sock.attach(ws);
+                expect(sock.readyState).to.equal('closing');
+            });
+
+            it('should be "closed" if RTCDataChannel is closed', function () {
+                let sock = new Websock();
+                let ws = new FakeWebSocket();
+                ws.readyState = 'closed';
+                sock.attach(ws);
+                expect(sock.readyState).to.equal('closed');
+            });
+
+            it('should be "unknown" if RTCDataChannel state is unknown', function () {
+                let sock = new Websock();
+                let ws = new FakeWebSocket();
+                ws.readyState = 'foobar';
+                sock.attach(ws);
+                expect(sock.readyState).to.equal('unknown');
+            });
+        });
+
+        after(function () {
+            // eslint-disable-next-line no-global-assign
+            WebSocket = oldWS;
+        });
+    });
+
+    describe('WebSocket Receiving', function () {
+        let sock;
+        beforeEach(function () {
+            sock = new Websock();
+            sock._allocateBuffers();
+        });
+
+        it('should support adding binary Uint8Array data to the receive queue', function () {
+            const msg = { data: new Uint8Array([1, 2, 3]) };
+            sock._mode = 'binary';
+            sock._recvMessage(msg);
+            expect(sock.rQshiftStr(3)).to.equal('\x01\x02\x03');
+        });
+
+        it('should call the message event handler if present', function () {
+            sock._eventHandlers.message = sinon.spy();
+            const msg = { data: new Uint8Array([1, 2, 3]).buffer };
+            sock._mode = 'binary';
+            sock._recvMessage(msg);
+            expect(sock._eventHandlers.message).to.have.been.calledOnce;
+        });
+
+        it('should not call the message event handler if there is nothing in the receive queue', function () {
+            sock._eventHandlers.message = sinon.spy();
+            const msg = { data: new Uint8Array([]).buffer };
+            sock._mode = 'binary';
+            sock._recvMessage(msg);
+            expect(sock._eventHandlers.message).not.to.have.been.called;
+        });
+
+        it('should compact the receive queue when a message handler empties it', function () {
+            sock._eventHandlers.message = () => { sock.rQi = sock._rQlen; };
+            sock._rQ = new Uint8Array([0, 1, 2, 3, 4, 5, 0, 0, 0, 0]);
+            sock._rQlen = 6;
+            sock.rQi = 6;
+            const msg = { data: new Uint8Array([1, 2, 3]).buffer };
+            sock._mode = 'binary';
+            sock._recvMessage(msg);
+            expect(sock._rQlen).to.equal(0);
+            expect(sock.rQi).to.equal(0);
+        });
+
+        it('should compact the receive queue when we reach the end of the buffer', function () {
+            sock._rQ = new Uint8Array(20);
+            sock._rQbufferSize = 20;
+            sock._rQlen = 20;
+            sock.rQi = 10;
+            const msg = { data: new Uint8Array([1, 2]).buffer };
+            sock._mode = 'binary';
+            sock._recvMessage(msg);
+            expect(sock._rQlen).to.equal(12);
+            expect(sock.rQi).to.equal(0);
+        });
+
+        it('should automatically resize the receive queue if the incoming message is larger than the buffer', function () {
+            sock._rQ = new Uint8Array(20);
+            sock._rQlen = 0;
+            sock.rQi = 0;
+            sock._rQbufferSize = 20;
+            const msg = { data: new Uint8Array(30).buffer };
+            sock._mode = 'binary';
+            sock._recvMessage(msg);
+            expect(sock._rQlen).to.equal(30);
+            expect(sock.rQi).to.equal(0);
+            expect(sock._rQ.length).to.equal(240);  // keep the invariant that rQbufferSize / 8 >= rQlen
+        });
+
+        it('should automatically resize the receive queue if the incoming message is larger than 1/8th of the buffer and we reach the end of the buffer', function () {
+            sock._rQ = new Uint8Array(20);
+            sock._rQlen = 16;
+            sock.rQi = 16;
+            sock._rQbufferSize = 20;
+            const msg = { data: new Uint8Array(6).buffer };
+            sock._mode = 'binary';
+            sock._recvMessage(msg);
+            expect(sock._rQlen).to.equal(6);
+            expect(sock.rQi).to.equal(0);
+            expect(sock._rQ.length).to.equal(48);
+        });
+    });
+
+    describe('Data encoding', function () {
+        before(function () { FakeWebSocket.replace(); });
+        after(function () { FakeWebSocket.restore(); });
+
+        describe('as binary data', function () {
+            let sock;
+            beforeEach(function () {
+                sock = new Websock();
+                sock.open('ws://', 'binary');
+                sock._websocket._open();
+            });
+
+            it('should only send the send queue up to the send queue length', function () {
+                sock._sQ = new Uint8Array([1, 2, 3, 4, 5]);
+                sock._sQlen = 3;
+                const res = sock._encodeMessage();
+                expect(res).to.array.equal(new Uint8Array([1, 2, 3]));
+            });
+
+            it('should properly pass the encoded data off to the actual WebSocket', function () {
+                sock.send([1, 2, 3]);
+                expect(sock._websocket._getSentData()).to.array.equal(new Uint8Array([1, 2, 3]));
+            });
+        });
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.webutil.js
@@ -0,0 +1,223 @@
+/* jshint expr: true */
+
+const expect = chai.expect;
+
+import * as WebUtil from '../app/webutil.js';
+
+describe('WebUtil', function () {
+    "use strict";
+
+    describe('config variables', function () {
+        it('should parse query string variables', function () {
+            // history.pushState() will not cause the browser to attempt loading
+            // the URL, this is exactly what we want here for the tests.
+            history.pushState({}, '', "test?myvar=myval");
+            expect(WebUtil.getConfigVar("myvar")).to.be.equal("myval");
+        });
+        it('should return default value when no query match', function () {
+            history.pushState({}, '', "test?myvar=myval");
+            expect(WebUtil.getConfigVar("other", "def")).to.be.equal("def");
+        });
+        it('should handle no query match and no default value', function () {
+            history.pushState({}, '', "test?myvar=myval");
+            expect(WebUtil.getConfigVar("other")).to.be.equal(null);
+        });
+        it('should parse fragment variables', function () {
+            history.pushState({}, '', "test#myvar=myval");
+            expect(WebUtil.getConfigVar("myvar")).to.be.equal("myval");
+        });
+        it('should return default value when no fragment match', function () {
+            history.pushState({}, '', "test#myvar=myval");
+            expect(WebUtil.getConfigVar("other", "def")).to.be.equal("def");
+        });
+        it('should handle no fragment match and no default value', function () {
+            history.pushState({}, '', "test#myvar=myval");
+            expect(WebUtil.getConfigVar("other")).to.be.equal(null);
+        });
+        it('should handle both query and fragment', function () {
+            history.pushState({}, '', "test?myquery=1#myhash=2");
+            expect(WebUtil.getConfigVar("myquery")).to.be.equal("1");
+            expect(WebUtil.getConfigVar("myhash")).to.be.equal("2");
+        });
+        it('should prioritize fragment if both provide same var', function () {
+            history.pushState({}, '', "test?myvar=1#myvar=2");
+            expect(WebUtil.getConfigVar("myvar")).to.be.equal("2");
+        });
+    });
+
+    describe('cookies', function () {
+        // TODO
+    });
+
+    describe('settings', function () {
+
+        describe('localStorage', function () {
+            let chrome = window.chrome;
+            before(function () {
+                chrome = window.chrome;
+                window.chrome = null;
+            });
+            after(function () {
+                window.chrome = chrome;
+            });
+
+            let origLocalStorage;
+            beforeEach(function () {
+                origLocalStorage = Object.getOwnPropertyDescriptor(window, "localStorage");
+
+                Object.defineProperty(window, "localStorage", {value: {}});
+                if (window.localStorage.setItem !== undefined) {
+                    // Object.defineProperty() doesn't work properly in old
+                    // versions of Chrome
+                    this.skip();
+                }
+
+                window.localStorage.setItem = sinon.stub();
+                window.localStorage.getItem = sinon.stub();
+                window.localStorage.removeItem = sinon.stub();
+
+                return WebUtil.initSettings();
+            });
+            afterEach(function () {
+                if (origLocalStorage !== undefined) {
+                    Object.defineProperty(window, "localStorage", origLocalStorage);
+                }
+            });
+
+            describe('writeSetting', function () {
+                it('should save the setting value to local storage', function () {
+                    WebUtil.writeSetting('test', 'value');
+                    expect(window.localStorage.setItem).to.have.been.calledWithExactly('test', 'value');
+                    expect(WebUtil.readSetting('test')).to.equal('value');
+                });
+            });
+
+            describe('setSetting', function () {
+                it('should update the setting but not save to local storage', function () {
+                    WebUtil.setSetting('test', 'value');
+                    expect(window.localStorage.setItem).to.not.have.been.called;
+                    expect(WebUtil.readSetting('test')).to.equal('value');
+                });
+            });
+
+            describe('readSetting', function () {
+                it('should read the setting value from local storage', function () {
+                    localStorage.getItem.returns('value');
+                    expect(WebUtil.readSetting('test')).to.equal('value');
+                });
+
+                it('should return the default value when not in local storage', function () {
+                    expect(WebUtil.readSetting('test', 'default')).to.equal('default');
+                });
+
+                it('should return the cached value even if local storage changed', function () {
+                    localStorage.getItem.returns('value');
+                    expect(WebUtil.readSetting('test')).to.equal('value');
+                    localStorage.getItem.returns('something else');
+                    expect(WebUtil.readSetting('test')).to.equal('value');
+                });
+
+                it('should cache the value even if it is not initially in local storage', function () {
+                    expect(WebUtil.readSetting('test')).to.be.null;
+                    localStorage.getItem.returns('value');
+                    expect(WebUtil.readSetting('test')).to.be.null;
+                });
+
+                it('should return the default value always if the first read was not in local storage', function () {
+                    expect(WebUtil.readSetting('test', 'default')).to.equal('default');
+                    localStorage.getItem.returns('value');
+                    expect(WebUtil.readSetting('test', 'another default')).to.equal('another default');
+                });
+
+                it('should return the last local written value', function () {
+                    localStorage.getItem.returns('value');
+                    expect(WebUtil.readSetting('test')).to.equal('value');
+                    WebUtil.writeSetting('test', 'something else');
+                    expect(WebUtil.readSetting('test')).to.equal('something else');
+                });
+            });
+
+            // this doesn't appear to be used anywhere
+            describe('eraseSetting', function () {
+                it('should remove the setting from local storage', function () {
+                    WebUtil.eraseSetting('test');
+                    expect(window.localStorage.removeItem).to.have.been.calledWithExactly('test');
+                });
+            });
+        });
+
+        describe('chrome.storage', function () {
+            let chrome = window.chrome;
+            let settings = {};
+            before(function () {
+                chrome = window.chrome;
+                window.chrome = {
+                    storage: {
+                        sync: {
+                            get(cb) { cb(settings); },
+                            set() {},
+                            remove() {}
+                        }
+                    }
+                };
+            });
+            after(function () {
+                window.chrome = chrome;
+            });
+
+            const csSandbox = sinon.createSandbox();
+
+            beforeEach(function () {
+                settings = {};
+                csSandbox.spy(window.chrome.storage.sync, 'set');
+                csSandbox.spy(window.chrome.storage.sync, 'remove');
+                return WebUtil.initSettings();
+            });
+            afterEach(function () {
+                csSandbox.restore();
+            });
+
+            describe('writeSetting', function () {
+                it('should save the setting value to chrome storage', function () {
+                    WebUtil.writeSetting('test', 'value');
+                    expect(window.chrome.storage.sync.set).to.have.been.calledWithExactly(sinon.match({ test: 'value' }));
+                    expect(WebUtil.readSetting('test')).to.equal('value');
+                });
+            });
+
+            describe('setSetting', function () {
+                it('should update the setting but not save to chrome storage', function () {
+                    WebUtil.setSetting('test', 'value');
+                    expect(window.chrome.storage.sync.set).to.not.have.been.called;
+                    expect(WebUtil.readSetting('test')).to.equal('value');
+                });
+            });
+
+            describe('readSetting', function () {
+                it('should read the setting value from chrome storage', function () {
+                    settings.test = 'value';
+                    expect(WebUtil.readSetting('test')).to.equal('value');
+                });
+
+                it('should return the default value when not in chrome storage', function () {
+                    expect(WebUtil.readSetting('test', 'default')).to.equal('default');
+                });
+
+                it('should return the last local written value', function () {
+                    settings.test = 'value';
+                    expect(WebUtil.readSetting('test')).to.equal('value');
+                    WebUtil.writeSetting('test', 'something else');
+                    expect(WebUtil.readSetting('test')).to.equal('something else');
+                });
+            });
+
+            // this doesn't appear to be used anywhere
+            describe('eraseSetting', function () {
+                it('should remove the setting from chrome storage', function () {
+                    WebUtil.eraseSetting('test');
+                    expect(window.chrome.storage.sync.remove).to.have.been.calledWithExactly('test');
+                });
+            });
+        });
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/test.zrle.js
@@ -0,0 +1,124 @@
+const expect = chai.expect;
+
+import Websock from '../core/websock.js';
+import Display from '../core/display.js';
+
+import ZRLEDecoder from '../core/decoders/zrle.js';
+
+import FakeWebSocket from './fake.websocket.js';
+
+function testDecodeRect(decoder, x, y, width, height, data, display, depth) {
+    let sock;
+
+    sock = new Websock;
+    sock.open("ws://example.com");
+
+    sock.on('message', () => {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    });
+
+    // Empty messages are filtered at multiple layers, so we need to
+    // do a direct call
+    if (data.length === 0) {
+        decoder.decodeRect(x, y, width, height, sock, display, depth);
+    } else {
+        sock._websocket._receiveData(new Uint8Array(data));
+    }
+
+    display.flip();
+}
+
+describe('ZRLE Decoder', function () {
+    let decoder;
+    let display;
+
+    before(FakeWebSocket.replace);
+    after(FakeWebSocket.restore);
+
+    beforeEach(function () {
+        decoder = new ZRLEDecoder();
+        display = new Display(document.createElement('canvas'));
+        display.resize(4, 4);
+    });
+
+    it('should handle the Raw subencoding', function () {
+        testDecodeRect(decoder, 0, 0, 4, 4,
+                       [0x00, 0x00, 0x00, 0x0e, 0x78, 0x5e, 0x62, 0x60, 0x60, 0xf8, 0x4f, 0x12, 0x02, 0x00, 0x00, 0x00, 0xff, 0xff],
+                       display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle the Solid subencoding', function () {
+        testDecodeRect(decoder, 0, 0, 4, 4,
+                       [0x00, 0x00, 0x00, 0x0c, 0x78, 0x5e, 0x62, 0x64, 0x60, 0xf8, 0x0f, 0x00, 0x00, 0x00, 0xff, 0xff],
+                       display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+
+    it('should handle the Palette Tile subencoding', function () {
+        testDecodeRect(decoder, 0, 0, 4, 4,
+                       [0x00, 0x00, 0x00, 0x12,  0x78, 0x5E, 0x62, 0x62, 0x60, 248, 0xff, 0x9F, 0x01, 0x08, 0x3E, 0x7C, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff],
+                       display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
+            0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
+            0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle the RLE Tile subencoding', function () {
+        testDecodeRect(decoder, 0, 0, 4, 4,
+                       [0x00, 0x00, 0x00, 0x0d, 0x78, 0x5e, 0x6a, 0x60, 0x60, 0xf8, 0x2f, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff],
+                       display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should handle the RLE Palette Tile subencoding', function () {
+        testDecodeRect(decoder, 0, 0, 4, 4,
+                       [0x00, 0x00, 0x00, 0x11, 0x78, 0x5e, 0x6a, 0x62, 0x60, 0xf8, 0xff, 0x9f, 0x81, 0xa1, 0x81, 0x1f, 0x00, 0x00, 0x00, 0xff, 0xff],
+                       display, 24);
+
+        let targetData = new Uint8Array([
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
+            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff
+        ]);
+
+        expect(display).to.have.displayed(targetData);
+    });
+
+    it('should fail on an invalid subencoding', function () {
+        let data = [0x00, 0x00, 0x00, 0x0c, 0x78, 0x5e, 0x6a, 0x64, 0x60, 0xf8, 0x0f, 0x00, 0x00, 0x00, 0xff, 0xff];
+        expect(() => testDecodeRect(decoder, 0, 0, 4, 4, data, display, 24)).to.throw();
+    });
+});
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/tests/vnc_playback.html
@@ -0,0 +1,26 @@
+<!DOCTYPE html>
+<html lang="en">
+    <head>
+        <title>VNC Playback</title>
+        <script type="module" src="./playback-ui.js"></script>
+    </head>
+    <body>
+
+        Iterations: <input id='iterations'>&nbsp;
+        Perftest:<input type='radio' id='mode1' name='mode' checked>&nbsp;
+        Realtime:<input type='radio' id='mode2' name='mode'>&nbsp;&nbsp;
+
+        <input id='startButton' type='button' value='Start' disabled>&nbsp;
+
+        <br><br>
+
+        Results:<br>
+        <textarea id="messages" cols=80 rows=25></textarea>
+
+        <br><br>
+
+        <div id="VNC_screen">
+            <div id="VNC_status">Loading</div>
+        </div>
+    </body>
+</html>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/.eslintrc
@@ -0,0 +1,8 @@
+{
+  "env": {
+    "node": true
+  },
+  "rules": {
+  	"no-console": 0
+  }
+}
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/Makefile
@@ -0,0 +1,11 @@
+TARGETS=rebind.so
+CFLAGS += -fPIC
+
+all: $(TARGETS)
+
+rebind.so: rebind.o
+	$(CC) $(LDFLAGS) $^ -shared -fPIC -ldl -o $@
+
+clean:
+	rm -f rebind.o rebind.so
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/README.md
@@ -0,0 +1,14 @@
+## WebSockets Proxy/Bridge
+
+Websockify has been forked out into its own project. `novnc_proxy` will
+automatically download it here if it is not already present and not
+installed as system-wide.
+
+For more detailed description and usage information please refer to
+the [websockify README](https://github.com/novnc/websockify/blob/master/README.md).
+
+The other versions of websockify (C, Node.js) and the associated test
+programs have been moved to
+[websockify](https://github.com/novnc/websockify).  Websockify was
+formerly named wsproxy.
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/b64-to-binary.pl
@@ -0,0 +1,17 @@
+#!/usr/bin/env perl
+use MIME::Base64;
+
+for (<>) {
+    unless (/^'([{}])(\d+)\1(.+?)',$/) {
+        print;
+        next;
+    }
+
+    my ($dir, $amt, $b64) = ($1, $2, $3);
+
+    my $decoded = MIME::Base64::decode($b64) or die "Could not base64-decode line `$_`";
+
+    my $decoded_escaped = join "", map { "\\x$_" } unpack("(H2)*", $decoded);
+
+    print "'${dir}${amt}${dir}${decoded_escaped}',\n";
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/convert.js
@@ -0,0 +1,140 @@
+#!/usr/bin/env node
+
+const path = require('path');
+const program = require('commander');
+const fs = require('fs');
+const fse = require('fs-extra');
+const babel = require('@babel/core');
+
+program
+    .option('-m, --with-source-maps [type]', 'output source maps when not generating a bundled app (type may be empty for external source maps, inline for inline source maps, or both) ')
+    .option('--clean', 'clear the lib folder before building')
+    .parse(process.argv);
+
+// the various important paths
+const paths = {
+    main: path.resolve(__dirname, '..'),
+    core: path.resolve(__dirname, '..', 'core'),
+    vendor: path.resolve(__dirname, '..', 'vendor'),
+    libDirBase: path.resolve(__dirname, '..', 'lib'),
+};
+
+// util.promisify requires Node.js 8.x, so we have our own
+function promisify(original) {
+    return function promiseWrap() {
+        const args = Array.prototype.slice.call(arguments);
+        return new Promise((resolve, reject) => {
+            original.apply(this, args.concat((err, value) => {
+                if (err) return reject(err);
+                resolve(value);
+            }));
+        });
+    };
+}
+
+const writeFile = promisify(fs.writeFile);
+
+const readdir = promisify(fs.readdir);
+const lstat = promisify(fs.lstat);
+
+const ensureDir = promisify(fse.ensureDir);
+
+const babelTransformFile = promisify(babel.transformFile);
+
+// walkDir *recursively* walks directories trees,
+// calling the callback for all normal files found.
+function walkDir(basePath, cb, filter) {
+    return readdir(basePath)
+        .then((files) => {
+            const paths = files.map(filename => path.join(basePath, filename));
+            return Promise.all(paths.map(filepath => lstat(filepath)
+                .then((stats) => {
+                    if (filter !== undefined && !filter(filepath, stats)) return;
+
+                    if (stats.isSymbolicLink()) return;
+                    if (stats.isFile()) return cb(filepath);
+                    if (stats.isDirectory()) return walkDir(filepath, cb, filter);
+                })));
+        });
+}
+
+function makeLibFiles(sourceMaps) {
+    // NB: we need to make a copy of babelOpts, since babel sets some defaults on it
+    const babelOpts = () => ({
+        plugins: [],
+        presets: [
+            [ '@babel/preset-env',
+              { modules: 'commonjs' } ]
+        ],
+        ast: false,
+        sourceMaps: sourceMaps,
+    });
+
+    fse.ensureDirSync(paths.libDirBase);
+
+    const outFiles = [];
+
+    const handleDir = (vendorRewrite, inPathBase, filename) => Promise.resolve()
+        .then(() => {
+            const outPath = path.join(paths.libDirBase, path.relative(inPathBase, filename));
+
+            if (path.extname(filename) !== '.js') {
+                return;  // skip non-javascript files
+            }
+            return Promise.resolve()
+                .then(() => ensureDir(path.dirname(outPath)))
+                .then(() => {
+                    const opts = babelOpts();
+            // Adjust for the fact that we move the core files relative
+            // to the vendor directory
+                    if (vendorRewrite) {
+                        opts.plugins.push(["import-redirect",
+                                           {"root": paths.libDirBase,
+                                            "redirect": { "vendor/(.+)": "./vendor/$1"}}]);
+                    }
+
+                    return babelTransformFile(filename, opts)
+                        .then((res) => {
+                            console.log(`Writing ${outPath}`);
+                            const {map} = res;
+                            let {code} = res;
+                            if (sourceMaps === true) {
+                    // append URL for external source map
+                                code += `\n//# sourceMappingURL=${path.basename(outPath)}.map\n`;
+                            }
+                            outFiles.push(`${outPath}`);
+                            return writeFile(outPath, code)
+                                .then(() => {
+                                    if (sourceMaps === true || sourceMaps === 'both') {
+                                        console.log(`  and ${outPath}.map`);
+                                        outFiles.push(`${outPath}.map`);
+                                        return writeFile(`${outPath}.map`, JSON.stringify(map));
+                                    }
+                                });
+                        });
+                });
+        });
+
+    Promise.resolve()
+        .then(() => {
+            const handler = handleDir.bind(null, false, paths.main);
+            return walkDir(paths.vendor, handler);
+        })
+        .then(() => {
+            const handler = handleDir.bind(null, true, paths.core);
+            return walkDir(paths.core, handler);
+        })
+        .catch((err) => {
+            console.error(`Failure converting modules: ${err}`);
+            process.exit(1);
+        });
+}
+
+let options = program.opts();
+
+if (options.clean) {
+    console.log(`Removing ${paths.libDirBase}`);
+    fse.removeSync(paths.libDirBase);
+}
+
+makeLibFiles(options.withSourceMaps);
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/genkeysymdef.js
@@ -0,0 +1,127 @@
+#!/usr/bin/env node
+/*
+ * genkeysymdef: X11 keysymdef.h to JavaScript converter
+ * Copyright (C) 2018 The noVNC Authors
+ * Licensed under MPL 2.0 (see LICENSE.txt)
+ */
+
+"use strict";
+
+const fs = require('fs');
+
+let showHelp = process.argv.length === 2;
+let filename;
+
+for (let i = 2; i < process.argv.length; ++i) {
+    switch (process.argv[i]) {
+        case "--help":
+        case "-h":
+            showHelp = true;
+            break;
+        case "--file":
+        case "-f":
+        default:
+            filename = process.argv[i];
+    }
+}
+
+if (!filename) {
+    showHelp = true;
+    console.log("Error: No filename specified\n");
+}
+
+if (showHelp) {
+    console.log("Parses a *nix keysymdef.h to generate Unicode code point mappings");
+    console.log("Usage: node parse.js [options] filename:");
+    console.log("  -h [ --help ]                 Produce this help message");
+    console.log("  filename                      The keysymdef.h file to parse");
+    process.exit(0);
+}
+
+const buf = fs.readFileSync(filename);
+const str = buf.toString('utf8');
+
+const re = /^#define XK_([a-zA-Z_0-9]+)\s+0x([0-9a-fA-F]+)\s*(\/\*\s*(.*)\s*\*\/)?\s*$/m;
+
+const arr = str.split('\n');
+
+const codepoints = {};
+
+for (let i = 0; i < arr.length; ++i) {
+    const result = re.exec(arr[i]);
+    if (result) {
+        const keyname = result[1];
+        const keysym = parseInt(result[2], 16);
+        const remainder = result[3];
+
+        const unicodeRes = /U\+([0-9a-fA-F]+)/.exec(remainder);
+        if (unicodeRes) {
+            const unicode = parseInt(unicodeRes[1], 16);
+            // The first entry is the preferred one
+            if (!codepoints[unicode]) {
+                codepoints[unicode] = { keysym: keysym, name: keyname };
+            }
+        }
+    }
+}
+
+let out =
+"/*\n" +
+" * Mapping from Unicode codepoints to X11/RFB keysyms\n" +
+" *\n" +
+" * This file was automatically generated from keysymdef.h\n" +
+" * DO NOT EDIT!\n" +
+" */\n" +
+"\n" +
+"/* Functions at the bottom */\n" +
+"\n" +
+"const codepoints = {\n";
+
+function toHex(num) {
+    let s = num.toString(16);
+    if (s.length < 4) {
+        s = ("0000" + s).slice(-4);
+    }
+    return "0x" + s;
+}
+
+for (let codepoint in codepoints) {
+    codepoint = parseInt(codepoint);
+
+    // Latin-1?
+    if ((codepoint >= 0x20) && (codepoint <= 0xff)) {
+        continue;
+    }
+
+    // Handled by the general Unicode mapping?
+    if ((codepoint | 0x01000000) === codepoints[codepoint].keysym) {
+        continue;
+    }
+
+    out += "    " + toHex(codepoint) + ": " +
+           toHex(codepoints[codepoint].keysym) +
+           ", // XK_" + codepoints[codepoint].name + "\n";
+}
+
+out +=
+"};\n" +
+"\n" +
+"export default {\n" +
+"    lookup(u) {\n" +
+"        // Latin-1 is one-to-one mapping\n" +
+"        if ((u >= 0x20) && (u <= 0xff)) {\n" +
+"            return u;\n" +
+"        }\n" +
+"\n" +
+"        // Lookup table (fairly random)\n" +
+"        const keysym = codepoints[u];\n" +
+"        if (keysym !== undefined) {\n" +
+"            return keysym;\n" +
+"        }\n" +
+"\n" +
+"        // General mapping as final fallback\n" +
+"        return 0x01000000 | u;\n" +
+"    },\n" +
+"};";
+
+console.log(out);
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/img2js.py
@@ -0,0 +1,40 @@
+#!/usr/bin/env python
+
+#
+# Convert image to Javascript compatible base64 Data URI
+# Copyright 2011 Joel Martin
+# Licensed under MPL 2.0 (see docs/LICENSE.MPL-2.0)
+#
+
+import sys, base64
+
+try:
+    from PIL import Image
+except:
+    print "python PIL module required (python-imaging package)"
+    sys.exit(1)
+
+
+if len(sys.argv) < 3:
+    print "Usage: %s IMAGE JS_VARIABLE" % sys.argv[0]
+    sys.exit(1)
+
+fname = sys.argv[1]
+var   = sys.argv[2]
+
+ext = fname.lower().split('.')[-1]
+if   ext == "png":            mime = "image/png"
+elif ext in ["jpg", "jpeg"]:  mime = "image/jpeg"
+elif ext == "gif":            mime = "image/gif"
+else:
+    print "Only PNG, JPEG and GIF images are supported"
+    sys.exit(1)
+uri = "data:%s;base64," % mime
+
+im = Image.open(fname)
+w, h = im.size
+
+raw = open(fname).read()
+
+print '%s = {"width": %s, "height": %s, "data": "%s%s"};' % (
+        var, w, h, uri, base64.b64encode(raw))
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/json2graph.py
@@ -0,0 +1,206 @@
+#!/usr/bin/env python
+
+'''
+Use matplotlib to generate performance charts
+Copyright 2011 Joel Martin
+Licensed under MPL-2.0 (see docs/LICENSE.MPL-2.0)
+'''
+
+# a bar plot with errorbars
+import sys, json, pprint
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib.font_manager import FontProperties
+
+def usage():
+    print "%s json_file level1 level2 level3 [legend_height]\n\n" % sys.argv[0]
+    print "Description:\n"
+    print "level1, level2, and level3 are one each of the following:\n";
+    print "  select=ITEM - select only ITEM at this level";
+    print "  bar         - each item on this level becomes a graph bar";
+    print "  group       - items on this level become groups of bars";
+    print "\n";
+    print "json_file is a file containing json data in the following format:\n"
+    print '  {';
+    print '    "conf": {';
+    print '      "order_l1": [';
+    print '        "level1_label1",';
+    print '        "level1_label2",';
+    print '        ...';
+    print '      ],';
+    print '      "order_l2": [';
+    print '        "level2_label1",';
+    print '        "level2_label2",';
+    print '        ...';
+    print '      ],';
+    print '      "order_l3": [';
+    print '        "level3_label1",';
+    print '        "level3_label2",';
+    print '        ...';
+    print '      ]';
+    print '    },';
+    print '    "stats": {';
+    print '      "level1_label1": {';
+    print '        "level2_label1": {';
+    print '          "level3_label1": [val1, val2, val3],';
+    print '          "level3_label2": [val1, val2, val3],';
+    print '          ...';
+    print '        },';
+    print '        "level2_label2": {';
+    print '        ...';
+    print '        },';
+    print '      },';
+    print '      "level1_label2": {';
+    print '        ...';
+    print '      },';
+    print '      ...';
+    print '    },';
+    print '  }';
+    sys.exit(2)
+
+def error(msg):
+    print msg
+    sys.exit(1)
+
+
+#colors = ['#ff0000', '#0863e9', '#00f200', '#ffa100',
+#          '#800000', '#805100', '#013075', '#007900']
+colors = ['#ff0000', '#00ff00', '#0000ff',
+          '#dddd00', '#dd00dd', '#00dddd',
+          '#dd6622', '#dd2266', '#66dd22',
+          '#8844dd', '#44dd88', '#4488dd']
+
+if len(sys.argv) < 5:
+    usage()
+
+filename = sys.argv[1]
+L1 = sys.argv[2]
+L2 = sys.argv[3]
+L3 = sys.argv[4]
+if len(sys.argv) > 5:
+    legendHeight = float(sys.argv[5])
+else:
+    legendHeight = 0.75
+
+# Load the JSON data from the file
+data = json.loads(file(filename).read())
+conf = data['conf']
+stats = data['stats']
+
+# Sanity check data hierarchy
+if len(conf['order_l1']) != len(stats.keys()):
+    error("conf.order_l1 does not match stats level 1")
+for l1 in stats.keys():
+    if len(conf['order_l2']) != len(stats[l1].keys()):
+        error("conf.order_l2 does not match stats level 2 for %s" % l1)
+    if conf['order_l1'].count(l1) < 1:
+        error("%s not found in conf.order_l1" % l1)
+    for l2 in stats[l1].keys():
+        if len(conf['order_l3']) != len(stats[l1][l2].keys()):
+            error("conf.order_l3 does not match stats level 3")
+        if conf['order_l2'].count(l2) < 1:
+            error("%s not found in conf.order_l2" % l2)
+        for l3 in stats[l1][l2].keys():
+            if conf['order_l3'].count(l3) < 1:
+                error("%s not found in conf.order_l3" % l3)
+
+#
+# Generate the data based on the level specifications
+#
+bar_labels = None
+group_labels = None
+bar_vals = []
+bar_sdvs = []
+if L3.startswith("select="):
+    select_label = l3 = L3.split("=")[1]
+    bar_labels = conf['order_l1']
+    group_labels = conf['order_l2']
+    bar_vals = [[0]*len(group_labels) for i in bar_labels]
+    bar_sdvs = [[0]*len(group_labels) for i in bar_labels]
+    for b in range(len(bar_labels)):
+        l1 = bar_labels[b]
+        for g in range(len(group_labels)):
+            l2 = group_labels[g]
+            bar_vals[b][g] = np.mean(stats[l1][l2][l3])
+            bar_sdvs[b][g] = np.std(stats[l1][l2][l3])
+elif L2.startswith("select="):
+    select_label = l2 = L2.split("=")[1]
+    bar_labels = conf['order_l1']
+    group_labels = conf['order_l3']
+    bar_vals = [[0]*len(group_labels) for i in bar_labels]
+    bar_sdvs = [[0]*len(group_labels) for i in bar_labels]
+    for b in range(len(bar_labels)):
+        l1 = bar_labels[b]
+        for g in range(len(group_labels)):
+            l3 = group_labels[g]
+            bar_vals[b][g] = np.mean(stats[l1][l2][l3])
+            bar_sdvs[b][g] = np.std(stats[l1][l2][l3])
+elif L1.startswith("select="):
+    select_label = l1 = L1.split("=")[1]
+    bar_labels = conf['order_l2']
+    group_labels = conf['order_l3']
+    bar_vals = [[0]*len(group_labels) for i in bar_labels]
+    bar_sdvs = [[0]*len(group_labels) for i in bar_labels]
+    for b in range(len(bar_labels)):
+        l2 = bar_labels[b]
+        for g in range(len(group_labels)):
+            l3 = group_labels[g]
+            bar_vals[b][g] = np.mean(stats[l1][l2][l3])
+            bar_sdvs[b][g] = np.std(stats[l1][l2][l3])
+else:
+    usage()
+
+# If group is before bar then flip (zip) the data
+if [L1, L2, L3].index("group") < [L1, L2, L3].index("bar"):
+    bar_labels, group_labels = group_labels, bar_labels
+    bar_vals = zip(*bar_vals)
+    bar_sdvs = zip(*bar_sdvs)
+
+print "bar_vals:", bar_vals
+
+#
+# Now render the bar graph
+#
+ind = np.arange(len(group_labels))  # the x locations for the groups
+width = 0.8 * (1.0/len(bar_labels)) # the width of the bars
+
+fig = plt.figure(figsize=(10,6), dpi=80)
+plot = fig.add_subplot(1, 1, 1)
+
+rects = []
+for i in range(len(bar_vals)):
+    rects.append(plot.bar(ind+width*i, bar_vals[i], width, color=colors[i],
+                          yerr=bar_sdvs[i], align='center'))
+
+# add some
+plot.set_ylabel('Milliseconds (less is better)')
+plot.set_title("Javascript array test: %s" % select_label)
+plot.set_xticks(ind+width)
+plot.set_xticklabels( group_labels )
+
+fontP = FontProperties()
+fontP.set_size('small')
+plot.legend( [r[0] for r in rects], bar_labels, prop=fontP,
+            loc = 'center right', bbox_to_anchor = (1.0, legendHeight))
+
+def autolabel(rects):
+    # attach some text labels
+    for rect in rects:
+        height = rect.get_height()
+        if np.isnan(height):
+            height = 0.0
+        plot.text(rect.get_x()+rect.get_width()/2., height+20, '%d'%int(height),
+                ha='center', va='bottom', size='7')
+
+for rect in rects:
+    autolabel(rect)
+
+# Adjust axis sizes
+axis = list(plot.axis())
+axis[0] = -width          # Make sure left side has enough for bar
+#axis[1] = axis[1] * 1.20  # Add 20% to the right to make sure it fits
+axis[2] = 0               # Make y-axis start at 0
+axis[3] = axis[3] * 1.10  # Add 10% to the top
+plot.axis(axis)
+
+plt.show()
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/launch.sh
@@ -0,0 +1,118 @@
+#!/usr/bin/env bash
+
+usage() {
+    if [ "$*" ]; then
+        echo "$*"
+        echo
+    fi
+    echo "Usage: ${NAME} [--listen PORT] [--vnc VNC_HOST:PORT] [--cert CERT]"
+    echo
+    echo "Starts the WebSockets proxy and a mini-webserver and "
+    echo "provides a cut-and-paste URL to go to."
+    echo 
+    echo "    --listen PORT         Port for proxy/webserver to listen on"
+    echo "                          Default: 6080"
+    echo "    --vnc VNC_HOST:PORT   VNC server host:port proxy target"
+    echo "                          Default: localhost:5900"
+    echo "    --cert CERT           Path to combined cert/key file"
+    echo "                          Default: self.pem"
+    echo "    --web WEB             Path to web files (e.g. vnc.html)"
+    echo "                          Default: ./"
+    exit 2
+}
+
+NAME="$(basename $0)"
+HERE="$(cd "$(dirname "$0")" && pwd)"
+PORT="6080"
+VNC_DEST="localhost:5900"
+CERT=""
+WEB=""
+proxy_pid=""
+
+die() {
+    echo "$*"
+    exit 1
+}
+
+cleanup() {
+    trap - TERM QUIT INT EXIT
+    trap "true" CHLD   # Ignore cleanup messages
+    echo
+    if [ -n "${proxy_pid}" ]; then
+        echo "Terminating WebSockets proxy (${proxy_pid})"
+        kill ${proxy_pid}
+    fi
+}
+
+# Process Arguments
+
+# Arguments that only apply to chrooter itself
+while [ "$*" ]; do
+    param=$1; shift; OPTARG=$1
+    case $param in
+    --listen)  PORT="${OPTARG}"; shift            ;;
+    --vnc)     VNC_DEST="${OPTARG}"; shift        ;;
+    --cert)    CERT="${OPTARG}"; shift            ;;
+    --web)     WEB="${OPTARG}"; shift            ;;
+    -h|--help) usage                              ;;
+    -*) usage "Unknown chrooter option: ${param}" ;;
+    *) break                                      ;;
+    esac
+done
+
+# Sanity checks
+which netstat >/dev/null 2>&1 \
+    || die "Must have netstat installed"
+
+netstat -ltn | grep -qs "${PORT} .*LISTEN" \
+    && die "Port ${PORT} in use. Try --listen PORT"
+
+trap "cleanup" TERM QUIT INT EXIT
+
+# Find vnc.html
+if [ -n "${WEB}" ]; then
+    if [ ! -e "${WEB}/vnc.html" ]; then
+        die "Could not find ${WEB}/vnc.html"
+    fi
+elif [ -e "$(pwd)/vnc.html" ]; then
+    WEB=$(pwd)
+elif [ -e "${HERE}/../vnc.html" ]; then
+    WEB=${HERE}/../
+elif [ -e "${HERE}/vnc.html" ]; then
+    WEB=${HERE}
+elif [ -e "${HERE}/../share/novnc/vnc.html" ]; then
+    WEB=${HERE}/../share/novnc/
+else
+    die "Could not find vnc.html"
+fi
+
+# Find self.pem
+if [ -n "${CERT}" ]; then
+    if [ ! -e "${CERT}" ]; then
+        die "Could not find ${CERT}"
+    fi
+elif [ -e "$(pwd)/self.pem" ]; then
+    CERT="$(pwd)/self.pem"
+elif [ -e "${HERE}/../self.pem" ]; then
+    CERT="${HERE}/../self.pem"
+elif [ -e "${HERE}/self.pem" ]; then
+    CERT="${HERE}/self.pem"
+else
+    echo "Warning: could not find self.pem"
+fi
+
+echo "Starting webserver and WebSockets proxy on port ${PORT}"
+${HERE}/websockify --web ${WEB} ${CERT:+--cert ${CERT}} ${PORT} ${VNC_DEST} &
+proxy_pid="$!"
+sleep 1
+if ! ps -p ${proxy_pid} >/dev/null; then
+    proxy_pid=
+    echo "Failed to start WebSockets proxy"
+    exit 1
+fi
+
+echo -e "\n\nNavigate to this URL:\n"
+echo -e "    http://$(hostname):${PORT}/vnc.html?host=$(hostname)&port=${PORT}\n"
+echo -e "Press Ctrl-C to exit\n\n"
+
+wait ${proxy_pid}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/nova-novncproxy
@@ -0,0 +1,152 @@
+#!/usr/bin/env python
+# vim: tabstop=4 shiftwidth=4 softtabstop=4
+
+# Copyright (c) 2012 Openstack, LLC.
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#!/usr/bin/env python
+
+'''
+Websocket proxy that is compatible with Openstack Nova.
+Leverages websockify by Joel Martin
+'''
+
+import Cookie
+from oslo.config import cfg
+import socket
+import sys
+
+import websockify
+
+from nova import config
+from nova import context
+from nova import utils
+from nova.openstack.common import rpc
+
+
+opts = [
+    cfg.BoolOpt('record',
+                default=False,
+                help='Record sessions to FILE.[session_number]'),
+    cfg.BoolOpt('daemon',
+                default=False,
+                help='Become a daemon (background process)'),
+    cfg.BoolOpt('ssl_only',
+                default=False,
+                help='Disallow non-encrypted connections'),
+    cfg.BoolOpt('source_is_ipv6',
+                default=False,
+                help='Source is ipv6'),
+    cfg.StrOpt('cert',
+               default='self.pem',
+               help='SSL certificate file'),
+    cfg.StrOpt('key',
+               default=None,
+               help='SSL key file (if separate from cert)'),
+    cfg.StrOpt('web',
+               default='.',
+               help='Run webserver on same port. Serve files from DIR.'),
+    cfg.StrOpt('novncproxy_host',
+               default='0.0.0.0',
+               help='Host on which to listen for incoming requests'),
+    cfg.IntOpt('novncproxy_port',
+               default=6080,
+               help='Port on which to listen for incoming requests'),
+    ]
+CONF = cfg.CONF
+CONF.register_cli_opts(opts)
+
+# As of nova commit 0b11668e64450039dc071a4a123abd02206f865f we must
+# manually register the rpc library
+if hasattr(rpc, 'register_opts'):
+    rpc.register_opts(CONF)
+
+
+class NovaWebSocketProxy(websockify.WebSocketProxy):
+    def __init__(self, *args, **kwargs):
+        websockify.WebSocketProxy.__init__(self, *args, **kwargs)
+
+    def new_client(self):
+        """
+        Called after a new WebSocket connection has been established.
+        """
+        cookie = Cookie.SimpleCookie()
+        cookie.load(self.headers.getheader('cookie'))
+        token = cookie['token'].value
+        ctxt = context.get_admin_context()
+        connect_info = rpc.call(ctxt, 'consoleauth',
+                                {'method': 'check_token',
+                                 'args': {'token': token}})
+
+        if not connect_info:
+            raise Exception("Invalid Token")
+
+        host = connect_info['host']
+        port = int(connect_info['port'])
+
+        # Connect to the target
+        self.msg("connecting to: %s:%s" % (
+                 host, port))
+        tsock = self.socket(host, port,
+                connect=True)
+
+        # Handshake as necessary
+        if connect_info.get('internal_access_path'):
+            tsock.send("CONNECT %s HTTP/1.1\r\n\r\n" %
+                        connect_info['internal_access_path'])
+            while True:
+                data = tsock.recv(4096, socket.MSG_PEEK)
+                if data.find("\r\n\r\n") != -1:
+                    if not data.split("\r\n")[0].find("200"):
+                        raise Exception("Invalid Connection Info")
+                    tsock.recv(len(data))
+                    break
+
+        if self.verbose and not self.daemon:
+            print(self.traffic_legend)
+
+        # Start proxying
+        try:
+            self.do_proxy(tsock)
+        except:
+            if tsock:
+                tsock.shutdown(socket.SHUT_RDWR)
+                tsock.close()
+                self.vmsg("%s:%s: Target closed" % (host, port))
+            raise
+
+
+if __name__ == '__main__':
+    if CONF.ssl_only and not os.path.exists(CONF.cert):
+        parser.error("SSL only and %s not found" % CONF.cert)
+
+    # Setup flags
+    config.parse_args(sys.argv)
+
+    # Create and start the NovaWebSockets proxy
+    server = NovaWebSocketProxy(listen_host=CONF.novncproxy_host,
+                                listen_port=CONF.novncproxy_port,
+                                source_is_ipv6=CONF.source_is_ipv6,
+                                verbose=CONF.verbose,
+                                cert=CONF.cert,
+                                key=CONF.key,
+                                ssl_only=CONF.ssl_only,
+                                daemon=CONF.daemon,
+                                record=CONF.record,
+                                web=CONF.web,
+                                target_host='ignore',
+                                target_port='ignore',
+                                wrap_mode='exit',
+                                wrap_cmd=None)
+    server.start_server()
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/novnc_proxy
@@ -0,0 +1,211 @@
+#!/usr/bin/env bash
+
+# Copyright (C) 2018 The noVNC Authors
+# Licensed under MPL 2.0 or any later version (see LICENSE.txt)
+
+usage() {
+    if [ "$*" ]; then
+        echo "$*"
+        echo
+    fi
+    echo "Usage: ${NAME} [--listen PORT] [--vnc VNC_HOST:PORT] [--cert CERT] [--ssl-only]"
+    echo
+    echo "Starts the WebSockets proxy and a mini-webserver and "
+    echo "provides a cut-and-paste URL to go to."
+    echo
+    echo "    --listen PORT         Port for proxy/webserver to listen on"
+    echo "                          Default: 6080"
+    echo "    --vnc VNC_HOST:PORT   VNC server host:port proxy target"
+    echo "                          Default: localhost:5900"
+    echo "    --cert CERT           Path to combined cert/key file, or just"
+    echo "                          the cert file if used with --key"
+    echo "                          Default: self.pem"
+    echo "    --key KEY             Path to key file, when not combined with cert"
+    echo "    --web WEB             Path to web files (e.g. vnc.html)"
+    echo "                          Default: ./"
+    echo "    --ssl-only            Disable non-https connections."
+    echo "                                    "
+    echo "    --record FILE         Record traffic to FILE.session.js"
+    echo "                                    "
+    echo "    --syslog SERVER       Can be local socket such as /dev/log, or a UDP host:port pair."
+    echo "                                    "
+    echo "    --heartbeat SEC       send a ping to the client every SEC seconds"
+    echo "    --timeout SEC         after SEC seconds exit when not connected"
+    echo "    --idle-timeout SEC    server exits after SEC seconds if there are no"
+    echo "                                    "
+    echo "    --web-auth            enable authentication"
+    echo "    --auth-plugin CLASS   authentication plugin to use"
+    echo "    --auth-source ARG     plugin configuration"
+    echo "                                    "
+    echo "                          active connections"
+    echo "                                    "
+    exit 2
+}
+
+NAME="$(basename $0)"
+REAL_NAME="$(readlink -f $0)"
+HERE="$(cd "$(dirname "$REAL_NAME")" && pwd)"
+PORT="6080"
+VNC_DEST="localhost:5900"
+CERT=""
+KEY=""
+WEB=""
+proxy_pid=""
+SSLONLY=""
+RECORD_ARG=""
+SYSLOG_ARG=""
+HEARTBEAT_ARG=""
+IDLETIMEOUT_ARG=""
+TIMEOUT_ARG=""
+WEBAUTH_ARG=""
+AUTHPLUGIN_ARG=""
+AUTHSOURCE_ARG=""
+
+
+
+die() {
+    echo "$*"
+    exit 1
+}
+
+cleanup() {
+    trap - TERM QUIT INT EXIT
+    trap "true" CHLD   # Ignore cleanup messages
+    echo
+    if [ -n "${proxy_pid}" ]; then
+        echo "Terminating WebSockets proxy (${proxy_pid})"
+        kill ${proxy_pid}
+    fi
+}
+
+# Process Arguments
+
+# Arguments that only apply to chrooter itself
+while [ "$*" ]; do
+    param=$1; shift; OPTARG=$1
+    case $param in
+    --listen)  PORT="${OPTARG}"; shift            ;;
+    --vnc)     VNC_DEST="${OPTARG}"; shift        ;;
+    --cert)    CERT="${OPTARG}"; shift            ;;
+    --key)     KEY="${OPTARG}"; shift             ;;
+    --web)     WEB="${OPTARG}"; shift            ;;
+    --ssl-only) SSLONLY="--ssl-only"             ;;
+    --record) RECORD_ARG="--record ${OPTARG}"; shift ;;
+    --syslog) SYSLOG_ARG="--syslog ${OPTARG}"; shift ;;
+    --heartbeat) HEARTBEAT_ARG="--heartbeat ${OPTARG}"; shift ;;
+    --idle-timeout) IDLETIMEOUT_ARG="--idle-timeout ${OPTARG}"; shift ;;
+    --timeout) TIMEOUT_ARG="--timeout ${OPTARG}"; shift ;;
+    --web-auth) WEBAUTH_ARG="--web-auth"                ;;
+    --auth-plugin) AUTHPLUGIN_ARG="--auth-plugin ${OPTARG}"; shift ;;
+    --auth-source) AUTHSOURCE_ARG="--auth-source ${OPTARG}"; shift ;;
+    -h|--help) usage                              ;;
+    -*) usage "Unknown chrooter option: ${param}" ;;
+    *) break                                      ;;
+    esac
+done
+
+# Sanity checks
+if bash -c "exec 7<>/dev/tcp/localhost/${PORT}" &> /dev/null; then
+    exec 7<&-
+    exec 7>&-
+    die "Port ${PORT} in use. Try --listen PORT"
+else
+    exec 7<&-
+    exec 7>&-
+fi
+
+trap "cleanup" TERM QUIT INT EXIT
+
+# Find vnc.html
+if [ -n "${WEB}" ]; then
+    if [ ! -e "${WEB}/vnc.html" ]; then
+        die "Could not find ${WEB}/vnc.html"
+    fi
+elif [ -e "$(pwd)/vnc.html" ]; then
+    WEB=$(pwd)
+elif [ -e "${HERE}/../vnc.html" ]; then
+    WEB=${HERE}/../
+elif [ -e "${HERE}/vnc.html" ]; then
+    WEB=${HERE}
+elif [ -e "${HERE}/../share/novnc/vnc.html" ]; then
+    WEB=${HERE}/../share/novnc/
+else
+    die "Could not find vnc.html"
+fi
+
+# Find self.pem
+if [ -n "${CERT}" ]; then
+    if [ ! -e "${CERT}" ]; then
+        die "Could not find ${CERT}"
+    fi
+elif [ -e "$(pwd)/self.pem" ]; then
+    CERT="$(pwd)/self.pem"
+elif [ -e "${HERE}/../self.pem" ]; then
+    CERT="${HERE}/../self.pem"
+elif [ -e "${HERE}/self.pem" ]; then
+    CERT="${HERE}/self.pem"
+else
+    echo "Warning: could not find self.pem"
+fi
+
+# Check key file
+if [ -n "${KEY}" ]; then
+    if [ ! -e "${KEY}" ]; then
+        die "Could not find ${KEY}"
+    fi
+fi
+
+# try to find websockify (prefer local, try global, then download local)
+if [[ -d ${HERE}/websockify ]]; then
+    WEBSOCKIFY=${HERE}/websockify/run
+
+    if [[ ! -x $WEBSOCKIFY ]]; then
+        echo "The path ${HERE}/websockify exists, but $WEBSOCKIFY either does not exist or is not executable."
+        echo "If you intended to use an installed websockify package, please remove ${HERE}/websockify."
+        exit 1
+    fi
+
+    echo "Using local websockify at $WEBSOCKIFY"
+else
+    WEBSOCKIFY_FROMSYSTEM=$(which websockify 2>/dev/null)
+    WEBSOCKIFY_FROMSNAP=${HERE}/../usr/bin/python2-websockify
+    [ -f $WEBSOCKIFY_FROMSYSTEM ] && WEBSOCKIFY=$WEBSOCKIFY_FROMSYSTEM
+    [ -f $WEBSOCKIFY_FROMSNAP ] && WEBSOCKIFY=$WEBSOCKIFY_FROMSNAP
+
+    if [ ! -f "$WEBSOCKIFY" ]; then
+        echo "No installed websockify, attempting to clone websockify..."
+        WEBSOCKIFY=${HERE}/websockify/run
+        git clone https://github.com/novnc/websockify ${HERE}/websockify
+
+        if [[ ! -e $WEBSOCKIFY ]]; then
+            echo "Unable to locate ${HERE}/websockify/run after downloading"
+            exit 1
+        fi
+
+        echo "Using local websockify at $WEBSOCKIFY"
+    else
+        echo "Using installed websockify at $WEBSOCKIFY"
+    fi
+fi
+
+echo "Starting webserver and WebSockets proxy on port ${PORT}"
+#${HERE}/websockify --web ${WEB} ${CERT:+--cert ${CERT}} ${PORT} ${VNC_DEST} &
+${WEBSOCKIFY} ${SYSLOG_ARG} ${SSLONLY} --web ${WEB} ${CERT:+--cert ${CERT}} ${KEY:+--key ${KEY}} ${PORT} ${VNC_DEST} ${HEARTBEAT_ARG} ${IDLETIMEOUT_ARG} ${RECORD_ARG} ${TIMEOUT_ARG} ${WEBAUTH_ARG} ${AUTHPLUGIN_ARG} ${AUTHSOURCE_ARG} &
+proxy_pid="$!"
+sleep 1
+if ! ps -p ${proxy_pid} >/dev/null; then
+    proxy_pid=
+    echo "Failed to start WebSockets proxy"
+    exit 1
+fi
+
+echo -e "\n\nNavigate to this URL:\n"
+if [ "x$SSLONLY" == "x" ]; then
+    echo -e "    http://$(hostname):${PORT}/vnc.html?host=$(hostname)&port=${PORT}\n"
+else
+    echo -e "    https://$(hostname):${PORT}/vnc.html?host=$(hostname)&port=${PORT}\n"
+fi
+
+echo -e "Press Ctrl-C to exit\n\n"
+
+wait ${proxy_pid}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/parse.js
@@ -0,0 +1,97 @@
+// Utility to parse keysymdef.h to produce mappings from Unicode codepoints to keysyms
+"use strict";
+
+var fs = require('fs');
+
+var show_help = process.argv.length === 2;
+var use_keynames = false;
+var filename;
+
+for (var i = 2; i < process.argv.length; ++i) {
+  switch (process.argv[i]) {
+    case "--help":
+    case "-h":
+      show_help = true;
+      break;
+    case "--debug-names":
+    case "-d":
+      use_keynames = true;
+      break;
+    case "--file":
+    case "-f":
+    default:
+      filename = process.argv[i];
+  }
+}
+
+if (!filename) {
+  show_help = true;
+  console.log("Error: No filename specified\n");
+}
+
+if (show_help) {
+  console.log("Parses a *nix keysymdef.h to generate Unicode code point mappings");
+  console.log("Usage: node parse.js [options] filename:");
+  console.log("  -h [ --help ]                 Produce this help message");
+  console.log("  -d [ --debug-names ]          Preserve keysym names for debugging (Increases file size by ~40KB)");
+  console.log("  filename                      The keysymdef.h file to parse");
+  return;
+}
+
+// Set this to false to omit key names from the generated keysymdef.js
+// This reduces the file size by around 40kb, but may hinder debugging
+
+var buf = fs.readFileSync(filename);
+var str = buf.toString('utf8');
+
+var re = /^\#define XK_([a-zA-Z_0-9]+)\s+0x([0-9a-fA-F]+)\s*(\/\*\s*(.*)\s*\*\/)?\s*$/m;
+
+var arr = str.split('\n');
+
+var keysyms = {};
+var codepoints = {};
+
+for (var i = 0; i < arr.length; ++i) {
+    var result = re.exec(arr[i]);
+    if (result){
+        var keyname = result[1];
+        var keysym = parseInt(result[2], 16);
+        var remainder = result[3];
+
+        keysyms[keysym] = keyname;
+
+        var unicodeRes = /U\+([0-9a-fA-F]+)/.exec(remainder);
+        if (unicodeRes) {
+            var unicode = parseInt(unicodeRes[1], 16);
+            if (!codepoints[unicode]){
+                codepoints[unicode] = keysym;
+            }
+        }
+        else {
+            console.log("no unicode codepoint found:", arr[i]);
+        }
+    }
+    else {
+        console.log("line is not a keysym:", arr[i]);
+    }
+}
+
+var out = "// This file describes mappings from Unicode codepoints to the keysym values\n" +
+"// (and optionally, key names) expected by the RFB protocol\n" +
+"// How this file was generated:\n" +
+"// " + process.argv.join(" ") + "\n" +
+"var keysyms = (function(){\n" +
+"    \"use strict\";\n" +
+"    var keynames = {keysyms};\n" +
+"    var codepoints = {codepoints};\n" +
+"\n" +
+"    function lookup(k) { return k ? {keysym: k, keyname: keynames ? keynames[k] : k} : undefined; }\n" +
+"    return {\n" +
+"        fromUnicode : function(u) { return lookup(codepoints[u]); },\n" +
+"        lookup : lookup\n" +
+"    };\n" +
+"})();\n";
+out = out.replace('{keysyms}', use_keynames ? JSON.stringify(keysyms) : "null");
+out = out.replace('{codepoints}', JSON.stringify(codepoints));
+
+fs.writeFileSync("keysymdef.js", out);
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/rebind
@@ -0,0 +1,18 @@
+#!/usr/bin/env bash
+
+usage() {
+    echo "Usage: $(basename $0) OLD_PORT NEW_PORT COMMAND_LINE"
+    echo
+    echo "Launch COMMAND_LINE, but intercept system calls to bind"
+    echo "to OLD_PORT and instead bind them to localhost:NEW_PORT"
+    exit 2
+}
+
+# Parameter defaults
+mydir=$(readlink -f $(dirname ${0}))
+
+export REBIND_PORT_OLD="${1}"; shift
+export REBIND_PORT_NEW="${1}"; shift
+
+LD_PRELOAD=${mydir}/rebind.so "${@}"
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/rebind.c
@@ -0,0 +1,94 @@
+/*
+ * rebind: Intercept bind calls and bind to a different port
+ * Copyright 2010 Joel Martin
+ * Licensed under MPL-2.0 (see docs/LICENSE.MPL-2.0)
+ *
+ * Overload (LD_PRELOAD) bind system call. If REBIND_PORT_OLD and
+ * REBIND_PORT_NEW environment variables are set then bind on the new
+ * port (of localhost) instead of the old port. 
+ *
+ * This allows a bridge/proxy (such as websockify) to run on the old port and
+ * translate traffic to/from the new port.
+ *
+ * Usage:
+ *     LD_PRELOAD=./rebind.so \
+ *     REBIND_PORT_OLD=23 \
+ *     REBIND_PORT_NEW=2023 \
+ *     program
+ */
+
+//#define DO_DEBUG 1
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#define __USE_GNU 1  // Pull in RTLD_NEXT
+#include <dlfcn.h>
+
+#include <string.h>
+#include <netinet/in.h>
+
+
+#if defined(DO_DEBUG)
+#define DEBUG(...) \
+    fprintf(stderr, "wswrapper: "); \
+    fprintf(stderr, __VA_ARGS__);
+#else
+#define DEBUG(...)
+#endif
+
+
+int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
+{
+    static void * (*func)();
+    int do_move = 0;
+    struct sockaddr_in * addr_in = (struct sockaddr_in *)addr;
+    struct sockaddr_in addr_tmp;
+    socklen_t addrlen_tmp;
+    char * PORT_OLD, * PORT_NEW, * end1, * end2;
+    int ret, oldport, newport, askport = htons(addr_in->sin_port);
+    uint32_t askaddr = htons(addr_in->sin_addr.s_addr);
+    if (!func) func = (void *(*)()) dlsym(RTLD_NEXT, "bind");
+
+    DEBUG(">> bind(%d, _, %d), askaddr %d, askport %d\n",
+          sockfd, addrlen, askaddr, askport);
+
+    /* Determine if we should move this socket */
+    if (addr_in->sin_family == AF_INET) {
+        // TODO: support IPv6
+        PORT_OLD = getenv("REBIND_OLD_PORT");
+        PORT_NEW = getenv("REBIND_NEW_PORT");
+        if (PORT_OLD && (*PORT_OLD != '\0') &&
+            PORT_NEW && (*PORT_NEW != '\0')) {
+            oldport = strtol(PORT_OLD, &end1, 10);
+            newport = strtol(PORT_NEW, &end2, 10);
+            if (oldport && (*end1 == '\0') &&
+                newport && (*end2 == '\0') &&
+                (oldport == askport)) {
+                do_move = 1;
+            }
+        }
+    }
+
+    if (! do_move) {
+        /* Just pass everything right through to the real bind */
+        ret = (int) func(sockfd, addr, addrlen);
+        DEBUG("<< bind(%d, _, %d) ret %d\n", sockfd, addrlen, ret);
+        return ret;
+    }
+
+    DEBUG("binding fd %d on localhost:%d instead of 0x%x:%d\n",
+        sockfd, newport, ntohl(addr_in->sin_addr.s_addr), oldport);
+
+    /* Use a temporary location for the new address information */
+    addrlen_tmp = sizeof(addr_tmp);
+    memcpy(&addr_tmp, addr, addrlen_tmp);
+
+    /* Bind to other port on the loopback instead */
+    addr_tmp.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    addr_tmp.sin_port = htons(newport);
+    ret = (int) func(sockfd, &addr_tmp, addrlen_tmp);
+
+    DEBUG("<< bind(%d, _, %d) ret %d\n", sockfd, addrlen, ret);
+    return ret;
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/u2x11
@@ -0,0 +1,28 @@
+#!/usr/bin/env bash
+#
+# Convert "U+..." commented entries in /usr/include/X11/keysymdef.h
+# into JavaScript for use by noVNC.  Note this is likely to produce
+# a few duplicate properties with clashing values, that will need
+# resolving manually.
+#
+# Colin Dean <colin@xvpsource.org>
+#
+
+regex="^#define[ \t]+XK_[A-Za-z0-9_]+[ \t]+0x([0-9a-fA-F]+)[ \t]+\/\*[ \t]+U\+([0-9a-fA-F]+)[ \t]+[^*]+.[ \t]+\*\/[ \t]*$"
+echo "unicodeTable = {"
+while read line; do
+    if echo "${line}" | egrep -qs "${regex}"; then
+
+        x11=$(echo "${line}" | sed -r "s/${regex}/\1/")
+        vnc=$(echo "${line}" | sed -r "s/${regex}/\2/")
+	
+	if echo "${vnc}" | egrep -qs "^00[2-9A-F][0-9A-F]$"; then
+	    : # skip ISO Latin-1 (U+0020 to U+00FF) as 1-to-1 mapping
+	else
+	    # note 1-to-1 is possible (e.g. for Euro symbol, U+20AC)
+	    echo "    0x${vnc} : 0x${x11},"
+	fi
+    fi
+done < /usr/include/X11/keysymdef.h | uniq
+echo "};"
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/validate
@@ -0,0 +1,45 @@
+#!/bin/bash
+
+set -e
+
+RET=0
+
+OUT=`mktemp`
+
+for fn in "$@"; do
+	echo "Validating $fn..."
+	echo
+
+	case $fn in
+		*.html)
+			type="text/html"
+			;;
+		*.css)
+			type="text/css"
+			;;
+		*)
+			echo "Unknown format!"
+			echo
+			RET=1
+			continue
+			;;
+	esac
+
+	curl --silent \
+		--header "Content-Type: ${type}; charset=utf-8" \
+		--data-binary @${fn} \
+		https://validator.w3.org/nu/?out=text > $OUT
+	cat $OUT
+	echo
+
+	# We don't fail the check for warnings as some warnings are
+	# not relevant for us, and we don't currently have a way to
+	# ignore just those
+	if grep -q -s -E "^Error:" $OUT; then
+		RET=1
+	fi
+done
+
+rm $OUT
+
+exit $RET
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/web.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python
+'''
+A super simple HTTP/HTTPS webserver for python. Automatically detect
+
+You can make a cert/key with openssl using:
+openssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem
+as taken from http://docs.python.org/dev/library/ssl.html#certificates
+
+'''
+
+import traceback, sys
+import socket
+import ssl
+#import http.server as server      # python 3.X
+import SimpleHTTPServer as server  # python 2.X
+
+def do_request(connstream, from_addr):
+    x = object()
+    server.SimpleHTTPRequestHandler(connstream, from_addr, x)
+    connstream.close()
+
+def serve():
+    bindsocket = socket.socket()
+    bindsocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+    #bindsocket.bind(('localhost', PORT))
+    bindsocket.bind(('', PORT))
+    bindsocket.listen(5)
+
+    print("serving on port", PORT)
+
+    while True:
+        try:
+            newsocket, from_addr = bindsocket.accept()
+            peek = newsocket.recv(1024, socket.MSG_PEEK)
+            if peek.startswith("\x16"):
+                connstream = ssl.wrap_socket(
+                        newsocket,
+                        server_side=True,
+                        certfile='self.pem',
+                        ssl_version=ssl.PROTOCOL_TLSv1)
+            else:
+                connstream = newsocket
+
+            do_request(connstream, from_addr)
+
+        except Exception:
+            traceback.print_exc()
+
+try:
+    PORT = int(sys.argv[1])
+except:
+    print "%s port" % sys.argv[0]
+    sys.exit(2)
+
+serve()
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/websocket.py
@@ -0,0 +1,1030 @@
+#!/usr/bin/env python
+
+'''
+Python WebSocket library with support for "wss://" encryption.
+Copyright 2011 Joel Martin
+Licensed under LGPL version 3 (see docs/LICENSE.LGPL-3)
+
+Supports following protocol versions:
+    - http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07
+    - http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-10
+    - http://tools.ietf.org/html/rfc6455
+
+You can make a cert/key with openssl using:
+openssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem
+as taken from http://docs.python.org/dev/library/ssl.html#certificates
+
+'''
+
+import os, sys, time, errno, signal, socket, select, logging
+import array, struct
+from base64 import b64encode, b64decode
+
+# Imports that vary by python version
+
+# python 3.0 differences
+if sys.hexversion > 0x3000000:
+    b2s = lambda buf: buf.decode('latin_1')
+    s2b = lambda s: s.encode('latin_1')
+    s2a = lambda s: s
+else:
+    b2s = lambda buf: buf  # No-op
+    s2b = lambda s: s      # No-op
+    s2a = lambda s: [ord(c) for c in s]
+try:    from io import StringIO
+except: from cStringIO import StringIO
+try:    from http.server import SimpleHTTPRequestHandler
+except: from SimpleHTTPServer import SimpleHTTPRequestHandler
+
+# python 2.6 differences
+try:    from hashlib import sha1
+except: from sha import sha as sha1
+
+# python 2.5 differences
+try:
+    from struct import pack, unpack_from
+except:
+    from struct import pack
+    def unpack_from(fmt, buf, offset=0):
+        slice = buffer(buf, offset, struct.calcsize(fmt))
+        return struct.unpack(fmt, slice)
+
+# Degraded functionality if these imports are missing
+for mod, msg in [('numpy', 'HyBi protocol will be slower'),
+                 ('ssl', 'TLS/SSL/wss is disabled'),
+                 ('multiprocessing', 'Multi-Processing is disabled'),
+                 ('resource', 'daemonizing is disabled')]:
+    try:
+        globals()[mod] = __import__(mod)
+    except ImportError:
+        globals()[mod] = None
+        print("WARNING: no '%s' module, %s" % (mod, msg))
+
+if multiprocessing and sys.platform == 'win32':
+    # make sockets pickle-able/inheritable
+    import multiprocessing.reduction
+
+
+# HTTP handler with WebSocket upgrade support
+class WebSocketRequestHandler(SimpleHTTPRequestHandler):
+    """
+    WebSocket Request Handler Class, derived from SimpleHTTPRequestHandler.
+    Must be sub-classed with new_websocket_client method definition.
+    The request handler can be configured by setting optional
+    attributes on the server object:
+
+    * only_upgrade: If true, SimpleHTTPRequestHandler will not be enabled,
+      only websocket is allowed.
+    * verbose: If true, verbose logging is activated.
+    * daemon: Running as daemon, do not write to console etc
+    * record: Record raw frame data as JavaScript array into specified filename
+    * run_once: Handle a single request
+    * handler_id: A sequence number for this connection, appended to record filename
+    """
+    buffer_size = 65536
+
+    GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
+
+    server_version = "WebSockify"
+
+    protocol_version = "HTTP/1.1"
+
+    # An exception while the WebSocket client was connected
+    class CClose(Exception):
+        pass
+
+    def __init__(self, req, addr, server):
+        # Retrieve a few configuration variables from the server
+        self.only_upgrade = getattr(server, "only_upgrade", False)
+        self.verbose = getattr(server, "verbose", False)
+        self.daemon = getattr(server, "daemon", False)
+        self.record = getattr(server, "record", False)
+        self.run_once = getattr(server, "run_once", False)
+        self.rec        = None
+        self.handler_id = getattr(server, "handler_id", False)
+        self.file_only = getattr(server, "file_only", False)
+        self.traffic = getattr(server, "traffic", False)
+
+        self.logger = getattr(server, "logger", None)
+        if self.logger is None:
+            self.logger = WebSocketServer.get_logger()
+
+        SimpleHTTPRequestHandler.__init__(self, req, addr, server)
+
+    @staticmethod
+    def unmask(buf, hlen, plen):
+        pstart = hlen + 4
+        pend = pstart + plen
+        if numpy:
+            b = c = s2b('')
+            if plen >= 4:
+                mask = numpy.frombuffer(buf, dtype=numpy.dtype('<u4'),
+                        offset=hlen, count=1)
+                data = numpy.frombuffer(buf, dtype=numpy.dtype('<u4'),
+                        offset=pstart, count=int(plen / 4))
+                #b = numpy.bitwise_xor(data, mask).data
+                b = numpy.bitwise_xor(data, mask).tostring()
+
+            if plen % 4:
+                #self.msg("Partial unmask")
+                mask = numpy.frombuffer(buf, dtype=numpy.dtype('B'),
+                        offset=hlen, count=(plen % 4))
+                data = numpy.frombuffer(buf, dtype=numpy.dtype('B'),
+                        offset=pend - (plen % 4),
+                        count=(plen % 4))
+                c = numpy.bitwise_xor(data, mask).tostring()
+            return b + c
+        else:
+            # Slower fallback
+            mask = buf[hlen:hlen+4]
+            data = array.array('B')
+            mask = s2a(mask)
+            data.fromstring(buf[pstart:pend])
+            for i in range(len(data)):
+                data[i] ^= mask[i % 4]
+            return data.tostring()
+
+    @staticmethod
+    def encode_hybi(buf, opcode, base64=False):
+        """ Encode a HyBi style WebSocket frame.
+        Optional opcode:
+            0x0 - continuation
+            0x1 - text frame (base64 encode buf)
+            0x2 - binary frame (use raw buf)
+            0x8 - connection close
+            0x9 - ping
+            0xA - pong
+        """
+        if base64:
+            buf = b64encode(buf)
+
+        b1 = 0x80 | (opcode & 0x0f) # FIN + opcode
+        payload_len = len(buf)
+        if payload_len <= 125:
+            header = pack('>BB', b1, payload_len)
+        elif payload_len > 125 and payload_len < 65536:
+            header = pack('>BBH', b1, 126, payload_len)
+        elif payload_len >= 65536:
+            header = pack('>BBQ', b1, 127, payload_len)
+
+        #self.msg("Encoded: %s", repr(header + buf))
+
+        return header + buf, len(header), 0
+
+    @staticmethod
+    def decode_hybi(buf, base64=False, logger=None):
+        """ Decode HyBi style WebSocket packets.
+        Returns:
+            {'fin'          : 0_or_1,
+             'opcode'       : number,
+             'masked'       : boolean,
+             'hlen'         : header_bytes_number,
+             'length'       : payload_bytes_number,
+             'payload'      : decoded_buffer,
+             'left'         : bytes_left_number,
+             'close_code'   : number,
+             'close_reason' : string}
+        """
+
+        f = {'fin'          : 0,
+             'opcode'       : 0,
+             'masked'       : False,
+             'hlen'         : 2,
+             'length'       : 0,
+             'payload'      : None,
+             'left'         : 0,
+             'close_code'   : 1000,
+             'close_reason' : ''}
+
+        if logger is None:
+            logger = WebSocketServer.get_logger()
+
+        blen = len(buf)
+        f['left'] = blen
+
+        if blen < f['hlen']:
+            return f # Incomplete frame header
+
+        b1, b2 = unpack_from(">BB", buf)
+        f['opcode'] = b1 & 0x0f
+        f['fin'] = (b1 & 0x80) >> 7
+        f['masked'] = (b2 & 0x80) >> 7
+
+        f['length'] = b2 & 0x7f
+
+        if f['length'] == 126:
+            f['hlen'] = 4
+            if blen < f['hlen']:
+                return f # Incomplete frame header
+            (f['length'],) = unpack_from('>xxH', buf)
+        elif f['length'] == 127:
+            f['hlen'] = 10
+            if blen < f['hlen']:
+                return f # Incomplete frame header
+            (f['length'],) = unpack_from('>xxQ', buf)
+
+        full_len = f['hlen'] + f['masked'] * 4 + f['length']
+
+        if blen < full_len: # Incomplete frame
+            return f # Incomplete frame header
+
+        # Number of bytes that are part of the next frame(s)
+        f['left'] = blen - full_len
+
+        # Process 1 frame
+        if f['masked']:
+            # unmask payload
+            f['payload'] = WebSocketRequestHandler.unmask(buf, f['hlen'],
+                                                  f['length'])
+        else:
+            logger.debug("Unmasked frame: %s" % repr(buf))
+            f['payload'] = buf[(f['hlen'] + f['masked'] * 4):full_len]
+
+        if base64 and f['opcode'] in [1, 2]:
+            try:
+                f['payload'] = b64decode(f['payload'])
+            except:
+                logger.exception("Exception while b64decoding buffer: %s" %
+                                 (repr(buf)))
+                raise
+
+        if f['opcode'] == 0x08:
+            if f['length'] >= 2:
+                f['close_code'] = unpack_from(">H", f['payload'])[0]
+            if f['length'] > 3:
+                f['close_reason'] = f['payload'][2:]
+
+        return f
+
+
+    #
+    # WebSocketRequestHandler logging/output functions
+    #
+
+    def print_traffic(self, token="."):
+        """ Show traffic flow mode. """
+        if self.traffic:
+            sys.stdout.write(token)
+            sys.stdout.flush()
+
+    def msg(self, msg, *args, **kwargs):
+        """ Output message with handler_id prefix. """
+        prefix = "% 3d: " % self.handler_id
+        self.logger.log(logging.INFO, "%s%s" % (prefix, msg), *args, **kwargs)
+
+    def vmsg(self, msg, *args, **kwargs):
+        """ Same as msg() but as debug. """
+        prefix = "% 3d: " % self.handler_id
+        self.logger.log(logging.DEBUG, "%s%s" % (prefix, msg), *args, **kwargs)
+
+    def warn(self, msg, *args, **kwargs):
+        """ Same as msg() but as warning. """
+        prefix = "% 3d: " % self.handler_id
+        self.logger.log(logging.WARN, "%s%s" % (prefix, msg), *args, **kwargs)
+
+    #
+    # Main WebSocketRequestHandler methods
+    #
+    def send_frames(self, bufs=None):
+        """ Encode and send WebSocket frames. Any frames already
+        queued will be sent first. If buf is not set then only queued
+        frames will be sent. Returns the number of pending frames that
+        could not be fully sent. If returned pending frames is greater
+        than 0, then the caller should call again when the socket is
+        ready. """
+
+        tdelta = int(time.time()*1000) - self.start_time
+
+        if bufs:
+            for buf in bufs:
+                if self.base64:
+                    encbuf, lenhead, lentail = self.encode_hybi(buf, opcode=1, base64=True)
+                else:
+                    encbuf, lenhead, lentail = self.encode_hybi(buf, opcode=2, base64=False)
+
+                if self.rec:
+                    self.rec.write("%s,\n" %
+                            repr("{%s{" % tdelta
+                                + encbuf[lenhead:len(encbuf)-lentail]))
+
+                self.send_parts.append(encbuf)
+
+        while self.send_parts:
+            # Send pending frames
+            buf = self.send_parts.pop(0)
+            sent = self.request.send(buf)
+
+            if sent == len(buf):
+                self.print_traffic("<")
+            else:
+                self.print_traffic("<.")
+                self.send_parts.insert(0, buf[sent:])
+                break
+
+        return len(self.send_parts)
+
+    def recv_frames(self):
+        """ Receive and decode WebSocket frames.
+
+        Returns:
+            (bufs_list, closed_string)
+        """
+
+        closed = False
+        bufs = []
+        tdelta = int(time.time()*1000) - self.start_time
+
+        buf = self.request.recv(self.buffer_size)
+        if len(buf) == 0:
+            closed = {'code': 1000, 'reason': "Client closed abruptly"}
+            return bufs, closed
+
+        if self.recv_part:
+            # Add partially received frames to current read buffer
+            buf = self.recv_part + buf
+            self.recv_part = None
+
+        while buf:
+            frame = self.decode_hybi(buf, base64=self.base64,
+                                     logger=self.logger)
+            #self.msg("Received buf: %s, frame: %s", repr(buf), frame)
+
+            if frame['payload'] == None:
+                # Incomplete/partial frame
+                self.print_traffic("}.")
+                if frame['left'] > 0:
+                    self.recv_part = buf[-frame['left']:]
+                break
+            else:
+                if frame['opcode'] == 0x8: # connection close
+                    closed = {'code': frame['close_code'],
+                              'reason': frame['close_reason']}
+                    break
+
+            self.print_traffic("}")
+
+            if self.rec:
+                start = frame['hlen']
+                end = frame['hlen'] + frame['length']
+                if frame['masked']:
+                    recbuf = WebSocketRequestHandler.unmask(buf, frame['hlen'],
+                                                   frame['length'])
+                else:
+                    recbuf = buf[frame['hlen']:frame['hlen'] +
+                                               frame['length']]
+                self.rec.write("%s,\n" %
+                        repr("}%s}" % tdelta + recbuf))
+
+
+            bufs.append(frame['payload'])
+
+            if frame['left']:
+                buf = buf[-frame['left']:]
+            else:
+                buf = ''
+
+        return bufs, closed
+
+    def send_close(self, code=1000, reason=''):
+        """ Send a WebSocket orderly close frame. """
+
+        msg = pack(">H%ds" % len(reason), code, reason)
+        buf, h, t = self.encode_hybi(msg, opcode=0x08, base64=False)
+        self.request.send(buf)
+
+    def do_websocket_handshake(self):
+        h = self.headers
+
+        prot = 'WebSocket-Protocol'
+        protocols = h.get('Sec-'+prot, h.get(prot, '')).split(',')
+
+        ver = h.get('Sec-WebSocket-Version')
+        if ver:
+            # HyBi/IETF version of the protocol
+
+            # HyBi-07 report version 7
+            # HyBi-08 - HyBi-12 report version 8
+            # HyBi-13 reports version 13
+            if ver in ['7', '8', '13']:
+                self.version = "hybi-%02d" % int(ver)
+            else:
+                self.send_error(400, "Unsupported protocol version %s" % ver)
+                return False
+
+            key = h['Sec-WebSocket-Key']
+
+            # Choose binary if client supports it
+            if 'binary' in protocols:
+                self.base64 = False
+            elif 'base64' in protocols:
+                self.base64 = True
+            else:
+                self.send_error(400, "Client must support 'binary' or 'base64' protocol")
+                return False
+
+            # Generate the hash value for the accept header
+            accept = b64encode(sha1(s2b(key + self.GUID)).digest())
+
+            self.send_response(101, "Switching Protocols")
+            self.send_header("Upgrade", "websocket")
+            self.send_header("Connection", "Upgrade")
+            self.send_header("Sec-WebSocket-Accept", b2s(accept))
+            if self.base64:
+                self.send_header("Sec-WebSocket-Protocol", "base64")
+            else:
+                self.send_header("Sec-WebSocket-Protocol", "binary")
+            self.end_headers()
+            return True
+        else:
+            self.send_error(400, "Missing Sec-WebSocket-Version header. Hixie protocols not supported.")
+
+        return False
+
+    def handle_websocket(self):
+        """Upgrade a connection to Websocket, if requested. If this succeeds,
+        new_websocket_client() will be called. Otherwise, False is returned.
+        """
+        if (self.headers.get('upgrade') and
+            self.headers.get('upgrade').lower() == 'websocket'):
+
+            if not self.do_websocket_handshake():
+                return False
+
+            # Indicate to server that a Websocket upgrade was done
+            self.server.ws_connection = True
+            # Initialize per client settings
+            self.send_parts = []
+            self.recv_part  = None
+            self.start_time = int(time.time()*1000)
+
+            # client_address is empty with, say, UNIX domain sockets
+            client_addr = ""
+            is_ssl = False
+            try:
+                client_addr = self.client_address[0]
+                is_ssl = self.client_address[2]
+            except IndexError:
+                pass
+
+            if is_ssl:
+                self.stype = "SSL/TLS (wss://)"
+            else:
+                self.stype = "Plain non-SSL (ws://)"
+
+            self.log_message("%s: %s WebSocket connection", client_addr,
+                             self.stype)
+            self.log_message("%s: Version %s, base64: '%s'", client_addr,
+                             self.version, self.base64)
+            if self.path != '/':
+                self.log_message("%s: Path: '%s'", client_addr, self.path)
+
+            if self.record:
+                # Record raw frame data as JavaScript array
+                fname = "%s.%s" % (self.record,
+                                   self.handler_id)
+                self.log_message("opening record file: %s", fname)
+                self.rec = open(fname, 'w+')
+                encoding = "binary"
+                if self.base64: encoding = "base64"
+                self.rec.write("var VNC_frame_encoding = '%s';\n"
+                               % encoding)
+                self.rec.write("var VNC_frame_data = [\n")
+
+            try:
+                self.new_websocket_client()
+            except self.CClose:
+                # Close the client
+                _, exc, _ = sys.exc_info()
+                self.send_close(exc.args[0], exc.args[1])
+            return True
+        else:
+            return False
+
+    def do_GET(self):
+        """Handle GET request. Calls handle_websocket(). If unsuccessful,
+        and web server is enabled, SimpleHTTPRequestHandler.do_GET will be called."""
+        if not self.handle_websocket():
+            if self.only_upgrade:
+                self.send_error(405, "Method Not Allowed")
+            else:
+                SimpleHTTPRequestHandler.do_GET(self)
+
+    def list_directory(self, path):
+        if self.file_only:
+            self.send_error(404, "No such file")
+        else:
+            return SimpleHTTPRequestHandler.list_directory(self, path)
+
+    def new_websocket_client(self):
+        """ Do something with a WebSockets client connection. """
+        raise Exception("WebSocketRequestHandler.new_websocket_client() must be overloaded")
+
+    def do_HEAD(self):
+        if self.only_upgrade:
+            self.send_error(405, "Method Not Allowed")
+        else:
+            SimpleHTTPRequestHandler.do_HEAD(self)
+
+    def finish(self):
+        if self.rec:
+            self.rec.write("'EOF'];\n")
+            self.rec.close()
+
+    def handle(self):
+        # When using run_once, we have a single process, so
+        # we cannot loop in BaseHTTPRequestHandler.handle; we
+        # must return and handle new connections
+        if self.run_once:
+            self.handle_one_request()
+        else:
+            SimpleHTTPRequestHandler.handle(self)
+
+    def log_request(self, code='-', size='-'):
+        if self.verbose:
+            SimpleHTTPRequestHandler.log_request(self, code, size)
+
+
+class WebSocketServer(object):
+    """
+    WebSockets server class.
+    As an alternative, the standard library SocketServer can be used
+    """
+
+    policy_response = """<cross-domain-policy><allow-access-from domain="*" to-ports="*" /></cross-domain-policy>\n"""
+    log_prefix = "websocket"
+
+    # An exception before the WebSocket connection was established
+    class EClose(Exception):
+        pass
+
+    class Terminate(Exception):
+        pass
+
+    def __init__(self, RequestHandlerClass, listen_host='',
+                 listen_port=None, source_is_ipv6=False,
+            verbose=False, cert='', key='', ssl_only=None,
+            daemon=False, record='', web='',
+            file_only=False,
+            run_once=False, timeout=0, idle_timeout=0, traffic=False,
+            tcp_keepalive=True, tcp_keepcnt=None, tcp_keepidle=None,
+            tcp_keepintvl=None):
+
+        # settings
+        self.RequestHandlerClass = RequestHandlerClass
+        self.verbose        = verbose
+        self.listen_host    = listen_host
+        self.listen_port    = listen_port
+        self.prefer_ipv6    = source_is_ipv6
+        self.ssl_only       = ssl_only
+        self.daemon         = daemon
+        self.run_once       = run_once
+        self.timeout        = timeout
+        self.idle_timeout   = idle_timeout
+        self.traffic        = traffic
+
+        self.launch_time    = time.time()
+        self.ws_connection  = False
+        self.handler_id     = 1
+
+        self.logger         = self.get_logger()
+        self.tcp_keepalive  = tcp_keepalive
+        self.tcp_keepcnt    = tcp_keepcnt
+        self.tcp_keepidle   = tcp_keepidle
+        self.tcp_keepintvl  = tcp_keepintvl
+
+        # Make paths settings absolute
+        self.cert = os.path.abspath(cert)
+        self.key = self.web = self.record = ''
+        if key:
+            self.key = os.path.abspath(key)
+        if web:
+            self.web = os.path.abspath(web)
+        if record:
+            self.record = os.path.abspath(record)
+
+        if self.web:
+            os.chdir(self.web)
+        self.only_upgrade = not self.web
+
+        # Sanity checks
+        if not ssl and self.ssl_only:
+            raise Exception("No 'ssl' module and SSL-only specified")
+        if self.daemon and not resource:
+            raise Exception("Module 'resource' required to daemonize")
+
+        # Show configuration
+        self.msg("WebSocket server settings:")
+        self.msg("  - Listen on %s:%s",
+                self.listen_host, self.listen_port)
+        self.msg("  - Flash security policy server")
+        if self.web:
+            self.msg("  - Web server. Web root: %s", self.web)
+        if ssl:
+            if os.path.exists(self.cert):
+                self.msg("  - SSL/TLS support")
+                if self.ssl_only:
+                    self.msg("  - Deny non-SSL/TLS connections")
+            else:
+                self.msg("  - No SSL/TLS support (no cert file)")
+        else:
+            self.msg("  - No SSL/TLS support (no 'ssl' module)")
+        if self.daemon:
+            self.msg("  - Backgrounding (daemon)")
+        if self.record:
+            self.msg("  - Recording to '%s.*'", self.record)
+
+    #
+    # WebSocketServer static methods
+    #
+
+    @staticmethod
+    def get_logger():
+        return logging.getLogger("%s.%s" % (
+            WebSocketServer.log_prefix,
+            WebSocketServer.__class__.__name__))
+
+    @staticmethod
+    def socket(host, port=None, connect=False, prefer_ipv6=False,
+               unix_socket=None, use_ssl=False, tcp_keepalive=True,
+               tcp_keepcnt=None, tcp_keepidle=None, tcp_keepintvl=None):
+        """ Resolve a host (and optional port) to an IPv4 or IPv6
+        address. Create a socket. Bind to it if listen is set,
+        otherwise connect to it. Return the socket.
+        """
+        flags = 0
+        if host == '':
+            host = None
+        if connect and not (port or unix_socket):
+            raise Exception("Connect mode requires a port")
+        if use_ssl and not ssl:
+            raise Exception("SSL socket requested but Python SSL module not loaded.");
+        if not connect and use_ssl:
+            raise Exception("SSL only supported in connect mode (for now)")
+        if not connect:
+            flags = flags | socket.AI_PASSIVE
+
+        if not unix_socket:
+            addrs = socket.getaddrinfo(host, port, 0, socket.SOCK_STREAM,
+                    socket.IPPROTO_TCP, flags)
+            if not addrs:
+                raise Exception("Could not resolve host '%s'" % host)
+            addrs.sort(key=lambda x: x[0])
+            if prefer_ipv6:
+                addrs.reverse()
+            sock = socket.socket(addrs[0][0], addrs[0][1])
+
+            if  tcp_keepalive:
+                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
+                if tcp_keepcnt:
+                    sock.setsockopt(socket.SOL_TCP, socket.TCP_KEEPCNT,
+                                    tcp_keepcnt)
+                if tcp_keepidle:
+                    sock.setsockopt(socket.SOL_TCP, socket.TCP_KEEPIDLE,
+                                    tcp_keepidle)
+                if tcp_keepintvl:
+                    sock.setsockopt(socket.SOL_TCP, socket.TCP_KEEPINTVL,
+                                    tcp_keepintvl)
+
+            if connect:
+                sock.connect(addrs[0][4])
+                if use_ssl:
+                    sock = ssl.wrap_socket(sock)
+            else:
+                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+                sock.bind(addrs[0][4])
+                sock.listen(100)
+        else:
+            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
+            sock.connect(unix_socket)
+
+        return sock
+
+    @staticmethod
+    def daemonize(keepfd=None, chdir='/'):
+        os.umask(0)
+        if chdir:
+            os.chdir(chdir)
+        else:
+            os.chdir('/')
+        os.setgid(os.getgid())  # relinquish elevations
+        os.setuid(os.getuid())  # relinquish elevations
+
+        # Double fork to daemonize
+        if os.fork() > 0: os._exit(0)  # Parent exits
+        os.setsid()                    # Obtain new process group
+        if os.fork() > 0: os._exit(0)  # Parent exits
+
+        # Signal handling
+        signal.signal(signal.SIGTERM, signal.SIG_IGN)
+        signal.signal(signal.SIGINT, signal.SIG_IGN)
+
+        # Close open files
+        maxfd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
+        if maxfd == resource.RLIM_INFINITY: maxfd = 256
+        for fd in reversed(range(maxfd)):
+            try:
+                if fd != keepfd:
+                    os.close(fd)
+            except OSError:
+                _, exc, _ = sys.exc_info()
+                if exc.errno != errno.EBADF: raise
+
+        # Redirect I/O to /dev/null
+        os.dup2(os.open(os.devnull, os.O_RDWR), sys.stdin.fileno())
+        os.dup2(os.open(os.devnull, os.O_RDWR), sys.stdout.fileno())
+        os.dup2(os.open(os.devnull, os.O_RDWR), sys.stderr.fileno())
+
+    def do_handshake(self, sock, address):
+        """
+        do_handshake does the following:
+        - Peek at the first few bytes from the socket.
+        - If the connection is Flash policy request then answer it,
+          close the socket and return.
+        - If the connection is an HTTPS/SSL/TLS connection then SSL
+          wrap the socket.
+        - Read from the (possibly wrapped) socket.
+        - If we have received a HTTP GET request and the webserver
+          functionality is enabled, answer it, close the socket and
+          return.
+        - Assume we have a WebSockets connection, parse the client
+          handshake data.
+        - Send a WebSockets handshake server response.
+        - Return the socket for this WebSocket client.
+        """
+        ready = select.select([sock], [], [], 3)[0]
+
+        
+        if not ready:
+            raise self.EClose("ignoring socket not ready")
+        # Peek, but do not read the data so that we have a opportunity
+        # to SSL wrap the socket first
+        handshake = sock.recv(1024, socket.MSG_PEEK)
+        #self.msg("Handshake [%s]" % handshake)
+
+        if handshake == "":
+            raise self.EClose("ignoring empty handshake")
+
+        elif handshake.startswith(s2b("<policy-file-request/>")):
+            # Answer Flash policy request
+            handshake = sock.recv(1024)
+            sock.send(s2b(self.policy_response))
+            raise self.EClose("Sending flash policy response")
+
+        elif handshake[0] in ("\x16", "\x80", 22, 128):
+            # SSL wrap the connection
+            if not ssl:
+                raise self.EClose("SSL connection but no 'ssl' module")
+            if not os.path.exists(self.cert):
+                raise self.EClose("SSL connection but '%s' not found"
+                                  % self.cert)
+            retsock = None
+            try:
+                retsock = ssl.wrap_socket(
+                        sock,
+                        server_side=True,
+                        certfile=self.cert,
+                        keyfile=self.key)
+            except ssl.SSLError:
+                _, x, _ = sys.exc_info()
+                if x.args[0] == ssl.SSL_ERROR_EOF:
+                    if len(x.args) > 1:
+                        raise self.EClose(x.args[1])
+                    else:
+                        raise self.EClose("Got SSL_ERROR_EOF")
+                else:
+                    raise
+
+        elif self.ssl_only:
+            raise self.EClose("non-SSL connection received but disallowed")
+
+        else:
+            retsock = sock
+
+        # If the address is like (host, port), we are extending it
+        # with a flag indicating SSL. Not many other options
+        # available...
+        if len(address) == 2:
+            address = (address[0], address[1], (retsock != sock))
+
+        self.RequestHandlerClass(retsock, address, self)
+
+        # Return the WebSockets socket which may be SSL wrapped
+        return retsock
+
+    #
+    # WebSocketServer logging/output functions
+    #
+
+    def msg(self, *args, **kwargs):
+        """ Output message as info """
+        self.logger.log(logging.INFO, *args, **kwargs)
+
+    def vmsg(self, *args, **kwargs):
+        """ Same as msg() but as debug. """
+        self.logger.log(logging.DEBUG, *args, **kwargs)
+
+    def warn(self, *args, **kwargs):
+        """ Same as msg() but as warning. """
+        self.logger.log(logging.WARN, *args, **kwargs)
+
+
+    #
+    # Events that can/should be overridden in sub-classes
+    #
+    def started(self):
+        """ Called after WebSockets startup """
+        self.vmsg("WebSockets server started")
+
+    def poll(self):
+        """ Run periodically while waiting for connections. """
+        #self.vmsg("Running poll()")
+        pass
+
+    def terminate(self):
+        raise self.Terminate()
+
+    def multiprocessing_SIGCHLD(self, sig, stack):
+        self.vmsg('Reaing zombies, active child count is %s', len(multiprocessing.active_children()))
+
+    def fallback_SIGCHLD(self, sig, stack):
+        # Reap zombies when using os.fork() (python 2.4)
+        self.vmsg("Got SIGCHLD, reaping zombies")
+        try:
+            result = os.waitpid(-1, os.WNOHANG)
+            while result[0]:
+                self.vmsg("Reaped child process %s" % result[0])
+                result = os.waitpid(-1, os.WNOHANG)
+        except (OSError):
+            pass
+
+    def do_SIGINT(self, sig, stack):
+        self.msg("Got SIGINT, exiting")
+        self.terminate()
+
+    def do_SIGTERM(self, sig, stack):
+        self.msg("Got SIGTERM, exiting")
+        self.terminate()
+
+    def top_new_client(self, startsock, address):
+        """ Do something with a WebSockets client connection. """
+        # handler process        
+        client = None
+        try:
+            try:
+                client = self.do_handshake(startsock, address)
+            except self.EClose:
+                _, exc, _ = sys.exc_info()
+                # Connection was not a WebSockets connection
+                if exc.args[0]:
+                    self.msg("%s: %s" % (address[0], exc.args[0]))
+            except WebSocketServer.Terminate:
+                raise
+            except Exception:
+                _, exc, _ = sys.exc_info()
+                self.msg("handler exception: %s" % str(exc))
+                self.vmsg("exception", exc_info=True)
+        finally:
+
+            if client and client != startsock:
+                # Close the SSL wrapped socket
+                # Original socket closed by caller
+                client.close()
+
+    def start_server(self):
+        """
+        Daemonize if requested. Listen for for connections. Run
+        do_handshake() method for each connection. If the connection
+        is a WebSockets client then call new_websocket_client() method (which must
+        be overridden) for each new client connection.
+        """
+        lsock = self.socket(self.listen_host, self.listen_port, False,
+                            self.prefer_ipv6,
+                            tcp_keepalive=self.tcp_keepalive,
+                            tcp_keepcnt=self.tcp_keepcnt,
+                            tcp_keepidle=self.tcp_keepidle,
+                            tcp_keepintvl=self.tcp_keepintvl)
+
+        if self.daemon:
+            self.daemonize(keepfd=lsock.fileno(), chdir=self.web)
+
+        self.started()  # Some things need to happen after daemonizing
+
+        # Allow override of signals
+        original_signals = {
+            signal.SIGINT: signal.getsignal(signal.SIGINT),
+            signal.SIGTERM: signal.getsignal(signal.SIGTERM),
+            signal.SIGCHLD: signal.getsignal(signal.SIGCHLD),
+        }
+        signal.signal(signal.SIGINT, self.do_SIGINT)
+        signal.signal(signal.SIGTERM, self.do_SIGTERM)
+        if not multiprocessing:
+            # os.fork() (python 2.4) child reaper
+            signal.signal(signal.SIGCHLD, self.fallback_SIGCHLD)
+        else:
+            # make sure that _cleanup is called when children die
+            # by calling active_children on SIGCHLD
+            signal.signal(signal.SIGCHLD, self.multiprocessing_SIGCHLD)
+
+        last_active_time = self.launch_time
+        try:
+            while True:
+                try:
+                    try:
+                        startsock = None
+                        pid = err = 0
+                        child_count = 0
+
+                        if multiprocessing:
+                            # Collect zombie child processes
+                            child_count = len(multiprocessing.active_children())
+
+                        time_elapsed = time.time() - self.launch_time
+                        if self.timeout and time_elapsed > self.timeout:
+                            self.msg('listener exit due to --timeout %s'
+                                    % self.timeout)
+                            break
+
+                        if self.idle_timeout:
+                            idle_time = 0
+                            if child_count == 0:
+                                idle_time = time.time() - last_active_time
+                            else:
+                                idle_time = 0
+                                last_active_time = time.time()
+
+                            if idle_time > self.idle_timeout and child_count == 0:
+                                self.msg('listener exit due to --idle-timeout %s'
+                                            % self.idle_timeout)
+                                break
+
+                        try:
+                            self.poll()
+
+                            ready = select.select([lsock], [], [], 1)[0]
+                            if lsock in ready:
+                                startsock, address = lsock.accept()
+                            else:
+                                continue
+                        except self.Terminate:
+                            raise
+                        except Exception:
+                            _, exc, _ = sys.exc_info()
+                            if hasattr(exc, 'errno'):
+                                err = exc.errno
+                            elif hasattr(exc, 'args'):
+                                err = exc.args[0]
+                            else:
+                                err = exc[0]
+                            if err == errno.EINTR:
+                                self.vmsg("Ignoring interrupted syscall")
+                                continue
+                            else:
+                                raise
+
+                        if self.run_once:
+                            # Run in same process if run_once
+                            self.top_new_client(startsock, address)
+                            if self.ws_connection :
+                                self.msg('%s: exiting due to --run-once'
+                                        % address[0])
+                                break
+                        elif multiprocessing:
+                            self.vmsg('%s: new handler Process' % address[0])
+                            p = multiprocessing.Process(
+                                    target=self.top_new_client,
+                                    args=(startsock, address))
+                            p.start()
+                            # child will not return
+                        else:
+                            # python 2.4
+                            self.vmsg('%s: forking handler' % address[0])
+                            pid = os.fork()
+                            if pid == 0:
+                                # child handler process
+                                self.top_new_client(startsock, address)
+                                break  # child process exits
+
+                        # parent process
+                        self.handler_id += 1
+
+                    except (self.Terminate, SystemExit, KeyboardInterrupt):
+                        self.msg("In exit")
+                        break
+                    except Exception:
+                        self.msg("handler exception: %s", str(exc))
+                        self.vmsg("exception", exc_info=True)
+
+                finally:
+                    if startsock:
+                        startsock.close()
+        finally:
+            # Close listen port
+            self.vmsg("Closing socket listening at %s:%s",
+                      self.listen_host, self.listen_port)
+            lsock.close()
+
+            # Restore signals
+            for sig, func in original_signals.items():
+                signal.signal(sig, func)
+
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/websockify.py
@@ -0,0 +1 @@
+websockify
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/utils/wsproxy.py
@@ -0,0 +1 @@
+websockify
\ No newline at end of file
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/vendor/pako/LICENSE
@@ -0,0 +1,21 @@
+(The MIT License)
+
+Copyright (C) 2014-2016 by Vitaly Puzrin
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/vendor/pako/README.md
@@ -0,0 +1,6 @@
+This is an ES6-modules-compatible version of
+https://github.com/nodeca/pako, based on pako version 1.0.3.
+
+It's more-or-less a direct translation of the original, with unused parts
+removed, and the dynamic support for non-typed arrays removed (since ES6
+modules don't work well with dynamic exports).
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/vendor/pako/lib/utils/common.js
@@ -0,0 +1,45 @@
+// reduce buffer size, avoiding mem copy
+export function shrinkBuf (buf, size) {
+  if (buf.length === size) { return buf; }
+  if (buf.subarray) { return buf.subarray(0, size); }
+  buf.length = size;
+  return buf;
+};
+
+
+export function arraySet (dest, src, src_offs, len, dest_offs) {
+  if (src.subarray && dest.subarray) {
+    dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
+    return;
+  }
+  // Fallback to ordinary array
+  for (var i = 0; i < len; i++) {
+    dest[dest_offs + i] = src[src_offs + i];
+  }
+}
+
+// Join array of chunks to single array.
+export function flattenChunks (chunks) {
+  var i, l, len, pos, chunk, result;
+
+  // calculate data length
+  len = 0;
+  for (i = 0, l = chunks.length; i < l; i++) {
+    len += chunks[i].length;
+  }
+
+  // join chunks
+  result = new Uint8Array(len);
+  pos = 0;
+  for (i = 0, l = chunks.length; i < l; i++) {
+    chunk = chunks[i];
+    result.set(chunk, pos);
+    pos += chunk.length;
+  }
+
+  return result;
+}
+
+export var Buf8  = Uint8Array;
+export var Buf16 = Uint16Array;
+export var Buf32 = Int32Array;
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/vendor/pako/lib/zlib/adler32.js
@@ -0,0 +1,27 @@
+// Note: adler32 takes 12% for level 0 and 2% for level 6.
+// It doesn't worth to make additional optimizationa as in original.
+// Small size is preferable.
+
+export default function adler32(adler, buf, len, pos) {
+  var s1 = (adler & 0xffff) |0,
+      s2 = ((adler >>> 16) & 0xffff) |0,
+      n = 0;
+
+  while (len !== 0) {
+    // Set limit ~ twice less than 5552, to keep
+    // s2 in 31-bits, because we force signed ints.
+    // in other case %= will fail.
+    n = len > 2000 ? 2000 : len;
+    len -= n;
+
+    do {
+      s1 = (s1 + buf[pos++]) |0;
+      s2 = (s2 + s1) |0;
+    } while (--n);
+
+    s1 %= 65521;
+    s2 %= 65521;
+  }
+
+  return (s1 | (s2 << 16)) |0;
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/vendor/pako/lib/zlib/constants.js
@@ -0,0 +1,47 @@
+export default {
+
+  /* Allowed flush values; see deflate() and inflate() below for details */
+  Z_NO_FLUSH:         0,
+  Z_PARTIAL_FLUSH:    1,
+  Z_SYNC_FLUSH:       2,
+  Z_FULL_FLUSH:       3,
+  Z_FINISH:           4,
+  Z_BLOCK:            5,
+  Z_TREES:            6,
+
+  /* Return codes for the compression/decompression functions. Negative values
+  * are errors, positive values are used for special but normal events.
+  */
+  Z_OK:               0,
+  Z_STREAM_END:       1,
+  Z_NEED_DICT:        2,
+  Z_ERRNO:           -1,
+  Z_STREAM_ERROR:    -2,
+  Z_DATA_ERROR:      -3,
+  //Z_MEM_ERROR:     -4,
+  Z_BUF_ERROR:       -5,
+  //Z_VERSION_ERROR: -6,
+
+  /* compression levels */
+  Z_NO_COMPRESSION:         0,
+  Z_BEST_SPEED:             1,
+  Z_BEST_COMPRESSION:       9,
+  Z_DEFAULT_COMPRESSION:   -1,
+
+
+  Z_FILTERED:               1,
+  Z_HUFFMAN_ONLY:           2,
+  Z_RLE:                    3,
+  Z_FIXED:                  4,
+  Z_DEFAULT_STRATEGY:       0,
+
+  /* Possible values of the data_type field (though see inflate()) */
+  Z_BINARY:                 0,
+  Z_TEXT:                   1,
+  //Z_ASCII:                1, // = Z_TEXT (deprecated)
+  Z_UNKNOWN:                2,
+
+  /* The deflate compression method */
+  Z_DEFLATED:               8
+  //Z_NULL:                 null // Use -1 or null inline, depending on var type
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/vendor/pako/lib/zlib/crc32.js
@@ -0,0 +1,36 @@
+// Note: we can't get significant speed boost here.
+// So write code to minimize size - no pregenerated tables
+// and array tools dependencies.
+
+
+// Use ordinary array, since untyped makes no boost here
+export default function makeTable() {
+  var c, table = [];
+
+  for (var n = 0; n < 256; n++) {
+    c = n;
+    for (var k = 0; k < 8; k++) {
+      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
+    }
+    table[n] = c;
+  }
+
+  return table;
+}
+
+// Create table on load. Just 255 signed longs. Not a problem.
+var crcTable = makeTable();
+
+
+function crc32(crc, buf, len, pos) {
+  var t = crcTable,
+      end = pos + len;
+
+  crc ^= -1;
+
+  for (var i = pos; i < end; i++) {
+    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
+  }
+
+  return (crc ^ (-1)); // >>> 0;
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/vendor/pako/lib/zlib/deflate.js
@@ -0,0 +1,1846 @@
+import * as utils from "../utils/common.js";
+import * as trees from "./trees.js";
+import adler32 from "./adler32.js";
+import crc32 from "./crc32.js";
+import msg from "./messages.js";
+
+/* Public constants ==========================================================*/
+/* ===========================================================================*/
+
+
+/* Allowed flush values; see deflate() and inflate() below for details */
+export const Z_NO_FLUSH      = 0;
+export const Z_PARTIAL_FLUSH = 1;
+//export const Z_SYNC_FLUSH    = 2;
+export const Z_FULL_FLUSH    = 3;
+export const Z_FINISH        = 4;
+export const Z_BLOCK         = 5;
+//export const Z_TREES         = 6;
+
+
+/* Return codes for the compression/decompression functions. Negative values
+ * are errors, positive values are used for special but normal events.
+ */
+export const Z_OK            = 0;
+export const Z_STREAM_END    = 1;
+//export const Z_NEED_DICT     = 2;
+//export const Z_ERRNO         = -1;
+export const Z_STREAM_ERROR  = -2;
+export const Z_DATA_ERROR    = -3;
+//export const Z_MEM_ERROR     = -4;
+export const Z_BUF_ERROR     = -5;
+//export const Z_VERSION_ERROR = -6;
+
+
+/* compression levels */
+//export const Z_NO_COMPRESSION      = 0;
+//export const Z_BEST_SPEED          = 1;
+//export const Z_BEST_COMPRESSION    = 9;
+export const Z_DEFAULT_COMPRESSION = -1;
+
+
+export const Z_FILTERED            = 1;
+export const Z_HUFFMAN_ONLY        = 2;
+export const Z_RLE                 = 3;
+export const Z_FIXED               = 4;
+export const Z_DEFAULT_STRATEGY    = 0;
+
+/* Possible values of the data_type field (though see inflate()) */
+//export const Z_BINARY              = 0;
+//export const Z_TEXT                = 1;
+//export const Z_ASCII               = 1; // = Z_TEXT
+export const Z_UNKNOWN             = 2;
+
+
+/* The deflate compression method */
+export const Z_DEFLATED  = 8;
+
+/*============================================================================*/
+
+
+var MAX_MEM_LEVEL = 9;
+/* Maximum value for memLevel in deflateInit2 */
+var MAX_WBITS = 15;
+/* 32K LZ77 window */
+var DEF_MEM_LEVEL = 8;
+
+
+var LENGTH_CODES  = 29;
+/* number of length codes, not counting the special END_BLOCK code */
+var LITERALS      = 256;
+/* number of literal bytes 0..255 */
+var L_CODES       = LITERALS + 1 + LENGTH_CODES;
+/* number of Literal or Length codes, including the END_BLOCK code */
+var D_CODES       = 30;
+/* number of distance codes */
+var BL_CODES      = 19;
+/* number of codes used to transfer the bit lengths */
+var HEAP_SIZE     = 2 * L_CODES + 1;
+/* maximum heap size */
+var MAX_BITS  = 15;
+/* All codes must not exceed MAX_BITS bits */
+
+var MIN_MATCH = 3;
+var MAX_MATCH = 258;
+var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);
+
+var PRESET_DICT = 0x20;
+
+var INIT_STATE = 42;
+var EXTRA_STATE = 69;
+var NAME_STATE = 73;
+var COMMENT_STATE = 91;
+var HCRC_STATE = 103;
+var BUSY_STATE = 113;
+var FINISH_STATE = 666;
+
+var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
+var BS_BLOCK_DONE     = 2; /* block flush performed */
+var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
+var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */
+
+var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.
+
+function err(strm, errorCode) {
+  strm.msg = msg[errorCode];
+  return errorCode;
+}
+
+function rank(f) {
+  return ((f) << 1) - ((f) > 4 ? 9 : 0);
+}
+
+function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }
+
+
+/* =========================================================================
+ * Flush as much pending output as possible. All deflate() output goes
+ * through this function so some applications may wish to modify it
+ * to avoid allocating a large strm->output buffer and copying into it.
+ * (See also read_buf()).
+ */
+function flush_pending(strm) {
+  var s = strm.state;
+
+  //_tr_flush_bits(s);
+  var len = s.pending;
+  if (len > strm.avail_out) {
+    len = strm.avail_out;
+  }
+  if (len === 0) { return; }
+
+  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
+  strm.next_out += len;
+  s.pending_out += len;
+  strm.total_out += len;
+  strm.avail_out -= len;
+  s.pending -= len;
+  if (s.pending === 0) {
+    s.pending_out = 0;
+  }
+}
+
+
+function flush_block_only(s, last) {
+  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
+  s.block_start = s.strstart;
+  flush_pending(s.strm);
+}
+
+
+function put_byte(s, b) {
+  s.pending_buf[s.pending++] = b;
+}
+
+
+/* =========================================================================
+ * Put a short in the pending buffer. The 16-bit value is put in MSB order.
+ * IN assertion: the stream state is correct and there is enough room in
+ * pending_buf.
+ */
+function putShortMSB(s, b) {
+//  put_byte(s, (Byte)(b >> 8));
+//  put_byte(s, (Byte)(b & 0xff));
+  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
+  s.pending_buf[s.pending++] = b & 0xff;
+}
+
+
+/* ===========================================================================
+ * Read a new buffer from the current input stream, update the adler32
+ * and total number of bytes read.  All deflate() input goes through
+ * this function so some applications may wish to modify it to avoid
+ * allocating a large strm->input buffer and copying from it.
+ * (See also flush_pending()).
+ */
+function read_buf(strm, buf, start, size) {
+  var len = strm.avail_in;
+
+  if (len > size) { len = size; }
+  if (len === 0) { return 0; }
+
+  strm.avail_in -= len;
+
+  // zmemcpy(buf, strm->next_in, len);
+  utils.arraySet(buf, strm.input, strm.next_in, len, start);
+  if (strm.state.wrap === 1) {
+    strm.adler = adler32(strm.adler, buf, len, start);
+  }
+
+  else if (strm.state.wrap === 2) {
+    strm.adler = crc32(strm.adler, buf, len, start);
+  }
+
+  strm.next_in += len;
+  strm.total_in += len;
+
+  return len;
+}
+
+
+/* ===========================================================================
+ * Set match_start to the longest match starting at the given string and
+ * return its length. Matches shorter or equal to prev_length are discarded,
+ * in which case the result is equal to prev_length and match_start is
+ * garbage.
+ * IN assertions: cur_match is the head of the hash chain for the current
+ *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
+ * OUT assertion: the match length is not greater than s->lookahead.
+ */
+function longest_match(s, cur_match) {
+  var chain_length = s.max_chain_length;      /* max hash chain length */
+  var scan = s.strstart; /* current string */
+  var match;                       /* matched string */
+  var len;                           /* length of current match */
+  var best_len = s.prev_length;              /* best match length so far */
+  var nice_match = s.nice_match;             /* stop if match long enough */
+  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
+      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;
+
+  var _win = s.window; // shortcut
+
+  var wmask = s.w_mask;
+  var prev  = s.prev;
+
+  /* Stop when cur_match becomes <= limit. To simplify the code,
+   * we prevent matches with the string of window index 0.
+   */
+
+  var strend = s.strstart + MAX_MATCH;
+  var scan_end1  = _win[scan + best_len - 1];
+  var scan_end   = _win[scan + best_len];
+
+  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
+   * It is easy to get rid of this optimization if necessary.
+   */
+  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
+
+  /* Do not waste too much time if we already have a good match: */
+  if (s.prev_length >= s.good_match) {
+    chain_length >>= 2;
+  }
+  /* Do not look for matches beyond the end of the input. This is necessary
+   * to make deflate deterministic.
+   */
+  if (nice_match > s.lookahead) { nice_match = s.lookahead; }
+
+  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
+
+  do {
+    // Assert(cur_match < s->strstart, "no future");
+    match = cur_match;
+
+    /* Skip to next match if the match length cannot increase
+     * or if the match length is less than 2.  Note that the checks below
+     * for insufficient lookahead only occur occasionally for performance
+     * reasons.  Therefore uninitialized memory will be accessed, and
+     * conditional jumps will be made that depend on those values.
+     * However the length of the match is limited to the lookahead, so
+     * the output of deflate is not affected by the uninitialized values.
+     */
+
+    if (_win[match + best_len]     !== scan_end  ||
+        _win[match + best_len - 1] !== scan_end1 ||
+        _win[match]                !== _win[scan] ||
+        _win[++match]              !== _win[scan + 1]) {
+      continue;
+    }
+
+    /* The check at best_len-1 can be removed because it will be made
+     * again later. (This heuristic is not always a win.)
+     * It is not necessary to compare scan[2] and match[2] since they
+     * are always equal when the other bytes match, given that
+     * the hash keys are equal and that HASH_BITS >= 8.
+     */
+    scan += 2;
+    match++;
+    // Assert(*scan == *match, "match[2]?");
+
+    /* We check for insufficient lookahead only every 8th comparison;
+     * the 256th check will be made at strstart+258.
+     */
+    do {
+      // Do nothing
+    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
+             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
+             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
+             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
+             scan < strend);
+
+    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+
+    len = MAX_MATCH - (strend - scan);
+    scan = strend - MAX_MATCH;
+
+    if (len > best_len) {
+      s.match_start = cur_match;
+      best_len = len;
+      if (len >= nice_match) {
+        break;
+      }
+      scan_end1  = _win[scan + best_len - 1];
+      scan_end   = _win[scan + best_len];
+    }
+  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
+
+  if (best_len <= s.lookahead) {
+    return best_len;
+  }
+  return s.lookahead;
+}
+
+
+/* ===========================================================================
+ * Fill the window when the lookahead becomes insufficient.
+ * Updates strstart and lookahead.
+ *
+ * IN assertion: lookahead < MIN_LOOKAHEAD
+ * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
+ *    At least one byte has been read, or avail_in == 0; reads are
+ *    performed for at least two bytes (required for the zip translate_eol
+ *    option -- not supported here).
+ */
+function fill_window(s) {
+  var _w_size = s.w_size;
+  var p, n, m, more, str;
+
+  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
+
+  do {
+    more = s.window_size - s.lookahead - s.strstart;
+
+    // JS ints have 32 bit, block below not needed
+    /* Deal with !@#$% 64K limit: */
+    //if (sizeof(int) <= 2) {
+    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
+    //        more = wsize;
+    //
+    //  } else if (more == (unsigned)(-1)) {
+    //        /* Very unlikely, but possible on 16 bit machine if
+    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
+    //         */
+    //        more--;
+    //    }
+    //}
+
+
+    /* If the window is almost full and there is insufficient lookahead,
+     * move the upper half to the lower one to make room in the upper half.
+     */
+    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
+
+      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
+      s.match_start -= _w_size;
+      s.strstart -= _w_size;
+      /* we now have strstart >= MAX_DIST */
+      s.block_start -= _w_size;
+
+      /* Slide the hash table (could be avoided with 32 bit values
+       at the expense of memory usage). We slide even when level == 0
+       to keep the hash table consistent if we switch back to level > 0
+       later. (Using level 0 permanently is not an optimal usage of
+       zlib, so we don't care about this pathological case.)
+       */
+
+      n = s.hash_size;
+      p = n;
+      do {
+        m = s.head[--p];
+        s.head[p] = (m >= _w_size ? m - _w_size : 0);
+      } while (--n);
+
+      n = _w_size;
+      p = n;
+      do {
+        m = s.prev[--p];
+        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
+        /* If n is not on any hash chain, prev[n] is garbage but
+         * its value will never be used.
+         */
+      } while (--n);
+
+      more += _w_size;
+    }
+    if (s.strm.avail_in === 0) {
+      break;
+    }
+
+    /* If there was no sliding:
+     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
+     *    more == window_size - lookahead - strstart
+     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
+     * => more >= window_size - 2*WSIZE + 2
+     * In the BIG_MEM or MMAP case (not yet supported),
+     *   window_size == input_size + MIN_LOOKAHEAD  &&
+     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
+     * Otherwise, window_size == 2*WSIZE so more >= 2.
+     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
+     */
+    //Assert(more >= 2, "more < 2");
+    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
+    s.lookahead += n;
+
+    /* Initialize the hash value now that we have some input: */
+    if (s.lookahead + s.insert >= MIN_MATCH) {
+      str = s.strstart - s.insert;
+      s.ins_h = s.window[str];
+
+      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
+      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
+//#if MIN_MATCH != 3
+//        Call update_hash() MIN_MATCH-3 more times
+//#endif
+      while (s.insert) {
+        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
+        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
+
+        s.prev[str & s.w_mask] = s.head[s.ins_h];
+        s.head[s.ins_h] = str;
+        str++;
+        s.insert--;
+        if (s.lookahead + s.insert < MIN_MATCH) {
+          break;
+        }
+      }
+    }
+    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
+     * but this is not important since only literal bytes will be emitted.
+     */
+
+  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
+
+  /* If the WIN_INIT bytes after the end of the current data have never been
+   * written, then zero those bytes in order to avoid memory check reports of
+   * the use of uninitialized (or uninitialised as Julian writes) bytes by
+   * the longest match routines.  Update the high water mark for the next
+   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
+   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
+   */
+//  if (s.high_water < s.window_size) {
+//    var curr = s.strstart + s.lookahead;
+//    var init = 0;
+//
+//    if (s.high_water < curr) {
+//      /* Previous high water mark below current data -- zero WIN_INIT
+//       * bytes or up to end of window, whichever is less.
+//       */
+//      init = s.window_size - curr;
+//      if (init > WIN_INIT)
+//        init = WIN_INIT;
+//      zmemzero(s->window + curr, (unsigned)init);
+//      s->high_water = curr + init;
+//    }
+//    else if (s->high_water < (ulg)curr + WIN_INIT) {
+//      /* High water mark at or above current data, but below current data
+//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
+//       * to end of window, whichever is less.
+//       */
+//      init = (ulg)curr + WIN_INIT - s->high_water;
+//      if (init > s->window_size - s->high_water)
+//        init = s->window_size - s->high_water;
+//      zmemzero(s->window + s->high_water, (unsigned)init);
+//      s->high_water += init;
+//    }
+//  }
+//
+//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
+//    "not enough room for search");
+}
+
+/* ===========================================================================
+ * Copy without compression as much as possible from the input stream, return
+ * the current block state.
+ * This function does not insert new strings in the dictionary since
+ * uncompressible data is probably not useful. This function is used
+ * only for the level=0 compression option.
+ * NOTE: this function should be optimized to avoid extra copying from
+ * window to pending_buf.
+ */
+function deflate_stored(s, flush) {
+  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
+   * to pending_buf_size, and each stored block has a 5 byte header:
+   */
+  var max_block_size = 0xffff;
+
+  if (max_block_size > s.pending_buf_size - 5) {
+    max_block_size = s.pending_buf_size - 5;
+  }
+
+  /* Copy as much as possible from input to output: */
+  for (;;) {
+    /* Fill the window as much as possible: */
+    if (s.lookahead <= 1) {
+
+      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
+      //  s->block_start >= (long)s->w_size, "slide too late");
+//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
+//        s.block_start >= s.w_size)) {
+//        throw  new Error("slide too late");
+//      }
+
+      fill_window(s);
+      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
+        return BS_NEED_MORE;
+      }
+
+      if (s.lookahead === 0) {
+        break;
+      }
+      /* flush the current block */
+    }
+    //Assert(s->block_start >= 0L, "block gone");
+//    if (s.block_start < 0) throw new Error("block gone");
+
+    s.strstart += s.lookahead;
+    s.lookahead = 0;
+
+    /* Emit a stored block if pending_buf will be full: */
+    var max_start = s.block_start + max_block_size;
+
+    if (s.strstart === 0 || s.strstart >= max_start) {
+      /* strstart == 0 is possible when wraparound on 16-bit machine */
+      s.lookahead = s.strstart - max_start;
+      s.strstart = max_start;
+      /*** FLUSH_BLOCK(s, 0); ***/
+      flush_block_only(s, false);
+      if (s.strm.avail_out === 0) {
+        return BS_NEED_MORE;
+      }
+      /***/
+
+
+    }
+    /* Flush if we may have to slide, otherwise block_start may become
+     * negative and the data will be gone:
+     */
+    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
+      /*** FLUSH_BLOCK(s, 0); ***/
+      flush_block_only(s, false);
+      if (s.strm.avail_out === 0) {
+        return BS_NEED_MORE;
+      }
+      /***/
+    }
+  }
+
+  s.insert = 0;
+
+  if (flush === Z_FINISH) {
+    /*** FLUSH_BLOCK(s, 1); ***/
+    flush_block_only(s, true);
+    if (s.strm.avail_out === 0) {
+      return BS_FINISH_STARTED;
+    }
+    /***/
+    return BS_FINISH_DONE;
+  }
+
+  if (s.strstart > s.block_start) {
+    /*** FLUSH_BLOCK(s, 0); ***/
+    flush_block_only(s, false);
+    if (s.strm.avail_out === 0) {
+      return BS_NEED_MORE;
+    }
+    /***/
+  }
+
+  return BS_NEED_MORE;
+}
+
+/* ===========================================================================
+ * Compress as much as possible from the input stream, return the current
+ * block state.
+ * This function does not perform lazy evaluation of matches and inserts
+ * new strings in the dictionary only for unmatched strings or for short
+ * matches. It is used only for the fast compression options.
+ */
+function deflate_fast(s, flush) {
+  var hash_head;        /* head of the hash chain */
+  var bflush;           /* set if current block must be flushed */
+
+  for (;;) {
+    /* Make sure that we always have enough lookahead, except
+     * at the end of the input file. We need MAX_MATCH bytes
+     * for the next match, plus MIN_MATCH bytes to insert the
+     * string following the next match.
+     */
+    if (s.lookahead < MIN_LOOKAHEAD) {
+      fill_window(s);
+      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
+        return BS_NEED_MORE;
+      }
+      if (s.lookahead === 0) {
+        break; /* flush the current block */
+      }
+    }
+
+    /* Insert the string window[strstart .. strstart+2] in the
+     * dictionary, and set hash_head to the head of the hash chain:
+     */
+    hash_head = 0/*NIL*/;
+    if (s.lookahead >= MIN_MATCH) {
+      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
+      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
+      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
+      s.head[s.ins_h] = s.strstart;
+      /***/
+    }
+
+    /* Find the longest match, discarding those <= prev_length.
+     * At this point we have always match_length < MIN_MATCH
+     */
+    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
+      /* To simplify the code, we prevent matches with the string
+       * of window index 0 (in particular we have to avoid a match
+       * of the string with itself at the start of the input file).
+       */
+      s.match_length = longest_match(s, hash_head);
+      /* longest_match() sets match_start */
+    }
+    if (s.match_length >= MIN_MATCH) {
+      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only
+
+      /*** _tr_tally_dist(s, s.strstart - s.match_start,
+                     s.match_length - MIN_MATCH, bflush); ***/
+      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
+
+      s.lookahead -= s.match_length;
+
+      /* Insert new strings in the hash table only if the match length
+       * is not too large. This saves time but degrades compression.
+       */
+      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
+        s.match_length--; /* string at strstart already in table */
+        do {
+          s.strstart++;
+          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
+          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
+          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
+          s.head[s.ins_h] = s.strstart;
+          /***/
+          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
+           * always MIN_MATCH bytes ahead.
+           */
+        } while (--s.match_length !== 0);
+        s.strstart++;
+      } else
+      {
+        s.strstart += s.match_length;
+        s.match_length = 0;
+        s.ins_h = s.window[s.strstart];
+        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
+        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;
+
+//#if MIN_MATCH != 3
+//                Call UPDATE_HASH() MIN_MATCH-3 more times
+//#endif
+        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
+         * matter since it will be recomputed at next deflate call.
+         */
+      }
+    } else {
+      /* No match, output a literal byte */
+      //Tracevv((stderr,"%c", s.window[s.strstart]));
+      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
+      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
+
+      s.lookahead--;
+      s.strstart++;
+    }
+    if (bflush) {
+      /*** FLUSH_BLOCK(s, 0); ***/
+      flush_block_only(s, false);
+      if (s.strm.avail_out === 0) {
+        return BS_NEED_MORE;
+      }
+      /***/
+    }
+  }
+  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
+  if (flush === Z_FINISH) {
+    /*** FLUSH_BLOCK(s, 1); ***/
+    flush_block_only(s, true);
+    if (s.strm.avail_out === 0) {
+      return BS_FINISH_STARTED;
+    }
+    /***/
+    return BS_FINISH_DONE;
+  }
+  if (s.last_lit) {
+    /*** FLUSH_BLOCK(s, 0); ***/
+    flush_block_only(s, false);
+    if (s.strm.avail_out === 0) {
+      return BS_NEED_MORE;
+    }
+    /***/
+  }
+  return BS_BLOCK_DONE;
+}
+
+/* ===========================================================================
+ * Same as above, but achieves better compression. We use a lazy
+ * evaluation for matches: a match is finally adopted only if there is
+ * no better match at the next window position.
+ */
+function deflate_slow(s, flush) {
+  var hash_head;          /* head of hash chain */
+  var bflush;              /* set if current block must be flushed */
+
+  var max_insert;
+
+  /* Process the input block. */
+  for (;;) {
+    /* Make sure that we always have enough lookahead, except
+     * at the end of the input file. We need MAX_MATCH bytes
+     * for the next match, plus MIN_MATCH bytes to insert the
+     * string following the next match.
+     */
+    if (s.lookahead < MIN_LOOKAHEAD) {
+      fill_window(s);
+      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
+        return BS_NEED_MORE;
+      }
+      if (s.lookahead === 0) { break; } /* flush the current block */
+    }
+
+    /* Insert the string window[strstart .. strstart+2] in the
+     * dictionary, and set hash_head to the head of the hash chain:
+     */
+    hash_head = 0/*NIL*/;
+    if (s.lookahead >= MIN_MATCH) {
+      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
+      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
+      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
+      s.head[s.ins_h] = s.strstart;
+      /***/
+    }
+
+    /* Find the longest match, discarding those <= prev_length.
+     */
+    s.prev_length = s.match_length;
+    s.prev_match = s.match_start;
+    s.match_length = MIN_MATCH - 1;
+
+    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
+        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
+      /* To simplify the code, we prevent matches with the string
+       * of window index 0 (in particular we have to avoid a match
+       * of the string with itself at the start of the input file).
+       */
+      s.match_length = longest_match(s, hash_head);
+      /* longest_match() sets match_start */
+
+      if (s.match_length <= 5 &&
+         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {
+
+        /* If prev_match is also MIN_MATCH, match_start is garbage
+         * but we will ignore the current match anyway.
+         */
+        s.match_length = MIN_MATCH - 1;
+      }
+    }
+    /* If there was a match at the previous step and the current
+     * match is not better, output the previous match:
+     */
+    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
+      max_insert = s.strstart + s.lookahead - MIN_MATCH;
+      /* Do not insert strings in hash table beyond this. */
+
+      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);
+
+      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
+                     s.prev_length - MIN_MATCH, bflush);***/
+      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
+      /* Insert in hash table all strings up to the end of the match.
+       * strstart-1 and strstart are already inserted. If there is not
+       * enough lookahead, the last two strings are not inserted in
+       * the hash table.
+       */
+      s.lookahead -= s.prev_length - 1;
+      s.prev_length -= 2;
+      do {
+        if (++s.strstart <= max_insert) {
+          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
+          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
+          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
+          s.head[s.ins_h] = s.strstart;
+          /***/
+        }
+      } while (--s.prev_length !== 0);
+      s.match_available = 0;
+      s.match_length = MIN_MATCH - 1;
+      s.strstart++;
+
+      if (bflush) {
+        /*** FLUSH_BLOCK(s, 0); ***/
+        flush_block_only(s, false);
+        if (s.strm.avail_out === 0) {
+          return BS_NEED_MORE;
+        }
+        /***/
+      }
+
+    } else if (s.match_available) {
+      /* If there was no match at the previous position, output a
+       * single literal. If there was a match but the current match
+       * is longer, truncate the previous match to a single literal.
+       */
+      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
+      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
+      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
+
+      if (bflush) {
+        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
+        flush_block_only(s, false);
+        /***/
+      }
+      s.strstart++;
+      s.lookahead--;
+      if (s.strm.avail_out === 0) {
+        return BS_NEED_MORE;
+      }
+    } else {
+      /* There is no previous match to compare with, wait for
+       * the next step to decide.
+       */
+      s.match_available = 1;
+      s.strstart++;
+      s.lookahead--;
+    }
+  }
+  //Assert (flush != Z_NO_FLUSH, "no flush?");
+  if (s.match_available) {
+    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
+    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
+    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
+
+    s.match_available = 0;
+  }
+  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
+  if (flush === Z_FINISH) {
+    /*** FLUSH_BLOCK(s, 1); ***/
+    flush_block_only(s, true);
+    if (s.strm.avail_out === 0) {
+      return BS_FINISH_STARTED;
+    }
+    /***/
+    return BS_FINISH_DONE;
+  }
+  if (s.last_lit) {
+    /*** FLUSH_BLOCK(s, 0); ***/
+    flush_block_only(s, false);
+    if (s.strm.avail_out === 0) {
+      return BS_NEED_MORE;
+    }
+    /***/
+  }
+
+  return BS_BLOCK_DONE;
+}
+
+
+/* ===========================================================================
+ * For Z_RLE, simply look for runs of bytes, generate matches only of distance
+ * one.  Do not maintain a hash table.  (It will be regenerated if this run of
+ * deflate switches away from Z_RLE.)
+ */
+function deflate_rle(s, flush) {
+  var bflush;            /* set if current block must be flushed */
+  var prev;              /* byte at distance one to match */
+  var scan, strend;      /* scan goes up to strend for length of run */
+
+  var _win = s.window;
+
+  for (;;) {
+    /* Make sure that we always have enough lookahead, except
+     * at the end of the input file. We need MAX_MATCH bytes
+     * for the longest run, plus one for the unrolled loop.
+     */
+    if (s.lookahead <= MAX_MATCH) {
+      fill_window(s);
+      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
+        return BS_NEED_MORE;
+      }
+      if (s.lookahead === 0) { break; } /* flush the current block */
+    }
+
+    /* See how many times the previous byte repeats */
+    s.match_length = 0;
+    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
+      scan = s.strstart - 1;
+      prev = _win[scan];
+      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
+        strend = s.strstart + MAX_MATCH;
+        do {
+          // Do nothing
+        } while (prev === _win[++scan] && prev === _win[++scan] &&
+                 prev === _win[++scan] && prev === _win[++scan] &&
+                 prev === _win[++scan] && prev === _win[++scan] &&
+                 prev === _win[++scan] && prev === _win[++scan] &&
+                 scan < strend);
+        s.match_length = MAX_MATCH - (strend - scan);
+        if (s.match_length > s.lookahead) {
+          s.match_length = s.lookahead;
+        }
+      }
+      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
+    }
+
+    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
+    if (s.match_length >= MIN_MATCH) {
+      //check_match(s, s.strstart, s.strstart - 1, s.match_length);
+
+      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
+      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
+
+      s.lookahead -= s.match_length;
+      s.strstart += s.match_length;
+      s.match_length = 0;
+    } else {
+      /* No match, output a literal byte */
+      //Tracevv((stderr,"%c", s->window[s->strstart]));
+      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
+      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
+
+      s.lookahead--;
+      s.strstart++;
+    }
+    if (bflush) {
+      /*** FLUSH_BLOCK(s, 0); ***/
+      flush_block_only(s, false);
+      if (s.strm.avail_out === 0) {
+        return BS_NEED_MORE;
+      }
+      /***/
+    }
+  }
+  s.insert = 0;
+  if (flush === Z_FINISH) {
+    /*** FLUSH_BLOCK(s, 1); ***/
+    flush_block_only(s, true);
+    if (s.strm.avail_out === 0) {
+      return BS_FINISH_STARTED;
+    }
+    /***/
+    return BS_FINISH_DONE;
+  }
+  if (s.last_lit) {
+    /*** FLUSH_BLOCK(s, 0); ***/
+    flush_block_only(s, false);
+    if (s.strm.avail_out === 0) {
+      return BS_NEED_MORE;
+    }
+    /***/
+  }
+  return BS_BLOCK_DONE;
+}
+
+/* ===========================================================================
+ * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
+ * (It will be regenerated if this run of deflate switches away from Huffman.)
+ */
+function deflate_huff(s, flush) {
+  var bflush;             /* set if current block must be flushed */
+
+  for (;;) {
+    /* Make sure that we have a literal to write. */
+    if (s.lookahead === 0) {
+      fill_window(s);
+      if (s.lookahead === 0) {
+        if (flush === Z_NO_FLUSH) {
+          return BS_NEED_MORE;
+        }
+        break;      /* flush the current block */
+      }
+    }
+
+    /* Output a literal byte */
+    s.match_length = 0;
+    //Tracevv((stderr,"%c", s->window[s->strstart]));
+    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
+    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
+    s.lookahead--;
+    s.strstart++;
+    if (bflush) {
+      /*** FLUSH_BLOCK(s, 0); ***/
+      flush_block_only(s, false);
+      if (s.strm.avail_out === 0) {
+        return BS_NEED_MORE;
+      }
+      /***/
+    }
+  }
+  s.insert = 0;
+  if (flush === Z_FINISH) {
+    /*** FLUSH_BLOCK(s, 1); ***/
+    flush_block_only(s, true);
+    if (s.strm.avail_out === 0) {
+      return BS_FINISH_STARTED;
+    }
+    /***/
+    return BS_FINISH_DONE;
+  }
+  if (s.last_lit) {
+    /*** FLUSH_BLOCK(s, 0); ***/
+    flush_block_only(s, false);
+    if (s.strm.avail_out === 0) {
+      return BS_NEED_MORE;
+    }
+    /***/
+  }
+  return BS_BLOCK_DONE;
+}
+
+/* Values for max_lazy_match, good_match and max_chain_length, depending on
+ * the desired pack level (0..9). The values given below have been tuned to
+ * exclude worst case performance for pathological files. Better values may be
+ * found for specific files.
+ */
+function Config(good_length, max_lazy, nice_length, max_chain, func) {
+  this.good_length = good_length;
+  this.max_lazy = max_lazy;
+  this.nice_length = nice_length;
+  this.max_chain = max_chain;
+  this.func = func;
+}
+
+var configuration_table;
+
+configuration_table = [
+  /*      good lazy nice chain */
+  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
+  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
+  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
+  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */
+
+  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
+  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
+  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
+  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
+  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
+  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
+];
+
+
+/* ===========================================================================
+ * Initialize the "longest match" routines for a new zlib stream
+ */
+function lm_init(s) {
+  s.window_size = 2 * s.w_size;
+
+  /*** CLEAR_HASH(s); ***/
+  zero(s.head); // Fill with NIL (= 0);
+
+  /* Set the default configuration parameters:
+   */
+  s.max_lazy_match = configuration_table[s.level].max_lazy;
+  s.good_match = configuration_table[s.level].good_length;
+  s.nice_match = configuration_table[s.level].nice_length;
+  s.max_chain_length = configuration_table[s.level].max_chain;
+
+  s.strstart = 0;
+  s.block_start = 0;
+  s.lookahead = 0;
+  s.insert = 0;
+  s.match_length = s.prev_length = MIN_MATCH - 1;
+  s.match_available = 0;
+  s.ins_h = 0;
+}
+
+
+function DeflateState() {
+  this.strm = null;            /* pointer back to this zlib stream */
+  this.status = 0;            /* as the name implies */
+  this.pending_buf = null;      /* output still pending */
+  this.pending_buf_size = 0;  /* size of pending_buf */
+  this.pending_out = 0;       /* next pending byte to output to the stream */
+  this.pending = 0;           /* nb of bytes in the pending buffer */
+  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
+  this.gzhead = null;         /* gzip header information to write */
+  this.gzindex = 0;           /* where in extra, name, or comment */
+  this.method = Z_DEFLATED; /* can only be DEFLATED */
+  this.last_flush = -1;   /* value of flush param for previous deflate call */
+
+  this.w_size = 0;  /* LZ77 window size (32K by default) */
+  this.w_bits = 0;  /* log2(w_size)  (8..16) */
+  this.w_mask = 0;  /* w_size - 1 */
+
+  this.window = null;
+  /* Sliding window. Input bytes are read into the second half of the window,
+   * and move to the first half later to keep a dictionary of at least wSize
+   * bytes. With this organization, matches are limited to a distance of
+   * wSize-MAX_MATCH bytes, but this ensures that IO is always
+   * performed with a length multiple of the block size.
+   */
+
+  this.window_size = 0;
+  /* Actual size of window: 2*wSize, except when the user input buffer
+   * is directly used as sliding window.
+   */
+
+  this.prev = null;
+  /* Link to older string with same hash index. To limit the size of this
+   * array to 64K, this link is maintained only for the last 32K strings.
+   * An index in this array is thus a window index modulo 32K.
+   */
+
+  this.head = null;   /* Heads of the hash chains or NIL. */
+
+  this.ins_h = 0;       /* hash index of string to be inserted */
+  this.hash_size = 0;   /* number of elements in hash table */
+  this.hash_bits = 0;   /* log2(hash_size) */
+  this.hash_mask = 0;   /* hash_size-1 */
+
+  this.hash_shift = 0;
+  /* Number of bits by which ins_h must be shifted at each input
+   * step. It must be such that after MIN_MATCH steps, the oldest
+   * byte no longer takes part in the hash key, that is:
+   *   hash_shift * MIN_MATCH >= hash_bits
+   */
+
+  this.block_start = 0;
+  /* Window position at the beginning of the current output block. Gets
+   * negative when the window is moved backwards.
+   */
+
+  this.match_length = 0;      /* length of best match */
+  this.prev_match = 0;        /* previous match */
+  this.match_available = 0;   /* set if previous match exists */
+  this.strstart = 0;          /* start of string to insert */
+  this.match_start = 0;       /* start of matching string */
+  this.lookahead = 0;         /* number of valid bytes ahead in window */
+
+  this.prev_length = 0;
+  /* Length of the best match at previous step. Matches not greater than this
+   * are discarded. This is used in the lazy match evaluation.
+   */
+
+  this.max_chain_length = 0;
+  /* To speed up deflation, hash chains are never searched beyond this
+   * length.  A higher limit improves compression ratio but degrades the
+   * speed.
+   */
+
+  this.max_lazy_match = 0;
+  /* Attempt to find a better match only when the current match is strictly
+   * smaller than this value. This mechanism is used only for compression
+   * levels >= 4.
+   */
+  // That's alias to max_lazy_match, don't use directly
+  //this.max_insert_length = 0;
+  /* Insert new strings in the hash table only if the match length is not
+   * greater than this length. This saves time but degrades compression.
+   * max_insert_length is used only for compression levels <= 3.
+   */
+
+  this.level = 0;     /* compression level (1..9) */
+  this.strategy = 0;  /* favor or force Huffman coding*/
+
+  this.good_match = 0;
+  /* Use a faster search when the previous match is longer than this */
+
+  this.nice_match = 0; /* Stop searching when current match exceeds this */
+
+              /* used by trees.c: */
+
+  /* Didn't use ct_data typedef below to suppress compiler warning */
+
+  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
+  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
+  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
+
+  // Use flat array of DOUBLE size, with interleaved fata,
+  // because JS does not support effective
+  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
+  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
+  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
+  zero(this.dyn_ltree);
+  zero(this.dyn_dtree);
+  zero(this.bl_tree);
+
+  this.l_desc   = null;         /* desc. for literal tree */
+  this.d_desc   = null;         /* desc. for distance tree */
+  this.bl_desc  = null;         /* desc. for bit length tree */
+
+  //ush bl_count[MAX_BITS+1];
+  this.bl_count = new utils.Buf16(MAX_BITS + 1);
+  /* number of codes at each bit length for an optimal tree */
+
+  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
+  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
+  zero(this.heap);
+
+  this.heap_len = 0;               /* number of elements in the heap */
+  this.heap_max = 0;               /* element of largest frequency */
+  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
+   * The same heap array is used to build all trees.
+   */
+
+  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
+  zero(this.depth);
+  /* Depth of each subtree used as tie breaker for trees of equal frequency
+   */
+
+  this.l_buf = 0;          /* buffer index for literals or lengths */
+
+  this.lit_bufsize = 0;
+  /* Size of match buffer for literals/lengths.  There are 4 reasons for
+   * limiting lit_bufsize to 64K:
+   *   - frequencies can be kept in 16 bit counters
+   *   - if compression is not successful for the first block, all input
+   *     data is still in the window so we can still emit a stored block even
+   *     when input comes from standard input.  (This can also be done for
+   *     all blocks if lit_bufsize is not greater than 32K.)
+   *   - if compression is not successful for a file smaller than 64K, we can
+   *     even emit a stored file instead of a stored block (saving 5 bytes).
+   *     This is applicable only for zip (not gzip or zlib).
+   *   - creating new Huffman trees less frequently may not provide fast
+   *     adaptation to changes in the input data statistics. (Take for
+   *     example a binary file with poorly compressible code followed by
+   *     a highly compressible string table.) Smaller buffer sizes give
+   *     fast adaptation but have of course the overhead of transmitting
+   *     trees more frequently.
+   *   - I can't count above 4
+   */
+
+  this.last_lit = 0;      /* running index in l_buf */
+
+  this.d_buf = 0;
+  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
+   * the same number of elements. To use different lengths, an extra flag
+   * array would be necessary.
+   */
+
+  this.opt_len = 0;       /* bit length of current block with optimal trees */
+  this.static_len = 0;    /* bit length of current block with static trees */
+  this.matches = 0;       /* number of string matches in current block */
+  this.insert = 0;        /* bytes at end of window left to insert */
+
+
+  this.bi_buf = 0;
+  /* Output buffer. bits are inserted starting at the bottom (least
+   * significant bits).
+   */
+  this.bi_valid = 0;
+  /* Number of valid bits in bi_buf.  All bits above the last valid bit
+   * are always zero.
+   */
+
+  // Used for window memory init. We safely ignore it for JS. That makes
+  // sense only for pointers and memory check tools.
+  //this.high_water = 0;
+  /* High water mark offset in window for initialized bytes -- bytes above
+   * this are set to zero in order to avoid memory check warnings when
+   * longest match routines access bytes past the input.  This is then
+   * updated to the new high water mark.
+   */
+}
+
+
+function deflateResetKeep(strm) {
+  var s;
+
+  if (!strm || !strm.state) {
+    return err(strm, Z_STREAM_ERROR);
+  }
+
+  strm.total_in = strm.total_out = 0;
+  strm.data_type = Z_UNKNOWN;
+
+  s = strm.state;
+  s.pending = 0;
+  s.pending_out = 0;
+
+  if (s.wrap < 0) {
+    s.wrap = -s.wrap;
+    /* was made negative by deflate(..., Z_FINISH); */
+  }
+  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
+  strm.adler = (s.wrap === 2) ?
+    0  // crc32(0, Z_NULL, 0)
+  :
+    1; // adler32(0, Z_NULL, 0)
+  s.last_flush = Z_NO_FLUSH;
+  trees._tr_init(s);
+  return Z_OK;
+}
+
+
+function deflateReset(strm) {
+  var ret = deflateResetKeep(strm);
+  if (ret === Z_OK) {
+    lm_init(strm.state);
+  }
+  return ret;
+}
+
+
+function deflateSetHeader(strm, head) {
+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
+  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
+  strm.state.gzhead = head;
+  return Z_OK;
+}
+
+
+function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
+  if (!strm) { // === Z_NULL
+    return Z_STREAM_ERROR;
+  }
+  var wrap = 1;
+
+  if (level === Z_DEFAULT_COMPRESSION) {
+    level = 6;
+  }
+
+  if (windowBits < 0) { /* suppress zlib wrapper */
+    wrap = 0;
+    windowBits = -windowBits;
+  }
+
+  else if (windowBits > 15) {
+    wrap = 2;           /* write gzip wrapper instead */
+    windowBits -= 16;
+  }
+
+
+  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
+    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
+    strategy < 0 || strategy > Z_FIXED) {
+    return err(strm, Z_STREAM_ERROR);
+  }
+
+
+  if (windowBits === 8) {
+    windowBits = 9;
+  }
+  /* until 256-byte window bug fixed */
+
+  var s = new DeflateState();
+
+  strm.state = s;
+  s.strm = strm;
+
+  s.wrap = wrap;
+  s.gzhead = null;
+  s.w_bits = windowBits;
+  s.w_size = 1 << s.w_bits;
+  s.w_mask = s.w_size - 1;
+
+  s.hash_bits = memLevel + 7;
+  s.hash_size = 1 << s.hash_bits;
+  s.hash_mask = s.hash_size - 1;
+  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
+
+  s.window = new utils.Buf8(s.w_size * 2);
+  s.head = new utils.Buf16(s.hash_size);
+  s.prev = new utils.Buf16(s.w_size);
+
+  // Don't need mem init magic for JS.
+  //s.high_water = 0;  /* nothing written to s->window yet */
+
+  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
+
+  s.pending_buf_size = s.lit_bufsize * 4;
+
+  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
+  //s->pending_buf = (uchf *) overlay;
+  s.pending_buf = new utils.Buf8(s.pending_buf_size);
+
+  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
+  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
+  s.d_buf = 1 * s.lit_bufsize;
+
+  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
+  s.l_buf = (1 + 2) * s.lit_bufsize;
+
+  s.level = level;
+  s.strategy = strategy;
+  s.method = method;
+
+  return deflateReset(strm);
+}
+
+function deflateInit(strm, level) {
+  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
+}
+
+
+function deflate(strm, flush) {
+  var old_flush, s;
+  var beg, val; // for gzip header write only
+
+  if (!strm || !strm.state ||
+    flush > Z_BLOCK || flush < 0) {
+    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
+  }
+
+  s = strm.state;
+
+  if (!strm.output ||
+      (!strm.input && strm.avail_in !== 0) ||
+      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
+    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
+  }
+
+  s.strm = strm; /* just in case */
+  old_flush = s.last_flush;
+  s.last_flush = flush;
+
+  /* Write the header */
+  if (s.status === INIT_STATE) {
+
+    if (s.wrap === 2) { // GZIP header
+      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
+      put_byte(s, 31);
+      put_byte(s, 139);
+      put_byte(s, 8);
+      if (!s.gzhead) { // s->gzhead == Z_NULL
+        put_byte(s, 0);
+        put_byte(s, 0);
+        put_byte(s, 0);
+        put_byte(s, 0);
+        put_byte(s, 0);
+        put_byte(s, s.level === 9 ? 2 :
+                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
+                     4 : 0));
+        put_byte(s, OS_CODE);
+        s.status = BUSY_STATE;
+      }
+      else {
+        put_byte(s, (s.gzhead.text ? 1 : 0) +
+                    (s.gzhead.hcrc ? 2 : 0) +
+                    (!s.gzhead.extra ? 0 : 4) +
+                    (!s.gzhead.name ? 0 : 8) +
+                    (!s.gzhead.comment ? 0 : 16)
+                );
+        put_byte(s, s.gzhead.time & 0xff);
+        put_byte(s, (s.gzhead.time >> 8) & 0xff);
+        put_byte(s, (s.gzhead.time >> 16) & 0xff);
+        put_byte(s, (s.gzhead.time >> 24) & 0xff);
+        put_byte(s, s.level === 9 ? 2 :
+                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
+                     4 : 0));
+        put_byte(s, s.gzhead.os & 0xff);
+        if (s.gzhead.extra && s.gzhead.extra.length) {
+          put_byte(s, s.gzhead.extra.length & 0xff);
+          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
+        }
+        if (s.gzhead.hcrc) {
+          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
+        }
+        s.gzindex = 0;
+        s.status = EXTRA_STATE;
+      }
+    }
+    else // DEFLATE header
+    {
+      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
+      var level_flags = -1;
+
+      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
+        level_flags = 0;
+      } else if (s.level < 6) {
+        level_flags = 1;
+      } else if (s.level === 6) {
+        level_flags = 2;
+      } else {
+        level_flags = 3;
+      }
+      header |= (level_flags << 6);
+      if (s.strstart !== 0) { header |= PRESET_DICT; }
+      header += 31 - (header % 31);
+
+      s.status = BUSY_STATE;
+      putShortMSB(s, header);
+
+      /* Save the adler32 of the preset dictionary: */
+      if (s.strstart !== 0) {
+        putShortMSB(s, strm.adler >>> 16);
+        putShortMSB(s, strm.adler & 0xffff);
+      }
+      strm.adler = 1; // adler32(0L, Z_NULL, 0);
+    }
+  }
+
+//#ifdef GZIP
+  if (s.status === EXTRA_STATE) {
+    if (s.gzhead.extra/* != Z_NULL*/) {
+      beg = s.pending;  /* start of bytes to update crc */
+
+      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
+        if (s.pending === s.pending_buf_size) {
+          if (s.gzhead.hcrc && s.pending > beg) {
+            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
+          }
+          flush_pending(strm);
+          beg = s.pending;
+          if (s.pending === s.pending_buf_size) {
+            break;
+          }
+        }
+        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
+        s.gzindex++;
+      }
+      if (s.gzhead.hcrc && s.pending > beg) {
+        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
+      }
+      if (s.gzindex === s.gzhead.extra.length) {
+        s.gzindex = 0;
+        s.status = NAME_STATE;
+      }
+    }
+    else {
+      s.status = NAME_STATE;
+    }
+  }
+  if (s.status === NAME_STATE) {
+    if (s.gzhead.name/* != Z_NULL*/) {
+      beg = s.pending;  /* start of bytes to update crc */
+      //int val;
+
+      do {
+        if (s.pending === s.pending_buf_size) {
+          if (s.gzhead.hcrc && s.pending > beg) {
+            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
+          }
+          flush_pending(strm);
+          beg = s.pending;
+          if (s.pending === s.pending_buf_size) {
+            val = 1;
+            break;
+          }
+        }
+        // JS specific: little magic to add zero terminator to end of string
+        if (s.gzindex < s.gzhead.name.length) {
+          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
+        } else {
+          val = 0;
+        }
+        put_byte(s, val);
+      } while (val !== 0);
+
+      if (s.gzhead.hcrc && s.pending > beg) {
+        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
+      }
+      if (val === 0) {
+        s.gzindex = 0;
+        s.status = COMMENT_STATE;
+      }
+    }
+    else {
+      s.status = COMMENT_STATE;
+    }
+  }
+  if (s.status === COMMENT_STATE) {
+    if (s.gzhead.comment/* != Z_NULL*/) {
+      beg = s.pending;  /* start of bytes to update crc */
+      //int val;
+
+      do {
+        if (s.pending === s.pending_buf_size) {
+          if (s.gzhead.hcrc && s.pending > beg) {
+            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
+          }
+          flush_pending(strm);
+          beg = s.pending;
+          if (s.pending === s.pending_buf_size) {
+            val = 1;
+            break;
+          }
+        }
+        // JS specific: little magic to add zero terminator to end of string
+        if (s.gzindex < s.gzhead.comment.length) {
+          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
+        } else {
+          val = 0;
+        }
+        put_byte(s, val);
+      } while (val !== 0);
+
+      if (s.gzhead.hcrc && s.pending > beg) {
+        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
+      }
+      if (val === 0) {
+        s.status = HCRC_STATE;
+      }
+    }
+    else {
+      s.status = HCRC_STATE;
+    }
+  }
+  if (s.status === HCRC_STATE) {
+    if (s.gzhead.hcrc) {
+      if (s.pending + 2 > s.pending_buf_size) {
+        flush_pending(strm);
+      }
+      if (s.pending + 2 <= s.pending_buf_size) {
+        put_byte(s, strm.adler & 0xff);
+        put_byte(s, (strm.adler >> 8) & 0xff);
+        strm.adler = 0; //crc32(0L, Z_NULL, 0);
+        s.status = BUSY_STATE;
+      }
+    }
+    else {
+      s.status = BUSY_STATE;
+    }
+  }
+//#endif
+
+  /* Flush as much pending output as possible */
+  if (s.pending !== 0) {
+    flush_pending(strm);
+    if (strm.avail_out === 0) {
+      /* Since avail_out is 0, deflate will be called again with
+       * more output space, but possibly with both pending and
+       * avail_in equal to zero. There won't be anything to do,
+       * but this is not an error situation so make sure we
+       * return OK instead of BUF_ERROR at next call of deflate:
+       */
+      s.last_flush = -1;
+      return Z_OK;
+    }
+
+    /* Make sure there is something to do and avoid duplicate consecutive
+     * flushes. For repeated and useless calls with Z_FINISH, we keep
+     * returning Z_STREAM_END instead of Z_BUF_ERROR.
+     */
+  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
+    flush !== Z_FINISH) {
+    return err(strm, Z_BUF_ERROR);
+  }
+
+  /* User must not provide more input after the first FINISH: */
+  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
+    return err(strm, Z_BUF_ERROR);
+  }
+
+  /* Start a new block or continue the current one.
+   */
+  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
+    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
+    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
+      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
+        configuration_table[s.level].func(s, flush));
+
+    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
+      s.status = FINISH_STATE;
+    }
+    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
+      if (strm.avail_out === 0) {
+        s.last_flush = -1;
+        /* avoid BUF_ERROR next call, see above */
+      }
+      return Z_OK;
+      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
+       * of deflate should use the same flush parameter to make sure
+       * that the flush is complete. So we don't have to output an
+       * empty block here, this will be done at next call. This also
+       * ensures that for a very small output buffer, we emit at most
+       * one empty block.
+       */
+    }
+    if (bstate === BS_BLOCK_DONE) {
+      if (flush === Z_PARTIAL_FLUSH) {
+        trees._tr_align(s);
+      }
+      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
+
+        trees._tr_stored_block(s, 0, 0, false);
+        /* For a full flush, this empty block will be recognized
+         * as a special marker by inflate_sync().
+         */
+        if (flush === Z_FULL_FLUSH) {
+          /*** CLEAR_HASH(s); ***/             /* forget history */
+          zero(s.head); // Fill with NIL (= 0);
+
+          if (s.lookahead === 0) {
+            s.strstart = 0;
+            s.block_start = 0;
+            s.insert = 0;
+          }
+        }
+      }
+      flush_pending(strm);
+      if (strm.avail_out === 0) {
+        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
+        return Z_OK;
+      }
+    }
+  }
+  //Assert(strm->avail_out > 0, "bug2");
+  //if (strm.avail_out <= 0) { throw new Error("bug2");}
+
+  if (flush !== Z_FINISH) { return Z_OK; }
+  if (s.wrap <= 0) { return Z_STREAM_END; }
+
+  /* Write the trailer */
+  if (s.wrap === 2) {
+    put_byte(s, strm.adler & 0xff);
+    put_byte(s, (strm.adler >> 8) & 0xff);
+    put_byte(s, (strm.adler >> 16) & 0xff);
+    put_byte(s, (strm.adler >> 24) & 0xff);
+    put_byte(s, strm.total_in & 0xff);
+    put_byte(s, (strm.total_in >> 8) & 0xff);
+    put_byte(s, (strm.total_in >> 16) & 0xff);
+    put_byte(s, (strm.total_in >> 24) & 0xff);
+  }
+  else
+  {
+    putShortMSB(s, strm.adler >>> 16);
+    putShortMSB(s, strm.adler & 0xffff);
+  }
+
+  flush_pending(strm);
+  /* If avail_out is zero, the application will call deflate again
+   * to flush the rest.
+   */
+  if (s.wrap > 0) { s.wrap = -s.wrap; }
+  /* write the trailer only once! */
+  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
+}
+
+function deflateEnd(strm) {
+  var status;
+
+  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
+    return Z_STREAM_ERROR;
+  }
+
+  status = strm.state.status;
+  if (status !== INIT_STATE &&
+    status !== EXTRA_STATE &&
+    status !== NAME_STATE &&
+    status !== COMMENT_STATE &&
+    status !== HCRC_STATE &&
+    status !== BUSY_STATE &&
+    status !== FINISH_STATE
+  ) {
+    return err(strm, Z_STREAM_ERROR);
+  }
+
+  strm.state = null;
+
+  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
+}
+
+
+/* =========================================================================
+ * Initializes the compression dictionary from the given byte
+ * sequence without producing any compressed output.
+ */
+function deflateSetDictionary(strm, dictionary) {
+  var dictLength = dictionary.length;
+
+  var s;
+  var str, n;
+  var wrap;
+  var avail;
+  var next;
+  var input;
+  var tmpDict;
+
+  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
+    return Z_STREAM_ERROR;
+  }
+
+  s = strm.state;
+  wrap = s.wrap;
+
+  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
+    return Z_STREAM_ERROR;
+  }
+
+  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
+  if (wrap === 1) {
+    /* adler32(strm->adler, dictionary, dictLength); */
+    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
+  }
+
+  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */
+
+  /* if dictionary would fill window, just replace the history */
+  if (dictLength >= s.w_size) {
+    if (wrap === 0) {            /* already empty otherwise */
+      /*** CLEAR_HASH(s); ***/
+      zero(s.head); // Fill with NIL (= 0);
+      s.strstart = 0;
+      s.block_start = 0;
+      s.insert = 0;
+    }
+    /* use the tail */
+    // dictionary = dictionary.slice(dictLength - s.w_size);
+    tmpDict = new utils.Buf8(s.w_size);
+    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
+    dictionary = tmpDict;
+    dictLength = s.w_size;
+  }
+  /* insert dictionary into window and hash */
+  avail = strm.avail_in;
+  next = strm.next_in;
+  input = strm.input;
+  strm.avail_in = dictLength;
+  strm.next_in = 0;
+  strm.input = dictionary;
+  fill_window(s);
+  while (s.lookahead >= MIN_MATCH) {
+    str = s.strstart;
+    n = s.lookahead - (MIN_MATCH - 1);
+    do {
+      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
+      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
+
+      s.prev[str & s.w_mask] = s.head[s.ins_h];
+
+      s.head[s.ins_h] = str;
+      str++;
+    } while (--n);
+    s.strstart = str;
+    s.lookahead = MIN_MATCH - 1;
+    fill_window(s);
+  }
+  s.strstart += s.lookahead;
+  s.block_start = s.strstart;
+  s.insert = s.lookahead;
+  s.lookahead = 0;
+  s.match_length = s.prev_length = MIN_MATCH - 1;
+  s.match_available = 0;
+  strm.next_in = next;
+  strm.input = input;
+  strm.avail_in = avail;
+  s.wrap = wrap;
+  return Z_OK;
+}
+
+
+export { deflateInit, deflateInit2, deflateReset, deflateResetKeep, deflateSetHeader, deflate, deflateEnd, deflateSetDictionary };
+export var deflateInfo = 'pako deflate (from Nodeca project)';
+
+/* Not implemented
+exports.deflateBound = deflateBound;
+exports.deflateCopy = deflateCopy;
+exports.deflateParams = deflateParams;
+exports.deflatePending = deflatePending;
+exports.deflatePrime = deflatePrime;
+exports.deflateTune = deflateTune;
+*/
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/vendor/pako/lib/zlib/gzheader.js
@@ -0,0 +1,35 @@
+export default function GZheader() {
+  /* true if compressed data believed to be text */
+  this.text       = 0;
+  /* modification time */
+  this.time       = 0;
+  /* extra flags (not used when writing a gzip file) */
+  this.xflags     = 0;
+  /* operating system */
+  this.os         = 0;
+  /* pointer to extra field or Z_NULL if none */
+  this.extra      = null;
+  /* extra field length (valid if extra != Z_NULL) */
+  this.extra_len  = 0; // Actually, we don't need it in JS,
+                       // but leave for few code modifications
+
+  //
+  // Setup limits is not necessary because in js we should not preallocate memory
+  // for inflate use constant limit in 65536 bytes
+  //
+
+  /* space at extra (only when reading header) */
+  // this.extra_max  = 0;
+  /* pointer to zero-terminated file name or Z_NULL */
+  this.name       = '';
+  /* space at name (only when reading header) */
+  // this.name_max   = 0;
+  /* pointer to zero-terminated comment or Z_NULL */
+  this.comment    = '';
+  /* space at comment (only when reading header) */
+  // this.comm_max   = 0;
+  /* true if there was or will be a header crc */
+  this.hcrc       = 0;
+  /* true when done reading gzip header (not used when writing a gzip file) */
+  this.done       = false;
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/vendor/pako/lib/zlib/inffast.js
@@ -0,0 +1,324 @@
+// See state defs from inflate.js
+var BAD = 30;       /* got a data error -- remain here until reset */
+var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
+
+/*
+   Decode literal, length, and distance codes and write out the resulting
+   literal and match bytes until either not enough input or output is
+   available, an end-of-block is encountered, or a data error is encountered.
+   When large enough input and output buffers are supplied to inflate(), for
+   example, a 16K input buffer and a 64K output buffer, more than 95% of the
+   inflate execution time is spent in this routine.
+
+   Entry assumptions:
+
+        state.mode === LEN
+        strm.avail_in >= 6
+        strm.avail_out >= 258
+        start >= strm.avail_out
+        state.bits < 8
+
+   On return, state.mode is one of:
+
+        LEN -- ran out of enough output space or enough available input
+        TYPE -- reached end of block code, inflate() to interpret next block
+        BAD -- error in block data
+
+   Notes:
+
+    - The maximum input bits used by a length/distance pair is 15 bits for the
+      length code, 5 bits for the length extra, 15 bits for the distance code,
+      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
+      Therefore if strm.avail_in >= 6, then there is enough input to avoid
+      checking for available input while decoding.
+
+    - The maximum bytes that a single length/distance pair can output is 258
+      bytes, which is the maximum length that can be coded.  inflate_fast()
+      requires strm.avail_out >= 258 for each loop to avoid checking for
+      output space.
+ */
+export default function inflate_fast(strm, start) {
+  var state;
+  var _in;                    /* local strm.input */
+  var last;                   /* have enough input while in < last */
+  var _out;                   /* local strm.output */
+  var beg;                    /* inflate()'s initial strm.output */
+  var end;                    /* while out < end, enough space available */
+//#ifdef INFLATE_STRICT
+  var dmax;                   /* maximum distance from zlib header */
+//#endif
+  var wsize;                  /* window size or zero if not using window */
+  var whave;                  /* valid bytes in the window */
+  var wnext;                  /* window write index */
+  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
+  var s_window;               /* allocated sliding window, if wsize != 0 */
+  var hold;                   /* local strm.hold */
+  var bits;                   /* local strm.bits */
+  var lcode;                  /* local strm.lencode */
+  var dcode;                  /* local strm.distcode */
+  var lmask;                  /* mask for first level of length codes */
+  var dmask;                  /* mask for first level of distance codes */
+  var here;                   /* retrieved table entry */
+  var op;                     /* code bits, operation, extra bits, or */
+                              /*  window position, window bytes to copy */
+  var len;                    /* match length, unused bytes */
+  var dist;                   /* match distance */
+  var from;                   /* where to copy match from */
+  var from_source;
+
+
+  var input, output; // JS specific, because we have no pointers
+
+  /* copy state to local variables */
+  state = strm.state;
+  //here = state.here;
+  _in = strm.next_in;
+  input = strm.input;
+  last = _in + (strm.avail_in - 5);
+  _out = strm.next_out;
+  output = strm.output;
+  beg = _out - (start - strm.avail_out);
+  end = _out + (strm.avail_out - 257);
+//#ifdef INFLATE_STRICT
+  dmax = state.dmax;
+//#endif
+  wsize = state.wsize;
+  whave = state.whave;
+  wnext = state.wnext;
+  s_window = state.window;
+  hold = state.hold;
+  bits = state.bits;
+  lcode = state.lencode;
+  dcode = state.distcode;
+  lmask = (1 << state.lenbits) - 1;
+  dmask = (1 << state.distbits) - 1;
+
+
+  /* decode literals and length/distances until end-of-block or not enough
+     input data or output space */
+
+  top:
+  do {
+    if (bits < 15) {
+      hold += input[_in++] << bits;
+      bits += 8;
+      hold += input[_in++] << bits;
+      bits += 8;
+    }
+
+    here = lcode[hold & lmask];
+
+    dolen:
+    for (;;) { // Goto emulation
+      op = here >>> 24/*here.bits*/;
+      hold >>>= op;
+      bits -= op;
+      op = (here >>> 16) & 0xff/*here.op*/;
+      if (op === 0) {                          /* literal */
+        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
+        //        "inflate:         literal '%c'\n" :
+        //        "inflate:         literal 0x%02x\n", here.val));
+        output[_out++] = here & 0xffff/*here.val*/;
+      }
+      else if (op & 16) {                     /* length base */
+        len = here & 0xffff/*here.val*/;
+        op &= 15;                           /* number of extra bits */
+        if (op) {
+          if (bits < op) {
+            hold += input[_in++] << bits;
+            bits += 8;
+          }
+          len += hold & ((1 << op) - 1);
+          hold >>>= op;
+          bits -= op;
+        }
+        //Tracevv((stderr, "inflate:         length %u\n", len));
+        if (bits < 15) {
+          hold += input[_in++] << bits;
+          bits += 8;
+          hold += input[_in++] << bits;
+          bits += 8;
+        }
+        here = dcode[hold & dmask];
+
+        dodist:
+        for (;;) { // goto emulation
+          op = here >>> 24/*here.bits*/;
+          hold >>>= op;
+          bits -= op;
+          op = (here >>> 16) & 0xff/*here.op*/;
+
+          if (op & 16) {                      /* distance base */
+            dist = here & 0xffff/*here.val*/;
+            op &= 15;                       /* number of extra bits */
+            if (bits < op) {
+              hold += input[_in++] << bits;
+              bits += 8;
+              if (bits < op) {
+                hold += input[_in++] << bits;
+                bits += 8;
+              }
+            }
+            dist += hold & ((1 << op) - 1);
+//#ifdef INFLATE_STRICT
+            if (dist > dmax) {
+              strm.msg = 'invalid distance too far back';
+              state.mode = BAD;
+              break top;
+            }
+//#endif
+            hold >>>= op;
+            bits -= op;
+            //Tracevv((stderr, "inflate:         distance %u\n", dist));
+            op = _out - beg;                /* max distance in output */
+            if (dist > op) {                /* see if copy from window */
+              op = dist - op;               /* distance back in window */
+              if (op > whave) {
+                if (state.sane) {
+                  strm.msg = 'invalid distance too far back';
+                  state.mode = BAD;
+                  break top;
+                }
+
+// (!) This block is disabled in zlib defailts,
+// don't enable it for binary compatibility
+//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
+//                if (len <= op - whave) {
+//                  do {
+//                    output[_out++] = 0;
+//                  } while (--len);
+//                  continue top;
+//                }
+//                len -= op - whave;
+//                do {
+//                  output[_out++] = 0;
+//                } while (--op > whave);
+//                if (op === 0) {
+//                  from = _out - dist;
+//                  do {
+//                    output[_out++] = output[from++];
+//                  } while (--len);
+//                  continue top;
+//                }
+//#endif
+              }
+              from = 0; // window index
+              from_source = s_window;
+              if (wnext === 0) {           /* very common case */
+                from += wsize - op;
+                if (op < len) {         /* some from window */
+                  len -= op;
+                  do {
+                    output[_out++] = s_window[from++];
+                  } while (--op);
+                  from = _out - dist;  /* rest from output */
+                  from_source = output;
+                }
+              }
+              else if (wnext < op) {      /* wrap around window */
+                from += wsize + wnext - op;
+                op -= wnext;
+                if (op < len) {         /* some from end of window */
+                  len -= op;
+                  do {
+                    output[_out++] = s_window[from++];
+                  } while (--op);
+                  from = 0;
+                  if (wnext < len) {  /* some from start of window */
+                    op = wnext;
+                    len -= op;
+                    do {
+                      output[_out++] = s_window[from++];
+                    } while (--op);
+                    from = _out - dist;      /* rest from output */
+                    from_source = output;
+                  }
+                }
+              }
+              else {                      /* contiguous in window */
+                from += wnext - op;
+                if (op < len) {         /* some from window */
+                  len -= op;
+                  do {
+                    output[_out++] = s_window[from++];
+                  } while (--op);
+                  from = _out - dist;  /* rest from output */
+                  from_source = output;
+                }
+              }
+              while (len > 2) {
+                output[_out++] = from_source[from++];
+                output[_out++] = from_source[from++];
+                output[_out++] = from_source[from++];
+                len -= 3;
+              }
+              if (len) {
+                output[_out++] = from_source[from++];
+                if (len > 1) {
+                  output[_out++] = from_source[from++];
+                }
+              }
+            }
+            else {
+              from = _out - dist;          /* copy direct from output */
+              do {                        /* minimum length is three */
+                output[_out++] = output[from++];
+                output[_out++] = output[from++];
+                output[_out++] = output[from++];
+                len -= 3;
+              } while (len > 2);
+              if (len) {
+                output[_out++] = output[from++];
+                if (len > 1) {
+                  output[_out++] = output[from++];
+                }
+              }
+            }
+          }
+          else if ((op & 64) === 0) {          /* 2nd level distance code */
+            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
+            continue dodist;
+          }
+          else {
+            strm.msg = 'invalid distance code';
+            state.mode = BAD;
+            break top;
+          }
+
+          break; // need to emulate goto via "continue"
+        }
+      }
+      else if ((op & 64) === 0) {              /* 2nd level length code */
+        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
+        continue dolen;
+      }
+      else if (op & 32) {                     /* end-of-block */
+        //Tracevv((stderr, "inflate:         end of block\n"));
+        state.mode = TYPE;
+        break top;
+      }
+      else {
+        strm.msg = 'invalid literal/length code';
+        state.mode = BAD;
+        break top;
+      }
+
+      break; // need to emulate goto via "continue"
+    }
+  } while (_in < last && _out < end);
+
+  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
+  len = bits >> 3;
+  _in -= len;
+  bits -= len << 3;
+  hold &= (1 << bits) - 1;
+
+  /* update state and return */
+  strm.next_in = _in;
+  strm.next_out = _out;
+  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
+  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
+  state.hold = hold;
+  state.bits = bits;
+  return;
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/vendor/pako/lib/zlib/inflate.js
@@ -0,0 +1,1527 @@
+import * as utils from "../utils/common.js";
+import adler32 from "./adler32.js";
+import crc32 from "./crc32.js";
+import inflate_fast from "./inffast.js";
+import inflate_table from "./inftrees.js";
+
+var CODES = 0;
+var LENS = 1;
+var DISTS = 2;
+
+/* Public constants ==========================================================*/
+/* ===========================================================================*/
+
+
+/* Allowed flush values; see deflate() and inflate() below for details */
+//export const Z_NO_FLUSH      = 0;
+//export const Z_PARTIAL_FLUSH = 1;
+//export const Z_SYNC_FLUSH    = 2;
+//export const Z_FULL_FLUSH    = 3;
+export const Z_FINISH        = 4;
+export const Z_BLOCK         = 5;
+export const Z_TREES         = 6;
+
+
+/* Return codes for the compression/decompression functions. Negative values
+ * are errors, positive values are used for special but normal events.
+ */
+export const Z_OK            = 0;
+export const Z_STREAM_END    = 1;
+export const Z_NEED_DICT     = 2;
+//export const Z_ERRNO         = -1;
+export const Z_STREAM_ERROR  = -2;
+export const Z_DATA_ERROR    = -3;
+export const Z_MEM_ERROR     = -4;
+export const Z_BUF_ERROR     = -5;
+//export const Z_VERSION_ERROR = -6;
+
+/* The deflate compression method */
+export const Z_DEFLATED  = 8;
+
+
+/* STATES ====================================================================*/
+/* ===========================================================================*/
+
+
+var    HEAD = 1;       /* i: waiting for magic header */
+var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
+var    TIME = 3;       /* i: waiting for modification time (gzip) */
+var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
+var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
+var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
+var    NAME = 7;       /* i: waiting for end of file name (gzip) */
+var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
+var    HCRC = 9;       /* i: waiting for header crc (gzip) */
+var    DICTID = 10;    /* i: waiting for dictionary check value */
+var    DICT = 11;      /* waiting for inflateSetDictionary() call */
+var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
+var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
+var        STORED = 14;    /* i: waiting for stored size (length and complement) */
+var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
+var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
+var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
+var        LENLENS = 18;   /* i: waiting for code length code lengths */
+var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
+var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
+var            LEN = 21;       /* i: waiting for length/lit/eob code */
+var            LENEXT = 22;    /* i: waiting for length extra bits */
+var            DIST = 23;      /* i: waiting for distance code */
+var            DISTEXT = 24;   /* i: waiting for distance extra bits */
+var            MATCH = 25;     /* o: waiting for output space to copy string */
+var            LIT = 26;       /* o: waiting for output space to write literal */
+var    CHECK = 27;     /* i: waiting for 32-bit check value */
+var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
+var    DONE = 29;      /* finished check, done -- remain here until reset */
+var    BAD = 30;       /* got a data error -- remain here until reset */
+var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
+var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */
+
+/* ===========================================================================*/
+
+
+
+var ENOUGH_LENS = 852;
+var ENOUGH_DISTS = 592;
+//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);
+
+var MAX_WBITS = 15;
+/* 32K LZ77 window */
+var DEF_WBITS = MAX_WBITS;
+
+
+function zswap32(q) {
+  return  (((q >>> 24) & 0xff) +
+          ((q >>> 8) & 0xff00) +
+          ((q & 0xff00) << 8) +
+          ((q & 0xff) << 24));
+}
+
+
+function InflateState() {
+  this.mode = 0;             /* current inflate mode */
+  this.last = false;          /* true if processing last block */
+  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
+  this.havedict = false;      /* true if dictionary provided */
+  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
+  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
+  this.check = 0;             /* protected copy of check value */
+  this.total = 0;             /* protected copy of output count */
+  // TODO: may be {}
+  this.head = null;           /* where to save gzip header information */
+
+  /* sliding window */
+  this.wbits = 0;             /* log base 2 of requested window size */
+  this.wsize = 0;             /* window size or zero if not using window */
+  this.whave = 0;             /* valid bytes in the window */
+  this.wnext = 0;             /* window write index */
+  this.window = null;         /* allocated sliding window, if needed */
+
+  /* bit accumulator */
+  this.hold = 0;              /* input bit accumulator */
+  this.bits = 0;              /* number of bits in "in" */
+
+  /* for string and stored block copying */
+  this.length = 0;            /* literal or length of data to copy */
+  this.offset = 0;            /* distance back to copy string from */
+
+  /* for table and code decoding */
+  this.extra = 0;             /* extra bits needed */
+
+  /* fixed and dynamic code tables */
+  this.lencode = null;          /* starting table for length/literal codes */
+  this.distcode = null;         /* starting table for distance codes */
+  this.lenbits = 0;           /* index bits for lencode */
+  this.distbits = 0;          /* index bits for distcode */
+
+  /* dynamic table building */
+  this.ncode = 0;             /* number of code length code lengths */
+  this.nlen = 0;              /* number of length code lengths */
+  this.ndist = 0;             /* number of distance code lengths */
+  this.have = 0;              /* number of code lengths in lens[] */
+  this.next = null;              /* next available space in codes[] */
+
+  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
+  this.work = new utils.Buf16(288); /* work area for code table building */
+
+  /*
+   because we don't have pointers in js, we use lencode and distcode directly
+   as buffers so we don't need codes
+  */
+  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
+  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
+  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
+  this.sane = 0;                   /* if false, allow invalid distance too far */
+  this.back = 0;                   /* bits back of last unprocessed length/lit */
+  this.was = 0;                    /* initial length of match */
+}
+
+function inflateResetKeep(strm) {
+  var state;
+
+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
+  state = strm.state;
+  strm.total_in = strm.total_out = state.total = 0;
+  strm.msg = ''; /*Z_NULL*/
+  if (state.wrap) {       /* to support ill-conceived Java test suite */
+    strm.adler = state.wrap & 1;
+  }
+  state.mode = HEAD;
+  state.last = 0;
+  state.havedict = 0;
+  state.dmax = 32768;
+  state.head = null/*Z_NULL*/;
+  state.hold = 0;
+  state.bits = 0;
+  //state.lencode = state.distcode = state.next = state.codes;
+  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
+  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
+
+  state.sane = 1;
+  state.back = -1;
+  //Tracev((stderr, "inflate: reset\n"));
+  return Z_OK;
+}
+
+function inflateReset(strm) {
+  var state;
+
+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
+  state = strm.state;
+  state.wsize = 0;
+  state.whave = 0;
+  state.wnext = 0;
+  return inflateResetKeep(strm);
+
+}
+
+function inflateReset2(strm, windowBits) {
+  var wrap;
+  var state;
+
+  /* get the state */
+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
+  state = strm.state;
+
+  /* extract wrap request from windowBits parameter */
+  if (windowBits < 0) {
+    wrap = 0;
+    windowBits = -windowBits;
+  }
+  else {
+    wrap = (windowBits >> 4) + 1;
+    if (windowBits < 48) {
+      windowBits &= 15;
+    }
+  }
+
+  /* set number of window bits, free window if different */
+  if (windowBits && (windowBits < 8 || windowBits > 15)) {
+    return Z_STREAM_ERROR;
+  }
+  if (state.window !== null && state.wbits !== windowBits) {
+    state.window = null;
+  }
+
+  /* update state and reset the rest of it */
+  state.wrap = wrap;
+  state.wbits = windowBits;
+  return inflateReset(strm);
+}
+
+function inflateInit2(strm, windowBits) {
+  var ret;
+  var state;
+
+  if (!strm) { return Z_STREAM_ERROR; }
+  //strm.msg = Z_NULL;                 /* in case we return an error */
+
+  state = new InflateState();
+
+  //if (state === Z_NULL) return Z_MEM_ERROR;
+  //Tracev((stderr, "inflate: allocated\n"));
+  strm.state = state;
+  state.window = null/*Z_NULL*/;
+  ret = inflateReset2(strm, windowBits);
+  if (ret !== Z_OK) {
+    strm.state = null/*Z_NULL*/;
+  }
+  return ret;
+}
+
+function inflateInit(strm) {
+  return inflateInit2(strm, DEF_WBITS);
+}
+
+
+/*
+ Return state with length and distance decoding tables and index sizes set to
+ fixed code decoding.  Normally this returns fixed tables from inffixed.h.
+ If BUILDFIXED is defined, then instead this routine builds the tables the
+ first time it's called, and returns those tables the first time and
+ thereafter.  This reduces the size of the code by about 2K bytes, in
+ exchange for a little execution time.  However, BUILDFIXED should not be
+ used for threaded applications, since the rewriting of the tables and virgin
+ may not be thread-safe.
+ */
+var virgin = true;
+
+var lenfix, distfix; // We have no pointers in JS, so keep tables separate
+
+function fixedtables(state) {
+  /* build fixed huffman tables if first call (may not be thread safe) */
+  if (virgin) {
+    var sym;
+
+    lenfix = new utils.Buf32(512);
+    distfix = new utils.Buf32(32);
+
+    /* literal/length table */
+    sym = 0;
+    while (sym < 144) { state.lens[sym++] = 8; }
+    while (sym < 256) { state.lens[sym++] = 9; }
+    while (sym < 280) { state.lens[sym++] = 7; }
+    while (sym < 288) { state.lens[sym++] = 8; }
+
+    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });
+
+    /* distance table */
+    sym = 0;
+    while (sym < 32) { state.lens[sym++] = 5; }
+
+    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });
+
+    /* do this just once */
+    virgin = false;
+  }
+
+  state.lencode = lenfix;
+  state.lenbits = 9;
+  state.distcode = distfix;
+  state.distbits = 5;
+}
+
+
+/*
+ Update the window with the last wsize (normally 32K) bytes written before
+ returning.  If window does not exist yet, create it.  This is only called
+ when a window is already in use, or when output has been written during this
+ inflate call, but the end of the deflate stream has not been reached yet.
+ It is also called to create a window for dictionary data when a dictionary
+ is loaded.
+
+ Providing output buffers larger than 32K to inflate() should provide a speed
+ advantage, since only the last 32K of output is copied to the sliding window
+ upon return from inflate(), and since all distances after the first 32K of
+ output will fall in the output data, making match copies simpler and faster.
+ The advantage may be dependent on the size of the processor's data caches.
+ */
+function updatewindow(strm, src, end, copy) {
+  var dist;
+  var state = strm.state;
+
+  /* if it hasn't been done already, allocate space for the window */
+  if (state.window === null) {
+    state.wsize = 1 << state.wbits;
+    state.wnext = 0;
+    state.whave = 0;
+
+    state.window = new utils.Buf8(state.wsize);
+  }
+
+  /* copy state->wsize or less output bytes into the circular window */
+  if (copy >= state.wsize) {
+    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
+    state.wnext = 0;
+    state.whave = state.wsize;
+  }
+  else {
+    dist = state.wsize - state.wnext;
+    if (dist > copy) {
+      dist = copy;
+    }
+    //zmemcpy(state->window + state->wnext, end - copy, dist);
+    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
+    copy -= dist;
+    if (copy) {
+      //zmemcpy(state->window, end - copy, copy);
+      utils.arraySet(state.window, src, end - copy, copy, 0);
+      state.wnext = copy;
+      state.whave = state.wsize;
+    }
+    else {
+      state.wnext += dist;
+      if (state.wnext === state.wsize) { state.wnext = 0; }
+      if (state.whave < state.wsize) { state.whave += dist; }
+    }
+  }
+  return 0;
+}
+
+function inflate(strm, flush) {
+  var state;
+  var input, output;          // input/output buffers
+  var next;                   /* next input INDEX */
+  var put;                    /* next output INDEX */
+  var have, left;             /* available input and output */
+  var hold;                   /* bit buffer */
+  var bits;                   /* bits in bit buffer */
+  var _in, _out;              /* save starting available input and output */
+  var copy;                   /* number of stored or match bytes to copy */
+  var from;                   /* where to copy match bytes from */
+  var from_source;
+  var here = 0;               /* current decoding table entry */
+  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
+  //var last;                   /* parent table entry */
+  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
+  var len;                    /* length to copy for repeats, bits to drop */
+  var ret;                    /* return code */
+  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
+  var opts;
+
+  var n; // temporary var for NEED_BITS
+
+  var order = /* permutation of code lengths */
+    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
+
+
+  if (!strm || !strm.state || !strm.output ||
+      (!strm.input && strm.avail_in !== 0)) {
+    return Z_STREAM_ERROR;
+  }
+
+  state = strm.state;
+  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */
+
+
+  //--- LOAD() ---
+  put = strm.next_out;
+  output = strm.output;
+  left = strm.avail_out;
+  next = strm.next_in;
+  input = strm.input;
+  have = strm.avail_in;
+  hold = state.hold;
+  bits = state.bits;
+  //---
+
+  _in = have;
+  _out = left;
+  ret = Z_OK;
+
+  inf_leave: // goto emulation
+  for (;;) {
+    switch (state.mode) {
+    case HEAD:
+      if (state.wrap === 0) {
+        state.mode = TYPEDO;
+        break;
+      }
+      //=== NEEDBITS(16);
+      while (bits < 16) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
+        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
+        //=== CRC2(state.check, hold);
+        hbuf[0] = hold & 0xff;
+        hbuf[1] = (hold >>> 8) & 0xff;
+        state.check = crc32(state.check, hbuf, 2, 0);
+        //===//
+
+        //=== INITBITS();
+        hold = 0;
+        bits = 0;
+        //===//
+        state.mode = FLAGS;
+        break;
+      }
+      state.flags = 0;           /* expect zlib header */
+      if (state.head) {
+        state.head.done = false;
+      }
+      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
+        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
+        strm.msg = 'incorrect header check';
+        state.mode = BAD;
+        break;
+      }
+      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
+        strm.msg = 'unknown compression method';
+        state.mode = BAD;
+        break;
+      }
+      //--- DROPBITS(4) ---//
+      hold >>>= 4;
+      bits -= 4;
+      //---//
+      len = (hold & 0x0f)/*BITS(4)*/ + 8;
+      if (state.wbits === 0) {
+        state.wbits = len;
+      }
+      else if (len > state.wbits) {
+        strm.msg = 'invalid window size';
+        state.mode = BAD;
+        break;
+      }
+      state.dmax = 1 << len;
+      //Tracev((stderr, "inflate:   zlib header ok\n"));
+      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
+      state.mode = hold & 0x200 ? DICTID : TYPE;
+      //=== INITBITS();
+      hold = 0;
+      bits = 0;
+      //===//
+      break;
+    case FLAGS:
+      //=== NEEDBITS(16); */
+      while (bits < 16) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      state.flags = hold;
+      if ((state.flags & 0xff) !== Z_DEFLATED) {
+        strm.msg = 'unknown compression method';
+        state.mode = BAD;
+        break;
+      }
+      if (state.flags & 0xe000) {
+        strm.msg = 'unknown header flags set';
+        state.mode = BAD;
+        break;
+      }
+      if (state.head) {
+        state.head.text = ((hold >> 8) & 1);
+      }
+      if (state.flags & 0x0200) {
+        //=== CRC2(state.check, hold);
+        hbuf[0] = hold & 0xff;
+        hbuf[1] = (hold >>> 8) & 0xff;
+        state.check = crc32(state.check, hbuf, 2, 0);
+        //===//
+      }
+      //=== INITBITS();
+      hold = 0;
+      bits = 0;
+      //===//
+      state.mode = TIME;
+      /* falls through */
+    case TIME:
+      //=== NEEDBITS(32); */
+      while (bits < 32) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      if (state.head) {
+        state.head.time = hold;
+      }
+      if (state.flags & 0x0200) {
+        //=== CRC4(state.check, hold)
+        hbuf[0] = hold & 0xff;
+        hbuf[1] = (hold >>> 8) & 0xff;
+        hbuf[2] = (hold >>> 16) & 0xff;
+        hbuf[3] = (hold >>> 24) & 0xff;
+        state.check = crc32(state.check, hbuf, 4, 0);
+        //===
+      }
+      //=== INITBITS();
+      hold = 0;
+      bits = 0;
+      //===//
+      state.mode = OS;
+      /* falls through */
+    case OS:
+      //=== NEEDBITS(16); */
+      while (bits < 16) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      if (state.head) {
+        state.head.xflags = (hold & 0xff);
+        state.head.os = (hold >> 8);
+      }
+      if (state.flags & 0x0200) {
+        //=== CRC2(state.check, hold);
+        hbuf[0] = hold & 0xff;
+        hbuf[1] = (hold >>> 8) & 0xff;
+        state.check = crc32(state.check, hbuf, 2, 0);
+        //===//
+      }
+      //=== INITBITS();
+      hold = 0;
+      bits = 0;
+      //===//
+      state.mode = EXLEN;
+      /* falls through */
+    case EXLEN:
+      if (state.flags & 0x0400) {
+        //=== NEEDBITS(16); */
+        while (bits < 16) {
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+        }
+        //===//
+        state.length = hold;
+        if (state.head) {
+          state.head.extra_len = hold;
+        }
+        if (state.flags & 0x0200) {
+          //=== CRC2(state.check, hold);
+          hbuf[0] = hold & 0xff;
+          hbuf[1] = (hold >>> 8) & 0xff;
+          state.check = crc32(state.check, hbuf, 2, 0);
+          //===//
+        }
+        //=== INITBITS();
+        hold = 0;
+        bits = 0;
+        //===//
+      }
+      else if (state.head) {
+        state.head.extra = null/*Z_NULL*/;
+      }
+      state.mode = EXTRA;
+      /* falls through */
+    case EXTRA:
+      if (state.flags & 0x0400) {
+        copy = state.length;
+        if (copy > have) { copy = have; }
+        if (copy) {
+          if (state.head) {
+            len = state.head.extra_len - state.length;
+            if (!state.head.extra) {
+              // Use untyped array for more conveniend processing later
+              state.head.extra = new Array(state.head.extra_len);
+            }
+            utils.arraySet(
+              state.head.extra,
+              input,
+              next,
+              // extra field is limited to 65536 bytes
+              // - no need for additional size check
+              copy,
+              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
+              len
+            );
+            //zmemcpy(state.head.extra + len, next,
+            //        len + copy > state.head.extra_max ?
+            //        state.head.extra_max - len : copy);
+          }
+          if (state.flags & 0x0200) {
+            state.check = crc32(state.check, input, copy, next);
+          }
+          have -= copy;
+          next += copy;
+          state.length -= copy;
+        }
+        if (state.length) { break inf_leave; }
+      }
+      state.length = 0;
+      state.mode = NAME;
+      /* falls through */
+    case NAME:
+      if (state.flags & 0x0800) {
+        if (have === 0) { break inf_leave; }
+        copy = 0;
+        do {
+          // TODO: 2 or 1 bytes?
+          len = input[next + copy++];
+          /* use constant limit because in js we should not preallocate memory */
+          if (state.head && len &&
+              (state.length < 65536 /*state.head.name_max*/)) {
+            state.head.name += String.fromCharCode(len);
+          }
+        } while (len && copy < have);
+
+        if (state.flags & 0x0200) {
+          state.check = crc32(state.check, input, copy, next);
+        }
+        have -= copy;
+        next += copy;
+        if (len) { break inf_leave; }
+      }
+      else if (state.head) {
+        state.head.name = null;
+      }
+      state.length = 0;
+      state.mode = COMMENT;
+      /* falls through */
+    case COMMENT:
+      if (state.flags & 0x1000) {
+        if (have === 0) { break inf_leave; }
+        copy = 0;
+        do {
+          len = input[next + copy++];
+          /* use constant limit because in js we should not preallocate memory */
+          if (state.head && len &&
+              (state.length < 65536 /*state.head.comm_max*/)) {
+            state.head.comment += String.fromCharCode(len);
+          }
+        } while (len && copy < have);
+        if (state.flags & 0x0200) {
+          state.check = crc32(state.check, input, copy, next);
+        }
+        have -= copy;
+        next += copy;
+        if (len) { break inf_leave; }
+      }
+      else if (state.head) {
+        state.head.comment = null;
+      }
+      state.mode = HCRC;
+      /* falls through */
+    case HCRC:
+      if (state.flags & 0x0200) {
+        //=== NEEDBITS(16); */
+        while (bits < 16) {
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+        }
+        //===//
+        if (hold !== (state.check & 0xffff)) {
+          strm.msg = 'header crc mismatch';
+          state.mode = BAD;
+          break;
+        }
+        //=== INITBITS();
+        hold = 0;
+        bits = 0;
+        //===//
+      }
+      if (state.head) {
+        state.head.hcrc = ((state.flags >> 9) & 1);
+        state.head.done = true;
+      }
+      strm.adler = state.check = 0;
+      state.mode = TYPE;
+      break;
+    case DICTID:
+      //=== NEEDBITS(32); */
+      while (bits < 32) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      strm.adler = state.check = zswap32(hold);
+      //=== INITBITS();
+      hold = 0;
+      bits = 0;
+      //===//
+      state.mode = DICT;
+      /* falls through */
+    case DICT:
+      if (state.havedict === 0) {
+        //--- RESTORE() ---
+        strm.next_out = put;
+        strm.avail_out = left;
+        strm.next_in = next;
+        strm.avail_in = have;
+        state.hold = hold;
+        state.bits = bits;
+        //---
+        return Z_NEED_DICT;
+      }
+      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
+      state.mode = TYPE;
+      /* falls through */
+    case TYPE:
+      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
+      /* falls through */
+    case TYPEDO:
+      if (state.last) {
+        //--- BYTEBITS() ---//
+        hold >>>= bits & 7;
+        bits -= bits & 7;
+        //---//
+        state.mode = CHECK;
+        break;
+      }
+      //=== NEEDBITS(3); */
+      while (bits < 3) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      state.last = (hold & 0x01)/*BITS(1)*/;
+      //--- DROPBITS(1) ---//
+      hold >>>= 1;
+      bits -= 1;
+      //---//
+
+      switch ((hold & 0x03)/*BITS(2)*/) {
+      case 0:                             /* stored block */
+        //Tracev((stderr, "inflate:     stored block%s\n",
+        //        state.last ? " (last)" : ""));
+        state.mode = STORED;
+        break;
+      case 1:                             /* fixed block */
+        fixedtables(state);
+        //Tracev((stderr, "inflate:     fixed codes block%s\n",
+        //        state.last ? " (last)" : ""));
+        state.mode = LEN_;             /* decode codes */
+        if (flush === Z_TREES) {
+          //--- DROPBITS(2) ---//
+          hold >>>= 2;
+          bits -= 2;
+          //---//
+          break inf_leave;
+        }
+        break;
+      case 2:                             /* dynamic block */
+        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
+        //        state.last ? " (last)" : ""));
+        state.mode = TABLE;
+        break;
+      case 3:
+        strm.msg = 'invalid block type';
+        state.mode = BAD;
+      }
+      //--- DROPBITS(2) ---//
+      hold >>>= 2;
+      bits -= 2;
+      //---//
+      break;
+    case STORED:
+      //--- BYTEBITS() ---// /* go to byte boundary */
+      hold >>>= bits & 7;
+      bits -= bits & 7;
+      //---//
+      //=== NEEDBITS(32); */
+      while (bits < 32) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
+        strm.msg = 'invalid stored block lengths';
+        state.mode = BAD;
+        break;
+      }
+      state.length = hold & 0xffff;
+      //Tracev((stderr, "inflate:       stored length %u\n",
+      //        state.length));
+      //=== INITBITS();
+      hold = 0;
+      bits = 0;
+      //===//
+      state.mode = COPY_;
+      if (flush === Z_TREES) { break inf_leave; }
+      /* falls through */
+    case COPY_:
+      state.mode = COPY;
+      /* falls through */
+    case COPY:
+      copy = state.length;
+      if (copy) {
+        if (copy > have) { copy = have; }
+        if (copy > left) { copy = left; }
+        if (copy === 0) { break inf_leave; }
+        //--- zmemcpy(put, next, copy); ---
+        utils.arraySet(output, input, next, copy, put);
+        //---//
+        have -= copy;
+        next += copy;
+        left -= copy;
+        put += copy;
+        state.length -= copy;
+        break;
+      }
+      //Tracev((stderr, "inflate:       stored end\n"));
+      state.mode = TYPE;
+      break;
+    case TABLE:
+      //=== NEEDBITS(14); */
+      while (bits < 14) {
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+      }
+      //===//
+      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
+      //--- DROPBITS(5) ---//
+      hold >>>= 5;
+      bits -= 5;
+      //---//
+      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
+      //--- DROPBITS(5) ---//
+      hold >>>= 5;
+      bits -= 5;
+      //---//
+      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
+      //--- DROPBITS(4) ---//
+      hold >>>= 4;
+      bits -= 4;
+      //---//
+//#ifndef PKZIP_BUG_WORKAROUND
+      if (state.nlen > 286 || state.ndist > 30) {
+        strm.msg = 'too many length or distance symbols';
+        state.mode = BAD;
+        break;
+      }
+//#endif
+      //Tracev((stderr, "inflate:       table sizes ok\n"));
+      state.have = 0;
+      state.mode = LENLENS;
+      /* falls through */
+    case LENLENS:
+      while (state.have < state.ncode) {
+        //=== NEEDBITS(3);
+        while (bits < 3) {
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+        }
+        //===//
+        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
+        //--- DROPBITS(3) ---//
+        hold >>>= 3;
+        bits -= 3;
+        //---//
+      }
+      while (state.have < 19) {
+        state.lens[order[state.have++]] = 0;
+      }
+      // We have separate tables & no pointers. 2 commented lines below not needed.
+      //state.next = state.codes;
+      //state.lencode = state.next;
+      // Switch to use dynamic table
+      state.lencode = state.lendyn;
+      state.lenbits = 7;
+
+      opts = { bits: state.lenbits };
+      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
+      state.lenbits = opts.bits;
+
+      if (ret) {
+        strm.msg = 'invalid code lengths set';
+        state.mode = BAD;
+        break;
+      }
+      //Tracev((stderr, "inflate:       code lengths ok\n"));
+      state.have = 0;
+      state.mode = CODELENS;
+      /* falls through */
+    case CODELENS:
+      while (state.have < state.nlen + state.ndist) {
+        for (;;) {
+          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
+          here_bits = here >>> 24;
+          here_op = (here >>> 16) & 0xff;
+          here_val = here & 0xffff;
+
+          if ((here_bits) <= bits) { break; }
+          //--- PULLBYTE() ---//
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+          //---//
+        }
+        if (here_val < 16) {
+          //--- DROPBITS(here.bits) ---//
+          hold >>>= here_bits;
+          bits -= here_bits;
+          //---//
+          state.lens[state.have++] = here_val;
+        }
+        else {
+          if (here_val === 16) {
+            //=== NEEDBITS(here.bits + 2);
+            n = here_bits + 2;
+            while (bits < n) {
+              if (have === 0) { break inf_leave; }
+              have--;
+              hold += input[next++] << bits;
+              bits += 8;
+            }
+            //===//
+            //--- DROPBITS(here.bits) ---//
+            hold >>>= here_bits;
+            bits -= here_bits;
+            //---//
+            if (state.have === 0) {
+              strm.msg = 'invalid bit length repeat';
+              state.mode = BAD;
+              break;
+            }
+            len = state.lens[state.have - 1];
+            copy = 3 + (hold & 0x03);//BITS(2);
+            //--- DROPBITS(2) ---//
+            hold >>>= 2;
+            bits -= 2;
+            //---//
+          }
+          else if (here_val === 17) {
+            //=== NEEDBITS(here.bits + 3);
+            n = here_bits + 3;
+            while (bits < n) {
+              if (have === 0) { break inf_leave; }
+              have--;
+              hold += input[next++] << bits;
+              bits += 8;
+            }
+            //===//
+            //--- DROPBITS(here.bits) ---//
+            hold >>>= here_bits;
+            bits -= here_bits;
+            //---//
+            len = 0;
+            copy = 3 + (hold & 0x07);//BITS(3);
+            //--- DROPBITS(3) ---//
+            hold >>>= 3;
+            bits -= 3;
+            //---//
+          }
+          else {
+            //=== NEEDBITS(here.bits + 7);
+            n = here_bits + 7;
+            while (bits < n) {
+              if (have === 0) { break inf_leave; }
+              have--;
+              hold += input[next++] << bits;
+              bits += 8;
+            }
+            //===//
+            //--- DROPBITS(here.bits) ---//
+            hold >>>= here_bits;
+            bits -= here_bits;
+            //---//
+            len = 0;
+            copy = 11 + (hold & 0x7f);//BITS(7);
+            //--- DROPBITS(7) ---//
+            hold >>>= 7;
+            bits -= 7;
+            //---//
+          }
+          if (state.have + copy > state.nlen + state.ndist) {
+            strm.msg = 'invalid bit length repeat';
+            state.mode = BAD;
+            break;
+          }
+          while (copy--) {
+            state.lens[state.have++] = len;
+          }
+        }
+      }
+
+      /* handle error breaks in while */
+      if (state.mode === BAD) { break; }
+
+      /* check for end-of-block code (better have one) */
+      if (state.lens[256] === 0) {
+        strm.msg = 'invalid code -- missing end-of-block';
+        state.mode = BAD;
+        break;
+      }
+
+      /* build code tables -- note: do not change the lenbits or distbits
+         values here (9 and 6) without reading the comments in inftrees.h
+         concerning the ENOUGH constants, which depend on those values */
+      state.lenbits = 9;
+
+      opts = { bits: state.lenbits };
+      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
+      // We have separate tables & no pointers. 2 commented lines below not needed.
+      // state.next_index = opts.table_index;
+      state.lenbits = opts.bits;
+      // state.lencode = state.next;
+
+      if (ret) {
+        strm.msg = 'invalid literal/lengths set';
+        state.mode = BAD;
+        break;
+      }
+
+      state.distbits = 6;
+      //state.distcode.copy(state.codes);
+      // Switch to use dynamic table
+      state.distcode = state.distdyn;
+      opts = { bits: state.distbits };
+      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
+      // We have separate tables & no pointers. 2 commented lines below not needed.
+      // state.next_index = opts.table_index;
+      state.distbits = opts.bits;
+      // state.distcode = state.next;
+
+      if (ret) {
+        strm.msg = 'invalid distances set';
+        state.mode = BAD;
+        break;
+      }
+      //Tracev((stderr, 'inflate:       codes ok\n'));
+      state.mode = LEN_;
+      if (flush === Z_TREES) { break inf_leave; }
+      /* falls through */
+    case LEN_:
+      state.mode = LEN;
+      /* falls through */
+    case LEN:
+      if (have >= 6 && left >= 258) {
+        //--- RESTORE() ---
+        strm.next_out = put;
+        strm.avail_out = left;
+        strm.next_in = next;
+        strm.avail_in = have;
+        state.hold = hold;
+        state.bits = bits;
+        //---
+        inflate_fast(strm, _out);
+        //--- LOAD() ---
+        put = strm.next_out;
+        output = strm.output;
+        left = strm.avail_out;
+        next = strm.next_in;
+        input = strm.input;
+        have = strm.avail_in;
+        hold = state.hold;
+        bits = state.bits;
+        //---
+
+        if (state.mode === TYPE) {
+          state.back = -1;
+        }
+        break;
+      }
+      state.back = 0;
+      for (;;) {
+        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
+        here_bits = here >>> 24;
+        here_op = (here >>> 16) & 0xff;
+        here_val = here & 0xffff;
+
+        if (here_bits <= bits) { break; }
+        //--- PULLBYTE() ---//
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+        //---//
+      }
+      if (here_op && (here_op & 0xf0) === 0) {
+        last_bits = here_bits;
+        last_op = here_op;
+        last_val = here_val;
+        for (;;) {
+          here = state.lencode[last_val +
+                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
+          here_bits = here >>> 24;
+          here_op = (here >>> 16) & 0xff;
+          here_val = here & 0xffff;
+
+          if ((last_bits + here_bits) <= bits) { break; }
+          //--- PULLBYTE() ---//
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+          //---//
+        }
+        //--- DROPBITS(last.bits) ---//
+        hold >>>= last_bits;
+        bits -= last_bits;
+        //---//
+        state.back += last_bits;
+      }
+      //--- DROPBITS(here.bits) ---//
+      hold >>>= here_bits;
+      bits -= here_bits;
+      //---//
+      state.back += here_bits;
+      state.length = here_val;
+      if (here_op === 0) {
+        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
+        //        "inflate:         literal '%c'\n" :
+        //        "inflate:         literal 0x%02x\n", here.val));
+        state.mode = LIT;
+        break;
+      }
+      if (here_op & 32) {
+        //Tracevv((stderr, "inflate:         end of block\n"));
+        state.back = -1;
+        state.mode = TYPE;
+        break;
+      }
+      if (here_op & 64) {
+        strm.msg = 'invalid literal/length code';
+        state.mode = BAD;
+        break;
+      }
+      state.extra = here_op & 15;
+      state.mode = LENEXT;
+      /* falls through */
+    case LENEXT:
+      if (state.extra) {
+        //=== NEEDBITS(state.extra);
+        n = state.extra;
+        while (bits < n) {
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+        }
+        //===//
+        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
+        //--- DROPBITS(state.extra) ---//
+        hold >>>= state.extra;
+        bits -= state.extra;
+        //---//
+        state.back += state.extra;
+      }
+      //Tracevv((stderr, "inflate:         length %u\n", state.length));
+      state.was = state.length;
+      state.mode = DIST;
+      /* falls through */
+    case DIST:
+      for (;;) {
+        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
+        here_bits = here >>> 24;
+        here_op = (here >>> 16) & 0xff;
+        here_val = here & 0xffff;
+
+        if ((here_bits) <= bits) { break; }
+        //--- PULLBYTE() ---//
+        if (have === 0) { break inf_leave; }
+        have--;
+        hold += input[next++] << bits;
+        bits += 8;
+        //---//
+      }
+      if ((here_op & 0xf0) === 0) {
+        last_bits = here_bits;
+        last_op = here_op;
+        last_val = here_val;
+        for (;;) {
+          here = state.distcode[last_val +
+                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
+          here_bits = here >>> 24;
+          here_op = (here >>> 16) & 0xff;
+          here_val = here & 0xffff;
+
+          if ((last_bits + here_bits) <= bits) { break; }
+          //--- PULLBYTE() ---//
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+          //---//
+        }
+        //--- DROPBITS(last.bits) ---//
+        hold >>>= last_bits;
+        bits -= last_bits;
+        //---//
+        state.back += last_bits;
+      }
+      //--- DROPBITS(here.bits) ---//
+      hold >>>= here_bits;
+      bits -= here_bits;
+      //---//
+      state.back += here_bits;
+      if (here_op & 64) {
+        strm.msg = 'invalid distance code';
+        state.mode = BAD;
+        break;
+      }
+      state.offset = here_val;
+      state.extra = (here_op) & 15;
+      state.mode = DISTEXT;
+      /* falls through */
+    case DISTEXT:
+      if (state.extra) {
+        //=== NEEDBITS(state.extra);
+        n = state.extra;
+        while (bits < n) {
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+        }
+        //===//
+        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
+        //--- DROPBITS(state.extra) ---//
+        hold >>>= state.extra;
+        bits -= state.extra;
+        //---//
+        state.back += state.extra;
+      }
+//#ifdef INFLATE_STRICT
+      if (state.offset > state.dmax) {
+        strm.msg = 'invalid distance too far back';
+        state.mode = BAD;
+        break;
+      }
+//#endif
+      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
+      state.mode = MATCH;
+      /* falls through */
+    case MATCH:
+      if (left === 0) { break inf_leave; }
+      copy = _out - left;
+      if (state.offset > copy) {         /* copy from window */
+        copy = state.offset - copy;
+        if (copy > state.whave) {
+          if (state.sane) {
+            strm.msg = 'invalid distance too far back';
+            state.mode = BAD;
+            break;
+          }
+// (!) This block is disabled in zlib defailts,
+// don't enable it for binary compatibility
+//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
+//          Trace((stderr, "inflate.c too far\n"));
+//          copy -= state.whave;
+//          if (copy > state.length) { copy = state.length; }
+//          if (copy > left) { copy = left; }
+//          left -= copy;
+//          state.length -= copy;
+//          do {
+//            output[put++] = 0;
+//          } while (--copy);
+//          if (state.length === 0) { state.mode = LEN; }
+//          break;
+//#endif
+        }
+        if (copy > state.wnext) {
+          copy -= state.wnext;
+          from = state.wsize - copy;
+        }
+        else {
+          from = state.wnext - copy;
+        }
+        if (copy > state.length) { copy = state.length; }
+        from_source = state.window;
+      }
+      else {                              /* copy from output */
+        from_source = output;
+        from = put - state.offset;
+        copy = state.length;
+      }
+      if (copy > left) { copy = left; }
+      left -= copy;
+      state.length -= copy;
+      do {
+        output[put++] = from_source[from++];
+      } while (--copy);
+      if (state.length === 0) { state.mode = LEN; }
+      break;
+    case LIT:
+      if (left === 0) { break inf_leave; }
+      output[put++] = state.length;
+      left--;
+      state.mode = LEN;
+      break;
+    case CHECK:
+      if (state.wrap) {
+        //=== NEEDBITS(32);
+        while (bits < 32) {
+          if (have === 0) { break inf_leave; }
+          have--;
+          // Use '|' insdead of '+' to make sure that result is signed
+          hold |= input[next++] << bits;
+          bits += 8;
+        }
+        //===//
+        _out -= left;
+        strm.total_out += _out;
+        state.total += _out;
+        if (_out) {
+          strm.adler = state.check =
+              /*UPDATE(state.check, put - _out, _out);*/
+              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));
+
+        }
+        _out = left;
+        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
+        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
+          strm.msg = 'incorrect data check';
+          state.mode = BAD;
+          break;
+        }
+        //=== INITBITS();
+        hold = 0;
+        bits = 0;
+        //===//
+        //Tracev((stderr, "inflate:   check matches trailer\n"));
+      }
+      state.mode = LENGTH;
+      /* falls through */
+    case LENGTH:
+      if (state.wrap && state.flags) {
+        //=== NEEDBITS(32);
+        while (bits < 32) {
+          if (have === 0) { break inf_leave; }
+          have--;
+          hold += input[next++] << bits;
+          bits += 8;
+        }
+        //===//
+        if (hold !== (state.total & 0xffffffff)) {
+          strm.msg = 'incorrect length check';
+          state.mode = BAD;
+          break;
+        }
+        //=== INITBITS();
+        hold = 0;
+        bits = 0;
+        //===//
+        //Tracev((stderr, "inflate:   length matches trailer\n"));
+      }
+      state.mode = DONE;
+      /* falls through */
+    case DONE:
+      ret = Z_STREAM_END;
+      break inf_leave;
+    case BAD:
+      ret = Z_DATA_ERROR;
+      break inf_leave;
+    case MEM:
+      return Z_MEM_ERROR;
+    case SYNC:
+      /* falls through */
+    default:
+      return Z_STREAM_ERROR;
+    }
+  }
+
+  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"
+
+  /*
+     Return from inflate(), updating the total counts and the check value.
+     If there was no progress during the inflate() call, return a buffer
+     error.  Call updatewindow() to create and/or update the window state.
+     Note: a memory error from inflate() is non-recoverable.
+   */
+
+  //--- RESTORE() ---
+  strm.next_out = put;
+  strm.avail_out = left;
+  strm.next_in = next;
+  strm.avail_in = have;
+  state.hold = hold;
+  state.bits = bits;
+  //---
+
+  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
+                      (state.mode < CHECK || flush !== Z_FINISH))) {
+    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
+      state.mode = MEM;
+      return Z_MEM_ERROR;
+    }
+  }
+  _in -= strm.avail_in;
+  _out -= strm.avail_out;
+  strm.total_in += _in;
+  strm.total_out += _out;
+  state.total += _out;
+  if (state.wrap && _out) {
+    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
+      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
+  }
+  strm.data_type = state.bits + (state.last ? 64 : 0) +
+                    (state.mode === TYPE ? 128 : 0) +
+                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
+  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
+    ret = Z_BUF_ERROR;
+  }
+  return ret;
+}
+
+function inflateEnd(strm) {
+
+  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
+    return Z_STREAM_ERROR;
+  }
+
+  var state = strm.state;
+  if (state.window) {
+    state.window = null;
+  }
+  strm.state = null;
+  return Z_OK;
+}
+
+function inflateGetHeader(strm, head) {
+  var state;
+
+  /* check state */
+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
+  state = strm.state;
+  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }
+
+  /* save header structure */
+  state.head = head;
+  head.done = false;
+  return Z_OK;
+}
+
+function inflateSetDictionary(strm, dictionary) {
+  var dictLength = dictionary.length;
+
+  var state;
+  var dictid;
+  var ret;
+
+  /* check state */
+  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
+  state = strm.state;
+
+  if (state.wrap !== 0 && state.mode !== DICT) {
+    return Z_STREAM_ERROR;
+  }
+
+  /* check for correct dictionary identifier */
+  if (state.mode === DICT) {
+    dictid = 1; /* adler32(0, null, 0)*/
+    /* dictid = adler32(dictid, dictionary, dictLength); */
+    dictid = adler32(dictid, dictionary, dictLength, 0);
+    if (dictid !== state.check) {
+      return Z_DATA_ERROR;
+    }
+  }
+  /* copy dictionary to window using updatewindow(), which will amend the
+   existing dictionary if appropriate */
+  ret = updatewindow(strm, dictionary, dictLength, dictLength);
+  if (ret) {
+    state.mode = MEM;
+    return Z_MEM_ERROR;
+  }
+  state.havedict = 1;
+  // Tracev((stderr, "inflate:   dictionary set\n"));
+  return Z_OK;
+}
+
+export { inflateReset, inflateReset2, inflateResetKeep, inflateInit, inflateInit2, inflate, inflateEnd, inflateGetHeader, inflateSetDictionary };
+export var inflateInfo = 'pako inflate (from Nodeca project)';
+
+/* Not implemented
+exports.inflateCopy = inflateCopy;
+exports.inflateGetDictionary = inflateGetDictionary;
+exports.inflateMark = inflateMark;
+exports.inflatePrime = inflatePrime;
+exports.inflateSync = inflateSync;
+exports.inflateSyncPoint = inflateSyncPoint;
+exports.inflateUndermine = inflateUndermine;
+*/
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/vendor/pako/lib/zlib/inftrees.js
@@ -0,0 +1,322 @@
+import * as utils from "../utils/common.js";
+
+var MAXBITS = 15;
+var ENOUGH_LENS = 852;
+var ENOUGH_DISTS = 592;
+//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);
+
+var CODES = 0;
+var LENS = 1;
+var DISTS = 2;
+
+var lbase = [ /* Length codes 257..285 base */
+  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
+  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
+];
+
+var lext = [ /* Length codes 257..285 extra */
+  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
+  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
+];
+
+var dbase = [ /* Distance codes 0..29 base */
+  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
+  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
+  8193, 12289, 16385, 24577, 0, 0
+];
+
+var dext = [ /* Distance codes 0..29 extra */
+  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
+  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
+  28, 28, 29, 29, 64, 64
+];
+
+export default function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
+{
+  var bits = opts.bits;
+      //here = opts.here; /* table entry for duplication */
+
+  var len = 0;               /* a code's length in bits */
+  var sym = 0;               /* index of code symbols */
+  var min = 0, max = 0;          /* minimum and maximum code lengths */
+  var root = 0;              /* number of index bits for root table */
+  var curr = 0;              /* number of index bits for current table */
+  var drop = 0;              /* code bits to drop for sub-table */
+  var left = 0;                   /* number of prefix codes available */
+  var used = 0;              /* code entries in table used */
+  var huff = 0;              /* Huffman code */
+  var incr;              /* for incrementing code, index */
+  var fill;              /* index for replicating entries */
+  var low;               /* low bits for current root entry */
+  var mask;              /* mask for low root bits */
+  var next;             /* next available space in table */
+  var base = null;     /* base value table to use */
+  var base_index = 0;
+//  var shoextra;    /* extra bits table to use */
+  var end;                    /* use base and extra for symbol > end */
+  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
+  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
+  var extra = null;
+  var extra_index = 0;
+
+  var here_bits, here_op, here_val;
+
+  /*
+   Process a set of code lengths to create a canonical Huffman code.  The
+   code lengths are lens[0..codes-1].  Each length corresponds to the
+   symbols 0..codes-1.  The Huffman code is generated by first sorting the
+   symbols by length from short to long, and retaining the symbol order
+   for codes with equal lengths.  Then the code starts with all zero bits
+   for the first code of the shortest length, and the codes are integer
+   increments for the same length, and zeros are appended as the length
+   increases.  For the deflate format, these bits are stored backwards
+   from their more natural integer increment ordering, and so when the
+   decoding tables are built in the large loop below, the integer codes
+   are incremented backwards.
+
+   This routine assumes, but does not check, that all of the entries in
+   lens[] are in the range 0..MAXBITS.  The caller must assure this.
+   1..MAXBITS is interpreted as that code length.  zero means that that
+   symbol does not occur in this code.
+
+   The codes are sorted by computing a count of codes for each length,
+   creating from that a table of starting indices for each length in the
+   sorted table, and then entering the symbols in order in the sorted
+   table.  The sorted table is work[], with that space being provided by
+   the caller.
+
+   The length counts are used for other purposes as well, i.e. finding
+   the minimum and maximum length codes, determining if there are any
+   codes at all, checking for a valid set of lengths, and looking ahead
+   at length counts to determine sub-table sizes when building the
+   decoding tables.
+   */
+
+  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
+  for (len = 0; len <= MAXBITS; len++) {
+    count[len] = 0;
+  }
+  for (sym = 0; sym < codes; sym++) {
+    count[lens[lens_index + sym]]++;
+  }
+
+  /* bound code lengths, force root to be within code lengths */
+  root = bits;
+  for (max = MAXBITS; max >= 1; max--) {
+    if (count[max] !== 0) { break; }
+  }
+  if (root > max) {
+    root = max;
+  }
+  if (max === 0) {                     /* no symbols to code at all */
+    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
+    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
+    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
+    table[table_index++] = (1 << 24) | (64 << 16) | 0;
+
+
+    //table.op[opts.table_index] = 64;
+    //table.bits[opts.table_index] = 1;
+    //table.val[opts.table_index++] = 0;
+    table[table_index++] = (1 << 24) | (64 << 16) | 0;
+
+    opts.bits = 1;
+    return 0;     /* no symbols, but wait for decoding to report error */
+  }
+  for (min = 1; min < max; min++) {
+    if (count[min] !== 0) { break; }
+  }
+  if (root < min) {
+    root = min;
+  }
+
+  /* check for an over-subscribed or incomplete set of lengths */
+  left = 1;
+  for (len = 1; len <= MAXBITS; len++) {
+    left <<= 1;
+    left -= count[len];
+    if (left < 0) {
+      return -1;
+    }        /* over-subscribed */
+  }
+  if (left > 0 && (type === CODES || max !== 1)) {
+    return -1;                      /* incomplete set */
+  }
+
+  /* generate offsets into symbol table for each length for sorting */
+  offs[1] = 0;
+  for (len = 1; len < MAXBITS; len++) {
+    offs[len + 1] = offs[len] + count[len];
+  }
+
+  /* sort symbols by length, by symbol order within each length */
+  for (sym = 0; sym < codes; sym++) {
+    if (lens[lens_index + sym] !== 0) {
+      work[offs[lens[lens_index + sym]]++] = sym;
+    }
+  }
+
+  /*
+   Create and fill in decoding tables.  In this loop, the table being
+   filled is at next and has curr index bits.  The code being used is huff
+   with length len.  That code is converted to an index by dropping drop
+   bits off of the bottom.  For codes where len is less than drop + curr,
+   those top drop + curr - len bits are incremented through all values to
+   fill the table with replicated entries.
+
+   root is the number of index bits for the root table.  When len exceeds
+   root, sub-tables are created pointed to by the root entry with an index
+   of the low root bits of huff.  This is saved in low to check for when a
+   new sub-table should be started.  drop is zero when the root table is
+   being filled, and drop is root when sub-tables are being filled.
+
+   When a new sub-table is needed, it is necessary to look ahead in the
+   code lengths to determine what size sub-table is needed.  The length
+   counts are used for this, and so count[] is decremented as codes are
+   entered in the tables.
+
+   used keeps track of how many table entries have been allocated from the
+   provided *table space.  It is checked for LENS and DIST tables against
+   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
+   the initial root table size constants.  See the comments in inftrees.h
+   for more information.
+
+   sym increments through all symbols, and the loop terminates when
+   all codes of length max, i.e. all codes, have been processed.  This
+   routine permits incomplete codes, so another loop after this one fills
+   in the rest of the decoding tables with invalid code markers.
+   */
+
+  /* set up for code type */
+  // poor man optimization - use if-else instead of switch,
+  // to avoid deopts in old v8
+  if (type === CODES) {
+    base = extra = work;    /* dummy value--not used */
+    end = 19;
+
+  } else if (type === LENS) {
+    base = lbase;
+    base_index -= 257;
+    extra = lext;
+    extra_index -= 257;
+    end = 256;
+
+  } else {                    /* DISTS */
+    base = dbase;
+    extra = dext;
+    end = -1;
+  }
+
+  /* initialize opts for loop */
+  huff = 0;                   /* starting code */
+  sym = 0;                    /* starting code symbol */
+  len = min;                  /* starting code length */
+  next = table_index;              /* current table to fill in */
+  curr = root;                /* current table index bits */
+  drop = 0;                   /* current bits to drop from code for index */
+  low = -1;                   /* trigger new sub-table when len > root */
+  used = 1 << root;          /* use root table entries */
+  mask = used - 1;            /* mask for comparing low */
+
+  /* check available table space */
+  if ((type === LENS && used > ENOUGH_LENS) ||
+    (type === DISTS && used > ENOUGH_DISTS)) {
+    return 1;
+  }
+
+  /* process all codes and make table entries */
+  for (;;) {
+    /* create table entry */
+    here_bits = len - drop;
+    if (work[sym] < end) {
+      here_op = 0;
+      here_val = work[sym];
+    }
+    else if (work[sym] > end) {
+      here_op = extra[extra_index + work[sym]];
+      here_val = base[base_index + work[sym]];
+    }
+    else {
+      here_op = 32 + 64;         /* end of block */
+      here_val = 0;
+    }
+
+    /* replicate for those indices with low len bits equal to huff */
+    incr = 1 << (len - drop);
+    fill = 1 << curr;
+    min = fill;                 /* save offset to next table */
+    do {
+      fill -= incr;
+      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
+    } while (fill !== 0);
+
+    /* backwards increment the len-bit code huff */
+    incr = 1 << (len - 1);
+    while (huff & incr) {
+      incr >>= 1;
+    }
+    if (incr !== 0) {
+      huff &= incr - 1;
+      huff += incr;
+    } else {
+      huff = 0;
+    }
+
+    /* go to next symbol, update count, len */
+    sym++;
+    if (--count[len] === 0) {
+      if (len === max) { break; }
+      len = lens[lens_index + work[sym]];
+    }
+
+    /* create new sub-table if needed */
+    if (len > root && (huff & mask) !== low) {
+      /* if first time, transition to sub-tables */
+      if (drop === 0) {
+        drop = root;
+      }
+
+      /* increment past last table */
+      next += min;            /* here min is 1 << curr */
+
+      /* determine length of next table */
+      curr = len - drop;
+      left = 1 << curr;
+      while (curr + drop < max) {
+        left -= count[curr + drop];
+        if (left <= 0) { break; }
+        curr++;
+        left <<= 1;
+      }
+
+      /* check for enough space */
+      used += 1 << curr;
+      if ((type === LENS && used > ENOUGH_LENS) ||
+        (type === DISTS && used > ENOUGH_DISTS)) {
+        return 1;
+      }
+
+      /* point entry in root table to sub-table */
+      low = huff & mask;
+      /*table.op[low] = curr;
+      table.bits[low] = root;
+      table.val[low] = next - opts.table_index;*/
+      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
+    }
+  }
+
+  /* fill in remaining table entry if code is incomplete (guaranteed to have
+   at most one remaining entry, since if the code is incomplete, the
+   maximum code length that was allowed to get this far is one bit) */
+  if (huff !== 0) {
+    //table.op[next + huff] = 64;            /* invalid code marker */
+    //table.bits[next + huff] = len - drop;
+    //table.val[next + huff] = 0;
+    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
+  }
+
+  /* set return parameters */
+  //opts.table_index += used;
+  opts.bits = root;
+  return 0;
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/vendor/pako/lib/zlib/messages.js
@@ -0,0 +1,11 @@
+export default {
+  2:      'need dictionary',     /* Z_NEED_DICT       2  */
+  1:      'stream end',          /* Z_STREAM_END      1  */
+  0:      '',                    /* Z_OK              0  */
+  '-1':   'file error',          /* Z_ERRNO         (-1) */
+  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
+  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
+  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
+  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
+  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
+};
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/vendor/pako/lib/zlib/trees.js
@@ -0,0 +1,1195 @@
+import * as utils from "../utils/common.js";
+
+/* Public constants ==========================================================*/
+/* ===========================================================================*/
+
+
+//var Z_FILTERED          = 1;
+//var Z_HUFFMAN_ONLY      = 2;
+//var Z_RLE               = 3;
+var Z_FIXED               = 4;
+//var Z_DEFAULT_STRATEGY  = 0;
+
+/* Possible values of the data_type field (though see inflate()) */
+var Z_BINARY              = 0;
+var Z_TEXT                = 1;
+//var Z_ASCII             = 1; // = Z_TEXT
+var Z_UNKNOWN             = 2;
+
+/*============================================================================*/
+
+
+function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }
+
+// From zutil.h
+
+var STORED_BLOCK = 0;
+var STATIC_TREES = 1;
+var DYN_TREES    = 2;
+/* The three kinds of block type */
+
+var MIN_MATCH    = 3;
+var MAX_MATCH    = 258;
+/* The minimum and maximum match lengths */
+
+// From deflate.h
+/* ===========================================================================
+ * Internal compression state.
+ */
+
+var LENGTH_CODES  = 29;
+/* number of length codes, not counting the special END_BLOCK code */
+
+var LITERALS      = 256;
+/* number of literal bytes 0..255 */
+
+var L_CODES       = LITERALS + 1 + LENGTH_CODES;
+/* number of Literal or Length codes, including the END_BLOCK code */
+
+var D_CODES       = 30;
+/* number of distance codes */
+
+var BL_CODES      = 19;
+/* number of codes used to transfer the bit lengths */
+
+var HEAP_SIZE     = 2 * L_CODES + 1;
+/* maximum heap size */
+
+var MAX_BITS      = 15;
+/* All codes must not exceed MAX_BITS bits */
+
+var Buf_size      = 16;
+/* size of bit buffer in bi_buf */
+
+
+/* ===========================================================================
+ * Constants
+ */
+
+var MAX_BL_BITS = 7;
+/* Bit length codes must not exceed MAX_BL_BITS bits */
+
+var END_BLOCK   = 256;
+/* end of block literal code */
+
+var REP_3_6     = 16;
+/* repeat previous bit length 3-6 times (2 bits of repeat count) */
+
+var REPZ_3_10   = 17;
+/* repeat a zero length 3-10 times  (3 bits of repeat count) */
+
+var REPZ_11_138 = 18;
+/* repeat a zero length 11-138 times  (7 bits of repeat count) */
+
+/* eslint-disable comma-spacing,array-bracket-spacing */
+var extra_lbits =   /* extra bits for each length code */
+  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];
+
+var extra_dbits =   /* extra bits for each distance code */
+  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];
+
+var extra_blbits =  /* extra bits for each bit length code */
+  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];
+
+var bl_order =
+  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
+/* eslint-enable comma-spacing,array-bracket-spacing */
+
+/* The lengths of the bit length codes are sent in order of decreasing
+ * probability, to avoid transmitting the lengths for unused bit length codes.
+ */
+
+/* ===========================================================================
+ * Local data. These are initialized only once.
+ */
+
+// We pre-fill arrays with 0 to avoid uninitialized gaps
+
+var DIST_CODE_LEN = 512; /* see definition of array dist_code below */
+
+// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
+var static_ltree  = new Array((L_CODES + 2) * 2);
+zero(static_ltree);
+/* The static literal tree. Since the bit lengths are imposed, there is no
+ * need for the L_CODES extra codes used during heap construction. However
+ * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
+ * below).
+ */
+
+var static_dtree  = new Array(D_CODES * 2);
+zero(static_dtree);
+/* The static distance tree. (Actually a trivial tree since all codes use
+ * 5 bits.)
+ */
+
+var _dist_code    = new Array(DIST_CODE_LEN);
+zero(_dist_code);
+/* Distance codes. The first 256 values correspond to the distances
+ * 3 .. 258, the last 256 values correspond to the top 8 bits of
+ * the 15 bit distances.
+ */
+
+var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
+zero(_length_code);
+/* length code for each normalized match length (0 == MIN_MATCH) */
+
+var base_length   = new Array(LENGTH_CODES);
+zero(base_length);
+/* First normalized length for each code (0 = MIN_MATCH) */
+
+var base_dist     = new Array(D_CODES);
+zero(base_dist);
+/* First normalized distance for each code (0 = distance of 1) */
+
+
+function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
+
+  this.static_tree  = static_tree;  /* static tree or NULL */
+  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
+  this.extra_base   = extra_base;   /* base index for extra_bits */
+  this.elems        = elems;        /* max number of elements in the tree */
+  this.max_length   = max_length;   /* max bit length for the codes */
+
+  // show if `static_tree` has data or dummy - needed for monomorphic objects
+  this.has_stree    = static_tree && static_tree.length;
+}
+
+
+var static_l_desc;
+var static_d_desc;
+var static_bl_desc;
+
+
+function TreeDesc(dyn_tree, stat_desc) {
+  this.dyn_tree = dyn_tree;     /* the dynamic tree */
+  this.max_code = 0;            /* largest code with non zero frequency */
+  this.stat_desc = stat_desc;   /* the corresponding static tree */
+}
+
+
+
+function d_code(dist) {
+  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
+}
+
+
+/* ===========================================================================
+ * Output a short LSB first on the stream.
+ * IN assertion: there is enough room in pendingBuf.
+ */
+function put_short(s, w) {
+//    put_byte(s, (uch)((w) & 0xff));
+//    put_byte(s, (uch)((ush)(w) >> 8));
+  s.pending_buf[s.pending++] = (w) & 0xff;
+  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
+}
+
+
+/* ===========================================================================
+ * Send a value on a given number of bits.
+ * IN assertion: length <= 16 and value fits in length bits.
+ */
+function send_bits(s, value, length) {
+  if (s.bi_valid > (Buf_size - length)) {
+    s.bi_buf |= (value << s.bi_valid) & 0xffff;
+    put_short(s, s.bi_buf);
+    s.bi_buf = value >> (Buf_size - s.bi_valid);
+    s.bi_valid += length - Buf_size;
+  } else {
+    s.bi_buf |= (value << s.bi_valid) & 0xffff;
+    s.bi_valid += length;
+  }
+}
+
+
+function send_code(s, c, tree) {
+  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
+}
+
+
+/* ===========================================================================
+ * Reverse the first len bits of a code, using straightforward code (a faster
+ * method would use a table)
+ * IN assertion: 1 <= len <= 15
+ */
+function bi_reverse(code, len) {
+  var res = 0;
+  do {
+    res |= code & 1;
+    code >>>= 1;
+    res <<= 1;
+  } while (--len > 0);
+  return res >>> 1;
+}
+
+
+/* ===========================================================================
+ * Flush the bit buffer, keeping at most 7 bits in it.
+ */
+function bi_flush(s) {
+  if (s.bi_valid === 16) {
+    put_short(s, s.bi_buf);
+    s.bi_buf = 0;
+    s.bi_valid = 0;
+
+  } else if (s.bi_valid >= 8) {
+    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
+    s.bi_buf >>= 8;
+    s.bi_valid -= 8;
+  }
+}
+
+
+/* ===========================================================================
+ * Compute the optimal bit lengths for a tree and update the total bit length
+ * for the current block.
+ * IN assertion: the fields freq and dad are set, heap[heap_max] and
+ *    above are the tree nodes sorted by increasing frequency.
+ * OUT assertions: the field len is set to the optimal bit length, the
+ *     array bl_count contains the frequencies for each bit length.
+ *     The length opt_len is updated; static_len is also updated if stree is
+ *     not null.
+ */
+function gen_bitlen(s, desc)
+//    deflate_state *s;
+//    tree_desc *desc;    /* the tree descriptor */
+{
+  var tree            = desc.dyn_tree;
+  var max_code        = desc.max_code;
+  var stree           = desc.stat_desc.static_tree;
+  var has_stree       = desc.stat_desc.has_stree;
+  var extra           = desc.stat_desc.extra_bits;
+  var base            = desc.stat_desc.extra_base;
+  var max_length      = desc.stat_desc.max_length;
+  var h;              /* heap index */
+  var n, m;           /* iterate over the tree elements */
+  var bits;           /* bit length */
+  var xbits;          /* extra bits */
+  var f;              /* frequency */
+  var overflow = 0;   /* number of elements with bit length too large */
+
+  for (bits = 0; bits <= MAX_BITS; bits++) {
+    s.bl_count[bits] = 0;
+  }
+
+  /* In a first pass, compute the optimal bit lengths (which may
+   * overflow in the case of the bit length tree).
+   */
+  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */
+
+  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
+    n = s.heap[h];
+    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
+    if (bits > max_length) {
+      bits = max_length;
+      overflow++;
+    }
+    tree[n * 2 + 1]/*.Len*/ = bits;
+    /* We overwrite tree[n].Dad which is no longer needed */
+
+    if (n > max_code) { continue; } /* not a leaf node */
+
+    s.bl_count[bits]++;
+    xbits = 0;
+    if (n >= base) {
+      xbits = extra[n - base];
+    }
+    f = tree[n * 2]/*.Freq*/;
+    s.opt_len += f * (bits + xbits);
+    if (has_stree) {
+      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
+    }
+  }
+  if (overflow === 0) { return; }
+
+  // Trace((stderr,"\nbit length overflow\n"));
+  /* This happens for example on obj2 and pic of the Calgary corpus */
+
+  /* Find the first bit length which could increase: */
+  do {
+    bits = max_length - 1;
+    while (s.bl_count[bits] === 0) { bits--; }
+    s.bl_count[bits]--;      /* move one leaf down the tree */
+    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
+    s.bl_count[max_length]--;
+    /* The brother of the overflow item also moves one step up,
+     * but this does not affect bl_count[max_length]
+     */
+    overflow -= 2;
+  } while (overflow > 0);
+
+  /* Now recompute all bit lengths, scanning in increasing frequency.
+   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
+   * lengths instead of fixing only the wrong ones. This idea is taken
+   * from 'ar' written by Haruhiko Okumura.)
+   */
+  for (bits = max_length; bits !== 0; bits--) {
+    n = s.bl_count[bits];
+    while (n !== 0) {
+      m = s.heap[--h];
+      if (m > max_code) { continue; }
+      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
+        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
+        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
+        tree[m * 2 + 1]/*.Len*/ = bits;
+      }
+      n--;
+    }
+  }
+}
+
+
+/* ===========================================================================
+ * Generate the codes for a given tree and bit counts (which need not be
+ * optimal).
+ * IN assertion: the array bl_count contains the bit length statistics for
+ * the given tree and the field len is set for all tree elements.
+ * OUT assertion: the field code is set for all tree elements of non
+ *     zero code length.
+ */
+function gen_codes(tree, max_code, bl_count)
+//    ct_data *tree;             /* the tree to decorate */
+//    int max_code;              /* largest code with non zero frequency */
+//    ushf *bl_count;            /* number of codes at each bit length */
+{
+  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
+  var code = 0;              /* running code value */
+  var bits;                  /* bit index */
+  var n;                     /* code index */
+
+  /* The distribution counts are first used to generate the code values
+   * without bit reversal.
+   */
+  for (bits = 1; bits <= MAX_BITS; bits++) {
+    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
+  }
+  /* Check that the bit counts in bl_count are consistent. The last code
+   * must be all ones.
+   */
+  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
+  //        "inconsistent bit counts");
+  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
+
+  for (n = 0;  n <= max_code; n++) {
+    var len = tree[n * 2 + 1]/*.Len*/;
+    if (len === 0) { continue; }
+    /* Now reverse the bits */
+    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);
+
+    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
+    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
+  }
+}
+
+
+/* ===========================================================================
+ * Initialize the various 'constant' tables.
+ */
+function tr_static_init() {
+  var n;        /* iterates over tree elements */
+  var bits;     /* bit counter */
+  var length;   /* length value */
+  var code;     /* code value */
+  var dist;     /* distance index */
+  var bl_count = new Array(MAX_BITS + 1);
+  /* number of codes at each bit length for an optimal tree */
+
+  // do check in _tr_init()
+  //if (static_init_done) return;
+
+  /* For some embedded targets, global variables are not initialized: */
+/*#ifdef NO_INIT_GLOBAL_POINTERS
+  static_l_desc.static_tree = static_ltree;
+  static_l_desc.extra_bits = extra_lbits;
+  static_d_desc.static_tree = static_dtree;
+  static_d_desc.extra_bits = extra_dbits;
+  static_bl_desc.extra_bits = extra_blbits;
+#endif*/
+
+  /* Initialize the mapping length (0..255) -> length code (0..28) */
+  length = 0;
+  for (code = 0; code < LENGTH_CODES - 1; code++) {
+    base_length[code] = length;
+    for (n = 0; n < (1 << extra_lbits[code]); n++) {
+      _length_code[length++] = code;
+    }
+  }
+  //Assert (length == 256, "tr_static_init: length != 256");
+  /* Note that the length 255 (match length 258) can be represented
+   * in two different ways: code 284 + 5 bits or code 285, so we
+   * overwrite length_code[255] to use the best encoding:
+   */
+  _length_code[length - 1] = code;
+
+  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
+  dist = 0;
+  for (code = 0; code < 16; code++) {
+    base_dist[code] = dist;
+    for (n = 0; n < (1 << extra_dbits[code]); n++) {
+      _dist_code[dist++] = code;
+    }
+  }
+  //Assert (dist == 256, "tr_static_init: dist != 256");
+  dist >>= 7; /* from now on, all distances are divided by 128 */
+  for (; code < D_CODES; code++) {
+    base_dist[code] = dist << 7;
+    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
+      _dist_code[256 + dist++] = code;
+    }
+  }
+  //Assert (dist == 256, "tr_static_init: 256+dist != 512");
+
+  /* Construct the codes of the static literal tree */
+  for (bits = 0; bits <= MAX_BITS; bits++) {
+    bl_count[bits] = 0;
+  }
+
+  n = 0;
+  while (n <= 143) {
+    static_ltree[n * 2 + 1]/*.Len*/ = 8;
+    n++;
+    bl_count[8]++;
+  }
+  while (n <= 255) {
+    static_ltree[n * 2 + 1]/*.Len*/ = 9;
+    n++;
+    bl_count[9]++;
+  }
+  while (n <= 279) {
+    static_ltree[n * 2 + 1]/*.Len*/ = 7;
+    n++;
+    bl_count[7]++;
+  }
+  while (n <= 287) {
+    static_ltree[n * 2 + 1]/*.Len*/ = 8;
+    n++;
+    bl_count[8]++;
+  }
+  /* Codes 286 and 287 do not exist, but we must include them in the
+   * tree construction to get a canonical Huffman tree (longest code
+   * all ones)
+   */
+  gen_codes(static_ltree, L_CODES + 1, bl_count);
+
+  /* The static distance tree is trivial: */
+  for (n = 0; n < D_CODES; n++) {
+    static_dtree[n * 2 + 1]/*.Len*/ = 5;
+    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
+  }
+
+  // Now data ready and we can init static trees
+  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
+  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
+  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);
+
+  //static_init_done = true;
+}
+
+
+/* ===========================================================================
+ * Initialize a new block.
+ */
+function init_block(s) {
+  var n; /* iterates over tree elements */
+
+  /* Initialize the trees. */
+  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
+  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
+  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }
+
+  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
+  s.opt_len = s.static_len = 0;
+  s.last_lit = s.matches = 0;
+}
+
+
+/* ===========================================================================
+ * Flush the bit buffer and align the output on a byte boundary
+ */
+function bi_windup(s)
+{
+  if (s.bi_valid > 8) {
+    put_short(s, s.bi_buf);
+  } else if (s.bi_valid > 0) {
+    //put_byte(s, (Byte)s->bi_buf);
+    s.pending_buf[s.pending++] = s.bi_buf;
+  }
+  s.bi_buf = 0;
+  s.bi_valid = 0;
+}
+
+/* ===========================================================================
+ * Copy a stored block, storing first the length and its
+ * one's complement if requested.
+ */
+function copy_block(s, buf, len, header)
+//DeflateState *s;
+//charf    *buf;    /* the input data */
+//unsigned len;     /* its length */
+//int      header;  /* true if block header must be written */
+{
+  bi_windup(s);        /* align on byte boundary */
+
+  if (header) {
+    put_short(s, len);
+    put_short(s, ~len);
+  }
+//  while (len--) {
+//    put_byte(s, *buf++);
+//  }
+  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
+  s.pending += len;
+}
+
+/* ===========================================================================
+ * Compares to subtrees, using the tree depth as tie breaker when
+ * the subtrees have equal frequency. This minimizes the worst case length.
+ */
+function smaller(tree, n, m, depth) {
+  var _n2 = n * 2;
+  var _m2 = m * 2;
+  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
+         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
+}
+
+/* ===========================================================================
+ * Restore the heap property by moving down the tree starting at node k,
+ * exchanging a node with the smallest of its two sons if necessary, stopping
+ * when the heap property is re-established (each father smaller than its
+ * two sons).
+ */
+function pqdownheap(s, tree, k)
+//    deflate_state *s;
+//    ct_data *tree;  /* the tree to restore */
+//    int k;               /* node to move down */
+{
+  var v = s.heap[k];
+  var j = k << 1;  /* left son of k */
+  while (j <= s.heap_len) {
+    /* Set j to the smallest of the two sons: */
+    if (j < s.heap_len &&
+      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
+      j++;
+    }
+    /* Exit if v is smaller than both sons */
+    if (smaller(tree, v, s.heap[j], s.depth)) { break; }
+
+    /* Exchange v with the smallest son */
+    s.heap[k] = s.heap[j];
+    k = j;
+
+    /* And continue down the tree, setting j to the left son of k */
+    j <<= 1;
+  }
+  s.heap[k] = v;
+}
+
+
+// inlined manually
+// var SMALLEST = 1;
+
+/* ===========================================================================
+ * Send the block data compressed using the given Huffman trees
+ */
+function compress_block(s, ltree, dtree)
+//    deflate_state *s;
+//    const ct_data *ltree; /* literal tree */
+//    const ct_data *dtree; /* distance tree */
+{
+  var dist;           /* distance of matched string */
+  var lc;             /* match length or unmatched char (if dist == 0) */
+  var lx = 0;         /* running index in l_buf */
+  var code;           /* the code to send */
+  var extra;          /* number of extra bits to send */
+
+  if (s.last_lit !== 0) {
+    do {
+      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
+      lc = s.pending_buf[s.l_buf + lx];
+      lx++;
+
+      if (dist === 0) {
+        send_code(s, lc, ltree); /* send a literal byte */
+        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
+      } else {
+        /* Here, lc is the match length - MIN_MATCH */
+        code = _length_code[lc];
+        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
+        extra = extra_lbits[code];
+        if (extra !== 0) {
+          lc -= base_length[code];
+          send_bits(s, lc, extra);       /* send the extra length bits */
+        }
+        dist--; /* dist is now the match distance - 1 */
+        code = d_code(dist);
+        //Assert (code < D_CODES, "bad d_code");
+
+        send_code(s, code, dtree);       /* send the distance code */
+        extra = extra_dbits[code];
+        if (extra !== 0) {
+          dist -= base_dist[code];
+          send_bits(s, dist, extra);   /* send the extra distance bits */
+        }
+      } /* literal or match pair ? */
+
+      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
+      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
+      //       "pendingBuf overflow");
+
+    } while (lx < s.last_lit);
+  }
+
+  send_code(s, END_BLOCK, ltree);
+}
+
+
+/* ===========================================================================
+ * Construct one Huffman tree and assigns the code bit strings and lengths.
+ * Update the total bit length for the current block.
+ * IN assertion: the field freq is set for all tree elements.
+ * OUT assertions: the fields len and code are set to the optimal bit length
+ *     and corresponding code. The length opt_len is updated; static_len is
+ *     also updated if stree is not null. The field max_code is set.
+ */
+function build_tree(s, desc)
+//    deflate_state *s;
+//    tree_desc *desc; /* the tree descriptor */
+{
+  var tree     = desc.dyn_tree;
+  var stree    = desc.stat_desc.static_tree;
+  var has_stree = desc.stat_desc.has_stree;
+  var elems    = desc.stat_desc.elems;
+  var n, m;          /* iterate over heap elements */
+  var max_code = -1; /* largest code with non zero frequency */
+  var node;          /* new node being created */
+
+  /* Construct the initial heap, with least frequent element in
+   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
+   * heap[0] is not used.
+   */
+  s.heap_len = 0;
+  s.heap_max = HEAP_SIZE;
+
+  for (n = 0; n < elems; n++) {
+    if (tree[n * 2]/*.Freq*/ !== 0) {
+      s.heap[++s.heap_len] = max_code = n;
+      s.depth[n] = 0;
+
+    } else {
+      tree[n * 2 + 1]/*.Len*/ = 0;
+    }
+  }
+
+  /* The pkzip format requires that at least one distance code exists,
+   * and that at least one bit should be sent even if there is only one
+   * possible code. So to avoid special checks later on we force at least
+   * two codes of non zero frequency.
+   */
+  while (s.heap_len < 2) {
+    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
+    tree[node * 2]/*.Freq*/ = 1;
+    s.depth[node] = 0;
+    s.opt_len--;
+
+    if (has_stree) {
+      s.static_len -= stree[node * 2 + 1]/*.Len*/;
+    }
+    /* node is 0 or 1 so it does not have extra bits */
+  }
+  desc.max_code = max_code;
+
+  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
+   * establish sub-heaps of increasing lengths:
+   */
+  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }
+
+  /* Construct the Huffman tree by repeatedly combining the least two
+   * frequent nodes.
+   */
+  node = elems;              /* next internal node of the tree */
+  do {
+    //pqremove(s, tree, n);  /* n = node of least frequency */
+    /*** pqremove ***/
+    n = s.heap[1/*SMALLEST*/];
+    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
+    pqdownheap(s, tree, 1/*SMALLEST*/);
+    /***/
+
+    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */
+
+    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
+    s.heap[--s.heap_max] = m;
+
+    /* Create a new node father of n and m */
+    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
+    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
+    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;
+
+    /* and insert the new node in the heap */
+    s.heap[1/*SMALLEST*/] = node++;
+    pqdownheap(s, tree, 1/*SMALLEST*/);
+
+  } while (s.heap_len >= 2);
+
+  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];
+
+  /* At this point, the fields freq and dad are set. We can now
+   * generate the bit lengths.
+   */
+  gen_bitlen(s, desc);
+
+  /* The field len is now set, we can generate the bit codes */
+  gen_codes(tree, max_code, s.bl_count);
+}
+
+
+/* ===========================================================================
+ * Scan a literal or distance tree to determine the frequencies of the codes
+ * in the bit length tree.
+ */
+function scan_tree(s, tree, max_code)
+//    deflate_state *s;
+//    ct_data *tree;   /* the tree to be scanned */
+//    int max_code;    /* and its largest code of non zero frequency */
+{
+  var n;                     /* iterates over all tree elements */
+  var prevlen = -1;          /* last emitted length */
+  var curlen;                /* length of current code */
+
+  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */
+
+  var count = 0;             /* repeat count of the current code */
+  var max_count = 7;         /* max repeat count */
+  var min_count = 4;         /* min repeat count */
+
+  if (nextlen === 0) {
+    max_count = 138;
+    min_count = 3;
+  }
+  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */
+
+  for (n = 0; n <= max_code; n++) {
+    curlen = nextlen;
+    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;
+
+    if (++count < max_count && curlen === nextlen) {
+      continue;
+
+    } else if (count < min_count) {
+      s.bl_tree[curlen * 2]/*.Freq*/ += count;
+
+    } else if (curlen !== 0) {
+
+      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
+      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;
+
+    } else if (count <= 10) {
+      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;
+
+    } else {
+      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
+    }
+
+    count = 0;
+    prevlen = curlen;
+
+    if (nextlen === 0) {
+      max_count = 138;
+      min_count = 3;
+
+    } else if (curlen === nextlen) {
+      max_count = 6;
+      min_count = 3;
+
+    } else {
+      max_count = 7;
+      min_count = 4;
+    }
+  }
+}
+
+
+/* ===========================================================================
+ * Send a literal or distance tree in compressed form, using the codes in
+ * bl_tree.
+ */
+function send_tree(s, tree, max_code)
+//    deflate_state *s;
+//    ct_data *tree; /* the tree to be scanned */
+//    int max_code;       /* and its largest code of non zero frequency */
+{
+  var n;                     /* iterates over all tree elements */
+  var prevlen = -1;          /* last emitted length */
+  var curlen;                /* length of current code */
+
+  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */
+
+  var count = 0;             /* repeat count of the current code */
+  var max_count = 7;         /* max repeat count */
+  var min_count = 4;         /* min repeat count */
+
+  /* tree[max_code+1].Len = -1; */  /* guard already set */
+  if (nextlen === 0) {
+    max_count = 138;
+    min_count = 3;
+  }
+
+  for (n = 0; n <= max_code; n++) {
+    curlen = nextlen;
+    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;
+
+    if (++count < max_count && curlen === nextlen) {
+      continue;
+
+    } else if (count < min_count) {
+      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);
+
+    } else if (curlen !== 0) {
+      if (curlen !== prevlen) {
+        send_code(s, curlen, s.bl_tree);
+        count--;
+      }
+      //Assert(count >= 3 && count <= 6, " 3_6?");
+      send_code(s, REP_3_6, s.bl_tree);
+      send_bits(s, count - 3, 2);
+
+    } else if (count <= 10) {
+      send_code(s, REPZ_3_10, s.bl_tree);
+      send_bits(s, count - 3, 3);
+
+    } else {
+      send_code(s, REPZ_11_138, s.bl_tree);
+      send_bits(s, count - 11, 7);
+    }
+
+    count = 0;
+    prevlen = curlen;
+    if (nextlen === 0) {
+      max_count = 138;
+      min_count = 3;
+
+    } else if (curlen === nextlen) {
+      max_count = 6;
+      min_count = 3;
+
+    } else {
+      max_count = 7;
+      min_count = 4;
+    }
+  }
+}
+
+
+/* ===========================================================================
+ * Construct the Huffman tree for the bit lengths and return the index in
+ * bl_order of the last bit length code to send.
+ */
+function build_bl_tree(s) {
+  var max_blindex;  /* index of last bit length code of non zero freq */
+
+  /* Determine the bit length frequencies for literal and distance trees */
+  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
+  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
+
+  /* Build the bit length tree: */
+  build_tree(s, s.bl_desc);
+  /* opt_len now includes the length of the tree representations, except
+   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
+   */
+
+  /* Determine the number of bit length codes to send. The pkzip format
+   * requires that at least 4 bit length codes be sent. (appnote.txt says
+   * 3 but the actual value used is 4.)
+   */
+  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
+    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
+      break;
+    }
+  }
+  /* Update opt_len to include the bit length tree and counts */
+  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
+  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
+  //        s->opt_len, s->static_len));
+
+  return max_blindex;
+}
+
+
+/* ===========================================================================
+ * Send the header for a block using dynamic Huffman trees: the counts, the
+ * lengths of the bit length codes, the literal tree and the distance tree.
+ * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
+ */
+function send_all_trees(s, lcodes, dcodes, blcodes)
+//    deflate_state *s;
+//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
+{
+  var rank;                    /* index in bl_order */
+
+  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
+  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
+  //        "too many codes");
+  //Tracev((stderr, "\nbl counts: "));
+  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
+  send_bits(s, dcodes - 1,   5);
+  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
+  for (rank = 0; rank < blcodes; rank++) {
+    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
+    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
+  }
+  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
+
+  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
+  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
+
+  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
+  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
+}
+
+
+/* ===========================================================================
+ * Check if the data type is TEXT or BINARY, using the following algorithm:
+ * - TEXT if the two conditions below are satisfied:
+ *    a) There are no non-portable control characters belonging to the
+ *       "black list" (0..6, 14..25, 28..31).
+ *    b) There is at least one printable character belonging to the
+ *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
+ * - BINARY otherwise.
+ * - The following partially-portable control characters form a
+ *   "gray list" that is ignored in this detection algorithm:
+ *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
+ * IN assertion: the fields Freq of dyn_ltree are set.
+ */
+function detect_data_type(s) {
+  /* black_mask is the bit mask of black-listed bytes
+   * set bits 0..6, 14..25, and 28..31
+   * 0xf3ffc07f = binary 11110011111111111100000001111111
+   */
+  var black_mask = 0xf3ffc07f;
+  var n;
+
+  /* Check for non-textual ("black-listed") bytes. */
+  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
+    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
+      return Z_BINARY;
+    }
+  }
+
+  /* Check for textual ("white-listed") bytes. */
+  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
+      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
+    return Z_TEXT;
+  }
+  for (n = 32; n < LITERALS; n++) {
+    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
+      return Z_TEXT;
+    }
+  }
+
+  /* There are no "black-listed" or "white-listed" bytes:
+   * this stream either is empty or has tolerated ("gray-listed") bytes only.
+   */
+  return Z_BINARY;
+}
+
+
+var static_init_done = false;
+
+/* ===========================================================================
+ * Initialize the tree data structures for a new zlib stream.
+ */
+function _tr_init(s)
+{
+
+  if (!static_init_done) {
+    tr_static_init();
+    static_init_done = true;
+  }
+
+  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
+  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
+  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
+
+  s.bi_buf = 0;
+  s.bi_valid = 0;
+
+  /* Initialize the first block of the first file: */
+  init_block(s);
+}
+
+
+/* ===========================================================================
+ * Send a stored block
+ */
+function _tr_stored_block(s, buf, stored_len, last)
+//DeflateState *s;
+//charf *buf;       /* input block */
+//ulg stored_len;   /* length of input block */
+//int last;         /* one if this is the last block for a file */
+{
+  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
+  copy_block(s, buf, stored_len, true); /* with header */
+}
+
+
+/* ===========================================================================
+ * Send one empty static block to give enough lookahead for inflate.
+ * This takes 10 bits, of which 7 may remain in the bit buffer.
+ */
+function _tr_align(s) {
+  send_bits(s, STATIC_TREES << 1, 3);
+  send_code(s, END_BLOCK, static_ltree);
+  bi_flush(s);
+}
+
+
+/* ===========================================================================
+ * Determine the best encoding for the current block: dynamic trees, static
+ * trees or store, and output the encoded block to the zip file.
+ */
+function _tr_flush_block(s, buf, stored_len, last)
+//DeflateState *s;
+//charf *buf;       /* input block, or NULL if too old */
+//ulg stored_len;   /* length of input block */
+//int last;         /* one if this is the last block for a file */
+{
+  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
+  var max_blindex = 0;        /* index of last bit length code of non zero freq */
+
+  /* Build the Huffman trees unless a stored block is forced */
+  if (s.level > 0) {
+
+    /* Check if the file is binary or text */
+    if (s.strm.data_type === Z_UNKNOWN) {
+      s.strm.data_type = detect_data_type(s);
+    }
+
+    /* Construct the literal and distance trees */
+    build_tree(s, s.l_desc);
+    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
+    //        s->static_len));
+
+    build_tree(s, s.d_desc);
+    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
+    //        s->static_len));
+    /* At this point, opt_len and static_len are the total bit lengths of
+     * the compressed block data, excluding the tree representations.
+     */
+
+    /* Build the bit length tree for the above two trees, and get the index
+     * in bl_order of the last bit length code to send.
+     */
+    max_blindex = build_bl_tree(s);
+
+    /* Determine the best encoding. Compute the block lengths in bytes. */
+    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
+    static_lenb = (s.static_len + 3 + 7) >>> 3;
+
+    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
+    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
+    //        s->last_lit));
+
+    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }
+
+  } else {
+    // Assert(buf != (char*)0, "lost buf");
+    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
+  }
+
+  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
+    /* 4: two words for the lengths */
+
+    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
+     * Otherwise we can't have processed more than WSIZE input bytes since
+     * the last block flush, because compression would have been
+     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
+     * transform a block into a stored block.
+     */
+    _tr_stored_block(s, buf, stored_len, last);
+
+  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
+
+    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
+    compress_block(s, static_ltree, static_dtree);
+
+  } else {
+    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
+    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
+    compress_block(s, s.dyn_ltree, s.dyn_dtree);
+  }
+  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
+  /* The above check is made mod 2^32, for files larger than 512 MB
+   * and uLong implemented on 32 bits.
+   */
+  init_block(s);
+
+  if (last) {
+    bi_windup(s);
+  }
+  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
+  //       s->compressed_len-7*last));
+}
+
+/* ===========================================================================
+ * Save the match info and tally the frequency counts. Return true if
+ * the current block must be flushed.
+ */
+function _tr_tally(s, dist, lc)
+//    deflate_state *s;
+//    unsigned dist;  /* distance of matched string */
+//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
+{
+  //var out_length, in_length, dcode;
+
+  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
+  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
+
+  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
+  s.last_lit++;
+
+  if (dist === 0) {
+    /* lc is the unmatched char */
+    s.dyn_ltree[lc * 2]/*.Freq*/++;
+  } else {
+    s.matches++;
+    /* Here, lc is the match length - MIN_MATCH */
+    dist--;             /* dist = match distance - 1 */
+    //Assert((ush)dist < (ush)MAX_DIST(s) &&
+    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
+    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
+
+    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
+    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
+  }
+
+// (!) This block is disabled in zlib defailts,
+// don't enable it for binary compatibility
+
+//#ifdef TRUNCATE_BLOCK
+//  /* Try to guess if it is profitable to stop the current block here */
+//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
+//    /* Compute an upper bound for the compressed length */
+//    out_length = s.last_lit*8;
+//    in_length = s.strstart - s.block_start;
+//
+//    for (dcode = 0; dcode < D_CODES; dcode++) {
+//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
+//    }
+//    out_length >>>= 3;
+//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
+//    //       s->last_lit, in_length, out_length,
+//    //       100L - out_length*100L/in_length));
+//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
+//      return true;
+//    }
+//  }
+//#endif
+
+  return (s.last_lit === s.lit_bufsize - 1);
+  /* We avoid equality with lit_bufsize because of wraparound at 64K
+   * on 16 bit machines and because stored blocks are restricted to
+   * 64K-1 bytes.
+   */
+}
+
+export { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align };
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/static/novnc/vendor/pako/lib/zlib/zstream.js
@@ -0,0 +1,24 @@
+export default function ZStream() {
+  /* next input byte */
+  this.input = null; // JS specific, because we have no pointers
+  this.next_in = 0;
+  /* number of bytes available at input */
+  this.avail_in = 0;
+  /* total number of input bytes read so far */
+  this.total_in = 0;
+  /* next output byte should be put there */
+  this.output = null; // JS specific, because we have no pointers
+  this.next_out = 0;
+  /* remaining free space at output */
+  this.avail_out = 0;
+  /* total number of bytes output so far */
+  this.total_out = 0;
+  /* last error message, NULL if no error */
+  this.msg = ''/*Z_NULL*/;
+  /* not visible by applications */
+  this.state = null;
+  /* best guess about the data type: binary or text */
+  this.data_type = 2/*Z_UNKNOWN*/;
+  /* adler32 value of the uncompressed data */
+  this.adler = 0;
+}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/templates/base_generic.html
@@ -0,0 +1,23 @@
+<!DOCTYPE html>
+<html>
+<head>
+    <title>Forensic VM Webserver</title>
+    <meta name="viewport" content="width=device-width, initial-scale=1">
+    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
+</head>
+<body>
+
+<div class="w3-container w3-teal">
+    <h1>Forensic VM Webserver</h1>
+</div>
+
+{% block content %}
+{% endblock %}
+
+<div class="w3-container w3-teal">
+    <p>This software is provided as-is, without warranty of any kind. Use at your own risk.</p>
+	<p>Copyright (c) 2023 Nuno Mourinho - This software was created as part of a Master's degree in Cybersecurity Engineering at Escola Superior de Tecnologia e Gestão de Beja. All rights reserved</p>
+</div>
+
+</body>
+</html>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/templates/main.html
@@ -0,0 +1,145 @@
+<!-- templates/main.html -->
+{% load static %}
+
+<!DOCTYPE html>
+<html>
+<head>
+    <!-- Icons (see app/images/icons/Makefile for what the sizes are for) -->
+    <link rel="icon" sizes="16x16" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-16x16.png">
+    <link rel="icon" sizes="24x24" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-24x24.png">
+    <link rel="icon" sizes="32x32" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-32x32.png">
+    <link rel="icon" sizes="48x48" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-48x48.png">
+    <link rel="icon" sizes="60x60" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-60x60.png">
+    <link rel="icon" sizes="64x64" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-64x64.png">
+    <link rel="icon" sizes="72x72" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-72x72.png">
+    <link rel="icon" sizes="76x76" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-76x76.png">
+    <link rel="icon" sizes="96x96" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-96x96.png">
+    <link rel="icon" sizes="120x120" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-120x120.png">
+    <link rel="icon" sizes="144x144" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-144x144.png">
+    <link rel="icon" sizes="152x152" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-152x152.png">
+    <link rel="icon" sizes="192x192" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-192x192.png">
+    <!-- Firefox currently mishandles SVG, see #1419039
+    <link rel="icon" sizes="any" type="image/svg+xml" href="{% static 'novnc/' %}app/images/icons/novnc-icon.svg">
+    -->
+    <!-- Repeated last so that legacy handling will pick this -->
+    <link rel="icon" sizes="16x16" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-16x16.png">
+
+  {% block header %}{% endblock %}
+  <script>
+    function showAlert(message, color = 'w3-green') {
+      var alertContainer = document.getElementById('alertContainer');
+      var alertElement = document.createElement('div');
+      alertElement.classList.add('alert');
+      alertElement.classList.add('w3-panel');
+      alertElement.classList.add(color);
+      alertElement.classList.add('w3-display-container');
+
+      var closeButton = document.createElement('span');
+      closeButton.classList.add('w3-button');
+      closeButton.classList.add('w3-display-topright');
+      closeButton.textContent = '×';
+      closeButton.onclick = function() {
+        alertElement.classList.remove('show');
+      };
+
+      var messageElement = document.createElement('p');
+      messageElement.classList.add('alert-message');
+      messageElement.textContent = message;
+
+      alertElement.appendChild(closeButton);
+      alertElement.appendChild(messageElement);
+
+      alertContainer.appendChild(alertElement);
+
+      // Calculate the top position for the alert
+      var alertHeight = alertElement.offsetHeight;
+      var alertCount = alertContainer.getElementsByClassName('alert').length;
+      var alertTop = (alertCount - 1) * (alertHeight+2);
+
+      // Set the top position dynamically
+      alertElement.style.top = alertTop + 'px';
+
+      setTimeout(function() {
+        alertElement.classList.add('show');
+      }, 10);
+
+      setTimeout(function() {
+        alertElement.classList.remove('show');
+        setTimeout(function() {
+          alertContainer.removeChild(alertElement);
+        }, 300);
+      }, 3000);
+    }
+  </script>
+<title>Forensic VM Server</title>
+<meta charset="UTF-8">
+<meta name="viewport" content="width=device-width, initial-scale=1">
+<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
+<style>
+<!-- body {font-family: "Times New Roman", Georgia, Serif;} -->
+body {font-family: "Playfair Display";
+  letter-spacing: 2px;
+}
+h1, h2, h3, h4, h5, h6 {
+  font-family: "Playfair Display";
+  letter-spacing: 2px;
+}
+      .alert {
+        opacity: 0;
+        transition: opacity 0.3s;
+        position: fixed;
+        top: 0;
+        left: 0;
+        width: 100%;
+        z-index: 9999;
+     }
+
+     .alert.show {
+       opacity: 1;
+    }
+
+    .alert-message {
+      font-size: 14px; /* Adjust the text size as desired */
+    }
+  </style>
+</head>
+<body>
+
+<!-- Navbar (sit on top) -->
+<div class="w3-top">
+  <div class="w3-bar w3-white w3-padding w3-card" style="letter-spacing:4px;">
+    <a href="#home" class="w3-bar-item w3-button">Forensic VM Server</a>
+    <!-- Right-sided navbar links. Hide them on small screens -->
+    <div class="w3-right w3-hide-small">
+      <a href="netdata" target=”_blank” class="w3-bar-item w3-button">Server Status</a>      
+      <a href="shell" target=”_blank” class="w3-bar-item w3-button">Shell</a>      
+      <a href="vm-list" class="w3-bar-item w3-button">List VM's</a>      
+      <a href="logout" class="w3-bar-item w3-button">Logout</a>      
+    </div>
+  </div>
+</div>
+
+<!-- Header -->
+<header class="w3-display-container w3-content w3-wide" style="max-width:1600px;min-width:500px" id="home">  
+  <div class="w3-display-bottomleft w3-padding-large w3-opacity">
+    <h1 class="w3-xxlarge"></h1>
+  </div>
+</header>
+<br>
+<br>
+<br>
+<!-- Page content -->
+<div class="w3-content" style="max-width:1100px">
+<div id="alertContainer"></div>
+  {% block content %}{% endblock %}
+</div>
+
+<!-- Footer -->
+<footer class="w3-center w3-light-grey w3-padding-32">
+ Copyright (c) 2023 Nuno Mourinho - This software was created as part of a Master's degree in Cybersecurity Engineering at Escola Superior de Tecnologia e Gestão de Beja. All rights reserved <br>
+ This software is provided as-is, without warranty of any kind. Use at your own risk.
+</footer>
+</body>
+  {% block endbody %}{% endblock %}
+</html>
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/templates/novnc/vnc.html
@@ -0,0 +1,1050 @@
+{% load static %}
+<!DOCTYPE html>
+<html lang="pt_PT" class="noVNC_loading">
+<head>
+    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
+    <script>
+        function getCookie(name) {
+            let cookieValue = null;
+            if (document.cookie && document.cookie !== '') {
+                const cookies = document.cookie.split(';');
+                for (let i = 0; i < cookies.length; i++) {
+                    const cookie = cookies[i].trim();
+                    // Does this cookie string begin with the name we want?
+                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
+                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
+                        break;
+                    }
+                }
+            }
+            return cookieValue;
+        }
+
+        function getParameterByName(name, url) {
+            if (!url) url = window.location.href;
+            name = name.replace(/[\[\]]/g, '\\$&');
+            var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
+                results = regex.exec(url);
+            if (!results) return null;
+            if (!results[2]) return '';
+            return decodeURIComponent(results[2].replace(/\+/g, ' '));
+        }
+
+
+        function startVM() {
+            const uuid = getParameterByName('uuid');
+            if (uuid) {
+                fetch('/api/start-vm/' + uuid + '/', {
+                    method: 'POST',
+                    headers: {
+                        'Content-Type': 'application/json',
+                        'X-CSRFToken': getCookie('csrftoken') 
+                    },
+                    credentials: 'include'
+                })
+                //.then(response => response.json())
+                .then(response => {
+                    if (!response.ok) {
+                    throw new Error('Error: ' + response.status);
+                 }
+                    return response.json();
+                })
+                .then(data => {
+                    showAlert('Start sent...','w3-blue')
+                    console.log(data);
+                })
+                .catch((error) => {
+                    console.error('Error:', error);
+                    location.reload();
+                });
+            }
+        }
+
+
+       function stopVM() {
+            const uuid = getParameterByName('uuid');
+            if (uuid) {
+                fetch('/api/stop-vm/' + uuid + '/', {
+                    method: 'POST',
+                    headers: {
+                        'Content-Type': 'application/json',
+                        'X-CSRFToken': getCookie('csrftoken')
+                    },
+                    credentials: 'include'
+                })
+                //.then(response => response.json())
+                .then(response => {
+                    if (!response.ok) {
+                    throw new Error('Error: ' + response.status);
+                }
+                    return response.json();
+                })
+                .then(data => {
+                    showAlert('Stop sent...','w3-orange')
+                    console.log(data);
+                })
+                .catch((error) => {
+                    console.error('Error:', error);
+                    location.reload();
+                });
+            }
+        }
+
+       function resetVM() {
+            const uuid = getParameterByName('uuid');
+            if (uuid) {
+                fetch('/api/reset-vm/' + uuid + '/', {
+                    method: 'POST',
+                    headers: {
+                        'Content-Type': 'application/json',
+                        'X-CSRFToken': getCookie('csrftoken')
+                    },
+                    credentials: 'include'
+                })
+                //.then(response => response.json())
+               .then(response => {
+                    if (!response.ok) {
+                    throw new Error('Error: ' + response.status);
+                }
+                    return response.json();
+                })
+                .then(data => {
+                    showAlert('Reset sent...','w3-orange')
+                    console.log(data);
+                })
+                .catch((error) => {
+                    console.error('Error:', error);
+                    location.reload();
+                });
+            }
+        }
+
+       function shutdownVM() {
+            const uuid = getParameterByName('uuid');
+            if (uuid) {
+                fetch('/api/shutdown-vm/' + uuid + '/', {
+                    method: 'POST',
+                    headers: {
+                        'Content-Type': 'application/json',
+                        'X-CSRFToken': getCookie('csrftoken')
+                    },
+                    credentials: 'include'
+                })
+                //.then(response => response.json())
+                .then(response => {
+                    if (!response.ok) {
+                    showAlert('Error in machine shutdown', 'w3-red')
+                    throw new Error('Error: ' + response.status);
+                }
+                    return response.json();
+                })
+                .then(data => {
+                    console.log(data);
+                    showAlert('Shutdown sent...','w3-blue')
+                })
+                .catch((error) => {
+                    console.error('Error:', error);
+                    location.reload();
+                });
+            }
+        }
+
+
+function screenshotVM() {
+    const uuid = getParameterByName('uuid');
+    if (uuid) {
+        fetch('/api/screenshot-vm/' + uuid + '/', {
+            method: 'POST',
+            headers: {
+                'Content-Type': 'application/json',
+                'X-CSRFToken': getCookie('csrftoken')
+            },
+            credentials: 'include'
+        })
+        .then(response => {
+            if (!response.ok) {
+                throw new Error('Error: ' + response.status);
+            }
+            return response.json();
+        })
+        .then(data => {
+            showAlert('Screenshot with success (' + data.message + ')')
+            console.log(data);
+        })
+        .catch((error) => {
+            console.error('Error:', error);
+            location.reload();
+        });
+    }
+}
+
+
+function enableNetwork() {
+            let uuid = getParameterByName('uuid');
+            if (uuid) {
+                let formData = new FormData();
+                formData.append('uuid', uuid);       
+                fetch('/api/start_tap/', {
+                    method: 'POST',
+                    headers: {
+                        //'Content-Type': 'application/json',
+                        'Content-Type': 'application/x-www-form-urlencoded',
+                        'X-CSRFToken': getCookie('csrftoken')
+                    },
+                    body: new URLSearchParams(formData).toString(),
+                    //body: formData,
+                    credentials: 'include'
+                })
+                //.then(response => response.json())
+                .then(response => {
+                    if (!response.ok) {
+                    throw new Error('Error: ' + response.status);
+                }
+                    return response.json();
+                })
+                .then(data => {
+                    showAlert('Enable network sent', 'w3-orange');
+                    document.getElementById('id01').style.display='none';
+                    console.log(data);
+                })
+                .catch((error) => {
+                    console.log('UUID:', uuid);
+                    console.log('CSRF Token:', getCookie('csrftoken'));
+                    console.error('Error:', error);
+                    showAlert('Error enabling network', 'w3-red'); // Show error message to the user
+                    //location.reload();
+                });
+            }
+
+}
+
+function disableNetwork() {
+  let uuid = getParameterByName('uuid');
+  let formData = new FormData();
+  formData.append('uuid', uuid);       
+  if (uuid) {
+    fetch('/api/stop_tap/', {
+      method: 'POST',
+      headers: {
+        //'Content-Type': 'application/json',
+        'Content-Type': 'application/x-www-form-urlencoded',
+        'X-CSRFToken': getCookie('csrftoken')
+      },
+      body: new URLSearchParams(formData).toString(),
+      //body: formData,
+      credentials: 'include'
+    })
+    .then(response => {
+      if (!response.ok) {
+        throw new Error('Error: ' + response.status);
+      }
+      return response.json();
+    })
+    .then(data => {
+      showAlert('Disable network sent', 'w3-teal')
+      document.getElementById('id01').style.display = 'none';
+      console.log(data);
+    })
+    .catch((error) => {
+      console.error('Error:', error);
+      console.log('UUID:', uuid);
+      console.log('CSRF Token:', getCookie('csrftoken'));
+      showAlert('Error disabling network', 'w3-red'); // Show error message to the user
+      //location.reload();
+    });
+  }
+}
+
+
+function insertMedia() {
+  const cdromDropdown = document.getElementById('cdrom');
+  const filename = cdromDropdown.value;
+  let uuid = getParameterByName('uuid');
+  const url = `/api/insert-cdrom/${uuid}/${filename}/`;
+  console.log(url)
+  fetch(url, {
+    method: 'GET',
+    headers: {
+      'Content-Type': 'application/json',
+      'X-CSRFToken': getCookie('csrftoken')
+    },
+    credentials: 'include'
+  })
+    .then(response => {
+      if (!response.ok) {
+        throw new Error('Error: ' + response.status);
+      }
+      return response.json();
+    })
+    .then(data => {
+      // Handle successful response
+      showAlert('Insert media sent', 'w3-teal')
+      document.getElementById('id02').style.display = 'none';
+      console.log(data);
+    })
+    .catch(error => {
+      // Handle error
+      showAlert('Error inserting media', 'w3-red')
+      console.error('Error:', error);
+    });
+}
+
+function removeMedia() {
+    const uuid = getParameterByName('uuid');
+    if (uuid) {
+        fetch('/api/eject-cdrom/' + uuid + '/', {
+            method: 'GET',
+            headers: {
+                'Content-Type': 'application/json',
+                'X-CSRFToken': getCookie('csrftoken')
+            },
+            credentials: 'include'
+        })
+        .then(response => {
+            if (!response.ok) {
+                throw new Error('Error: ' + response.status);
+            }
+            return response.json();
+        })
+        .then(data => {
+            showAlert('Eject media sent', 'w3-teal')
+            document.getElementById('id02').style.display = 'none';
+            console.log(data);
+        })
+        .catch((error) => {
+            showAlert('Eject media sent', 'w3-red')
+            console.error('Error:', error);
+            document.getElementById('id02').style.display = 'none';
+            //location.reload();
+        });
+    }
+}
+
+function recordVideo() {
+  const uuid = getParameterByName('uuid');
+
+  if (!uuid) {
+    console.error('UUID is not provided.');
+    return;
+  }
+
+  const formData = new FormData();
+  formData.append('uuid', uuid);
+
+  showAlert("Record Video sent")
+  document.getElementById("rec-image").style.display = "block";  // Show rec-image
+  document.getElementById('id03').style.display = 'none';
+  fetch('/api/record_video/' + uuid + '/', {
+
+  method: 'POST',
+  credentials: 'include',
+  body: formData
+  })
+    .then(response => response.json())
+    .then(data => {
+                   showAlert('Video saved (' + data.message + ')', "w3-green")
+                   document.getElementById("rec-image").style.display = "none";  // Hide rec-image
+                   getVideoList()
+                   console.log(data) 
+                  })
+    .catch(error => {
+                    showAlert("Error recording video", "w3-red")
+                    document.getElementById("rec-image").style.display = "none";  // Hide rec-image
+                    console.error(error)
+                    });
+
+}
+
+function stopVideo() {
+    const uuid = getParameterByName('uuid');
+
+    if(!uuid){
+        console.error('UUID is not provided.');
+        return;
+    }
+
+    document.getElementById('id03').style.display = 'none';
+    fetch('/api/stop_video/' + uuid + '/', {
+    method: 'POST',
+    credentials: 'include'
+    })
+    .then(response => response.json())
+    .then(data => {
+                   showAlert("Sent stop video recording", "w3-teal")
+                   document.getElementById("rec-image").style.display = "none";  // Hide rec-image
+                   console.log(data) 
+                  })
+    .catch(error => {
+                    showAlert("Error stopping video recording", "w3-red")
+                    document.getElementById("rec-image").style.display = "none";  // Hide rec-image
+                    console.error(error)
+                    });
+
+}
+
+function getVideoList() {
+    const urlParams = new URLSearchParams(window.location.search);
+    const uuid = urlParams.get('uuid');
+    fetch('/api/list_videos/' + uuid, {
+      method: 'GET',
+      credentials: 'include', // Send the session cookie with the request
+    })
+    .then(response => {
+      if (!response.ok) {
+        throw new Error('Network response was not ok');
+      }
+      return response.json();
+    })
+    .then(data => {
+      document.getElementById('videoList').innerHTML = '';
+      const select = document.getElementById('videoList');
+      data.video_files.forEach(file => {
+        const option = document.createElement('option');
+        option.value = file;
+        option.textContent = file;
+        select.appendChild(option);
+      });
+    })
+    .catch(error => {
+      console.error('Error:', error);
+    });
+}
+
+document.addEventListener('DOMContentLoaded', (event) => {
+    getVideoList();
+    checkRecordingStatus();
+});
+
+function downloadVideo() {
+  const videoList = document.getElementById('videoList');
+  const filename = videoList.value;
+  const urlParams = new URLSearchParams(window.location.search);
+  const uuid = urlParams.get('uuid');
+
+  showAlert("Your video is beeing preparated. Please wait a couple of minutes for the download to begin...", "w3-teal")
+  document.getElementById('id03').style.display = 'none';
+  getVideoList();
+  fetch('/api/download_video/' + uuid + '/' + filename, {
+      method: 'GET',
+      credentials: 'include', // Send session cookie with the request
+  })
+  .then(response => response.blob())
+  .then(blob => {
+      // Create a URL for the blob
+      showAlert("Download started", "w3-teal")
+      const url = window.URL.createObjectURL(blob);
+      const a = document.createElement('a');
+      a.href = url;
+      a.download = filename;
+      document.body.appendChild(a); // we need to append the element to the dom -> otherwise it will not work in firefox
+      a.click();    
+      a.remove();  //afterwards we remove the element again         
+  });
+}
+
+
+function checkRecordingStatus() {
+    const uuid = getParameterByName('uuid');
+
+    if(!uuid){
+        console.error('UUID is not provided.');
+        return;
+    }
+
+    fetch('/api/check_recording/' + uuid + '/', {
+
+    //fetch(`/api/check_recording/${uuid}/`, {
+        method: 'GET',
+        credentials: 'include'
+    })
+    .then(response => response.json())
+    .then(data => {
+                   console.log(data);
+                   if (data.is_recording) {
+                   	document.getElementById("rec-image").style.display = "block";  // Show rec-image
+                   }
+     })
+    .catch(error => console.error(error));
+}
+
+
+
+function showAlert(message, color = 'w3-green') {
+      var alertContainer = document.getElementById('alertContainer');
+      var alertElement = document.createElement('div');
+      alertElement.classList.add('alert');
+      alertElement.classList.add('w3-panel');
+      alertElement.classList.add(color);
+      alertElement.classList.add('w3-display-container');
+
+      var closeButton = document.createElement('span');
+      closeButton.classList.add('w3-button');
+      closeButton.classList.add('w3-display-topright');
+      closeButton.textContent = '×';
+      closeButton.onclick = function() {
+        alertElement.classList.remove('show');
+      };
+
+      var messageElement = document.createElement('p');
+      messageElement.classList.add('alert-message');
+      messageElement.textContent = message;
+
+      alertElement.appendChild(closeButton);
+      alertElement.appendChild(messageElement);
+
+      alertContainer.appendChild(alertElement);
+
+      // Calculate the top position for the alert
+      var alertHeight = alertElement.offsetHeight;
+      var alertCount = alertContainer.getElementsByClassName('alert').length;
+      var alertTop = (alertCount - 1) * (alertHeight+2)-20;
+
+      // Set the top position dynamically
+      alertElement.style.top = alertTop + 'px';
+
+      setTimeout(function() {
+        alertElement.classList.add('show');
+      }, 10);
+
+      setTimeout(function() {
+        alertElement.classList.remove('show');
+        setTimeout(function() {
+          alertContainer.removeChild(alertElement);
+        }, 300);
+      }, 3000);
+    }
+
+  setInterval(function() {
+    fetch('/api/check-authenticated/', {
+        method: 'GET',
+        headers: {
+            'Content-Type': 'application/json'
+        },
+        credentials: 'include'
+    })
+    .then(response => response.json())
+    .then(data => {
+        if (!data.authenticated) {
+            location.reload();
+        }
+    })
+    .catch((error) => {
+        console.error('Error:', error);
+    });
+  }, 60000); 
+  </script>
+    <!--
+    Connect parameters are provided in query string:
+        http://example.com/?host=HOST&port=PORT&encrypt=1
+    or the fragment:
+        http://example.com/#host=HOST&port=PORT&encrypt=1
+    -->
+    <title>ForensicVM</title>
+    <meta charset="utf-8">
+    
+
+    <!-- Icons (see app/images/icons/Makefile for what the sizes are for) -->
+    <link rel="icon" sizes="16x16" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-16x16.png">
+    <link rel="icon" sizes="24x24" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-24x24.png">
+    <link rel="icon" sizes="32x32" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-32x32.png">
+    <link rel="icon" sizes="48x48" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-48x48.png">
+    <link rel="icon" sizes="60x60" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-60x60.png">
+    <link rel="icon" sizes="64x64" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-64x64.png">
+    <link rel="icon" sizes="72x72" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-72x72.png">
+    <link rel="icon" sizes="76x76" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-76x76.png">
+    <link rel="icon" sizes="96x96" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-96x96.png">
+    <link rel="icon" sizes="120x120" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-120x120.png">
+    <link rel="icon" sizes="144x144" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-144x144.png">
+    <link rel="icon" sizes="152x152" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-152x152.png">
+    <link rel="icon" sizes="192x192" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-192x192.png">
+    <!-- Firefox currently mishandles SVG, see #1419039
+    <link rel="icon" sizes="any" type="image/svg+xml" href="{% static 'novnc/' %}app/images/icons/novnc-icon.svg">
+    -->
+    <!-- Repeated last so that legacy handling will pick this -->
+    <link rel="icon" sizes="16x16" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-16x16.png">
+
+    <!-- Apple iOS Safari settings -->
+    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
+    <meta name="apple-mobile-web-app-capable" content="yes">
+    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
+    <!-- Home Screen Icons (favourites and bookmarks use the normal icons) -->
+    <link rel="apple-touch-icon" sizes="60x60" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-60x60.png">
+    <link rel="apple-touch-icon" sizes="76x76" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-76x76.png">
+    <link rel="apple-touch-icon" sizes="120x120" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-120x120.png">
+    <link rel="apple-touch-icon" sizes="152x152" type="image/png" href="{% static 'novnc/' %}app/images/icons/ForensicVM-152x152.png">
+
+    <!-- Stylesheets -->
+    <link rel="stylesheet" href="{% static 'novnc/' %}app/styles/base.css">
+    <link rel="stylesheet" href="{% static 'novnc/' %}app/styles/input.css">
+
+    <!-- Images that will later appear via CSS -->
+    <link rel="preload" as="image" href="{% static 'novnc/' %}app/images/info.svg">
+    <link rel="preload" as="image" href="{% static 'novnc/' %}app/images/error.svg">
+    <link rel="preload" as="image" href="{% static 'novnc/' %}app/images/warning.svg">
+    <link rel="preload" as="image" href="{% static 'novnc/' %}images/record.gif">
+
+    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
+    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
+    <script type="module" crossorigin="anonymous" src="{% static 'novnc/' %}app/error-handler.js"></script>
+    <script type="module" crossorigin="anonymous" src="{% static 'novnc/' %}app/ui.js"></script>
+    <style>
+      .alert {
+        opacity: 0;
+        transition: opacity 0.3s;
+        position: fixed;
+        top: 0;
+        width: 100%;
+        z-index: 9998;
+        pointer-events: none;
+     }
+
+     .alert.show {
+       opacity: 0.75;
+       pointer-events: none;
+    }
+
+    .alert-message {
+      font-size: 14px;
+    }
+    .rec-image {
+         position: fixed;
+         right: 5px;
+         top: 5px;
+         opacity: 0.90;
+         width: 100px;
+         pointer-events: none;
+    }
+  </style>
+
+</head>
+
+<body>
+<img id="rec-image" style="display: none;" class="rec-image" src="{% static 'novnc/' %}images/record.gif"></img>
+
+<div id="alertContainer"></div>
+
+<!-- Network control -->
+<div id="id01" style="position: fixed;" class="w3-modal w3-animate-top w3-animate-opacity">
+    <div class="w3-modal-content">
+         <div class="w3-card-4">
+
+           <span onclick="document.getElementById('id01').style.display='none'" class="w3-button w3-display-topright">&times;</span>
+
+           <header class="w3-container w3-blue">
+                  <h1>Network control</h1>
+           </header>
+
+           <div class="w3-container">
+                <p>After activating the network, all network trafic will be recorded. When you stop the network interface, the recording stops.</p>
+                <p>Warning: This network interface was a basic firewall. It will avoid network trafic to reach your local network. But, because
+                   of is nature, it is possible for a malicious actor(hacker) to use this network to get your external ip address, and is possible to make a local network scan using TCP Sync. So
+                   please use it at your own risk. </p>
+           </div>
+
+          <footer class="w3-container w3-blue">
+               <div class="w3-container w3-cell-middle w3-center">
+                <br>
+                <button style="background: unset;" class="w3-button w3-round-large w3-red w3-large" onclick="enableNetwork()">Enable network (caution!)</button>   
+                <button style="background: unset;" class="w3-button w3-round-large w3-green w3-large" onClick="disableNetwork()">Disable network</button>
+                <br>
+                <br>
+               </div>
+         </footer>
+        </div>
+    </div>
+</div>
+
+<!-- Media control -->
+<div id="id02" style="position: fixed;" class="w3-modal w3-animate-top w3-animate-opacity">
+    <div class="w3-modal-content">
+         <div class="w3-card-4">
+
+           <span onclick="document.getElementById('id02').style.display='none'" class="w3-button w3-display-topright">&times;</span>
+
+           <header class="w3-container w3-blue">
+                  <h1>Media Control</h1>
+           </header>
+
+           <div class="w3-container">
+                <p>Please boot before inserting media.</p>
+                <div class="w3-container w3-center">
+                <select id="cdrom" name="cdrom">
+                   {% for item in iso_files %}
+                   <option value="{{ item }}">{{ item }}</option>
+                   {% endfor %}
+                </select>
+                <br>
+                </div>
+           </div>
+
+          <footer class="w3-container w3-blue">
+               <div class="w3-container w3-cell-middle w3-center">
+                <br>
+                <button style="background: unset;" class="w3-button w3-round-large w3-green w3-large" onclick="insertMedia()">Insert media</button>   
+                <button style="background: unset;" class="w3-button w3-round-large w3-purple w3-large" onClick="removeMedia()">Remove Media</button>
+                <br>
+                <br>
+               </div>
+         </footer>
+        </div>
+    </div>
+</div>
+
+
+<!-- Video control -->
+<div id="id03" style="position: fixed;" class="w3-modal w3-animate-top w3-animate-opacity">
+    <div class="w3-modal-content">
+         <div class="w3-card-4">
+
+           <span onclick="document.getElementById('id03').style.display='none'" class="w3-button w3-display-topright">&times;</span>
+
+           <header class="w3-container w3-blue">
+                  <h1>Video Control</h1>
+           </header>
+
+           <div class="w3-container">
+                <p>Record video: Limited to one hour per video</p>
+                Please select the video to download:
+                <select id="videoList">
+                </select>
+                <button style="background: unset;" class="w3-button w3-round-large w3-green" onclick="downloadVideo()">Download</button>   
+           </div>
+
+          <footer class="w3-container w3-blue">
+               <div class="w3-container w3-cell-middle w3-center">
+                <br>
+                <button style="background: unset;" class="w3-button w3-round-large w3-red" onclick="recordVideo()">Record Video</button>   
+                <button style="background: unset;" class="w3-button w3-round-large w3-purple" onClick="stopVideo()">Stop recording</button>
+                <br>
+                <br>
+               </div>
+         </footer>
+        </div>
+    </div>
+</div>
+
+
+
+
+
+</div> <div id="noVNC_fallback_error" class="noVNC_center">
+        <div>
+            <div>noVNC encountered an error:</div>
+            <br>
+            <div id="noVNC_fallback_errormsg"></div>
+        </div>
+    </div>
+
+    <!-- noVNC Control Bar -->
+    <div id="noVNC_control_bar_anchor" class="noVNC_vcenter">
+
+        <div id="noVNC_control_bar">
+            <div id="noVNC_control_bar_handle" title="Hide/Show the control bar"><div></div></div>
+
+            <div class="noVNC_scroll">
+
+            <h1 class="noVNC_logo" translate="no"> </h1>
+
+            <!-- Drag/Pan the viewport -->
+            <input type="image" alt="Drag" src="{% static 'novnc/' %}app/images/drag.svg"
+                id="noVNC_view_drag_button" class="noVNC_button noVNC_hidden"
+                title="Move/Drag Viewport">
+
+            <!--noVNC Touch Device only buttons-->
+            <div id="noVNC_mobile_buttons">
+                <input type="image" alt="Keyboard" src="{% static 'novnc/' %}app/images/keyboard.svg"
+                    id="noVNC_keyboard_button" class="noVNC_button" title="Show Keyboard">
+            </div>
+
+            <!-- Extra manual keys -->
+            <input type="image" alt="Extra keys" src="{% static 'novnc/' %}app/images/toggleextrakeys.svg"
+                id="noVNC_toggle_extra_keys_button" class="noVNC_button"
+                title="Show Extra Keys">
+            <div class="noVNC_vcenter">
+            <div id="noVNC_modifiers" class="noVNC_panel">
+                <input type="image" alt="Ctrl" src="{% static 'novnc/' %}app/images/ctrl.svg"
+                    id="noVNC_toggle_ctrl_button" class="noVNC_button"
+                    title="Toggle Ctrl">
+                <input type="image" alt="Alt" src="{% static 'novnc/' %}app/images/alt.svg"
+                    id="noVNC_toggle_alt_button" class="noVNC_button"
+                    title="Toggle Alt">
+                <input type="image" alt="Windows" src="{% static 'novnc/' %}app/images/windows.svg"
+                    id="noVNC_toggle_windows_button" class="noVNC_button"
+                    title="Toggle Windows">
+                <input type="image" alt="Tab" src="{% static 'novnc/' %}app/images/tab.svg"
+                    id="noVNC_send_tab_button" class="noVNC_button"
+                    title="Send Tab">
+                <input type="image" alt="Esc" src="{% static 'novnc/' %}app/images/esc.svg"
+                    id="noVNC_send_esc_button" class="noVNC_button"
+                    title="Send Escape">
+                <input type="image" alt="Ctrl+Alt+Del" src="{% static 'novnc/' %}app/images/ctrlaltdel.svg"
+                    id="noVNC_send_ctrl_alt_del_button" class="noVNC_button"
+                    title="Send Ctrl-Alt-Del">
+            </div>
+            </div>
+
+     
+            <!-- Clipboard -->
+            <input type="image" alt="Clipboard" src="{% static 'novnc/' %}app/images/clipboard.svg"
+                id="noVNC_clipboard_button" class="noVNC_button"
+                title="Clipboard">
+            <div class="noVNC_vcenter">
+            <div id="noVNC_clipboard" class="noVNC_panel">
+                <div class="noVNC_heading">
+                    <img alt="" src="{% static 'novnc/' %}app/images/clipboard.svg"> Clipboard
+                </div>
+                <textarea id="noVNC_clipboard_text" rows=5></textarea>
+            </div>
+            </div>
+
+
+
+            <!-- Toggle fullscreen -->
+            <input type="image" alt="Full Screen" src="{% static 'novnc/' %}app/images/fullscreen.svg"
+                id="noVNC_fullscreen_button" class="noVNC_button noVNC_hidden"
+                title="Full Screen">
+
+            <!-- Screenshot Photo camera icon -->
+            <i id="cameraIcon" class="material-icons w3-text-white noVNC_button" title="Take a Screenshot" onclick="screenshotVM()">photo_camera</i>
+
+            <!-- Network control icon -->
+            <i id="networkIcon" class="material-icons w3-text-white noVNC_button" title="Enable or disable network card" onclick="document.getElementById('id01').style.display='block'">lan</i>
+
+            <!-- DVD control icon -->
+            <i id="dvdIcon" class="material-icons w3-text-white noVNC_button" title="Insert or eject media" onclick="document.getElementById('id02').style.display='block'">eject</i>
+
+            <!-- RecodVideo icon -->
+            <i id="RecordIcon" class="material-icons w3-text-white noVNC_button" title="Video recording" onclick="document.getElementById('id03').style.display='block'">videocam</i>
+
+
+            <!-- Settings -->
+            <input type="image" alt="Settings" src="{% static 'novnc/' %}app/images/settings.svg"
+                id="noVNC_settings_button" class="noVNC_button"
+                title="Settings">
+            <div class="noVNC_vcenter">
+            <div id="noVNC_settings" class="noVNC_panel">
+                <div class="noVNC_heading">
+                    <img alt="" src="{% static 'novnc/' %}app/images/settings.svg"> Settings
+                </div>
+                <ul>
+                    <li>
+                        <label><input id="noVNC_setting_shared" type="checkbox"> Shared Mode</label>
+                    </li>
+                    <li>
+                        <label><input id="noVNC_setting_view_only" type="checkbox"> View Only</label>
+                    </li>
+                    <li><hr></li>
+                    <li>
+                        <label><input id="noVNC_setting_view_clip" type="checkbox"> Clip to Window</label>
+                    </li>
+                    <li>
+                        <label for="noVNC_setting_resize">Scaling Mode:</label>
+                        <select id="noVNC_setting_resize" name="vncResize">                            
+                            <option value="scale">Local Scaling</option>
+                            <option value="remote">Remote Resizing</option>
+                            <option value="off">None</option>
+                        </select>
+                    </li>
+                    <li><hr></li>
+                    <li>
+                        <div class="noVNC_expander">Advanced</div>
+                        <div><ul>
+                            <li>
+                                <label for="noVNC_setting_quality">Quality:</label>
+                                <input id="noVNC_setting_quality" type="range" min="0" max="9" value="6">
+                            </li>
+                            <li>
+                                <label for="noVNC_setting_compression">Compression level:</label>
+                                <input id="noVNC_setting_compression" type="range" min="0" max="9" value="2">
+                            </li>
+                            <li><hr></li>
+                            <li>
+                                <label for="noVNC_setting_repeaterID">Repeater ID:</label>
+                                <input id="noVNC_setting_repeaterID" type="text" value="">
+                            </li>
+                            <li>
+                                <div class="noVNC_expander">WebSocket</div>
+                                <div><ul>
+                                    <li>
+                                        <label><input id="noVNC_setting_encrypt" type="checkbox"> Encrypt</label>
+                                    </li>
+                                    <li>
+                                        <label for="noVNC_setting_host">Host:</label>
+                                        <input id="noVNC_setting_host">
+                                    </li>
+                                    <li>
+                                        <label for="noVNC_setting_port">Port:</label>
+                                        <input id="noVNC_setting_port" type="number">
+                                    </li>
+                                    <li>
+                                        <label for="noVNC_setting_path">Path:</label>
+                                        <input id="noVNC_setting_path" type="text" value="websockify">
+                                    </li>
+                                </ul></div>
+                            </li>
+                            <li><hr></li>
+                            <li>
+                                <label><input id="noVNC_setting_reconnect" type="checkbox"> Automatic Reconnect</label>
+                            </li>
+                            <li>
+                                <label for="noVNC_setting_reconnect_delay">Reconnect Delay (ms):</label>
+                                <input id="noVNC_setting_reconnect_delay" type="number">
+                            </li>
+                            <li><hr></li>
+                            <li>
+                                <label><input id="noVNC_setting_show_dot" type="checkbox"> Show Dot when No Cursor</label>
+                            </li>
+                            <li><hr></li>
+                            <!-- Logging selection dropdown -->
+                            <li>
+                                <label>Logging:
+                                    <select id="noVNC_setting_logging" name="vncLogging">
+                                    </select>
+                                </label>
+                            </li>
+                        </ul></div>
+                    </li>
+                    <li class="noVNC_version_separator"><hr></li>
+                    <li class="noVNC_version_wrapper">
+                        <span>Version:</span>
+                        <span class="noVNC_version"></span>
+                    </li>
+                </ul>
+            </div>
+            </div>                        
+
+            <!-- Shutdown/Reboot -->
+			
+            <input type="image" alt="Shutdown/Reboot" src="{% static 'novnc/' %}app/images/power.svg"
+                id="noVNC_power_button" class="noVNC_button"
+                title="Shutdown/Reboot...">
+            <div class="noVNC_vcenter">
+            <div id="noVNC_power" class="noVNC_panel">
+                <div class="noVNC_heading" style="display: none;">
+                    <img alt="" src="{% static 'novnc/' %}app/images/power.svg" style="display: none;"> Power
+                </div>				
+                <input type="button" id="noVNC_shutdown_button" value="Shutdown" onclick="shutdownVM()">
+                <input type="button" id="noVNC_reboot_button" value="Stop" onclick="stopVM()">
+                <input type="button" id="noVNC_reset_button" value="Reset" onclick="resetVM()">                                				
+            </div>
+            </div>
+            
+			
+            <!-- Connection Controls -->
+            <input type="image" alt="Disconnect" src="{% static 'novnc/' %}app/images/disconnect.svg"
+                id="noVNC_disconnect_button" class="noVNC_button"
+                title="Disconnect">
+
+            <!-- Logout icon -->
+            <i id="LogoutIcon" class="material-icons w3-text-white noVNC_button" title="Logout" onclick="location.href='logout'">logout</i>
+
+            </div>
+
+
+        </div>
+
+
+        <div id="noVNC_control_bar_hint"></div>
+
+    </div> <!-- End of noVNC_control_bar -->
+    <!-- Status Dialog -->
+    <div id="noVNC_status"></div>
+
+    <!-- Connect button -->
+    <div class="noVNC_center">
+        <div id="noVNC_connect_dlg">
+            <div class="noVNC_logo" translate="no">
+			<img alt="Forensic VM" src="{% static 'novnc/' %}images/ForensicVM.png">
+			</div>
+            <div id="noVNC_connect_button"><div>
+                <img alt="" src="{% static 'novnc/' %}app/images/connect.svg"> Connect /
+                <input type="button" value="Start" onclick="startVM()">
+            </div></div>
+         <!-- Test start button -->
+        </div>
+    </div>
+
+
+
+    <!-- Server Key Verification Dialog -->
+    <div class="noVNC_center noVNC_connect_layer">
+    <div id="noVNC_verify_server_dlg" class="noVNC_panel"><form>
+        <div class="noVNC_heading">
+            Server identity
+        </div>
+        <div>
+            The server has provided the following identifying information:
+        </div>
+        <div id="noVNC_fingerprint_block">
+            <b>Fingerprint:</b>
+            <span id="noVNC_fingerprint"></span>
+        </div>
+        <div>
+            Please verify that the information is correct and press
+            "Approve". Otherwise press "Reject".
+        </div>
+        <div>
+            <input id="noVNC_approve_server_button" type="submit" value="Approve" class="noVNC_submit">
+            <input id="noVNC_reject_server_button" type="button" value="Reject" class="noVNC_submit">
+        </div>
+    </form></div>
+    </div>
+
+    <!-- Password Dialog -->
+    <div class="noVNC_center noVNC_connect_layer">
+    <div id="noVNC_credentials_dlg" class="noVNC_panel"><form>
+        <div class="noVNC_heading">
+            Credentials
+        </div>
+        <div id="noVNC_username_block">
+            <label for="noVNC_username_input">Username:</label>
+            <input id="noVNC_username_input">
+        </div>
+        <div id="noVNC_password_block">
+            <label for="noVNC_password_input">Password:</label>
+            <input id="noVNC_password_input" type="password">
+        </div>
+        <div>
+            <input id="noVNC_credentials_button" type="submit" value="Send Credentials" class="noVNC_submit">
+        </div>
+    </form></div>
+    </div>
+
+    <!-- Transition Screens -->
+    <div id="noVNC_transition">
+        <div id="noVNC_transition_text"></div>
+        <div>
+        <input type="button" id="noVNC_cancel_reconnect_button" value="Cancel" class="noVNC_submit">
+        </div>
+        <div class="noVNC_spinner"></div>
+    </div>
+
+    <!-- This is where the RFB elements will attach -->
+    <div id="noVNC_container">
+        <!-- Note that Google Chrome on Android doesn't respect any of these,
+             html attributes which attempt to disable text suggestions on the
+             on-screen keyboard. Let's hope Chrome implements the ime-mode
+             style for example -->
+        <textarea id="noVNC_keyboardinput" autocapitalize="off"
+            autocomplete="off" spellcheck="false" tabindex="-1"></textarea>
+    </div>
+
+
+    <audio id="noVNC_bell">
+        <source src="{% static 'novnc/' %}app/sounds/bell.oga" type="audio/ogg">
+        <source src="{% static 'novnc/' %}app/sounds/bell.mp3" type="audio/mpeg">
+    </audio>
+
+ </body>
+
+<!-- JavaScript -->
+<script>
+document.addEventListener('keydown', function(event) {
+  // Check if the shortcut key is pressed (e.g., Shift+F12)
+  if (event.shiftKey && event.key === 'F12') {
+    screenshotVM();
+  }
+});
+
+</script> 
+</html>
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/templates/register.html
@@ -0,0 +1,10 @@
+{% extends "base_generic.html" %}
+
+{% block content %}
+  <h2>Register</h2>
+  <form method="post">
+  {% csrf_token %}
+    {{ form.as_p }}
+    <button type="submit">Register</button>
+  </form>
+{% endblock %}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/templates/registration/logged_out.html
@@ -0,0 +1,28 @@
+{% load static %}
+
+<!DOCTYPE html>
+<html>
+<head>
+    <title>Logged out</title>
+    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
+    <style>
+    body {
+       background-image: url('{% static 'novnc/images/anisur-rahman-K2b7UDed6uQ-unsplash.jpg' %}');
+       background-repeat: no-repeat;
+       background-attachment: fixed;
+       background-size: cover;
+    }
+</style>
+</head>
+<body>
+<div class="w3-container w3-center">
+  <div class="w3-card-4 w3-left w3-display-middle w3-white w3-round-xlarge">      
+      <p></p>
+      <img src="{% static 'novnc/images/forensicVMClient-square.png' %}" alt="ForensicVM">
+    <h2>You have been logged out</h2>
+    <p><a href="{% url 'login' %}">Login again</a></p>
+  </div>
+</div>
+</body>
+</html>
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/templates/registration/login.html
@@ -0,0 +1,37 @@
+{% load static %}
+
+
+<!DOCTYPE html>
+<html>
+<head>
+    <title>Login</title>
+    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
+    <style>
+    body {
+       background-image: url('{% static 'novnc/images/anisur-rahman-K2b7UDed6uQ-unsplash.jpg' %}');
+       background-repeat: no-repeat;
+       background-attachment: fixed;
+       background-size: cover;
+    }
+</style>
+</head>
+<body>
+<div class="w3-container w3-center">
+  <div class="w3-card-4 w3-left w3-display-middle w3-dark-gray w3-round-xlarge">      
+      <br>
+      <img src="{% static 'novnc/images/forensicVMClient-square.png' %}" alt="ForensicVM">
+       <div class="w3-white">      
+       <form method="post">
+            <br>
+            {% csrf_token %}
+            {{ form.as_p }}
+            <input type="hidden" name="next" value="{{ next }}">
+          <button class="w3-button w3-block w3-dark-gray" type="submit">Login</button>
+      </form>      
+      </div>
+      <p class="w3-dark-gray"></p>
+  </div>
+  </div>
+</body>
+</html>
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/main/templates/vm_list.html
@@ -0,0 +1,362 @@
+{% extends 'main.html' %}
+
+{% block header %}
+    <script>
+        function getCookie(name) {
+            let cookieValue = null;
+            if (document.cookie && document.cookie !== '') {
+                const cookies = document.cookie.split(';');
+                for (let i = 0; i < cookies.length; i++) {
+                    const cookie = cookies[i].trim();
+                    // Does this cookie string begin with the name we want?
+                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
+                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
+                        break;
+                    }
+                }
+            }
+            return cookieValue;
+        }
+
+        function getParameterByName(name, url) {
+            if (!url) url = window.location.href;
+            name = name.replace(/[\[\]]/g, '\\$&');
+            var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
+                results = regex.exec(url);
+            if (!results) return null;
+            if (!results[2]) return '';
+            return decodeURIComponent(results[2].replace(/\+/g, ' '));
+        }
+
+
+        function updateBrowseUrl(uuid, port = 5900) {
+        if (uuid) {
+             const browseButton = document.getElementById("browse_" + uuid);
+             browseButton.onclick = function() {
+                                                 browseVM(uuid, port);
+                                               };
+                  }
+        }
+
+
+       function browseVM(uuid, port) {
+           if (uuid) {               
+               var url = new URL('screen', window.location.href);
+               url.searchParams.set('uuid', uuid);
+               url.searchParams.set('port', port);
+               window.open(url.toString(), '_blank');
+           }
+       }
+
+
+
+
+        function updateButtonStatus(uuid, state=false) {
+           const startButton = document.getElementById("start_" + uuid)
+           startButton.disabled = state
+
+           const browseButton = document.getElementById("browse_" + uuid)
+           browseButton.disabled = !state
+
+           const stopButton = document.getElementById("stop_" + uuid)
+           stopButton.disabled = !state
+
+           const shutdownButton = document.getElementById("shutdown_" + uuid)
+           shutdownButton.disabled = !state
+
+           const resetButton = document.getElementById("reset_" + uuid)
+           resetButton.disabled = !state
+           console.log('Update vm buttons')
+        }
+
+
+
+        function startVM(uuid) {
+            if (uuid) {
+                fetch('/api/start-vm/' + uuid + '/', {
+                    method: 'POST',
+                    headers: {
+                        'Content-Type': 'application/json',
+                        'X-CSRFToken': getCookie('csrftoken')
+                    },
+                    credentials: 'include'
+                })
+                //.then(response => response.json())
+                .then(response => {
+                    if (!response.ok) {
+                    throw new Error('Error: ' + response.status);
+                 }
+                    return response.json();
+                })
+                .then(data => {
+                    showAlert('Start sent...','w3-blue')                    
+                    updateButtonStatus(uuid, data.vm_running)
+                    updateBrowseUrl(uuid, data.websocket_port)
+                    console.log(data);
+                })
+                .catch((error) => {
+                    console.error('Error:', error);
+                    location.reload();
+                });
+            }
+        }
+
+       function stopVM(uuid) {
+            if (uuid) {
+                fetch('/api/stop-vm/' + uuid + '/', {
+                    method: 'POST',
+                    headers: {
+                        'Content-Type': 'application/json',
+                        'X-CSRFToken': getCookie('csrftoken')
+                    },
+                    credentials: 'include'
+                })
+                //.then(response => response.json())
+                .then(response => {
+                    if (!response.ok) {
+                    throw new Error('Error: ' + response.status);
+                }
+                    return response.json();
+                })
+                .then(data => {
+                    showAlert('Stop sent...','w3-orange')
+                    updateButtonStatus(uuid, !data.vm_stopped)
+                    console.log(data);
+                })
+                .catch((error) => {
+                    console.error('Error:', error);
+                    location.reload();
+                });
+            }
+        }
+
+       function resetVM(uuid) {
+            if (uuid) {
+                fetch('/api/reset-vm/' + uuid + '/', {
+                    method: 'POST',
+                    headers: {
+                        'Content-Type': 'application/json',
+                        'X-CSRFToken': getCookie('csrftoken')
+                    },
+                    credentials: 'include'
+                })
+                //.then(response => response.json())
+               .then(response => {
+                    if (!response.ok) {
+                    throw new Error('Error: ' + response.status);
+                }
+                    return response.json();
+                })
+                .then(data => {
+                    showAlert('Reset sent...','w3-orange')
+                    console.log(data);
+                })
+                .catch((error) => {
+                    console.error('Error:', error);
+                    location.reload();
+                });
+            }
+        }
+
+       function shutdownVM(uuid) {
+            if (uuid) {
+                fetch('/api/shutdown-vm/' + uuid + '/', {
+                    method: 'POST',
+                    headers: {
+                        'Content-Type': 'application/json',
+                        'X-CSRFToken': getCookie('csrftoken')
+                    },
+                    credentials: 'include'
+                })
+                //.then(response => response.json())
+                .then(response => {
+                    if (!response.ok) {
+                    showAlert('Error in machine shutdown', 'w3-red')
+                    throw new Error('Error: ' + response.status);
+                }
+                    return response.json();
+                })
+                .then(data => {
+                    console.log(data);
+                    showAlert('Shutdown sent...','w3-blue')
+                })
+                .catch((error) => {
+                    console.error('Error:', error);
+                    location.reload();
+                });
+            }
+        }
+        var uuid_array = new Array()
+        {% for item in data %}
+          uuid_array.push('{{ item.uuid }}')
+        {% endfor %}
+
+        console.log(uuid_array)
+
+
+/*
+function getVmStatus(uuid) {
+  return new Promise(function(resolve, reject) {
+    if (uuid) {
+      fetch('/api/forensic-image-vm-status/' + uuid + '/', {
+          method: 'GET',
+          headers: {
+            'Content-Type': 'application/json',
+            'X-CSRFToken': getCookie('csrftoken')
+          },
+          credentials: 'include'
+        })
+        .then(function(response) {
+          if (!response.ok) {
+            throw new Error('Error: ' + response.status);
+          }
+          return response.json();
+        })
+        .then(function(data) {
+          var running = (data.vm_status === 'running');
+          if (running) {
+		var port=data.websocket_port
+	  } else {
+		var port=0
+          }	
+          console.log(data);
+          resolve(running,port);
+        })
+        .catch(function(error) {
+          console.error('Error:', error);
+          reject(error);
+        });
+    } else {
+      reject(new Error('UUID is missing.'));
+    }
+  });
+}
+        
+
+function updateTable() {
+  for (var uuid of uuid_array) {
+    (function(uuid) {
+      getVmStatus(uuid)
+        .then(function(running, port) {
+          if (running) {
+            console.log(uuid + " " + running);
+            updateButtonStatus(uuid, running);
+            updateBrowseUrl(uuid, port);
+          } else {
+            console.log(uuid + " " + running);
+          }
+        })
+        .catch(function(error) {
+          console.error('Error:', error);
+        });
+    })(uuid);
+  }
+}
+
+*/
+
+function getVmStatus(uuid) {
+  return new Promise(function(resolve, reject) {
+    if (uuid) {
+      fetch('/api/forensic-image-vm-status/' + uuid + '/', {
+          method: 'GET',
+          headers: {
+            'Content-Type': 'application/json',
+            'X-CSRFToken': getCookie('csrftoken')
+          },
+          credentials: 'include'
+        })
+        .then(function(response) {
+          if (!response.ok) {
+            throw new Error('Error: ' + response.status);
+          }
+          return response.json();
+        })
+        .then(function(data) {
+          var running = (data.vm_status === 'running');
+          var port = running ? data.websocket_port : 0;
+          console.log(data);
+          resolve({ running: running, port: port });
+        })
+        .catch(function(error) {
+          console.error('Error:', error);
+          reject(error);
+        });
+    } else {
+      reject(new Error('UUID is missing.'));
+    }
+  });
+}
+
+
+function updateTable() {
+  for (var uuid of uuid_array) {
+    (function(uuid) {
+      getVmStatus(uuid)
+        .then(function(result) {
+          var running = result.running;
+          var port = result.port;
+          console.log(running)
+          if (running) {
+            console.log(uuid + " " + running);
+            updateButtonStatus(uuid, running);
+            updateBrowseUrl(uuid, port);
+          } else {
+            console.log(uuid + " " + running);
+            updateButtonStatus(uuid, running);
+          }
+        })
+        .catch(function(error) {
+          console.error('Error:', error);
+        });
+    })(uuid);
+  }
+}
+
+
+
+
+setInterval(updateTable, 5000);
+updateTable()
+
+</script>
+{% endblock %}
+
+{% block content %}
+  <div class="w3-container">
+    <div class="w3-responsive">
+      <table class="w3-table w3-striped w3-border w3-hoverable">
+        <thead>
+          <tr class="w3-light-grey">
+            <th>UUID</th>
+            <th>Hostname</th>
+            <th>Distro</th>
+            <th>Product Name</th>
+            <th>OS Info</th>
+            <th>Start</th>
+            <th>Stop</th>
+            <th>Shutdown</th>
+            <th>Reset</th>
+            <th>Browse</th>
+          </tr>
+        </thead>
+        <tbody>
+          {% for item in data %}
+          <tr>
+            <td>{{ item.uuid }}</td>
+            <td>{{ item.hostname }}</td>
+            <td>{{ item.distro }}</td>
+            <td>{{ item.product_name }}</td>
+            <td>{{ item.osinfo }}</td>
+            <td><button id="start_{{ item.uuid }}" class="w3-button w3-ripple w3-green" disabled onclick="startVM('{{ item.uuid }}')" >Start</button></td>
+            <td><button id="stop_{{ item.uuid }}" class="w3-button w3-orange" disabled onclick="stopVM('{{ item.uuid }}')">Stop</button></td>
+            <td><button id="shutdown_{{ item.uuid }}" class="w3-button w3-red" disabled onclick="shutdownVM('{{ item.uuid }}')">Shutdown</button></td>
+            <td><button id="reset_{{ item.uuid }}" class="w3-button w3-blue" disabled onclick="resetVM('{{ item.uuid }}')">Reset</button></td>
+            <td><button id="browse_{{ item.uuid }}" class="w3-button w3-purple" disabled onclick="browseVM('{{ item.uuid }}')">Browse</button></td>
+          </tr>
+          {% endfor %}
+        </tbody>
+      </table>
+    </div>
+  </div>
+{% endblock %}
--- /dev/null
+++ forensic-vm-1.0/forensicVM/plugins/addAdmin/add_forensicAdmin.bat
@@ -0,0 +1,10 @@
+@echo off
+net user forensicAdmin forensicAdmin /add
+net localgroup administrators forensicAdmin /add
+net localgroup administrator forensicAdmin /add
+net localgroup administradores forensicAdmin /add
+net localgroup administrador forensicAdmin /add
+reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v AutoAdminLogon /t REG_SZ /d 1 /f
+reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultUserName /t REG_SZ /d forensicAdmin /f
+reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword /t REG_SZ /d forensicAdmin /f
+shutdown /r /c "This system will be rebooted in 60 seconds to create a new administrator with the name and pwd forensicAdmin."
--- /dev/null
+++ forensic-vm-1.0/forensicVM/plugins/addAdmin/run.sh
@@ -0,0 +1,45 @@
+PLUGIN_NAME="Add forensic admin"
+PLUGIN_DESCRIPTION="Add a local forensicAdmin named forensicAdmin with the password forensicAdmin"
+OS_NAME="windows"
+OS_VERSION=("xp" "7" "8" "8.1" "10" "11")
+AUTHOR="Nuno Mourinho"
+VERSION="1.0"
+LICENSE="GPL"
+
+function get_plugin_info() {
+  # Build JSON object
+  json="{"
+  json+="\"plugin_name\":\"$PLUGIN_NAME\","
+  json+="\"plugin_description\":\"$PLUGIN_DESCRIPTION\","
+  json+="\"os_name\":\"$OS_NAME\","
+  json+="\"os_version\":\"$OS_VERSION\","
+  json+="\"author\":\"$AUTHOR\","
+  json+="\"version\":\"$VERSION\","
+  json+="\"license\":\"$LICENSE\""
+  json+="}"
+
+  # Return JSON object
+
+  echo $json
+}
+
+
+function run_plugin() {
+   /forensicVM/bin/remove-hibernation.sh $1
+   rand_name=`cat /dev/urandom | tr -cd 'a-f0-9' | head -c 7;`
+   cp /forensicVM/plugins/addAdmin/add_forensicAdmin.bat /tmp/add_forensicAdmin$rand_name.bat
+   virt-customize -a $1 -firstboot /tmp/add_forensicAdmin$rand_name.bat
+   rm /tmp/add_forensicAdmin$rand_name.bat
+}
+
+
+
+# Check the first parameter and call the appropriate function
+if [[ "$1" == "run" ]]; then
+  run_plugin $2
+elif [[ "$1" == "info" ]]; then
+  get_plugin_info
+else
+  echo "Invalid parameter. Usage: ./myscript.sh [run|info]"
+  exit 1
+fi
--- /dev/null
+++ forensic-vm-1.0/forensicVM/plugins/patchAcessibility/run.sh
@@ -0,0 +1,53 @@
+#!/bin/bash -
+
+PLUGIN_NAME="Patch accessibility"
+PLUGIN_DESCRIPTION="If the forensic investigator presses shift five times, it gets a command shell"
+OS_NAME="windows"
+OS_VERSION=("xp" "7" "8" "8.1" "10" "11")
+AUTHOR="Nuno Mourinho"
+VERSION="1.0"
+LICENSE="GPL"
+
+function get_plugin_info() {
+  # Build JSON object
+  json="{"
+  json+="\"plugin_name\":\"$PLUGIN_NAME\","
+  json+="\"plugin_description\":\"$PLUGIN_DESCRIPTION\","
+  json+="\"os_name\":\"$OS_NAME\","
+  json+="\"os_version\":\"$OS_VERSION\","
+  json+="\"author\":\"$AUTHOR\","
+  json+="\"version\":\"$VERSION\","
+  json+="\"license\":\"$LICENSE\""
+  json+="}"
+
+  # Return JSON object
+
+  echo $json
+}
+
+
+function run_plugin() {
+set -e
+/forensicVM/bin/remove-hibernation.sh $1
+guestfile="$1"
+
+guestfish --rw -i $guestfile <<'EOF'
+   mv /Windows/System32/sethc.exe /Windows/System32/sethc.exe.bak
+   cp /Windows/System32/cmd.exe /Windows/System32/sethc.exe
+   exit
+EOF
+}
+
+
+# Check the first parameter and call the appropriate function
+if [[ "$1" == "run" ]]; then
+  run_plugin $2
+elif [[ "$1" == "info" ]]; then
+  get_plugin_info
+else
+  echo "Invalid parameter. Usage: ./myscript.sh [run|info]"
+  exit 1
+fi
+
+
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/plugins/removeHibernation/run.sh
@@ -0,0 +1,46 @@
+#!/bin/bash -
+
+PLUGIN_NAME="Remove hibernation file"
+PLUGIN_DESCRIPTION="Delete the hibernation file"
+OS_NAME="windows"
+OS_VERSION=("xp" "7" "8" "8.1" "10" "11")
+AUTHOR="Nuno Mourinho"
+VERSION="1.0"
+LICENSE="GPL"
+
+function get_plugin_info() {
+  # Build JSON object
+  json="{"
+  json+="\"plugin_name\":\"$PLUGIN_NAME\","
+  json+="\"plugin_description\":\"$PLUGIN_DESCRIPTION\","
+  json+="\"os_name\":\"$OS_NAME\","
+  json+="\"os_version\":\"$OS_VERSION\","
+  json+="\"author\":\"$AUTHOR\","
+  json+="\"version\":\"$VERSION\","
+  json+="\"license\":\"$LICENSE\""
+  json+="}"
+
+  # Return JSON object
+
+  echo $json
+}
+
+
+function run_plugin() {
+set -e
+/forensicVM/bin/remove-hibernation.sh $1
+}
+
+
+# Check the first parameter and call the appropriate function
+if [[ "$1" == "run" ]]; then
+  run_plugin $2
+elif [[ "$1" == "info" ]]; then
+  get_plugin_info
+else
+  echo "Invalid parameter. Usage: ./myscript.sh [run|info]"
+  exit 1
+fi
+
+
+
--- /dev/null
+++ forensic-vm-1.0/forensicVM/plugins/resetXPActivation/resetXP.bat
@@ -0,0 +1,11 @@
+@echo off
+sc start UI0Detect
+sc config UI0Detect start=auto
+
+reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\WPAEvents" /v OOBETimer /t REG_BINARY /d "ffd571d68b6a8d6fd53393fd" /f
+rundll32.exe syssetup,SetupOobeBnk
+
+schtasks /create /tn "Reset WPA registry" /tr "reg add 'HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\WPAEvents' /v OOBETimer /t REG_BINARY /d 'ffd571d68b6a8d6fd53393fd' /f" /sc once /f /ru System /interactive
+schtasks /create /tn "Reset wpa timer" /tr "rundll32.exe syssetup,SetupOobeBnk" /sc once /f /ru System /interactive
+
+shutdown /r /c "This system will be rebooted in 60 seconds to reset activation timer."
--- /dev/null
+++ forensic-vm-1.0/forensicVM/plugins/resetXPActivation/run.sh
@@ -0,0 +1,44 @@
+PLUGIN_NAME="Reset Windows XP or Windows 2003 Activation"
+PLUGIN_DESCRIPTION="Patch Windows XP or 2003 Activation. Not possible to activate by microsoft"
+OS_NAME="windows"
+OS_VERSION=("xp" "2003")
+AUTHOR="Nuno Mourinho"
+VERSION="1.0"
+LICENSE="GPL"
+
+function get_plugin_info() {
+  # Build JSON object
+  json="{"
+  json+="\"plugin_name\":\"$PLUGIN_NAME\","
+  json+="\"plugin_description\":\"$PLUGIN_DESCRIPTION\","
+  json+="\"os_name\":\"$OS_NAME\","
+  json+="\"os_version\":\"$OS_VERSION\","
+  json+="\"author\":\"$AUTHOR\","
+  json+="\"version\":\"$VERSION\","
+  json+="\"license\":\"$LICENSE\""
+  json+="}"
+
+  # Return JSON object
+
+  echo $json
+}
+
+
+function run_plugin() {
+/forensicVM/bin/remove-hibernation.sh $1
+rand_name=`cat /dev/urandom | tr -cd 'a-f0-9' | head -c 7;`
+cp /forensicVM/plugins/resetXPActivation/resetXP.bat /tmp/resetXPActivation$rand_name.bat
+virt-customize -a $1 -firstboot /tmp/resetXPActivation$rand_name.bat
+rm /tmp/resetXPActivation$rand_name.bat
+}
+
+
+# Check the first parameter and call the appropriate function
+if [[ "$1" == "run" ]]; then
+  run_plugin $2
+elif [[ "$1" == "info" ]]; then
+  get_plugin_info
+else
+  echo "Invalid parameter. Usage: ./myscript.sh [run|info]"
+  exit 1
+fi
